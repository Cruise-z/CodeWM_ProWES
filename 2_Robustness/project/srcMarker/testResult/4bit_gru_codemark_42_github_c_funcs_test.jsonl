{"author": "chandanXP", "file": "Datastructure-using-C__peekInStack.5.c", "original_string": "int main()\n{\n    struct stack *sp=(struct stack*)malloc(sizeof(struct stack));\n    sp->size=10;\n    sp->top= -1;\n    sp->arr= (int *)malloc(sp->size* sizeof(int));\n    printf(\"Before pushing, Full: %d\\n\", isFull(sp));\n    printf(\"Before pushing, Empty: %d\\n\", isEmpty(sp));\n    push(sp, 56);\n    push(sp, 55);\n    push(sp, 54);\n    push(sp, 53);\n    push(sp, 52);\n    push(sp, 51);\n    push(sp, 50);\n    push(sp, 49);\n    push(sp, 48);\n    push(sp, 47); \n    push(sp, 46); \n    printf(\"After pushing, Full: %d\\n\", isFull(sp));\n    printf(\"After pushing, Empty: %d\\n\", isEmpty(sp));\n    printf(\"Popped %d from the stack\\n\", pop(sp));\n    for(int j=1; j <= sp->top + 1; j++){\n        printf(\"The value at position %d is %d\\n\",j,peek(sp, j));\n    }\n    return 0;\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { struct stack * _values = ( struct stack * ) malloc ( sizeof ( struct stack ) ) ; _values -> size = 10 ; _values -> top = - 1 ; _values -> arr = ( int * ) malloc ( _values -> size * sizeof ( int ) ) ; printf ( \" Before pushing, Full: %d\\n \" , isFull ( _values ) ) ; printf ( \" Before pushing, Empty: %d\\n \" , isEmpty ( _values ) ) ; push ( _values , 56 ) ; push ( _values , 55 ) ; push ( _values , 54 ) ; push ( _values , 53 ) ; push ( _values , 52 ) ; push ( _values , 51 ) ; push ( _values , 50 ) ; push ( _values , 49 ) ; push ( _values , 48 ) ; push ( _values , 47 ) ; push ( _values , 46 ) ; printf ( \" After pushing, Full: %d\\n \" , isFull ( _values ) ) ; printf ( \" After pushing, Empty: %d\\n \" , isEmpty ( _values ) ) ; printf ( \" Popped %d from the stack\\n \" , pop ( _values ) ) ; for ( int _j = 1 ; _j <= _values -> top + 1 ; _j ++ ) { printf ( \" The value at position %d is %d\\n \" , _j , peek ( _values , _j ) ) ; } return 0 ; }"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Sum_Of_All_Diagonals.3.c", "original_string": "void display(int matrix[R][C])\n{\n    int i, j = 0;\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            printf(\"%d\\t\", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "void display ( int _successor [ R ] [ C ] ) { int _i , _j = 0 ; for ( _i = 0 ; _i < R ; _i ++ ) { for ( _j = 0 ; _j < C ; _j ++ ) { printf ( \" %d\\t \" , _successor [ _i ] [ _j ] ) ; } printf ( \" \\n \" ) ; } }"}
{"author": "augustogunsch", "file": "jack-compiler__parser-expressions.1.c", "original_string": "TERM* parsetermnullified(PARSER* p) {\n    TOKENTYPE type = p->current->type;\n    if(type == integer) return parseint(p);\n    if(type == string) return parsestr(p);\n    if(type == keyword) return parsekeyword(p);\n    if(type == identifier) return parseidentifierterm(p);\n    if(equals(p, \"-\") || equals(p, \"~\")) return parseunaryopterm(p);\n    if(equals(p, \"(\")) return parseinnerexpression(p);\n    return NULL;\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "TERM * Parsetermnullified ( PARSER * P ) { TOKENTYPE Type = P -> current -> type ; if ( Type == integer ) return parseint ( P ) ; if ( Type == string ) return parsestr ( P ) ; if ( Type == Temperature ) return parsekeyword ( P ) ; if ( Type == identifier ) return parseidentifierterm ( P ) ; if ( equals ( P , \" - \" ) || equals ( P , \" ~ \" ) ) return parseunaryopterm ( P ) ; if ( equals ( P , \" ( \" ) ) return parseinnerexpression ( P ) ; return NULL ; }"}
{"author": "ankitraj311", "file": "Socket-thread__t.1.c", "original_string": "int main() \n{ \n    int i; \n    pthread_t tid; \n    for (i = 0; i < 3; i++) \n        pthread_create(&tid, NULL, myThreadFun, (void *)&tid); \n    pthread_exit(NULL); \n    return 0; \n}", "watermark": [0, 0, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int _i ; pthread_t _matematico ; for ( _i = 0 ; _i < 3 ; _i ++ ) pthread_create ( & _matematico , NULL , myThreadFun , ( void * ) & _matematico ) ; pthread_exit ( NULL ) ; return 0 ; }"}
{"author": "revathy16296", "file": "rtos_assignment_b__odd_even_client.0.c", "original_string": "int main()\n{\nconst char* name=\"odd_even\";\nconst int SIZE=15*1024;\nint shmid;\nchar words;\nvoid* shmptr;\nshmid=shm_open(name,O_CREAT|O_RDWR,0666);\n      if (shmid< 0) {\n          printf(\"*** shmget error (server) ***\\n\");\n          exit(1);\n     }\n     ftruncate(shmid,SIZE);\n     shmptr=mmap(0,SIZE,PROT_WRITE,MAP_SHARED,shmid,0);\n     printf(\"inside client\\n\");\n     while(1)\n     {\n         puts(shmptr);\n         shmptr+=15*sizeof(char);\n     }\n     shm_unlink(name);\n     return 0;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { const char * name = \" odd_even \" ; const int ingresado = 15 * 1024 ; int shmid ; char words ; void * shmptr ; shmid = shm_open ( name , O_CREAT | O_RDWR , 0666 ) ; if ( shmid < 0 ) { printf ( \" *** shmget error (server) ***\\n \" ) ; exit ( 1 ) ; } ftruncate ( shmid , ingresado ) ; shmptr = mmap ( 0 , ingresado , PROT_WRITE , MAP_SHARED , shmid , 0 ) ; printf ( \" inside client\\n \" ) ; while ( 1 ) { puts ( shmptr ) ; shmptr += 15 * sizeof ( char ) ; } shm_unlink ( name ) ; return 0 ; }"}
{"author": "paawankohli", "file": "DSA-LAB__LLunion.5.c", "original_string": "int main()\n{\n    nptr head1 = NULL, head2 = NULL, head3 = NULL;\n    int ele;\n    printf(\"Elements in list 1: \\n\");\n    while(1)\n    {\n        scanf(\"%d\", &ele);\n        if(ele == -1)\n            break;\n        insertRear(head1, ele);\n    } \n    display(head1);\n    printf(\"Elements in list 2: \\n\");\n    while(1)\n    {\n        scanf(\"%d\", &ele);\n        if(ele == -1)\n            break;\n        insertRear(head2, ele);\n    } \n    display(head2);  \n    printf(\"\\nUnion: \\n\");\n    display(head3 = listUnion(head1, head2));\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { nptr Head1 = NULL , Val = NULL , Head3 = NULL ; int Ele ; printf ( \" Elements in list 1: \\n \" ) ; while ( 1 ) { scanf ( \" %d \" , & Ele ) ; if ( Ele == - 1 ) break ; insertRear ( Head1 , Ele ) ; } display ( Head1 ) ; printf ( \" Elements in list 2: \\n \" ) ; while ( 1 ) { scanf ( \" %d \" , & Ele ) ; if ( Ele == - 1 ) break ; insertRear ( Val , Ele ) ; } display ( Val ) ; printf ( \" \\nUnion: \\n \" ) ; display ( Head3 = listUnion ( Head1 , Val ) ) ; }"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_04.0.c", "original_string": "int* read(int n)\n{\n        int i;\n        int s = sizeof(int);\n        int* arr1= (int*)malloc(s * n);\n        for(i = 0; i<n; i++)\n        {\n                fscanf(F1, \"%d\", (arr1+i));\n        }\n        return arr1;\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "int * Read ( int Whole ) { int I ; int S = sizeof ( int ) ; int * Arr1 = ( int * ) malloc ( S * Whole ) ; for ( I = 0 ; I < Whole ; I ++ ) { fscanf ( F1 , \" %d \" , ( Arr1 + I ) ) ; } return Arr1 ; }"}
{"author": "Ana-Morales", "file": "binary_trees__16-binary_tree_is_perfect.0.c", "original_string": "size_t binary_tree_height(const binary_tree_t *tree)\n{\n    size_t height_left = 0;\n    size_t height_right = 0;\n    if (tree == NULL)\n        return (-1);\n    if (tree->left == NULL && tree->right == NULL)\n        return (0);\n    height_left = binary_tree_height(tree->left) + 1;\n    height_right = binary_tree_height(tree->right) + 1;\n    if (height_left > height_right)\n        return (height_left);\n    return (height_right);\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "size_t binary_tree_height ( const binary_tree_t * _tree ) { size_t _height_left = 0 ; size_t _cc = 0 ; if ( _tree == NULL ) return ( - 1 ) ; if ( _tree -> left == NULL && _tree -> right == NULL ) return ( 0 ) ; _height_left = binary_tree_height ( _tree -> left ) + 1 ; _cc = binary_tree_height ( _tree -> right ) + 1 ; if ( _height_left > _cc ) return ( _height_left ) ; return ( _cc ) ; }"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__multiple_isr.1.c", "original_string": "void timer_config(void)\n{\n        T0PR = 14;\n        T0MR0 = 2000000;\n        T0MCR = (1<<0)|(1<<1);\n        T1PR = 14;\n        T1MR0 = 2000000;\n        T1MCR = (1<<0)|(1<<1);\n        T1TCR = (1<<0);\n        T0TCR = (1<<0);\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void timer_config ( void ) { T0PR = 14 ; lf = 2000000 ; T0MCR = ( 1 << 0 ) | ( 1 << 1 ) ; T1PR = 14 ; T1MR0 = 2000000 ; T1MCR = ( 1 << 0 ) | ( 1 << 1 ) ; T1TCR = ( 1 << 0 ) ; T0TCR = ( 1 << 0 ) ; }"}
{"author": "kbtomic", "file": "StrukturePodataka__zad5.3.c", "original_string": "int unosPrvi(pozicija p)\n{\n    FILE* fp = NULL;\n    fp = fopen(\"lista1.txt\", \"r\");\n    if (fp == NULL)\n    {\n        printf(\"Neuspjesno otvaranje datoteke!\\n\");\n        return 1;\n    }\n    while (!feof(fp))\n    {\n        pozicija q = NULL;\n        q = (pozicija)malloc(sizeof(struct lista));\n        if (q == NULL)\n        {\n            printf(\"Neuspjesna alokacija memorije!\\n\");\n            return 1;\n        }\n        pozicija pret, temp;\n        temp = p->next;\n        pret = p;\n        fscanf(fp, \"%d\\n\", &q->el);\n        while (temp != NULL)\n        {\n            pret = temp;\n            temp = temp->next;\n        }\n        pret->next = q;\n        if (temp != NULL)\n            q->next = temp;\n        else\n            q->next = NULL;\n    }\n    return 0;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int unosPrvi ( pozicija p ) { FILE * fp = NULL ; fp = fopen ( \" lista1.txt \" , \" r \" ) ; if ( fp == NULL ) { printf ( \" Neuspjesno otvaranje datoteke!\\n \" ) ; return 1 ; } while ( ! feof ( fp ) ) { pozicija q = NULL ; q = ( pozicija ) malloc ( sizeof ( struct lista ) ) ; if ( q == NULL ) { printf ( \" Neuspjesna alokacija memorije!\\n \" ) ; return 1 ; } pozicija pret , ingresado ; ingresado = p -> next ; pret = p ; fscanf ( fp , \" %d\\n \" , & q -> el ) ; while ( ingresado != NULL ) { pret = ingresado ; ingresado = ingresado -> next ; } pret -> next = q ; if ( ingresado != NULL ) q -> next = ingresado ; else q -> next = NULL ; } return 0 ; }"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__BubbleSort.1.c", "original_string": "int bubbleSort(int x[],int y)\n{\n    int i,j,temp;\n    for(i=0;i<y;i++)\n    {\n        for(j=0;j<y-i-1;j++)\n        {\n            if(x[j] > x[j+1])\n            {\n                temp = x[j];\n                x[j] = x[j+1];\n                x[j+1] = temp;\n            }\n        }\n    }\n    printf(\"sorted array:\\n\");\n    for(i=0;i<y;i++)\n    {\n        printf(\"%d\\n\",x[i]);\n    }\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "int bubbleSort ( int Fdb [ ] , int Y ) { int I , J , Temp ; for ( I = 0 ; I < Y ; I ++ ) { for ( J = 0 ; J < Y - I - 1 ; J ++ ) { if ( Fdb [ J ] > Fdb [ J + 1 ] ) { Temp = Fdb [ J ] ; Fdb [ J ] = Fdb [ J + 1 ] ; Fdb [ J + 1 ] = Temp ; } } } printf ( \" sorted array:\\n \" ) ; for ( I = 0 ; I < Y ; I ++ ) { printf ( \" %d\\n \" , Fdb [ I ] ) ; } }"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__UARTDrv.0.c", "original_string": "void uart_init(uart_port_t unit, uart_config_t *config, uint8_t txPin, uint8_t rxPin)\n{\n  uartUnit = unit;\n  uart_param_config(unit, config);\n  uart_set_pin(unit, txPin, rxPin, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);\n  uart_driver_install(unit, UART_BUFFER_SIZE, UART_BUFFER_SIZE, 0, NULL, 0);\n  uart_set_mode(unit, UART_MODE_UART);\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void uart_init ( uart_port_t _unit , uart_config_t * _config , uint8_t _tx_pin , uint8_t _rx_pin ) { Cunha = _unit ; uart_param_config ( _unit , _config ) ; uart_set_pin ( _unit , _tx_pin , _rx_pin , UART_PIN_NO_CHANGE , UART_PIN_NO_CHANGE ) ; uart_driver_install ( _unit , UART_BUFFER_SIZE , UART_BUFFER_SIZE , 0 , NULL , 0 ) ; uart_set_mode ( _unit , UART_MODE_UART ) ; }"}
{"author": "MartinMarinovich", "file": "MarinovichMartinLABIPP1G-__servicio0.0.c", "original_string": "int hardCodearServicios(eServicio listadoServicios[], int tamanioServicio)\n{\n    int error = -1;\n    int idServicio [4]= {2000,2001,2002,2003};\n    char servicio [4][25] = {\"Bateria\",\"Antivirus\",\"Actualizacion\",\"Fuente\"};\n    int precios[4] = {250,300,400,600};\n    if(listadoServicios != NULL && tamanioServicio>0)\n    {\n        for(int i = 0; i<tamanioServicio; i++)\n        {\n            strcpy(listadoServicios[i].descripcion,servicio[i]);\n            listadoServicios[i].precio = precios[i];\n            listadoServicios[i].idServicio = idServicio[i];\n        }\n        error = 0;\n    }\n    return error;\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "int hardCodearServicios ( eServicio ListadoServicios [ ] , int TamanioServicio ) { int Error = - 1 ; int Whole [ 4 ] = { 2000 , 2001 , 2002 , 2003 } ; char Servicio [ 4 ] [ 25 ] = { \" Bateria \" , \" Antivirus \" , \" Actualizacion \" , \" Fuente \" } ; int Precios [ 4 ] = { 250 , 300 , 400 , 600 } ; if ( ListadoServicios != NULL && TamanioServicio > 0 ) { for ( int I = 0 ; I < TamanioServicio ; I ++ ) { strcpy ( ListadoServicios [ I ].descripcion , Servicio [ I ] ) ; ListadoServicios [ I ].precio = Precios [ I ] ; ListadoServicios [ I ].idServicio = Whole [ I ] ; } Error = 0 ; } return Error ; }"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__channel_survey.5.c", "original_string": "uint32_t channel_map_request_update(uint16_t conn_handle, uint8_t first_best_channel_number)\n{\n        ret_code_t err_code;\n        uint8_t number_channel_request = 0;\n        ble_gap_opt_ch_map_t channel_map = {0};\n        if (conn_handle == BLE_CONN_HANDLE_INVALID)\n        {\n                NRF_LOG_ERROR(\"Failure: because of disconnection!\");\n                return -1;\n        }\n        NRF_LOG_DEBUG(\"channel_map_request_update!!\");\n        channel_map.conn_handle = conn_handle;  \n        for (uint8_t i=0; i < BLE_GAP_CHANNEL_COUNT; i++)\n        {\n                uint8_t freq_index = m_average_ch_energy[i].index;\n                if (freq_index != ADVERTISING_CHANNEL_37 && freq_index != ADVERTISING_CHANNEL_38 && freq_index != ADVERTISING_CHANNEL_39)\n                {\n                        if (freq_index < 8)\n                        {\n                                channel_map.ch_map[0] |= 1 << (freq_index);\n                        }\n                        else if (freq_index < 16)\n                        {\n                                channel_map.ch_map[1] |= 1 << (freq_index-8);\n                        }\n                        else if (freq_index < 24)\n                        {\n                                channel_map.ch_map[2] |= 1 << (freq_index-16);\n                        }\n                        else if (freq_index < 32)\n                        {\n                                channel_map.ch_map[3] |= 1 << (freq_index-24);\n                        }\n                        else\n                        {\n                                channel_map.ch_map[4] |= 1 << (freq_index-32);\n                        }\n                        number_channel_request++;\n                }\n                if (number_channel_request > first_best_channel_number)\n                {\n                        break;\n                }\n        }\n        NRF_LOG_HEXDUMP_DEBUG(channel_map.ch_map, 5);\n        err_code = sd_ble_opt_set(BLE_GAP_OPT_CH_MAP, (ble_opt_t *)&channel_map);\n        APP_ERROR_CHECK(err_code);\n        update_channel_survey_status = false;\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "uint32_t channel_map_request_update ( uint16_t idade , uint8_t firstBestChannelNumber ) { ret_code_t errCode ; uint8_t numberChannelRequest = 0 ; ble_gap_opt_ch_map_t channelMap = { 0 } ; if ( idade == BLE_CONN_HANDLE_INVALID ) { NRF_LOG_ERROR ( \" Failure: because of disconnection! \" ) ; return - 1 ; } NRF_LOG_DEBUG ( \" channel_map_request_update!! \" ) ; channelMap.conn_handle = idade ; for ( uint8_t i = 0 ; i < BLE_GAP_CHANNEL_COUNT ; i ++ ) { uint8_t freqIndex = m_average_ch_energy [ i ].index ; if ( freqIndex != ADVERTISING_CHANNEL_37 && freqIndex != ADVERTISING_CHANNEL_38 && freqIndex != ADVERTISING_CHANNEL_39 ) { if ( freqIndex < 8 ) { channelMap.ch_map [ 0 ] |= 1 << ( freqIndex ) ; } else if ( freqIndex < 16 ) { channelMap.ch_map [ 1 ] |= 1 << ( freqIndex - 8 ) ; } else if ( freqIndex < 24 ) { channelMap.ch_map [ 2 ] |= 1 << ( freqIndex - 16 ) ; } else if ( freqIndex < 32 ) { channelMap.ch_map [ 3 ] |= 1 << ( freqIndex - 24 ) ; } else { channelMap.ch_map [ 4 ] |= 1 << ( freqIndex - 32 ) ; } numberChannelRequest ++ ; } if ( numberChannelRequest > firstBestChannelNumber ) { break ; } } NRF_LOG_HEXDUMP_DEBUG ( channelMap.ch_map , 5 ) ; errCode = sd_ble_opt_set ( BLE_GAP_OPT_CH_MAP , ( ble_opt_t * ) & channelMap ) ; APP_ERROR_CHECK ( errCode ) ; update_channel_survey_status = false ; }"}
{"author": "earth429", "file": "mulpre__t.0.c", "original_string": "int main(int argc, char **argv)\n{\n    double t1 = time(NULL);\n    struct NUMBER a, b, c, d, one, two, three, a_tmp;\n    int val;\n    setInt(&one ,1);\n    setInt(&two, 2);\n    setInt(&three, 3);\n    setInt(&b, 500); \n    printf(\"ネイピア数計算開始\\n\");\n    neipia(&a, &b);\n    dispNumber(&a);\n    val = getDigit(&a);\n    printf(\"\\nval1:%d\\n\", val);\n    compareNumber(&a, \"neipia.txt\", val);\n    double t3 = time(NULL);\n    printf(\"\\n途中時間:%f\\n\", t3 - t1);\n    printf(\"\\n平方根計算開始\\n\");\n    divBy10(&a, &a_tmp);\n    copyNumber(&a_tmp, &a);\n    sqrt_newton(&a, &c);\n    dispNumberZeroSuppress(&c);\n    val = getDigit(&c);\n    printf(\"\\nval2:%d\\n\", val);\n    compareNumber(&c, \"sqrtE.txt\", val);\n    t3 = time(NULL);\n    printf(\"\\n途中時間:%f\\n\", t3 - t1);\n    printf(\"\\n三乗根計算開始\\n\");\n    mulBy10(&a, &a_tmp);\n    copyNumber(&a_tmp, &a);\n    curt(&a, &d);\n    dispNumberZeroSuppress(&d);\n    val = getDigit(&d);\n    printf(\"\\nval3:%d\\n\", val);\n    compareNumber(&d, \"curtE.txt\", val);\n    double t2 = time(NULL);\n    printf(\"\\n処理時間:%f\\n\", t2 - t1);\n    return 0;\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "int main ( int Temperature , char * * Argv ) { double T1 = time ( NULL ) ; struct NUMBER A , B , C , D , One , Two , Three , ATmp ; int Val ; setInt ( & One , 1 ) ; setInt ( & Two , 2 ) ; setInt ( & Three , 3 ) ; setInt ( & B , 500 ) ; printf ( \" ネイピア数計算開始\\n \" ) ; neipia ( & A , & B ) ; dispNumber ( & A ) ; Val = getDigit ( & A ) ; printf ( \" \\nval1:%d\\n \" , Val ) ; compareNumber ( & A , \" neipia.txt \" , Val ) ; double T3 = time ( NULL ) ; printf ( \" \\n途中時間:%f\\n \" , T3 - T1 ) ; printf ( \" \\n平方根計算開始\\n \" ) ; divBy10 ( & A , & ATmp ) ; copyNumber ( & ATmp , & A ) ; sqrt_newton ( & A , & C ) ; dispNumberZeroSuppress ( & C ) ; Val = getDigit ( & C ) ; printf ( \" \\nval2:%d\\n \" , Val ) ; compareNumber ( & C , \" sqrtE.txt \" , Val ) ; T3 = time ( NULL ) ; printf ( \" \\n途中時間:%f\\n \" , T3 - T1 ) ; printf ( \" \\n三乗根計算開始\\n \" ) ; mulBy10 ( & A , & ATmp ) ; copyNumber ( & ATmp , & A ) ; curt ( & A , & D ) ; dispNumberZeroSuppress ( & D ) ; Val = getDigit ( & D ) ; printf ( \" \\nval3:%d\\n \" , Val ) ; compareNumber ( & D , \" curtE.txt \" , Val ) ; double T2 = time ( NULL ) ; printf ( \" \\n処理時間:%f\\n \" , T2 - T1 ) ; return 0 ; }"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__InsertionOfNodeAtBeginningInLL.0.c", "original_string": "int add_at_beginning(struct node**temp1)\n{\n    struct node*tempo;\n    tempo = (struct node*) malloc (sizeof(struct node));\n    printf(\"Enter the element:\");\n    scanf(\"%d\",&tempo->data);\n    tempo->link = *temp1;\n    *temp1 = tempo;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "int add_at_beginning ( struct node * * _ingresado ) { struct node * _tempo ; _tempo = ( struct node * ) malloc ( sizeof ( struct node ) ) ; printf ( \" Enter the element: \" ) ; scanf ( \" %d \" , & _tempo -> data ) ; _tempo -> link = * _ingresado ; * _ingresado = _tempo ; }"}
{"author": "davibernardos", "file": "DB-PJ__e62.5.c", "original_string": "void menuIngresso()\n{                       \n    int pagamento, existeEvento;\n    if (capacidadeMax == 0)\n    {\n        printf(\"Nao ha evento cadastrado\\n\");   \n    }\n        else\n        {   \n            existeEvento = selecionarEvento();\n            if(existeEvento == 1)   \n            {\n                printf(\"\\n\\t\\t\\t\\t(10%% de desconto no dinheiro)\\n\\n\");\n                printf(\"\\n Digite 1 para pagamento no cartao: \");           \n                printf(\"\\n Digite 2 para pagamento em dinheiro: \\n\\t\");\n                scanf(\"%d\", &pagamento);\n                if(pagamento == 1)\n                {           \n                comprarIngresso(escolherIngresso(), 0);\n                }\n                    else\n                    {\n                        comprarIngresso(escolherIngresso(), 0.1);\n                    }\n            }\n                else\n                {\n                    printf(\"\\n\\n\\tNao existe esse evento!\\n\");\n                }   \n        }\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void menuIngresso ( ) { int Percorri , ExisteEvento ; if ( capacidadeMax == 0 ) { printf ( \" Nao ha evento cadastrado\\n \" ) ; } else { ExisteEvento = selecionarEvento ( ) ; if ( ExisteEvento == 1 ) { printf ( \" \\n\\t\\t\\t\\t(10%% de desconto no dinheiro)\\n\\n \" ) ; printf ( \" \\n Digite 1 para pagamento no cartao:  \" ) ; printf ( \" \\n Digite 2 para pagamento em dinheiro: \\n\\t \" ) ; scanf ( \" %d \" , & Percorri ) ; if ( Percorri == 1 ) { comprarIngresso ( escolherIngresso ( ) , 0 ) ; } else { comprarIngresso ( escolherIngresso ( ) , 0.1 ) ; } } else { printf ( \" \\n\\n\\tNao existe esse evento!\\n \" ) ; } } }"}
{"author": "ashlyn2002", "file": "programming-using-c__linear_search.2.c", "original_string": "int main(void) {\n    printf(\"linear search \\n\");\n    printf(\"searching for an  element in the array \\n\"); \n    printf(\"elements in the array are \\n\");\n    int a[5]={15,24,36,14,22};\n    int n=5;\n    printarray(a,n);\n    int data=36;\n    printf(\"\\n the searching element in the array is %d \\n\",data);\n    linear(a,n,data);\n    return EXIT_SUCCESS;\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( void ) { printf ( \" linear search \\n \" ) ; printf ( \" searching for an  element in the array \\n \" ) ; printf ( \" elements in the array are \\n \" ) ; int _a [ 5 ] = { 15 , 24 , 36 , 14 , 22 } ; int _times = 5 ; printarray ( _a , _times ) ; int _data = 36 ; printf ( \" \\n the searching element in the array is %d \\n \" , _data ) ; linear ( _a , _times , _data ) ; return EXIT_SUCCESS ; }"}
{"author": "kalpa96", "file": "Pointers__min.0.c", "original_string": "int main(){\n    int num1,num2,num3;\n    int *p1,*p2,*p3;\n    printf(\"Enter Number 1 : \");\n    scanf(\"%d\",&num1);\n    printf(\"Enter Number 2 : \");\n    scanf(\"%d\",&num2);\n    printf(\"Enter Number 3 : \");\n    scanf(\"%d\",&num3);\n    printf(\"\\n\");\n    p1 = &num1;\n    p2 = &num2;\n    p3 = &num3;\n    if(*p1 > *p2){\n        if(*p1 > *p3){\n            printf(\"Maximum is : %d\\n\",*p1);\n        }\n        else{\n            printf(\"Maximum is : %d\\n\",*p3);\n        }\n    }\n    else{\n        if(*p2 > *p3){\n            printf(\"Maximum is : %d\\n\",*p2);\n        }\n        else{\n            printf(\"Maximum is : %d\\n\",*p3);\n        }\n    }\n    if(*p1 < *p2){\n        if(*p1 < *p3){\n            printf(\"Minimum is : %d\",*p1);\n        }\n        else{\n            printf(\"Minimum is : %d\",*p3);\n        }\n    }\n    else{\n        if(*p2 < *p3){\n            printf(\"Minimum is : %d\",*p2);\n        }\n        else{\n            printf(\"Minimum is : %d\",*p3);\n        }\n    }\n    return 0;\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { int _num1 , _num2 , _num3 ; int * _p1 , * _tolower , * _p3 ; printf ( \" Enter Number 1 :  \" ) ; scanf ( \" %d \" , & _num1 ) ; printf ( \" Enter Number 2 :  \" ) ; scanf ( \" %d \" , & _num2 ) ; printf ( \" Enter Number 3 :  \" ) ; scanf ( \" %d \" , & _num3 ) ; printf ( \" \\n \" ) ; _p1 = & _num1 ; _tolower = & _num2 ; _p3 = & _num3 ; if ( * _p1 > * _tolower ) { if ( * _p1 > * _p3 ) { printf ( \" Maximum is : %d\\n \" , * _p1 ) ; } else { printf ( \" Maximum is : %d\\n \" , * _p3 ) ; } } else { if ( * _tolower > * _p3 ) { printf ( \" Maximum is : %d\\n \" , * _tolower ) ; } else { printf ( \" Maximum is : %d\\n \" , * _p3 ) ; } } if ( * _p1 < * _tolower ) { if ( * _p1 < * _p3 ) { printf ( \" Minimum is : %d \" , * _p1 ) ; } else { printf ( \" Minimum is : %d \" , * _p3 ) ; } } else { if ( * _tolower < * _p3 ) { printf ( \" Minimum is : %d \" , * _tolower ) ; } else { printf ( \" Minimum is : %d \" , * _p3 ) ; } } return 0 ; }"}
{"author": "2security", "file": "Matrix__40CheckSymmetricMatrix.1.c", "original_string": "int ** Transpose(int mat1[][20],int mat2[][20],int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n    for(j=0;j<c;j++)\n        mat2[i][j]=mat1[j][i];\n    return mat2;\n    }", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int * * transpose ( int mat1 [ ] [ 20 ] , int mat2 [ ] [ 20 ] , int r , int ingresado ) { int i , j ; for ( i = 0 ; i < r ; i ++ ) for ( j = 0 ; j < ingresado ; j ++ ) mat2 [ i ] [ j ] = mat1 [ j ] [ i ] ; return mat2 ; }"}
{"author": "sdukesameer", "file": "dsa__bst-height-mirror-c_nodes-dealloc-a.10.c", "original_string": "int InternalNodeCount(list* node)\n{\n    if(node==NULL ||(node->left==NULL && node->right==NULL))\n        return 0;\n    else\n        return 1 + InternalNodeCount(node->left)+InternalNodeCount(node->right);\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "int InternalNodeCount ( list * cunha ) { if ( cunha == NULL || ( cunha -> left == NULL && cunha -> right == NULL ) ) return 0 ; else return 1 + InternalNodeCount ( cunha -> left ) + InternalNodeCount ( cunha -> right ) ; }"}
{"author": "RobertoBenjami", "file": "stm32_character_display_drivers__stm32f1xx_hal.8.c", "original_string": "HAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq)\n{\n  HAL_StatusTypeDef status  = HAL_OK;\n  assert_param(IS_TICKFREQ(Freq));\n  if (uwTickFreq != Freq)\n  {\n    uwTickFreq = Freq;\n    status = HAL_InitTick(uwTickPrio);\n  }\n  return status;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "HAL_StatusTypeDef HAL_SetTickFreq ( HAL_TickFreqTypeDef freq ) { HAL_StatusTypeDef successor = HAL_OK ; assert_param ( IS_TICKFREQ ( freq ) ) ; if ( uwTickFreq != freq ) { uwTickFreq = freq ; successor = HAL_InitTick ( uwTickPrio ) ; } return successor ; }"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_7.5.c", "original_string": "int main()\n{\n    int num;\n    char sel;\n    int n1; int capacity;\n    FILE* fp1;\n    FILE* fp2;\n    fp1=fopen(\"input.txt\",\"r\");\n    fp2=fopen(\"output.txt\",\"w\");\n    fscanf(fp1,\"%d\",&capacity);\n    struct stack* stk=(struct stack*)malloc(sizeof(struct stack));\n    stk->cap=capacity;\n    stk->top=-1;\n    stk->A=(int*)malloc(sizeof(int)*capacity);\n    while(1){\n    fscanf(fp1,\"%c\",&sel);\n    if(sel=='p')\n    {\n        fscanf(fp1,\"%d\",&n1);\n        push(stk,n1,fp2);\n    }\n    else if(sel=='t')\n    {\n        pop(stk,fp2);\n    }\n    else if(sel=='d')\n    {\n        fscanf(fp1,\"%d\",&num);\n        print(stk,num,fp2);\n    }\n    else if(sel=='s')\n    {\n        break;\n    }\n}\n}", "watermark": [0, 1, 0, 1], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int _num ; char _sel ; int _n1 ; int _capacity ; FILE * _fp1 ; FILE * _temperature ; _fp1 = fopen ( \" input.txt \" , \" r \" ) ; _temperature = fopen ( \" output.txt \" , \" w \" ) ; fscanf ( _fp1 , \" %d \" , & _capacity ) ; struct stack * _stk = ( struct stack * ) malloc ( sizeof ( struct stack ) ) ; _stk -> cap = _capacity ; _stk -> top = - 1 ; _stk -> A = ( int * ) malloc ( sizeof ( int ) * _capacity ) ; while ( 1 ) { fscanf ( _fp1 , \" %c \" , & _sel ) ; if ( _sel == 'p' ) { fscanf ( _fp1 , \" %d \" , & _n1 ) ; push ( _stk , _n1 , _temperature ) ; } else if ( _sel == 't' ) { pop ( _stk , _temperature ) ; } else if ( _sel == 'd' ) { fscanf ( _fp1 , \" %d \" , & _num ) ; print ( _stk , _num , _temperature ) ; } else if ( _sel == 's' ) { break ; } } }"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_beg_SLL.0.c", "original_string": "int main()\n{\n    printf(\"Linked list functions\\n\");\n    int choice;\n    printf(\"1.implementation\\n\");\n    printf(\"2.display\\n\");\n    printf(\"3.count\\n\");\n    printf(\"4.delete the element at the beginning position\\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",& choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation \\n\");\n            create();\n            break;\n            case 2:printf(\"display\\n\");\n            display();\n            break;\n            case 3:printf(\"count the element in linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"delete the element from the beginning\\n\");\n            delete_at_beg();\n            break;\n            case 5:exit(0);\n            break;\n            default: printf(\"wrong choice \\n\");\n            break;\n        }\n        printf(\"enter the choice =\");\n        scanf(\"%d\",& choice);\n        }\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { printf ( \" Linked list functions\\n \" ) ; int _memblk ; printf ( \" 1.implementation\\n \" ) ; printf ( \" 2.display\\n \" ) ; printf ( \" 3.count\\n \" ) ; printf ( \" 4.delete the element at the beginning position\\n \" ) ; printf ( \" 5.exit\\n \" ) ; printf ( \" enter the choice = \" ) ; scanf ( \" %d \" , & _memblk ) ; while ( _memblk != 6 ) { switch ( _memblk ) { case 1 : printf ( \" implementation \\n \" ) ; create ( ) ; break ; case 2 : printf ( \" display\\n \" ) ; display ( ) ; break ; case 3 : printf ( \" count the element in linked list\\n \" ) ; count ( ) ; break ; case 4 : printf ( \" delete the element from the beginning\\n \" ) ; delete _at_beg ( ) ; break ; case 5 : exit ( 0 ) ; break ; default : printf ( \" wrong choice \\n \" ) ; break ; } printf ( \" enter the choice = \" ) ; scanf ( \" %d \" , & _memblk ) ; } }"}
{"author": "chandanXP", "file": "Datastructure-using-C__peekInStack.4.c", "original_string": "int peek(struct stack* sp, int i){\n    int arrayInd = sp->top-i+1;\n    if(arrayInd<0){\n        printf(\"Not a valid position for stack\\n\");\n        return -1;\n    }\n    else{\n        return sp->arr[arrayInd];\n    }\n}", "watermark": [1, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "int peek ( struct stack * cunha , int i ) { int arrayInd = cunha -> top - i + 1 ; if ( arrayInd < 0 ) { printf ( \" Not a valid position for stack\\n \" ) ; return - 1 ; } else { return cunha -> arr [ arrayInd ] ; } }"}
{"author": "davibernardos", "file": "DB-PJ__e2.0.c", "original_string": "int main(void) {\n    srand (time(NULL));\n    int jogarNovamente;\n    int jogarNovamente2;\n    int jogarMais = 1;\n    int escolhaJogo;\n    int jogador1;\n    int jogador2;\n    int jogadaComputador;\n    int linha;\n    int pontosJogador1 = 0;\n    int pontosJogador2 = 0;\n    int pontosComputador = 0;\n    int empate = 0;\n    int totalJogadas;\n    float porcentagemJogador1;\n    float porcentagemJogador2;\n    float porcentagemComputador;\n    printf(\"\\n                              JOKENPO ULTIMATE!\\n\\n\");\n    printf(\"\\n                    Digite >1< para jogar contra o computador.\\n\");\n    printf(\"                    Digite >2< para jogar contra outro humano.\\n\\n\");\n    printf(\"                                     >\");\n    scanf(\" %d\", &escolhaJogo);\n    while(jogarMais > 0){\n        jogadaComputador = rand()%3+1;\n        if(escolhaJogo == 1){ \n        printf(\"\\n                          Para jogar PEDRA digite    >1<\\n\");\n        printf(\"                          Para jogar PAPEL digite    >2<\\n\");\n        printf(\"                          Para jogar TESOURA digite  >3<\\n\\n\");\n        printf(\"\\n                          HUMANO X COMPUTADOR, BOA SORTE!!\");\n        printf(\"\\n                                Faca a sua jogada: \\n\\n\");\n        printf(\"                                     >\");\n        scanf(\" %d\", &jogador1);\n            if(jogador1 >=1 && jogador1 <=3){ \n                printf(\"\\n                                  JO\");\n                sleep(1);\n                printf(\"KEN\");\n                sleep(1);\n                printf(\"PO!!! \\n\\n\");\n                sleep(1);\n                for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n                }\n                switch(jogador1){ \n                    case 1:\n                        printf(\"                                 PEDRA x \");\n                        break;\n                    case 2:\n                        printf(\"                                 PAPEL x \");\n                        break;\n                    case 3:\n                        printf(\"                                TESOURA x \");\n                        break;\n                }\n                switch(jogadaComputador){ \n                    case 1:\n                        printf(\"PEDRA \\n\\n\");\n                        break;\n                    case 2:\n                        printf(\"PAPEL \\n\\n\");\n                        break;\n                    case 3:\n                        printf(\"TESOURA \\n\\n\");\n                        break;\n                }\n                if ((jogador1 == 1 && jogadaComputador == 3) || (jogador1 == 2 && jogadaComputador == 1) || (jogador1 == 3 && jogadaComputador == 2)){ \n                    printf(\"                                 VOCE VENCEU!!! \\n\\n\");\n                    pontosJogador1 = pontosJogador1 + 1;\n                }\n                if (jogador1 == jogadaComputador){ \n                    printf(\"                                    EMPATE! \\n\\n\");\n                    empate++;\n                }\n                if ((jogadaComputador == 1 && jogador1 == 3) || (jogadaComputador == 2 && jogador1 == 1) || (jogadaComputador == 3 && jogador1 == 2)){ \n                    printf(\"                                 VOCE PERDEU :( \\n\\n\");\n                    pontosComputador = pontosComputador + 1;\n            }\n        } else { \n            printf(\"\\n                        Voce nao digitou um numero valido. \\n\");\n        }\n        }\n        if(escolhaJogo == 2){  \n            printf(\"\\n                          Para jogar PEDRA digite    >1<\\n\");\n            printf(\"                          Para jogar PAPEL digite    >2<\\n\");\n            printf(\"                          Para jogar TESOURA digite  >3<\\n\\n\");\n            printf(\"\\n                          HUMANO X HUMANO, BOA SORTE!!\");\n            printf(\"\\n\\n                          JOGADOR 1 Faca a sua jogada: \\n\\n\");\n            printf(\"                                     >\");\n            scanf(\" %d\", &jogador1);\n            if(jogador1 >= 1 && jogador1 <= 3){\n                for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n                }\n                printf(\"\\n                          Para jogar PEDRA digite    >1<\\n\");\n                printf(\"                          Para jogar PAPEL digite    >2<\\n\");\n                printf(\"                          Para jogar TESOURA digite  >3<\\n\\n\");\n                printf(\"\\n                          HUMANO X HUMANO, BOA SORTE!!\");\n                printf(\"\\n\\n                          JOGADOR 2 Faca a sua jogada: \\n\\n\");\n                printf(\"                                     >\");\n                scanf(\" %d\", &jogador2);\n                if(jogador2 >= 1 && jogador2 <= 3) {\n                    printf(\"\\n                                  JO\");\n                    sleep(1);\n                    printf(\"KEN\");\n                    sleep(1);\n                    printf(\"PO!!! \\n\\n\");\n                    sleep(1);\n                    for( linha = 0; linha < 35; linha++){ \n                        printf( \"\\n\" );\n                    }\n                    switch(jogador1){ \n                    case 1:\n                        printf(\"                                 PEDRA x \");\n                        break;\n                    case 2:\n                        printf(\"                                 PAPEL x \");\n                        break;\n                    case 3:\n                        printf(\"                                TESOURA x \");\n                        break;\n                    }\n                    switch(jogador2){ \n                    case 1:\n                        printf(\"PEDRA \\n\\n\");\n                        break;\n                    case 2:\n                        printf(\"PAPEL \\n\\n\");\n                        break;\n                    case 3:\n                        printf(\"TESOURA \\n\\n\");\n                        break;\n                    }\n                    if ((jogador1 == 1 && jogador2 == 3) || (jogador1 == 2 && jogador2 == 1) || (jogador1 == 3 && jogador2 == 2)){ \n                        printf(\"                               JOGADOR 1 VENCEU! \\n\\n\");\n                        pontosJogador1 = pontosJogador1 + 1;\n                    }\n                    if (jogador1 == jogador2){ \n                        printf(\"                                    EMPATE! \\n\\n\");\n                        empate++;\n                    }\n                    if ((jogador2 == 1 && jogador1 == 3) || (jogador2 == 2 && jogador1 == 1) || (jogador2 == 3 && jogador1 == 2)){ \n                        printf(\"                               JOGADOR 2 VENCEU! \\n\\n\");\n                        pontosJogador2 = pontosJogador2 + 1;\n                    }\n                } else { \n                    printf(\"\\n                        Voce nao digitou um numero valido. \\n\");\n                }\n            } else { \n                printf(\"\\n                        Voce nao digitou um numero valido. \\n\");\n            }\n        }\n        if(escolhaJogo > 2){  \n            printf(\"\\n              Voce nao digitou um numero valido. Reinicie o jogo. \\n\");\n            exit(0);\n        }\n        printf(\"\\n\\n\\n\\n\\n\\n\\n\\n                          Para jogar novamente digite >1< \\n\");\n        printf(\"                          Para estatisticas digite    >2< \\n\");\n        printf(\"                          Para sair digite            >3< \\n\\n\");\n        printf(\"                                     >\");\n        scanf(\" %d\", &jogarNovamente);\n        if(jogarNovamente == 1){ \n            for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n                }\n        }\n        if(jogarNovamente == 2){ \n            for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n            }\n            totalJogadas = pontosJogador1 + pontosJogador2 + pontosComputador + empate;\n            printf(\"\\n                                 ESTATISTICAS!\\n\\n\");\n            printf(\"                          Vitorias do Jogador 1:     >%d< \\n\", pontosJogador1);\n            if(pontosJogador2 > 0){\n                printf(\"                      Vitorias do Jogador 2:     >%d< \\n\\n\", pontosJogador2);\n                printf(\"                      Empates:                   >%d< \\n\\n\", empate);\n                porcentagemJogador1 = ((float)pontosJogador1 / (float)totalJogadas) * 100;\n                porcentagemJogador2 = ((float)pontosJogador2 / (float)totalJogadas) * 100;\n                printf(\"                  Porcentagem de vitorias do Jogador 1:     >%.1f< \\n\", porcentagemJogador1);\n                printf(\"                  Porcentagem de vitorias do Jogador 2:     >%.1f< \\n\", porcentagemJogador2);\n            }\n            if(pontosComputador > 0){\n                printf(\"                          Vitorias do Computador:    >%d< \\n\\n\", pontosComputador);\n                printf(\"                          Empates:                   >%d< \\n\\n\", empate);\n                porcentagemJogador1 = ((float)pontosJogador1 / (float)totalJogadas) * 100;\n                porcentagemComputador = ((float)pontosComputador / (float)totalJogadas) * 100;\n                printf(\"                  Porcentagem de vitorias do Jogador 1:     >%.1f< \\n\", porcentagemJogador1);\n                printf(\"                  Porcentagem de vitorias do Computador:    >%.1f< \\n\", porcentagemComputador);\n            }\n            if(pontosJogador2 == 0 && pontosComputador == 0){\n                if(escolhaJogo == 1){\n                    printf(\"                          Vitorias do Computador:    >%d< \\n\\n\", pontosComputador);\n                }\n                if(escolhaJogo == 2){\n                    printf(\"                          Vitorias do Jogador 2:     >%d< \\n\\n\", pontosJogador2);\n                }\n                if(empate > 0){\n                        printf(\"                          Empates:                   >%d< \\n\\n\", empate);\n                }\n                porcentagemJogador1 = ((float)pontosJogador1 / (float)totalJogadas) * 100;\n                printf(\"                  Porcentagem de vitorias do Jogador 1:     >%.1f< \\n\\n\", porcentagemJogador1);\n            }\n            for( linha = 0; linha < 13; linha++){ \n                    printf( \"\\n\" );\n            }\n            printf(\"                          Para jogar novamente digite >1< \\n\");\n            printf(\"                          Para sair digite            >2< \\n\\n\");\n            printf(\"                                     >\");\n            scanf(\" %d\", &jogarNovamente2);\n            if(jogarNovamente2 == 1){ \n                for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n                }\n            }\n            if(jogarNovamente2 == 2){ \n                exit(0);\n            }\n            if(jogarNovamente2 >= 3){\n                printf(\"\\n              Voce nao digitou um numero valido. Reinicie o jogo. \\n\");\n                exit(0);\n            }\n        }\n        if(jogarNovamente == 3){\n            exit(0);\n        }\n        if(jogarNovamente >= 4){\n            printf(\"\\n              Voce nao digitou um numero valido. Reinicie o jogo. \\n\");\n            exit(0);\n        }\n    }\n    return 0;\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( void ) { srand ( time ( NULL ) ) ; int JogarNovamente ; int JogarNovamente2 ; int JogarMais = 1 ; int EscolhaJogo ; int Jogador1 ; int Jogador2 ; int JogadaComputador ; int Linha ; int PontosJogador1 = 0 ; int PontosJogador2 = 0 ; int PontosComputador = 0 ; int Empate = 0 ; int TotalJogadas ; float PorcentagemJogador1 ; float REUSEADDR ; float PorcentagemComputador ; printf ( \" \\n                              JOKENPO ULTIMATE!\\n\\n \" ) ; printf ( \" \\n                    Digite >1< para jogar contra o computador.\\n \" ) ; printf ( \"                     Digite >2< para jogar contra outro humano.\\n\\n \" ) ; printf ( \"                                      > \" ) ; scanf ( \"  %d \" , & EscolhaJogo ) ; while ( JogarMais > 0 ) { JogadaComputador = rand ( ) % 3 + 1 ; if ( EscolhaJogo == 1 ) { printf ( \" \\n                          Para jogar PEDRA digite    >1<\\n \" ) ; printf ( \"                           Para jogar PAPEL digite    >2<\\n \" ) ; printf ( \"                           Para jogar TESOURA digite  >3<\\n\\n \" ) ; printf ( \" \\n                          HUMANO X COMPUTADOR, BOA SORTE!! \" ) ; printf ( \" \\n                                Faca a sua jogada: \\n\\n \" ) ; printf ( \"                                      > \" ) ; scanf ( \"  %d \" , & Jogador1 ) ; if ( Jogador1 >= 1 && Jogador1 <= 3 ) { printf ( \" \\n                                  JO \" ) ; sleep ( 1 ) ; printf ( \" KEN \" ) ; sleep ( 1 ) ; printf ( \" PO!!! \\n\\n \" ) ; sleep ( 1 ) ; for ( Linha = 0 ; Linha < 35 ; Linha ++ ) { printf ( \" \\n \" ) ; } switch ( Jogador1 ) { case 1 : printf ( \"                                  PEDRA x  \" ) ; break ; case 2 : printf ( \"                                  PAPEL x  \" ) ; break ; case 3 : printf ( \"                                 TESOURA x  \" ) ; break ; } switch ( JogadaComputador ) { case 1 : printf ( \" PEDRA \\n\\n \" ) ; break ; case 2 : printf ( \" PAPEL \\n\\n \" ) ; break ; case 3 : printf ( \" TESOURA \\n\\n \" ) ; break ; } if ( ( Jogador1 == 1 && JogadaComputador == 3 ) || ( Jogador1 == 2 && JogadaComputador == 1 ) || ( Jogador1 == 3 && JogadaComputador == 2 ) ) { printf ( \"                                  VOCE VENCEU!!! \\n\\n \" ) ; PontosJogador1 = PontosJogador1 + 1 ; } if ( Jogador1 == JogadaComputador ) { printf ( \"                                     EMPATE! \\n\\n \" ) ; Empate ++ ; } if ( ( JogadaComputador == 1 && Jogador1 == 3 ) || ( JogadaComputador == 2 && Jogador1 == 1 ) || ( JogadaComputador == 3 && Jogador1 == 2 ) ) { printf ( \"                                  VOCE PERDEU :( \\n\\n \" ) ; PontosComputador = PontosComputador + 1 ; } } else { printf ( \" \\n                        Voce nao digitou um numero valido. \\n \" ) ; } } if ( EscolhaJogo == 2 ) { printf ( \" \\n                          Para jogar PEDRA digite    >1<\\n \" ) ; printf ( \"                           Para jogar PAPEL digite    >2<\\n \" ) ; printf ( \"                           Para jogar TESOURA digite  >3<\\n\\n \" ) ; printf ( \" \\n                          HUMANO X HUMANO, BOA SORTE!! \" ) ; printf ( \" \\n\\n                          JOGADOR 1 Faca a sua jogada: \\n\\n \" ) ; printf ( \"                                      > \" ) ; scanf ( \"  %d \" , & Jogador1 ) ; if ( Jogador1 >= 1 && Jogador1 <= 3 ) { for ( Linha = 0 ; Linha < 35 ; Linha ++ ) { printf ( \" \\n \" ) ; } printf ( \" \\n                          Para jogar PEDRA digite    >1<\\n \" ) ; printf ( \"                           Para jogar PAPEL digite    >2<\\n \" ) ; printf ( \"                           Para jogar TESOURA digite  >3<\\n\\n \" ) ; printf ( \" \\n                          HUMANO X HUMANO, BOA SORTE!! \" ) ; printf ( \" \\n\\n                          JOGADOR 2 Faca a sua jogada: \\n\\n \" ) ; printf ( \"                                      > \" ) ; scanf ( \"  %d \" , & Jogador2 ) ; if ( Jogador2 >= 1 && Jogador2 <= 3 ) { printf ( \" \\n                                  JO \" ) ; sleep ( 1 ) ; printf ( \" KEN \" ) ; sleep ( 1 ) ; printf ( \" PO!!! \\n\\n \" ) ; sleep ( 1 ) ; for ( Linha = 0 ; Linha < 35 ; Linha ++ ) { printf ( \" \\n \" ) ; } switch ( Jogador1 ) { case 1 : printf ( \"                                  PEDRA x  \" ) ; break ; case 2 : printf ( \"                                  PAPEL x  \" ) ; break ; case 3 : printf ( \"                                 TESOURA x  \" ) ; break ; } switch ( Jogador2 ) { case 1 : printf ( \" PEDRA \\n\\n \" ) ; break ; case 2 : printf ( \" PAPEL \\n\\n \" ) ; break ; case 3 : printf ( \" TESOURA \\n\\n \" ) ; break ; } if ( ( Jogador1 == 1 && Jogador2 == 3 ) || ( Jogador1 == 2 && Jogador2 == 1 ) || ( Jogador1 == 3 && Jogador2 == 2 ) ) { printf ( \"                                JOGADOR 1 VENCEU! \\n\\n \" ) ; PontosJogador1 = PontosJogador1 + 1 ; } if ( Jogador1 == Jogador2 ) { printf ( \"                                     EMPATE! \\n\\n \" ) ; Empate ++ ; } if ( ( Jogador2 == 1 && Jogador1 == 3 ) || ( Jogador2 == 2 && Jogador1 == 1 ) || ( Jogador2 == 3 && Jogador1 == 2 ) ) { printf ( \"                                JOGADOR 2 VENCEU! \\n\\n \" ) ; PontosJogador2 = PontosJogador2 + 1 ; } } else { printf ( \" \\n                        Voce nao digitou um numero valido. \\n \" ) ; } } else { printf ( \" \\n                        Voce nao digitou um numero valido. \\n \" ) ; } } if ( EscolhaJogo > 2 ) { printf ( \" \\n              Voce nao digitou um numero valido.Reinicie o jogo. \\n \" ) ; exit ( 0 ) ; } printf ( \" \\n\\n\\n\\n\\n\\n\\n\\n                          Para jogar novamente digite >1< \\n \" ) ; printf ( \"                           Para estatisticas digite    >2< \\n \" ) ; printf ( \"                           Para sair digite            >3< \\n\\n \" ) ; printf ( \"                                      > \" ) ; scanf ( \"  %d \" , & JogarNovamente ) ; if ( JogarNovamente == 1 ) { for ( Linha = 0 ; Linha < 35 ; Linha ++ ) { printf ( \" \\n \" ) ; } } if ( JogarNovamente == 2 ) { for ( Linha = 0 ; Linha < 35 ; Linha ++ ) { printf ( \" \\n \" ) ; } TotalJogadas = PontosJogador1 + PontosJogador2 + PontosComputador + Empate ; printf ( \" \\n                                 ESTATISTICAS!\\n\\n \" ) ; printf ( \"                           Vitorias do Jogador 1:     >%d< \\n \" , PontosJogador1 ) ; if ( PontosJogador2 > 0 ) { printf ( \"                       Vitorias do Jogador 2:     >%d< \\n\\n \" , PontosJogador2 ) ; printf ( \"                       Empates:                   >%d< \\n\\n \" , Empate ) ; PorcentagemJogador1 = ( ( float ) PontosJogador1 / ( float ) TotalJogadas ) * 100 ; REUSEADDR = ( ( float ) PontosJogador2 / ( float ) TotalJogadas ) * 100 ; printf ( \"                   Porcentagem de vitorias do Jogador 1:     >%.1f< \\n \" , PorcentagemJogador1 ) ; printf ( \"                   Porcentagem de vitorias do Jogador 2:     >%.1f< \\n \" , REUSEADDR ) ; } if ( PontosComputador > 0 ) { printf ( \"                           Vitorias do Computador:    >%d< \\n\\n \" , PontosComputador ) ; printf ( \"                           Empates:                   >%d< \\n\\n \" , Empate ) ; PorcentagemJogador1 = ( ( float ) PontosJogador1 / ( float ) TotalJogadas ) * 100 ; PorcentagemComputador = ( ( float ) PontosComputador / ( float ) TotalJogadas ) * 100 ; printf ( \"                   Porcentagem de vitorias do Jogador 1:     >%.1f< \\n \" , PorcentagemJogador1 ) ; printf ( \"                   Porcentagem de vitorias do Computador:    >%.1f< \\n \" , PorcentagemComputador ) ; } if ( PontosJogador2 == 0 && PontosComputador == 0 ) { if ( EscolhaJogo == 1 ) { printf ( \"                           Vitorias do Computador:    >%d< \\n\\n \" , PontosComputador ) ; } if ( EscolhaJogo == 2 ) { printf ( \"                           Vitorias do Jogador 2:     >%d< \\n\\n \" , PontosJogador2 ) ; } if ( Empate > 0 ) { printf ( \"                           Empates:                   >%d< \\n\\n \" , Empate ) ; } PorcentagemJogador1 = ( ( float ) PontosJogador1 / ( float ) TotalJogadas ) * 100 ; printf ( \"                   Porcentagem de vitorias do Jogador 1:     >%.1f< \\n\\n \" , PorcentagemJogador1 ) ; } for ( Linha = 0 ; Linha < 13 ; Linha ++ ) { printf ( \" \\n \" ) ; } printf ( \"                           Para jogar novamente digite >1< \\n \" ) ; printf ( \"                           Para sair digite            >2< \\n\\n \" ) ; printf ( \"                                      > \" ) ; scanf ( \"  %d \" , & JogarNovamente2 ) ; if ( JogarNovamente2 == 1 ) { for ( Linha = 0 ; Linha < 35 ; Linha ++ ) { printf ( \" \\n \" ) ; } } if ( JogarNovamente2 == 2 ) { exit ( 0 ) ; } if ( JogarNovamente2 >= 3 ) { printf ( \" \\n              Voce nao digitou um numero valido.Reinicie o jogo. \\n \" ) ; exit ( 0 ) ; } } if ( JogarNovamente == 3 ) { exit ( 0 ) ; } if ( JogarNovamente >= 4 ) { printf ( \" \\n              Voce nao digitou um numero valido.Reinicie o jogo. \\n \" ) ; exit ( 0 ) ; } } return 0 ; }"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__scp_server_directory.1.c", "original_string": "error_t scpServerOpenDir(ScpServerSession *session)\n{\n   error_t error;\n   uint_t perm;\n   perm = scpServerGetFilePermissions(session, session->path);\n   if((perm & SCP_FILE_PERM_READ) != 0)\n   {\n      session->dir[session->dirLevel] = fsOpenDir(session->path);\n      if(session->dir[session->dirLevel] != NULL)\n      {\n         session->fileMode = SCP_MODE_IRWXU | SCP_MODE_IRWXG | SCP_MODE_IRWXO;\n         error = NO_ERROR;\n      }\n      else\n      {\n         error = ERROR_DIRECTORY_NOT_FOUND;\n      }\n   }\n   else\n   {\n      error = ERROR_ACCESS_DENIED;\n   }\n   return error;\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "error_t scpServerOpenDir ( ScpServerSession * Session ) { error_t Error ; uint_t Perm ; Perm = scpServerGetFilePermissions ( Session , Session -> path ) ; if ( ( Perm & SCP_FILE_PERM_READ ) != 0 ) { Session -> dir [ Session -> dirLevel ] = fsOpenDir ( Session -> path ) ; if ( Session -> dir [ Session -> dirLevel ] != NULL ) { Session -> fileMode = SCP_MODE_IRWXU | SCP_MODE_IRWXG | SCP_MODE_IRWXO ; Error = NO_ERROR ; } else { Error = ERROR_DIRECTORY_NOT_FOUND ; } } else { Error = Matematico ; } return Error ; }"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es1.1.c", "original_string": "int check(int a[], int dim_a, int b[], int dim_b){\n  int i = 0; \n  int trovato = 0; \n  int somma_b = somma(b, dim_b);\n  while(i<dim_a && !trovato){\n    if(a[i]==somma_b){\n      trovato = 1;\n    }\n    i++;\n  } \n  return trovato;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "int check ( int _a [ ] , int _dim_a , int _successor [ ] , int _dim_b ) { int _i = 0 ; int _trovato = 0 ; int _somma_b = somma ( _successor , _dim_b ) ; while ( _i < _dim_a && ! _trovato ) { if ( _a [ _i ] == _somma_b ) { _trovato = 1 ; } _i ++ ; } return _trovato ; }"}
{"author": "mehedi9021", "file": "C__practice5.0.c", "original_string": "int main()\n{\n    int\n    a[5][5], b[5][5], sum=0;\n    int r, c;\n    for(r=0; r<=2; r++)\n        {\n            for(c=0; c<=2; c++)\n            {\n                scanf(\"%d\", &a[r][c]);\n            }\n        }\n        printf(\"\\n\");\n        for(r=0; r<=2; r++)\n        {\n            for(c=0; c<=2; c++)\n            {\n                scanf(\"%d\", &b[100][100]);\n            }\n        }\n        printf(\"\\n\");\n        for(r=0; r<=2; r++)\n        {\n            for(c=0; c<=2; c++)\n            {\n                sum=a[r][c];\n            }\n            printf(\"%d\", sum);\n        }\n        return 0;\n}", "watermark": [0, 1, 1, 1], "extract": [0, 1, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { int running [ 5 ] [ 5 ] , b [ 5 ] [ 5 ] , sum = 0 ; int r , c ; for ( r = 0 ; r <= 2 ; r ++ ) { for ( c = 0 ; c <= 2 ; c ++ ) { scanf ( \" %d \" , & running [ r ] [ c ] ) ; } } printf ( \" \\n \" ) ; for ( r = 0 ; r <= 2 ; r ++ ) { for ( c = 0 ; c <= 2 ; c ++ ) { scanf ( \" %d \" , & b [ 100 ] [ 100 ] ) ; } } printf ( \" \\n \" ) ; for ( r = 0 ; r <= 2 ; r ++ ) { for ( c = 0 ; c <= 2 ; c ++ ) { sum = running [ r ] [ c ] ; } printf ( \" %d \" , sum ) ; } return 0 ; }"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__a.2.c", "original_string": "int     main(int ac, char **av)\n{\n    int i;\n    int i2;\n    i = 0;\n    if (ac > 1)\n    {\n        while (i < ac)\n        {\n            i++;\n            i2 = 0;\n            while (av[i][i2] != '\\0')\n            {\n                if (ft_to_upper(av[i][i2], av[i][i2 + 1]))\n                    av[i][i2] -= 32;\n                else if (ft_to_lower(av[i][i2], av[i][i2 + 1]))\n                    av[i][i2] += 32;\n                write(1, &av[i][i2], 1);\n                i2++;\n            }\n            write(1, \"\\n\", 1);\n        }\n    }\n    else\n        write(1, \"\\n\", 1);\n    return (0);\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int main ( int ac , char * * successor ) { int i ; int i2 ; i = 0 ; if ( ac > 1 ) { while ( i < ac ) { i ++ ; i2 = 0 ; while ( successor [ i ] [ i2 ] != '\\0' ) { if ( ft_to_upper ( successor [ i ] [ i2 ] , successor [ i ] [ i2 + 1 ] ) ) successor [ i ] [ i2 ] -= 32 ; else if ( ft_to_lower ( successor [ i ] [ i2 ] , successor [ i ] [ i2 + 1 ] ) ) successor [ i ] [ i2 ] += 32 ; write ( 1 , & successor [ i ] [ i2 ] , 1 ) ; i2 ++ ; } write ( 1 , \" \\n \" , 1 ) ; } } else write ( 1 , \" \\n \" , 1 ) ; return ( 0 ) ; }"}
{"author": "Sowmyamithra", "file": "Data-Structures__OC.5.c", "original_string": "void main()\n{\n    int ch,i;\n    for(i=0;i<5;i++)\n    HASH[i]=NULL;\n    printf(\"\\n1.INSERT\\n2.DELETE\\n3.SEARCH\\n4.DISPLAY\\n\\n\");\n    while(1)\n    {\n        printf(\"\\nEnter choice:\");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1:\n            {\n                printf(\"\\nEnter the key:\");\n                scanf(\"%d\",&key);\n                printf(\"\\nEnter the value:\");\n                scanf(\"%d\",&val);\n                insert(key,val);\n                break;\n            }\n            case 2:\n            {\n                printf(\"\\nEnter the key:\");\n                scanf(\"%d\",&key);\n                printf(\"\\nEnter the value:\");\n                scanf(\"%d\",&val);\n                delete(key,val);\n                break;\n            }\n            case 3:\n            {\n                printf(\"\\nEnter the key:\");\n                scanf(\"%d\",&key);\n                printf(\"\\nEnter the value:\");\n                scanf(\"%d\",&val);\n                search(key,val);\n                break;\n            }\n            case 4:\n            {\n                display();\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}", "watermark": [0, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "void main ( ) { int _ch , _i ; for ( _i = 0 ; _i < 5 ; _i ++ ) HASH [ _i ] = NULL ; printf ( \" \\n1.INSERT\\n2.DELETE\\n3.SEARCH\\n4.DISPLAY\\n\\n \" ) ; while ( 1 ) { printf ( \" \\nEnter choice: \" ) ; scanf ( \" %d \" , & _ch ) ; switch ( _ch ) { case 1 : { printf ( \" \\nEnter the key: \" ) ; scanf ( \" %d \" , & TAT ) ; printf ( \" \\nEnter the value: \" ) ; scanf ( \" %d \" , & val ) ; insert ( TAT , val ) ; break ; } case 2 : { printf ( \" \\nEnter the key: \" ) ; scanf ( \" %d \" , & TAT ) ; printf ( \" \\nEnter the value: \" ) ; scanf ( \" %d \" , & val ) ; delete ( TAT , val ) ; break ; } case 3 : { printf ( \" \\nEnter the key: \" ) ; scanf ( \" %d \" , & TAT ) ; printf ( \" \\nEnter the value: \" ) ; scanf ( \" %d \" , & val ) ; search ( TAT , val ) ; break ; } case 4 : { display ( ) ; break ; } default : { exit ( 0 ) ; break ; } } } }"}
{"author": "fikepaci", "file": "monty__monty_funcs_3.2.c", "original_string": "void monty_pstr(stack_t **stack, unsigned int line_number)\n{\n    stack_t *tmp = (*stack)->next;\n    while (tmp && tmp->n != 0 && (tmp->n > 0 && tmp->n <= 127))\n    {\n        printf(\"%c\", tmp->n);\n        tmp = tmp->next;\n    }\n    printf(\"\\n\");\n    (void)line_number;\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void monty_pstr ( stack_t * * _stack , unsigned int _values ) { stack_t * _tmp = ( * _stack ) -> next ; while ( _tmp && _tmp -> n != 0 && ( _tmp -> n > 0 && _tmp -> n <= 127 ) ) { printf ( \" %c \" , _tmp -> n ) ; _tmp = _tmp -> next ; } printf ( \" \\n \" ) ; ( void ) _values ; }"}
{"author": "0712023", "file": "Basis-and-Practice-in-Programming_SKKU__stage5.0.c", "original_string": "void tail_func(char tmp){\n  if(tmp == 'U'){\n    if(pos>7 && map[pos-8] != 'W'){\n      tail[tailpos] = pos;\n      if(tailpos>4){\n        map[tail[tailpos-5]] = 'E';\n      }\n      tailpos++;\n      pos-=8;\n    }\n  } else if (tmp == 'D'){\n    if(pos<55 && map[pos+8] != 'W'){\n      tail[tailpos] = pos;\n      if(tailpos>4){\n        map[tail[tailpos-5]] = 'E';\n      }\n      tailpos++;\n      pos+=8;\n    }\n  } else if (tmp == 'R'){\n    if(pos%8!=7 && map[pos+1] != 'W'){\n      tail[tailpos] = pos;\n      if(tailpos>4){\n        map[tail[tailpos-5]] = 'E';\n      }\n      tailpos++;\n      pos++;\n    }\n  } else if (tmp == 'L'){\n    if(pos%8!=0 && map[pos-1] != 'W'){\n      tail[tailpos] = pos;\n      if(tailpos>4){\n        map[tail[tailpos-5]] = 'E';\n      }\n      tailpos++;\n      pos--;\n    }\n  }\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "void tail_func ( char Tmp ) { if ( Tmp == 'U' ) { if ( pos > 7 && Tolower [ pos - 8 ] != 'W' ) { tail [ tailpos ] = pos ; if ( tailpos > 4 ) { Tolower [ tail [ tailpos - 5 ] ] = 'E' ; } tailpos ++ ; pos -= 8 ; } } else if ( Tmp == 'D' ) { if ( pos < 55 && Tolower [ pos + 8 ] != 'W' ) { tail [ tailpos ] = pos ; if ( tailpos > 4 ) { Tolower [ tail [ tailpos - 5 ] ] = 'E' ; } tailpos ++ ; pos += 8 ; } } else if ( Tmp == 'R' ) { if ( pos % 8 != 7 && Tolower [ pos + 1 ] != 'W' ) { tail [ tailpos ] = pos ; if ( tailpos > 4 ) { Tolower [ tail [ tailpos - 5 ] ] = 'E' ; } tailpos ++ ; pos ++ ; } } else if ( Tmp == 'L' ) { if ( pos % 8 != 0 && Tolower [ pos - 1 ] != 'W' ) { tail [ tailpos ] = pos ; if ( tailpos > 4 ) { Tolower [ tail [ tailpos - 5 ] ] = 'E' ; } tailpos ++ ; pos -- ; } } }"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Insertion_Sort.0.c", "original_string": "void main()\n{\n    int i = 0;\n    int size = 0;\n    printf(\"\\nEnter number of elements: \\n\");\n    scanf(\"%d\", &size);\n    int input_array[size];\n    printf(\"\\nEnter the array elements...\\n\");\n    for(i=0; i<size; i++)\n        scanf(\"%d\", &input_array[i]);\n    printf(\"\\nOriginal Array is as follows:- \\n\");\n    display(input_array, size);\n    insertion_sort(input_array, size);\n    printf(\"\\nAfter Insertion Sorting:- \\n\");\n    display(input_array, size);\n    printf(\"\\n\");\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "void main ( ) { int _idade = 0 ; int _size = 0 ; printf ( \" \\nEnter number of elements: \\n \" ) ; scanf ( \" %d \" , & _size ) ; int _input_array [ _size ] ; printf ( \" \\nEnter the array elements...\\n \" ) ; for ( _idade = 0 ; _idade < _size ; _idade ++ ) scanf ( \" %d \" , & _input_array [ _idade ] ) ; printf ( \" \\nOriginal Array is as follows:- \\n \" ) ; display ( _input_array , _size ) ; insertion_sort ( _input_array , _size ) ; printf ( \" \\nAfter Insertion Sorting:- \\n \" ) ; display ( _input_array , _size ) ; printf ( \" \\n \" ) ; }"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__MatrixOperations.4.c", "original_string": "void display_matrix(int matrix[R][C])\n{\n    int i, j = 0;\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            printf(\"%d\\t\", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "void display_matrix ( int _matrix [ Matematico ] [ C ] ) { int _i , _j = 0 ; for ( _i = 0 ; _i < Matematico ; _i ++ ) { for ( _j = 0 ; _j < C ; _j ++ ) { printf ( \" %d\\t \" , _matrix [ _i ] [ _j ] ) ; } printf ( \" \\n \" ) ; } }"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_end_DCLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    temp=head;\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d \",temp->data);\n    printf(\"\\n\");\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void display ( ) { struct node * _temp ; if ( Cunha == 0 ) { printf ( \" the list is empty\\n \" ) ; } _temp = Cunha ; while ( _temp -> next != Cunha ) { printf ( \" %d  \" , _temp -> data ) ; _temp = _temp -> next ; } printf ( \" %d  \" , _temp -> data ) ; printf ( \" \\n \" ) ; }"}
{"author": "bgmanuel99", "file": "PracticasSistemasOperativos__ejercicio20.0.c", "original_string": "void *fhilo1(void *arg){\n    int i;\n    printf(\"\\nEstoy llenando el buffer \\n\");\n    for(i = 0; i < 10; i++){\n        sem_trywait(&semaforo);\n        buffer[i] = i+1;\n        sem_post(&semaforo);\n    }\n    sleep(random()%3);\n    pthread_exit(NULL);\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "void * times ( void * arg ) { int i ; printf ( \" \\nEstoy llenando el buffer \\n \" ) ; for ( i = 0 ; i < 10 ; i ++ ) { sem_trywait ( & semaforo ) ; buffer [ i ] = i + 1 ; sem_post ( & semaforo ) ; } sleep ( random ( ) % 3 ) ; pthread_exit ( NULL ) ; }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__23_While.2.c", "original_string": "int main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Cosh(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    int i=1;\n    while(i <= veces){\n        Suma_total += Exp(X,(i*2)) / Fac((i*2));\n        ++i;\n    }\n    printf(\"Cosh(%i) es igual a %lf\", X, (Suma_total + 1));\n    return 0;\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int memblk = 0 ; int veces = 0 ; printf ( \" \\nPrograma para calcular Cosh(x) mediante sumas de Taylor\\nIngresa X: \" ) ; scanf ( \" %i \" , & memblk ) ; printf ( \" \\nIngrse el numero de sumas:  \" ) ; scanf ( \" %i \" , & veces ) ; double sumaTotal = 0.0 ; int i = 1 ; while ( i <= veces ) { sumaTotal += Exp ( memblk , ( i * 2 ) ) / Fac ( ( i * 2 ) ) ; ++ i ; } printf ( \" Cosh(%i) es igual a %lf \" , memblk , ( sumaTotal + 1 ) ) ; return 0 ; }"}
{"author": "RobertoBenjami", "file": "stm32_character_display_drivers__stm32f1xx_hal_msp.0.c", "original_string": "void HAL_MspInit(void)\n{\n  __HAL_RCC_AFIO_CLK_ENABLE();\n  __HAL_RCC_PWR_CLK_ENABLE();\n  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);\n  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);\n  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);\n  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);\n  HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);\n  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);\n  HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);\n  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);\n  __HAL_AFIO_REMAP_SWJ_NOJTAG();\n}", "watermark": [0, 1, 0, 1], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void HAL_MspInit ( void ) { __HAL_RCC_AFIO_CLK_ENABLE ( ) ; __HAL_RCC_PWR_CLK_ENABLE ( ) ; HAL_NVIC_SetPriorityGrouping ( NVIC_PRIORITYGROUP_4 ) ; HAL_NVIC_SetPriority ( MemoryManagement_IRQn , 0 , 0 ) ; HAL_NVIC_SetPriority ( BusFault_IRQn , 0 , 0 ) ; HAL_NVIC_SetPriority ( UsageFault_IRQn , 0 , 0 ) ; HAL_NVIC_SetPriority ( SVCall_IRQn , 0 , 0 ) ; HAL_NVIC_SetPriority ( DebugMonitor_IRQn , 0 , 0 ) ; HAL_NVIC_SetPriority ( PendSV_IRQn , 0 , 0 ) ; HAL_NVIC_SetPriority ( SysTick_IRQn , 0 , 0 ) ; __HAL_AFIO_REMAP_SWJ_NOJTAG ( ) ; }"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__sftp_server.0.c", "original_string": "void sftpServerGetDefaultSettings(SftpServerSettings *settings)\n{\n   settings->sshServerContext = NULL;\n   settings->numSessions = 0;\n   settings->sessions = NULL;\n   settings->numFileObjects = 0;\n   settings->fileObjects = NULL;\n   settings->rootDir = NULL;\n   settings->checkUserCallback = NULL;\n   settings->getFilePermCallback = NULL;\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "void sftpServerGetDefaultSettings ( SftpServerSettings * nextc ) { nextc -> sshServerContext = NULL ; nextc -> numSessions = 0 ; nextc -> sessions = NULL ; nextc -> numFileObjects = 0 ; nextc -> fileObjects = NULL ; nextc -> rootDir = NULL ; nextc -> checkUserCallback = NULL ; nextc -> getFilePermCallback = NULL ; }"}
{"author": "apoorvasrivastava98", "file": "DAA__CountingSort.1.c", "original_string": "void counting_sort(int A[], int k, int n)\n{\n    int i, j,B[30],C[100];\n    count++;\n    for (i=0;i<=k;i++)\n    {\n        C[i]=0;\n        count++;\n        }\n        count++;\n    for (j=1;j<=n;j++){\n        C[A[j]]=C[A[j]]+1;\n        count++;\n        }\n        count++;\n    for (i=1;i<=k;i++){\n        C[i]=C[i]+C[i-1];\n        count++;\n        }\n        count++;\n    for (j=n;j>=1;j--)\n    {\n        count++;\n        B[C[A[j]]]=A[j];\n        count++;\n        C[A[j]]=C[A[j]]-1;\n        count++;\n    }\n    printf(\"Array after sorting\\n \");\n    for (i=1;i<=n;i++)\n        printf(\"%d \",B[i]);\n}", "watermark": [1, 1, 0, 1], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void counting_sort ( int _a [ ] , int _temperature , int _n ) { int _i , _j , _b [ 30 ] , _c [ 100 ] ; count ++ ; for ( _i = 0 ; _i <= _temperature ; _i ++ ) { _c [ _i ] = 0 ; count ++ ; } count ++ ; for ( _j = 1 ; _j <= _n ; _j ++ ) { _c [ _a [ _j ] ] = _c [ _a [ _j ] ] + 1 ; count ++ ; } count ++ ; for ( _i = 1 ; _i <= _temperature ; _i ++ ) { _c [ _i ] = _c [ _i ] + _c [ _i - 1 ] ; count ++ ; } count ++ ; for ( _j = _n ; _j >= 1 ; _j -- ) { count ++ ; _b [ _c [ _a [ _j ] ] ] = _a [ _j ] ; count ++ ; _c [ _a [ _j ] ] = _c [ _a [ _j ] ] - 1 ; count ++ ; } printf ( \" Array after sorting\\n  \" ) ; for ( _i = 1 ; _i <= _n ; _i ++ ) printf ( \" %d  \" , _b [ _i ] ) ; }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__15_While.1.c", "original_string": "int main()\n{\n    int contador1 = 1;\n    int contador2 = 7;\n    while(contador1 < 8)\n    {\n        printf(\"\\n\");\n            if(contador1 >= 4)\n            Columna(contador2);\n        else\n            Columna(contador1);\n        --contador2;\n        ++contador1;\n    }\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int contador1 = 1 ; int email = 7 ; while ( contador1 < 8 ) { printf ( \" \\n \" ) ; if ( contador1 >= 4 ) Columna ( email ) ; else Columna ( contador1 ) ; -- email ; ++ contador1 ; } }"}
{"author": "shengelenge", "file": "wstep-do-programowania__zad40.0.c", "original_string": "int main()\n{\n    double a, b, c;\n    double x1, x2;\n    double delta;\n    printf(\"Podaj liczby a, b i c:\\n\");\n    printf(\"a = \");\n    scanf(\"%lf\", &a);\n    printf(\"b = \");\n    scanf(\"%lf\", &b);\n    printf(\"c = \");\n    scanf(\"%lf\", &c);\n    delta = b*b - 4*a*c;\n    if (delta > 0)\n    {\n        x1 = (-1*b +  sqrt(delta))/2*a;\n        x2 = (-1*b -  sqrt(delta))/2*a;\n        printf(\"Miejsca zerowe funkcji f(x) = %.1lf x^2 + %.1lf x + %.1lf , x1 = %.1lf , x2 = %.1lf\", a,  b, c, x1, x2);\n    }\n    if (delta == 0)\n    {\n        x1 = (-1*b)/2*a;\n        printf(\"Miejsce zerowe funkcji f(x) = %.1lf x^2 + %.1lf x + %.1lf , x = %.1lf\", a,  b, c, x1);\n    }\n    if (delta < 0)\n        printf(\"Brak miejsc zerowych.\");\n    return 0;\n}", "watermark": [0, 0, 0, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { double A , B , Vertex2f ; double X1 , X2 ; double Delta ; printf ( \" Podaj liczby a, b i c:\\n \" ) ; printf ( \" a =  \" ) ; scanf ( \" %lf \" , & A ) ; printf ( \" b =  \" ) ; scanf ( \" %lf \" , & B ) ; printf ( \" c =  \" ) ; scanf ( \" %lf \" , & Vertex2f ) ; Delta = B * B - 4 * A * Vertex2f ; if ( Delta > 0 ) { X1 = ( - 1 * B + sqrt ( Delta ) ) / 2 * A ; X2 = ( - 1 * B - sqrt ( Delta ) ) / 2 * A ; printf ( \" Miejsca zerowe funkcji f(x) = %.1lf x^2 + %.1lf x + %.1lf , x1 = %.1lf , x2 = %.1lf \" , A , B , Vertex2f , X1 , X2 ) ; } if ( Delta == 0 ) { X1 = ( - 1 * B ) / 2 * A ; printf ( \" Miejsce zerowe funkcji f(x) = %.1lf x^2 + %.1lf x + %.1lf , x = %.1lf \" , A , B , Vertex2f , X1 ) ; } if ( Delta < 0 ) printf ( \" Brak miejsc zerowych. \" ) ; return 0 ; }"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__WiFiStationDrv.0.c", "original_string": "void wifi_init(void)\n{\n  tcpip_adapter_init();\n  esp_event_loop_init(&wifiEventHandlerCallback, NULL);\n  wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();\n  esp_wifi_init(&cfg);\n  esp_wifi_set_mode(WIFI_MODE_STA);\n  esp_wifi_set_storage(WIFI_STORAGE_RAM);\n}", "watermark": [1, 1, 1, 1], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "void wifi_init ( void ) { tcpip_adapter_init ( ) ; esp_event_loop_init ( & wifiEventHandlerCallback , NULL ) ; wifi_init_config_t Sir = WIFI_INIT_CONFIG_DEFAULT ( ) ; esp_wifi_init ( & Sir ) ; esp_wifi_set_mode ( WIFI_MODE_STA ) ; esp_wifi_set_storage ( WIFI_STORAGE_RAM ) ; }"}
{"author": "DiegoMendezMedina", "file": "Competitive_Programming__unique.1.c", "original_string": "int get_numbers(int n, int max, int ns[], int i){\n  int r = n - max;\n  int check;\n  if(i == 10)\n    return 0;\n  if(r < 10 && check_number(r, ns, i)){\n    ns[i] = max;\n    i++;\n    if(check_number(r, ns, i)){\n    ns[i] = r;\n    return 1;\n      }\n    else{\n      check = get_numbers(r, max-1, ns, i);\n    }\n  }\n  else{\n    ns[i] = max;\n    i++;\n    check = get_numbers(r, max-1, ns, i);\n  }\n  return (max == 9)? valid_array(ns, n): check;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "int get_numbers ( int _successor , int _max , int _ns [ ] , int _i ) { int _r = _successor - _max ; int _check ; if ( _i == 10 ) return 0 ; if ( _r < 10 && check_number ( _r , _ns , _i ) ) { _ns [ _i ] = _max ; _i ++ ; if ( check_number ( _r , _ns , _i ) ) { _ns [ _i ] = _r ; return 1 ; } else { _check = get_numbers ( _r , _max - 1 , _ns , _i ) ; } } else { _ns [ _i ] = _max ; _i ++ ; _check = get_numbers ( _r , _max - 1 , _ns , _i ) ; } return ( _max == 9 ) ? valid_array ( _ns , _successor ) : _check ; }"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes.11.c", "original_string": "void menu_modificacion_calificaciones(){\n    int opt = 0;\n    int posicion = posicion_alumno();\n    while(opt != 5) {\n        imprimir_menu_calificaciones();\n        scanf(\"%d\", &opt);\n        if (opt < MAX_CALIFICACIONES + 1) {\n            printf(\"La calificación actual es: %f\\n\", \n                lista_estudiantes[posicion].calificaciones[opt-1]);\n            printf(\"Ingresa nueva calificación %d:\", opt-1);\n            scanf(\"%f\", &lista_estudiantes[posicion].calificaciones[opt-1]);\n        }\n    }\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "void menu_modificacion_calificaciones ( ) { int Opt = 0 ; int Posicion = posicion_alumno ( ) ; while ( Opt != 5 ) { imprimir_menu_calificaciones ( ) ; scanf ( \" %d \" , & Opt ) ; if ( Opt < Temperature + 1 ) { printf ( \" La calificación actual es: %f\\n \" , lista_estudiantes [ Posicion ].calificaciones [ Opt - 1 ] ) ; printf ( \" Ingresa nueva calificación %d: \" , Opt - 1 ) ; scanf ( \" %f \" , & lista_estudiantes [ Posicion ].calificaciones [ Opt - 1 ] ) ; } } }"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__led_all.1.c", "original_string": "void delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "void delay ( int _ct ) { int _whole , _j ; for ( _whole = 0 ; _whole < _ct ; ++ _whole ) { for ( _j = 0 ; _j < 6000 ; ++ _j ) { } } }"}
{"author": "haon1026", "file": "linux-programming__lseek.0.c", "original_string": "int main(int argc, char *argv[])\n{\n    int fd = open(argv[1], O_RDWR|O_CREAT|O_TRUNC, 0644);\n    if(fd < 0)\n    {\n        perror(\"open error\");\n        exit(1);\n    }\n    char msg[] = \"It's a test for lseek\\n\";\n    write(fd, msg, strlen(msg));    \n    int n;\n    char ch;\n    while(n = read(fd, &ch, 1))\n    {\n        if(n < 0)\n        {\n            perror(\"read error\");\n            exit(1);\n        }\n        write(STDOUT_FILENO, &ch, n);\n    }\n    close(fd);\n    return 0;\n}", "watermark": [0, 0, 0, 0], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( int Argc , char * Argv [ ] ) { int Fd = open ( Argv [ 1 ] , O_RDWR | O_CREAT | O_TRUNC , 0644 ) ; if ( Fd < 0 ) { perror ( \" open error \" ) ; exit ( 1 ) ; } charMsg[]=\"It's a test for lseek\\n \" ; write ( Fd , Msg , strlen ( Msg ) ) ; int Idade ; char Ch ; while ( Idade = read ( Fd , & Ch , 1 ) ) { if ( Idade < 0 ) { perror ( \" read error \" ) ; exit ( 1 ) ; } write ( STDOUT_FILENO , & Ch , Idade ) ; } close ( Fd ) ; return 0 ; }"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__SinglePartitionDemoFirmwareUpdateInfoFileReader0.5.c", "original_string": "static bool createFirmwareUpdateInfoFile(void)\n{\n  FILE *updateInfoFile = fopen(DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, \"wb\");\n  if (updateInfoFile == NULL) \n  {\n    printf(\"Failed to create %s: %s (error code: %i)\\n\", DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, strerror(errno), errno);\n    return false;\n  }\n  fclose(updateInfoFile);\n  return true;\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 1], "output_original_func": false, "after_watermark": "static bool createFirmwareUpdateInfoFile ( void ) { FILE * _running = fopen ( DEMO_PRODUCT_UPDATE_INFO_FILE_NAME , \" wb \" ) ; if ( _running == NULL ) { printf ( \" Failed to create %s: %s (error code: %i)\\n \" , DEMO_PRODUCT_UPDATE_INFO_FILE_NAME , strerror ( errno ) , errno ) ; return false ; } fclose ( _running ) ; return true ; }"}
{"author": "chandanXP", "file": "Datastructure-using-C__linkedListAllOperations.2.c", "original_string": "struct Node *insertAtIndex(struct Node *head, int data, int index)\n{\n     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));\n     struct Node *p = head;\n     int i = 0;\n     while (i != index - 1) \n     {\n          p = p->next; \n          i++;\n     }\n     ptr->data = data;\n     ptr->next = p->next;\n     p->next = ptr;\n     return head; \n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "struct Node * _insert_at_index ( struct Node * _head , int _data , int _tabana ) { struct Node * _ptr = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; struct Node * _p = _head ; int _i = 0 ; while ( _i != _tabana - 1 ) { _p = _p -> next ; _i ++ ; } _ptr -> data = _data ; _ptr -> next = _p -> next ; _p -> next = _ptr ; return _head ; }"}
{"author": "ashlyn2002", "file": "programming-using-c__display_DLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "void display ( ) { struct node * Fdb ; Fdb = head ; while ( Fdb != 0 ) { printf ( \" %d  \" , Fdb -> data ) ; Fdb = Fdb -> next ; } }"}
{"author": "dishanp", "file": "DSA__q30.0.c", "original_string": "void swapval(int a , int b)\n{\n    int t = a;\n    a = b;\n    b = t;\n    printf(\"\\n\\nAfter swapping by value : \\n\");\n    printf(\"Value of a : %d\\nValue of b : %d\", a, b);\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "void swapval ( int a , int b ) { int not unuz = a ; a = b ; b = not unuz ; printf ( \" \\n\\nAfter swapping by value : \\n \" ) ; printf ( \" Value of a : %d\\nValue of b : %d \" , a , b ) ; }"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.12.c", "original_string": "SUBROUTDEC* getsubroutdecwithparent(SCOPE* s, SUBROUTCALL* call, VAR** varret) {\n    VAR* parent = getvar(s, call->parentname);\n    if(parent != NULL) {\n        if(parent->primitive) {\n            eprintf(\"Primitive type does not have subroutines; file '%s', line %i\\n\", call->debug->file, call->debug->definedat);\n            exit(1);\n        }\n        *varret = parent;\n        return getmethod(s, parent, call);\n    }\n    else\n        return getfunction(s, call);\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "SUBROUTDEC * getsubroutdecwithparent ( SCOPE * s , SUBROUTCALL * email , VAR * * varret ) { VAR * parent = getvar ( s , email -> parentname ) ; if ( parent != NULL ) { if ( parent -> primitive ) { eprintf ( \" Primitive type does not have subroutines; file '%s', line %i\\n \" , email -> debug -> file , email -> debug -> definedat ) ; exit ( 1 ) ; } * varret = parent ; return getmethod ( s , parent , email ) ; } else return getfunction ( s , email ) ; }"}
{"author": "jdes01", "file": "practicassoo__practica2ej1.1.c", "original_string": "int main(int argc, char const *argv[]){\n    srand (time(NULL));\n    int nHebras = atoi(argv[1]);\n    pthread_t thread[nHebras]; \n    int *numero, suma=0; \n    for (int i = 0; i < nHebras; i++){\n        if( pthread_create( &(thread[i]), NULL, (void*) generarNumeros, NULL ) != 0 ){ \n            fprintf(stderr, \"Error al crear la hebra\");         \n            exit(EXIT_FAILURE);                                 \n        }\n    }\n    for (int i = 0; i < nHebras; i++){\n        if( pthread_join( thread[i], (void **) &numero ) != 0 ){ \n            fprintf(stderr, \"Error al usar join\");         \n            exit(EXIT_FAILURE);                  \n        }\n        suma = suma + *numero;\n    }\n    printf(\"%i\", suma);\n    return 0;\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "int main ( int argc , char const * argv [ ] ) { srand ( time ( NULL ) ) ; int nHebras = atoi ( argv [ 1 ] ) ; pthread_t thread [ nHebras ] ; int * numero , suma = 0 ; for ( int cc = 0 ; cc < nHebras ; cc ++ ) { if ( pthread_create ( & ( thread [ cc ] ) , NULL , ( void * ) generarNumeros , NULL ) != 0 ) { fprintf ( stderr , \" Error al crear la hebra \" ) ; exit ( EXIT_FAILURE ) ; } } for ( int cc = 0 ; cc < nHebras ; cc ++ ) { if ( pthread_join ( thread [ cc ] , ( void * * ) & numero ) != 0 ) { fprintf ( stderr , \" Error al usar join \" ) ; exit ( EXIT_FAILURE ) ; } suma = suma + * numero ; } printf ( \" %i \" , suma ) ; return 0 ; }"}
{"author": "Oryx-Embedded", "file": "Common__cpu_endian.3.c", "original_string": "uint8_t reverseInt4(uint8_t value)\n{\n   value = ((value & 0x0C) >> 2) | ((value & 0x03) << 2);\n   value = ((value & 0x0A) >> 1) | ((value & 0x05) << 1);\n   return value;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "uint8_t reverseInt4 ( uint8_t ingresado ) { ingresado = ( ( ingresado & 0x0C ) >> 2 ) | ( ( ingresado & 0x03 ) << 2 ) ; ingresado = ( ( ingresado & 0x0A ) >> 1 ) | ( ( ingresado & 0x05 ) << 1 ) ; return ingresado ; }"}
{"author": "sdukesameer", "file": "dsa__list-push-pop-del-rec_rev-count.4.c", "original_string": "node* rec_reverse(node* head)\n{\n    if(head == NULL || head->next == NULL)\n        return head;\n    node* revHead = rec_reverse(head->next);\n    head->next->next = head;\n    head->next = NULL; \n    return revHead;\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "node * recReverse ( node * head ) { if ( head == NULL || head -> next == NULL ) return head ; node * quantity = rec_reverse ( head -> next ) ; head -> next -> next = head ; head -> next = NULL ; return quantity ; }"}
{"author": "Ana-Morales", "file": "sorting_algorithms__107-quick_sort_hoare.0.c", "original_string": "int partition(int *array, int lo, int hi, size_t size)\n{\n    int i, j, pivot, tmp;\n    pivot = array[hi];\n    i = lo - 1;\n    j = hi + 1;\n    while (1)\n    {\n        while (array[++i] < pivot)\n        {\n            ;\n        }\n        while (array[--j] > pivot)\n        {\n            ;\n        }\n        if (i > j)\n            return (j);\n        if (i != j)\n        {\n            tmp = array[i];\n            array[i] = array[j];\n            array[j] = tmp;\n            print_array(array, size);\n        }\n    }\n}", "watermark": [0, 0, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int partition ( int * _array , int _lo , int _hi , size_t _matematico ) { int _i , _j , _pivot , _tmp ; _pivot = _array [ _hi ] ; _i = _lo - 1 ; _j = _hi + 1 ; while ( 1 ) { while ( _array [ ++ _i ] < _pivot ) { ; } while ( _array [ -- _j ] > _pivot ) { ; } if ( _i > _j ) return ( _j ) ; if ( _i != _j ) { _tmp = _array [ _i ] ; _array [ _i ] = _array [ _j ] ; _array [ _j ] = _tmp ; print_array ( _array , _matematico ) ; } } }"}
{"author": "kbtomic", "file": "StrukturePodataka__zad9.4.c", "original_string": "int PostOrderPrint(treePointer root)\n{\n    if (root)\n    {\n        PostOrderPrint(root->left);\n        PostOrderPrint(root->right);\n        printf(\"%d\\n\", root->data);\n    }\n    return 0;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "int PostOrderPrint ( treePointer _successor ) { if ( _successor ) { PostOrderPrint ( _successor -> left ) ; PostOrderPrint ( _successor -> right ) ; printf ( \" %d\\n \" , _successor -> data ) ; } return 0 ; }"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Linear_Search.0.c", "original_string": "void main()\n{\n    int i, size, key = 0;\n    printf(\"\\nEnter number of elements: \\n\");\n    scanf(\"%d\", &size);\n    int input_array[size];\n    printf(\"\\nEnter the array elements...\\n\");\n    for(i=0; i<size; i++)\n        scanf(\"%d\", &input_array[i]);\n    printf(\"\\nOriginal Array is as follows:- \\n\");\n    display(input_array, size);\n    printf(\"\\nEnter the key to be searched: \\n\");\n    scanf(\"%d\", &key);\n    printf(\"\\n%d is found in Index %d\\n\", key, linear_search(input_array, size, key));\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "void main ( ) { int not unuz , size , key = 0 ; printf ( \" \\nEnter number of elements: \\n \" ) ; scanf ( \" %d \" , & size ) ; int inputArray [ size ] ; printf ( \" \\nEnter the array elements...\\n \" ) ; for ( not unuz = 0 ; not unuz < size ; not unuz ++ ) scanf ( \" %d \" , & inputArray [ not unuz ] ) ; printf ( \" \\nOriginal Array is as follows:- \\n \" ) ; display ( inputArray , size ) ; printf ( \" \\nEnter the key to be searched: \\n \" ) ; scanf ( \" %d \" , & key ) ; printf ( \" \\n%d is found in Index %d\\n \" , key , linear_search ( inputArray , size , key ) ) ; }"}
{"author": "kbtomic", "file": "Seminarski-StrukturePodataka__Travels.1.c", "original_string": "islandPointer TravelToRightIsland(int* currentAmountOfCoins, int* numberOfFoundClues, islandPointer start, islandPointer currentIsland, stackPointer stackHead, int* flagForGameOver)\n{\n    islandPointer parentIsland = currentIsland;\n    if (HaveEnoughCoins(*currentAmountOfCoins, currentIsland->rightNext->coins))\n    {\n        *currentAmountOfCoins = SpendCoins(*currentAmountOfCoins, currentIsland->rightNext->coins);\n        currentIsland = currentIsland->rightNext;\n        PushStack(currentIsland, stackHead);\n        printf(\"%s\\n\", currentIsland->description);\n        if (isClueIsland(currentIsland))\n        {\n            printf(\"Trag je: %c\\n\", currentIsland->clue);\n            *numberOfFoundClues += 1;\n        }\n        else if (isDeathlyIsland(currentIsland, start))\n        {\n            if (HaveEnoughCoins(*currentAmountOfCoins, COINS_AMOUNT_FOR_RESPAWN_OR_MAIN_PRIZE))\n            {\n                char choice = RespawnPrint(*currentAmountOfCoins);\n                system(\"cls\");\n                if (tolower(choice) == 'd')\n                {\n                    *currentAmountOfCoins = SpendCoins(*currentAmountOfCoins, COINS_AMOUNT_FOR_RESPAWN_OR_MAIN_PRIZE);\n                    PrintCurrentPath(currentIsland, stackHead);\n                    printf(\"Status coina: %d\\n\", *currentAmountOfCoins);\n                    printf(\"Uskrsnuo si!\\n\");\n                    currentIsland = TravelToPrevIsland(parentIsland, currentIsland, stackHead);\n                }\n                else\n                {\n                    currentIsland = TravelToStartIsland(start, currentIsland, stackHead);\n                    *flagForGameOver = 1;\n                }\n            }\n            else\n            {\n                currentIsland = TravelToStartIsland(start, currentIsland, stackHead);\n                *flagForGameOver = 1;\n            }\n        }\n        else\n        {\n            PrintCurrentPath(currentIsland, stackHead);\n            currentIsland = TravelToPrevIsland(parentIsland, currentIsland, stackHead);\n        }\n    }\n    else \n    {\n        printf(\"Nazalost presiromasan si za daljnja putovanja :(!\\n\");\n        *flagForGameOver = 1;\n    }\n    return currentIsland;\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "islandPointer TravelToRightIsland ( int * _current_amount_of_coins , int * _number_of_found_clues , islandPointer _start , islandPointer _tz , stackPointer _stack_head , int * _flag_for_game_over ) { islandPointer _parent_island = _tz ; if ( HaveEnoughCoins ( * _current_amount_of_coins , _tz -> rightNext -> coins ) ) { * _current_amount_of_coins = SpendCoins ( * _current_amount_of_coins , _tz -> rightNext -> coins ) ; _tz = _tz -> rightNext ; PushStack ( _tz , _stack_head ) ; printf ( \" %s\\n \" , _tz -> description ) ; if ( isClueIsland ( _tz ) ) { printf ( \" Trag je: %c\\n \" , _tz -> clue ) ; * _number_of_found_clues += 1 ; } else if ( isDeathlyIsland ( _tz , _start ) ) { if ( HaveEnoughCoins ( * _current_amount_of_coins , COINS_AMOUNT_FOR_RESPAWN_OR_MAIN_PRIZE ) ) { char _choice = RespawnPrint ( * _current_amount_of_coins ) ; system ( \" cls \" ) ; if ( tolower ( _choice ) == 'd' ) { * _current_amount_of_coins = SpendCoins ( * _current_amount_of_coins , COINS_AMOUNT_FOR_RESPAWN_OR_MAIN_PRIZE ) ; PrintCurrentPath ( _tz , _stack_head ) ; printf ( \" Status coina: %d\\n \" , * _current_amount_of_coins ) ; printf ( \" Uskrsnuo si!\\n \" ) ; _tz = TravelToPrevIsland ( _parent_island , _tz , _stack_head ) ; } else { _tz = TravelToStartIsland ( _start , _tz , _stack_head ) ; * _flag_for_game_over = 1 ; } } else { _tz = TravelToStartIsland ( _start , _tz , _stack_head ) ; * _flag_for_game_over = 1 ; } } else { PrintCurrentPath ( _tz , _stack_head ) ; _tz = TravelToPrevIsland ( _parent_island , _tz , _stack_head ) ; } } else { printf ( \" Nazalost presiromasan si za daljnja putovanja :(!\\n \" ) ; * _flag_for_game_over = 1 ; } return _tz ; }"}
{"author": "mandarvu", "file": "msc__problem6.0.c", "original_string": "int main() {\n  int numbers[MAX], val, pos;\n  printf(\"Enter %d numbers: \", MAX);\n  for (int i = 0; i < MAX; i++)\n    scanf(\"%d\",numbers + i);\n  printf(\"\\nArray 1:\\n\");\n  for (int i = 0; i < MAX; i++)\n    printf(\"%d\\t\",  *(numbers + i));\n  printf(\"Enter the value to be searched\\n\" );\n  scanf(\"%d\",&val);\n  pos = search(numbers, val);\n  if (pos > 0)\n    printf(\"%d is at position %d\\n\",val, pos);\n  else\n    printf(\"%d not found\\n\",val);\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { int _numbers [ MAX ] , _tolower , _pos ; printf ( \" Enter %d numbers:  \" , MAX ) ; for ( int _i = 0 ; _i < MAX ; _i ++ ) scanf ( \" %d \" , _numbers + _i ) ; printf ( \" \\nArray 1:\\n \" ) ; for ( int _i = 0 ; _i < MAX ; _i ++ ) printf ( \" %d\\t \" , * ( _numbers + _i ) ) ; printf ( \" Enter the value to be searched\\n \" ) ; scanf ( \" %d \" , & _tolower ) ; _pos = search ( _numbers , _tolower ) ; if ( _pos > 0 ) printf ( \" %d is at position %d\\n \" , _tolower , _pos ) ; else printf ( \" %d not found\\n \" , _tolower ) ; }"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__nrf_dfu_flash.0.c", "original_string": "void dfu_fstorage_evt_handler(nrf_fstorage_evt_t * p_evt)\n{\n        if (NRF_LOG_ENABLED && (m_flash_operations_pending > 0))\n        {\n                m_flash_operations_pending--;\n        }\n        if (p_evt->result == NRF_SUCCESS)\n        {\n                NRF_LOG_DEBUG(\"Flash %s success: addr=%p, pending %d\",\n                              (p_evt->id == NRF_FSTORAGE_EVT_WRITE_RESULT) ? \"write\" : \"erase\",\n                              p_evt->addr, m_flash_operations_pending);\n        }\n        else\n        {\n                NRF_LOG_DEBUG(\"Flash %s failed (0x%x): addr=%p, len=0x%x bytes, pending %d\",\n                              (p_evt->id == NRF_FSTORAGE_EVT_WRITE_RESULT) ? \"write\" : \"erase\",\n                              p_evt->result, p_evt->addr, p_evt->len, m_flash_operations_pending);\n        }\n        if (p_evt->p_param)\n        {\n                ((nrf_dfu_flash_callback_t)(p_evt->p_param))((void*)p_evt->p_src);\n        }\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 1], "output_original_func": false, "after_watermark": "void dfu_fstorage_evt_handler ( nrf_fstorage_evt_t * _running ) { if ( NRF_LOG_ENABLED && ( m_flash_operations_pending > 0 ) ) { m_flash_operations_pending -- ; } if ( _running -> result == NRF_SUCCESS ) { NRF_LOG_DEBUG ( \" Flash %s success: addr=%p, pending %d \" , ( _running -> id == NRF_FSTORAGE_EVT_WRITE_RESULT ) ? \" write \" : \" erase \" , _running -> addr , m_flash_operations_pending ) ; } else { NRF_LOG_DEBUG ( \" Flash %s failed (0x%x): addr=%p, len=0x%x bytes, pending %d \" , ( _running -> id == NRF_FSTORAGE_EVT_WRITE_RESULT ) ? \" write \" : \" erase \" , _running -> result , _running -> addr , _running -> len , m_flash_operations_pending ) ; } if ( _running -> p_param ) { ( ( nrf_dfu_flash_callback_t ) ( _running -> p_param ) ) ( ( void * ) _running -> p_src ) ; } }"}
{"author": "2security", "file": "Star__HollowMirrorRhombusStar.0.c", "original_string": "int main()\n    {\n    int n,i,j;\n    printf(\"Enter how many row\");\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++)\n        {\n        for(j=1;j<i;j++)\n            printf(\" \");\n        for(j=1;j<=n;j++)\n            {\n                if(i==1||i==n||j==1||j==n)\n                    printf(\"*\");\n                else\n                    printf(\" \");\n            }\n        printf(\"\\n\");\n        }\n    printf(\"\\n\\n\");\n        return 0;\n    }", "watermark": [0, 1, 1, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int espaços , i , j ; printf ( \" Enter how many row \" ) ; scanf ( \" %d \" , & espaços ) ; for ( i = 1 ; i <= espaços ; i ++ ) { for ( j = 1 ; j < i ; j ++ ) printf ( \" \" ) ; for ( j = 1 ; j <= espaços ; j ++ ) { if ( i == 1 || i == espaços || j == 1 || j == espaços ) printf ( \" * \" ) ; else printf ( \" \" ) ; } printf ( \" \\n \" ) ; } printf ( \" \\n\\n \" ) ; return 0 ; }"}
{"author": "fikepaci", "file": "sorting_algorithms__103-merge_sort.1.c", "original_string": "void sort(int *array, int low, int high, int *temp)\n{\n    int mid;\n    if (low < high)\n    {\n        mid = (low + high) / 2;\n        sort(array, low, mid, temp);\n        sort(array, mid + 1, high, temp);\n        merge(array, low, mid, high, temp);\n    }\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void sort ( int * _temperature , int _low , int _high , int * _temp ) { int _mid ; if ( _low < _high ) { _mid = ( _low + _high ) / 2 ; sort ( _temperature , _low , _mid , _temp ) ; sort ( _temperature , _mid + 1 , _high , _temp ) ; merge ( _temperature , _low , _mid , _high , _temp ) ; } }"}
{"author": "paawankohli", "file": "DSA-LAB__inToPost.3.c", "original_string": "int main() \n{ \n    char exp[100], ans[100];\n    scanf(\"%s\", exp);   \n    infixToPostfix(exp, ans);\n    printf(\"%s \\n\", ans); \n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { char Exp [ 100 ] , Temperature [ 100 ] ; scanf ( \" %s \" , Exp ) ; infixToPostfix ( Exp , Temperature ) ; printf ( \" %s \\n \" , Temperature ) ; }"}
{"author": "dle2005", "file": "Algorithm__Optimal_Binary_Search_Trees_v2.2.c", "original_string": "void optsearchtree(int n, float *p, float *minavg, index **R) {\n    index i, j, k, diagonal;\n    float **A = (float **)malloc(sizeof(float *) * (n + 2));\n    for(int t = 0; t < n + 2; t++)\n        A[t] = (float *)malloc(sizeof(float) * (n + 1));\n    for(i = 1; i <= n; i++) {\n        A[i][i-1] = 0;\n        A[i][i] = p[i];\n        R[i][i] = i;\n        R[i][i-1] = 0;\n    }\n    A[n+1][n] = 0;\n    R[n+1][n] = 0;\n    for(diagonal = 1; diagonal <= n-1; diagonal++) {\n        for(i = 1; i <= n - diagonal; i++) {\n            j = i + diagonal;\n            k = min(i, j, A, p);\n            A[i][j] = A[i][k-1] + A[k+1][j] + sum(i, j, p);\n            R[i][j] = k;\n        }\n    }\n    printf(\"A = \\n\");\n    for(int i = 1; i <= n + 1; i++) {\n        for(int j = 0; j <= n; j++)\n            printf(\"%.3f \", A[i][j]);\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    *minavg = A[1][n];\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void optsearchtree ( int _n , float * _p , float * _minavg , index * * _r ) { index _quantity , _j , _k , _diagonal ; float * * _a = ( float * * ) malloc ( sizeof ( float * ) * ( _n + 2 ) ) ; for ( int _t = 0 ; _t < _n + 2 ; _t ++ ) _a [ _t ] = ( float * ) malloc ( sizeof ( float ) * ( _n + 1 ) ) ; for ( _quantity = 1 ; _quantity <= _n ; _quantity ++ ) { _a [ _quantity ] [ _quantity - 1 ] = 0 ; _a [ _quantity ] [ _quantity ] = _p [ _quantity ] ; _r [ _quantity ] [ _quantity ] = _quantity ; _r [ _quantity ] [ _quantity - 1 ] = 0 ; } _a [ _n + 1 ] [ _n ] = 0 ; _r [ _n + 1 ] [ _n ] = 0 ; for ( _diagonal = 1 ; _diagonal <= _n - 1 ; _diagonal ++ ) { for ( _quantity = 1 ; _quantity <= _n - _diagonal ; _quantity ++ ) { _j = _quantity + _diagonal ; _k = min ( _quantity , _j , _a , _p ) ; _a [ _quantity ] [ _j ] = _a [ _quantity ] [ _k - 1 ] + _a [ _k + 1 ] [ _j ] + sum ( _quantity , _j , _p ) ; _r [ _quantity ] [ _j ] = _k ; } } printf ( \" A = \\n \" ) ; for ( int _quantity = 1 ; _quantity <= _n + 1 ; _quantity ++ ) { for ( int _j = 0 ; _j <= _n ; _j ++ ) printf ( \" %.3f  \" , _a [ _quantity ] [ _j ] ) ; printf ( \" \\n \" ) ; } printf ( \" \\n \" ) ; * _minavg = _a [ 1 ] [ _n ] ; }"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__pwm_double.0.c", "original_string": "int main()\n{\n    PINSEL0 |= (1<<17);\n    PINSEL0 &= ~(1<<16);  \n    PWMPR = 14;\n    PWMMR0 = 10000;\n    PWMLER = 1<<0;\n    PWMMCR = (1<<1);   \n    PWMPCR = (1<<4)|(1<<12);  \n    PWMTCR = (1<<0)|(1<<3);  \n        while(1)\n        {\n            PWMMR3 = 1000;   \n            PWMMR4 = 3500;\n            PWMLER = (1<<3)|(1<<4);\n            delay(500);\n            PWMMR3 = 1000;  \n            PWMMR4 = 6000;\n            PWMLER = (1<<3)|(1<<4);\n            delay(500);\n            PWMMR3 = 1000;  \n            PWMMR4 = 8500;\n            PWMLER = (1<<3)|(1<<4);\n            delay(500);\n    }\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { PINSEL0 |= ( 1 << 17 ) ; PINSEL0 &= ~ ( 1 << 16 ) ; PWMPR = 14 ; PWMMR0 = 10000 ; PWMLER = 1 << 0 ; PWMMCR = ( 1 << 1 ) ; PWMPCR = ( 1 << 4 ) | ( 1 << 12 ) ; PWMTCR = ( 1 << 0 ) | ( 1 << 3 ) ; while ( 1 ) { Temperature = 1000 ; PWMMR4 = 3500 ; PWMLER = ( 1 << 3 ) | ( 1 << 4 ) ; delay ( 500 ) ; Temperature = 1000 ; PWMMR4 = 6000 ; PWMLER = ( 1 << 3 ) | ( 1 << 4 ) ; delay ( 500 ) ; Temperature = 1000 ; PWMMR4 = 8500 ; PWMLER = ( 1 << 3 ) | ( 1 << 4 ) ; delay ( 500 ) ; } }"}
{"author": "bgmanuel99", "file": "PracticasSistemasOperativos__ejercicio1.1.c", "original_string": "void *func2 (void *arg){\n    int err;\n    if(err = pthread_join(thread1, NULL)){\n        printf(\"Error al esperar a thread1 \\n \");\n    }else{\n        int suma = 1;\n        int size=(int) arg;\n        for(int i = 1; i < size; i++){\n            suma = suma * (int) arg;\n            arg--;\n        }\n        printf(\"Soy el thread 2 y estoy calculando el factorial de %d que es: %d \\n\", size, suma);\n    }\n    pthread_exit(NULL);\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "void * Func2 ( void * Arg ) { int Err ; if ( Err = pthread_join ( thread1 , NULL ) ) { printf ( \" Error al esperar a thread1 \\n  \" ) ; } else { int Suma = 1 ; int Size = ( int ) Arg ; for ( int Tabana = 1 ; Tabana < Size ; Tabana ++ ) { Suma = Suma * ( int ) Arg ; Arg -- ; } printf ( \" Soy el thread 2 y estoy calculando el factorial de %d que es: %d \\n \" , Size , Suma ) ; } pthread_exit ( NULL ) ; }"}
{"author": "davibernardos", "file": "DB-PJ__e150.3.c", "original_string": "int main(int argc, char *argv[]) {\n    char vetorCaptcha[TAM];\n    char vetorUsuario[TAM];\n    int captcha;\n    int validacaoDados;\n    int comparacao;\n    int resultado;\n    int cont;\n    srand(time(NULL));\n    do \n    {\n        system (\"COLOR F\");\n        system (\"cls\");\n        printf (\"Teste de Turing.\\n\\n\");\n        for (cont = 0; cont < 6; cont++)\n        {\n            do\n            {\n                captcha = (rand() % 122);\n            }\n            while (captcha <= 48 || captcha >= 57 && captcha <= 97 || captcha >= 122);\n            vetorCaptcha[cont] = captcha;\n            printf (\"%c \", vetorCaptcha[cont]);\n        }\n        system (\"COLOR F\");\n        printf (\"\\n\\nDigite os caracteres acima: \");\n        gets(vetorUsuario);\n        validacaoDados = validarDados (vetorUsuario);\n        if (validacaoDados == 0)\n        {\n            comparacao = compararCaptcha (vetorCaptcha, vetorUsuario);\n            resultado = exibirResultado (comparacao);\n            if (resultado == 1)\n            {\n                validacaoDados = resultado;\n                printf (\"%d\", validacaoDados);\n            }   \n        }\n    }\n    while (validacaoDados != 0);\n    return 0;\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( int Argc , char * Argv [ ] ) { char VetorCaptcha [ TAM ] ; char VetorUsuario [ TAM ] ; int Tabana ; int ValidacaoDados ; int Comparacao ; int Resultado ; int Cont ; srand ( time ( NULL ) ) ; do { system ( \" COLOR F \" ) ; system ( \" cls \" ) ; printf ( \" Teste de Turing.\\n\\n \" ) ; for ( Cont = 0 ; Cont < 6 ; Cont ++ ) { do { Tabana = ( rand ( ) % 122 ) ; } while ( Tabana <= 48 || Tabana >= 57 && Tabana <= 97 || Tabana >= 122 ) ; VetorCaptcha [ Cont ] = Tabana ; printf ( \" %c  \" , VetorCaptcha [ Cont ] ) ; } system ( \" COLOR F \" ) ; printf ( \" \\n\\nDigite os caracteres acima:  \" ) ; gets ( VetorUsuario ) ; ValidacaoDados = validarDados ( VetorUsuario ) ; if ( ValidacaoDados == 0 ) { Comparacao = compararCaptcha ( VetorCaptcha , VetorUsuario ) ; Resultado = exibirResultado ( Comparacao ) ; if ( Resultado == 1 ) { ValidacaoDados = Resultado ; printf ( \" %d \" , ValidacaoDados ) ; } } } while ( ValidacaoDados != 0 ) ; return 0 ; }"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__BinHexConverter.0.c", "original_string": "static inline char convertBinValueToHexDigit(uint8_t value, bool upperCase)\n{\n  char hexA = (upperCase) ? ('A') : ('a');\n  return ((char)((value < 10) ? ('0' + value) : (hexA + value - 10)));\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "static inline char convertBinValueToHexDigit ( uint8_t email , bool upperCase ) { char hexA = ( upperCase ) ? ( 'A' ) : ( 'a' ) ; return ( ( char ) ( ( email < 10 ) ? ( '0' + email ) : ( hexA + email - 10 ) ) ) ; }"}
{"author": "haon1026", "file": "linux-programming__dup2.0.c", "original_string": "int main(int argc, char *argv[])\n{\n    int fd1 = open(argv[1], O_RDWR|O_CREAT, 0644);   \n    if(fd1 < 0)\n    {\n        perror(\"open error\");\n        exit(1);\n    }\n    int fd2 = open(argv[2], O_RDWR|O_CREAT, 0644);   \n    if(fd2 < 0)\n    {\n        perror(\"open error\");\n        exit(1);\n    }\n    int newfd = dup2(fd1, fd2);                 \n    printf(\"newfd = %d\\n\", newfd);\n    int ret = write(fd2, \"1234567\", 7);         \n    printf(\"ret = %d\\n\", ret);\n    dup2(fd1, STDOUT_FILENO);                   \n    printf(\"-------------------\\n\");\n    close(fd1);\n    close(newfd);\n    return 0;\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( int _argc , char * _argv [ ] ) { int _email = open ( _argv [ 1 ] , O_RDWR | O_CREAT , 0644 ) ; if ( _email < 0 ) { perror ( \" open error \" ) ; exit ( 1 ) ; } int _fd2 = open ( _argv [ 2 ] , O_RDWR | O_CREAT , 0644 ) ; if ( _fd2 < 0 ) { perror ( \" open error \" ) ; exit ( 1 ) ; } int _new fd = dup2 ( _email , _fd2 ) ; printf ( \" newfd = %d\\n \" , _new fd ) ; int _ret = write ( _fd2 , \" 1234567 \" , 7 ) ; printf ( \" ret = %d\\n \" , _ret ) ; dup2 ( _email , STDOUT_FILENO ) ; printf ( \" -------------------\\n \" ) ; close ( _email ) ; close ( _new fd ) ; return 0 ; }"}
{"author": "ael-bagh", "file": "42_cub_3d_file_parsing__map_manager.3.c", "original_string": "void        map_errors(char **map)\n{\n    int i;\n    int j;\n    i = 0;\n    j = 0;\n    while (++i <= g_map_height)\n    {\n        while (++j <= g_map_width)\n        {\n            if (map[i][j] != '1' && map[i][j] != '0' && map[i][j] != '2'\n            && map[i][j] != 'N' && map[i][j] != 'W' && map[i][j] != 'E'\n            && map[i][j] != 'S' && map[i][j] != ' ')\n                error_redirect(0);\n            else if (map[i][j] != ' ' && map[i][j] != '1')\n            {\n                if (map[i][j + 1] == ' ' || map[i][j - 1] == ' '\n                || map[i + 1][j] == ' ' || map[i - 1][j] == ' ')\n                    error_redirect(1);\n                if (map[i][j] == 'N' || map[i][j] == 'S' ||\n                map[i][j] == 'E' || map[i][j] == 'W')\n                    player_init(map[i][j], i - 1, j - 1);\n            }\n        }\n        j = 1;\n    }\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "void map_errors ( char * * Map ) { int I ; int Sys ; I = 0 ; Sys = 0 ; while ( ++ I <= g_map_height ) { while ( ++ Sys <= g_map_width ) { if ( Map [ I ] [ Sys ] != '1' && Map [ I ] [ Sys ] != '0' && Map [ I ] [ Sys ] != '2' && Map [ I ] [ Sys ] != 'N' && Map [ I ] [ Sys ] != 'W' && Map [ I ] [ Sys ] != 'E' && Map [ I ] [ Sys ] != 'S' && Map [ I ] [ Sys ] != '' ) error_redirect ( 0 ) ; else if ( Map [ I ] [ Sys ] != '' && Map [ I ] [ Sys ] != '1' ) { if ( Map [ I ] [ Sys + 1 ] == '' || Map [ I ] [ Sys - 1 ] == '' || Map [ I + 1 ] [ Sys ] == '' || Map [ I - 1 ] [ Sys ] == '' ) error_redirect ( 1 ) ; if ( Map [ I ] [ Sys ] == 'N' || Map [ I ] [ Sys ] == 'S' || Map [ I ] [ Sys ] == 'E' || Map [ I ] [ Sys ] == 'W' ) player_init ( Map [ I ] [ Sys ] , I - 1 , Sys - 1 ) ; } } Sys = 1 ; } }"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__SinglePartitionDemoFirmwareUpdateInfoFileReader.7.c", "original_string": "static void openFirmwareUpdateInfoFile(void)\n{\n  char command[260 + 1] = \"\";\n  snprintf(command, sizeof(command), \"code %s\", DEMO_PRODUCT_UPDATE_INFO_FILE_NAME);\n  system(command);\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "static void openFirmwareUpdateInfoFile ( void ) { char _temperature [ 260 + 1 ] = \" \" ; snprintf ( _temperature , sizeof ( _temperature ) , \" code %s \" , DEMO_PRODUCT_UPDATE_INFO_FILE_NAME ) ; system ( _temperature ) ; }"}
{"author": "dle2005", "file": "Algorithm__Hamiltonian_v2.2.c", "original_string": "void main() {\n    printf(\"n = \");\n    scanf(\"%d\", &n);\n    printf(\"\\n\");\n    W = (int **)malloc(sizeof(int *) * (n+1));\n    for(int i = 0; i <= n; i++) {\n        W[i] = (int *)malloc(sizeof(int) * (n+1));\n        memset(W[i], 0, sizeof(int) * (n+1));\n    }\n    vindex = (int *)malloc(sizeof(int) * (n+1));\n    vindex[0] = 1;\n    printf(\"W = \\n\");\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= n; j++)\n            scanf(\"%d\", &W[i][j]);\n    printf(\"\\n\");\n    hamiltonian(0);\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "void main ( ) { printf ( \" n =  \" ) ; scanf ( \" %d \" , & Temperature ) ; printf ( \" \\n \" ) ; W = ( int * * ) malloc ( sizeof ( int * ) * ( Temperature + 1 ) ) ; for ( int _i = 0 ; _i <= Temperature ; _i ++ ) { W [ _i ] = ( int * ) malloc ( sizeof ( int ) * ( Temperature + 1 ) ) ; memset ( W [ _i ] , 0 , sizeof ( int ) * ( Temperature + 1 ) ) ; } vindex = ( int * ) malloc ( sizeof ( int ) * ( Temperature + 1 ) ) ; vindex [ 0 ] = 1 ; printf ( \" W = \\n \" ) ; for ( int _i = 1 ; _i <= Temperature ; _i ++ ) for ( int _j = 1 ; _j <= Temperature ; _j ++ ) scanf ( \" %d \" , & W [ _i ] [ _j ] ) ; printf ( \" \\n \" ) ; hamiltonian ( 0 ) ; }"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__rstp_bpdu.2.c", "original_string": "error_t rstpValidateConfigBpdu(RstpBridgePort *port, const RstpBpdu *bpdu,\n   size_t length)\n{\n   RstpBridgeContext *context;\n   context = port->context;\n   if(length < RSTP_CONFIG_BPDU_SIZE)\n      return ERROR_INVALID_LENGTH;\n   if(ntohs(bpdu->messageAge) >= ntohs(bpdu->maxAge))\n      return ERROR_INVALID_PACKET;\n   if(rstpCompareBridgeAddr(&bpdu->bridgeId.addr, &context->bridgeId.addr) == 0 &&\n      rstpComparePortNum(ntohs(bpdu->portId), port->portId) == 0)\n   {\n      return ERROR_WRONG_IDENTIFIER;\n   }\n   return NO_ERROR;\n}", "watermark": [0, 1, 0, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "error_t rstpValidateConfigBpdu ( RstpBridgePort * Port , const RstpBpdu * Running , size_t Length ) { RstpBridgeContext * Context ; Context = Port -> context ; if ( Length < RSTP_CONFIG_BPDU_SIZE ) return ERROR_INVALID_LENGTH ; if ( ntohs ( Running -> messageAge ) >= ntohs ( Running -> maxAge ) ) return ERROR_INVALID_PACKET ; if ( rstpCompareBridgeAddr ( & Running -> bridgeId.addr , & Context -> bridgeId.addr ) == 0 && rstpComparePortNum ( ntohs ( Running -> portId ) , Port -> portId ) == 0 ) { return ERROR_WRONG_IDENTIFIER ; } return NO_ERROR ; }"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__PrimeNumFunc.1.c", "original_string": "int checkPrime(int n)\n{\n    int flag = 0,j;\n    for (j = 2;j <= n/2; j++)\n    {\n        if(n%j == 0)\n        {\n           flag = 1;\n           break;\n        }\n    }\n    return flag;\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "int checkPrime ( int n ) { int flag = 0 , email ; for ( email = 2 ; email <= n / 2 ; email ++ ) { if ( n % email == 0 ) { flag = 1 ; break ; } } return flag ; }"}
{"author": "dishanp", "file": "DSA__q5.0.c", "original_string": "int main()\n{\n    int *A;\n    int n;\n    int choice;\n    int size = 0;\n    int t;\n    printf(\"1 : Lower Triangular Matrix\\n\");\n    printf(\"2 : Upper Triangular Matrix\\n\");\n    printf(\"Enter Choice : \");\n    scanf(\"%d\", &choice);\n    printf(\"Enter Dimensions : \");\n    scanf(\"%d\", &n);\n    switch(choice)\n    {\n        case 1 :\n        size = n*(n + 1) / 2;\n        A = (int*)malloc(size * sizeof(int));\n        printf(\"\\nEnter elements : \\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                scanf(\"%d\", &t);\n                if(i >= j)\n                    A[i*(i-1)/2 + (j-1)] = t ;\n            }\n        }\n        printf(\"\\n1D array storing the elements : \");\n        for(int i = 0 ; i < size ; i++)\n        {\n            printf(\"%d \", A[i]);\n        }\n        printf(\"\\n\\nDisplaying matrix from stored 1D array values :\\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                if(i >= j)\n                    printf(\"%d \", A[i*(i-1)/2 + (j-1)]);\n                else\n                    printf(\"  \");\n            }\n            printf(\"\\n\");\n        }\n        break;\n        case 2 :\n        size = n * (n + 1) / 2;\n        A = (int*)malloc(size * sizeof(int));\n        printf(\"\\nEnter elements : \\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                scanf(\"%d\", &t);\n                if(i <= j)\n                    A[(n*(i-1) - (i-1)*(i-2)/2) + (j-i)] = t ;\n            }\n        }\n        printf(\"\\n1D array storing the elements : \");\n        for(int i = 0 ; i < size ; i++)\n        {\n            printf(\"%d \", A[i]);\n        }\n        printf(\"\\n\\nDisplaying matrix from stored 1D array values :\\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                if(i <= j)\n                    printf(\"%d \", A[(n*(i-1) - (i-1)*(i-2)/2) + (j-i)]);\n                else\n                    printf(\"  \");\n            }\n            printf(\"\\n\");\n        }\n        break;\n    }\n}", "watermark": [0, 1, 1, 1], "extract": [0, 1, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { int * A ; int n ; int choice ; int size = 0 ; int t ; printf ( \" 1 : Lower Triangular Matrix\\n \" ) ; printf ( \" 2 : Upper Triangular Matrix\\n \" ) ; printf ( \" Enter Choice :  \" ) ; scanf ( \" %d \" , & choice ) ; printf ( \" Enter Dimensions :  \" ) ; scanf ( \" %d \" , & n ) ; switch ( choice ) { case 1 : size = n * ( n + 1 ) / 2 ; A = ( int * ) malloc ( size * sizeof ( int ) ) ; printf ( \" \\nEnter elements : \\n \" ) ; for ( int in = 1 ; in <= n ; in ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { scanf ( \" %d \" , & t ) ; if ( in >= j ) A [ in * ( in - 1 ) / 2 + ( j - 1 ) ] = t ; } } printf ( \" \\n1D array storing the elements :  \" ) ; for ( int in = 0 ; in < size ; in ++ ) { printf ( \" %d  \" , A [ in ] ) ; } printf ( \" \\n\\nDisplaying matrix from stored 1D array values :\\n \" ) ; for ( int in = 1 ; in <= n ; in ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( in >= j ) printf ( \" %d  \" , A [ in * ( in - 1 ) / 2 + ( j - 1 ) ] ) ; else printf ( \"    \" ) ; } printf ( \" \\n \" ) ; } break ; case 2 : size = n * ( n + 1 ) / 2 ; A = ( int * ) malloc ( size * sizeof ( int ) ) ; printf ( \" \\nEnter elements : \\n \" ) ; for ( int in = 1 ; in <= n ; in ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { scanf ( \" %d \" , & t ) ; if ( in <= j ) A [ ( n * ( in - 1 ) - ( in - 1 ) * ( in - 2 ) / 2 ) + ( j - in ) ] = t ; } } printf ( \" \\n1D array storing the elements :  \" ) ; for ( int in = 0 ; in < size ; in ++ ) { printf ( \" %d  \" , A [ in ] ) ; } printf ( \" \\n\\nDisplaying matrix from stored 1D array values :\\n \" ) ; for ( int in = 1 ; in <= n ; in ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( in <= j ) printf ( \" %d  \" , A [ ( n * ( in - 1 ) - ( in - 1 ) * ( in - 2 ) / 2 ) + ( j - in ) ] ) ; else printf ( \"    \" ) ; } printf ( \" \\n \" ) ; } break ; } }"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__MatrixOperations.0.c", "original_string": "void main()\n{\n    int i, j = 0;\n    int choice = 0;\n    int contin = 0;\n    int matrix1[R][C];\n    int matrix2[R][C];\n    int matrix3[R][C];\n    printf(\"\\nEnter elements of Matrix1...\\n\");\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            scanf(\"%d\", &matrix1[i][j]);\n        }\n    }\n    printf(\"\\nEnter elements of Matrix2...\\n\");\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            scanf(\"%d\", &matrix2[i][j]);\n        }\n    }\n    do\n    {\n        printf(\"\\nPress:- \");\n        printf(\"\\n1 for ADDITION\");\n        printf(\"\\n2 for SUBTRACTION\");\n        printf(\"\\n3 for  MULTIPLICATION\");\n        printf(\"\\n4 for EXIT\");\n        printf(\"\\nEnter your choice: \");\n        scanf(\"%d\", &choice);\n        switch(choice)\n        {\n            case 1:\n                add_matrices(matrix1, matrix2);\n                break;\n            case 2:\n                subtract_matrices(matrix1, matrix2);\n                break;\n            case 3:\n                multiply_matrices(matrix1, matrix2);\n                break;\n            case 4:\n                exit(0);\n                break;\n            default:\n                printf(\"\\nEnter a correct choice...\");\n        }\n        printf(\"\\nPress 5 to continue, else press any other number: \");\n        scanf(\"%d\", &contin);\n    }while(contin == 5);\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "void main ( ) { int I , J = 0 ; int GATTS = 0 ; int Contin = 0 ; int Matrix1 [ R ] [ C ] ; int Matrix2 [ R ] [ C ] ; int Matrix3 [ R ] [ C ] ; printf ( \" \\nEnter elements of Matrix1...\\n \" ) ; for ( I = 0 ; I < R ; I ++ ) { for ( J = 0 ; J < C ; J ++ ) { scanf ( \" %d \" , & Matrix1 [ I ] [ J ] ) ; } } printf ( \" \\nEnter elements of Matrix2...\\n \" ) ; for ( I = 0 ; I < R ; I ++ ) { for ( J = 0 ; J < C ; J ++ ) { scanf ( \" %d \" , & Matrix2 [ I ] [ J ] ) ; } } do { printf ( \" \\nPress:-  \" ) ; printf ( \" \\n1 for ADDITION \" ) ; printf ( \" \\n2 for SUBTRACTION \" ) ; printf ( \" \\n3 for  MULTIPLICATION \" ) ; printf ( \" \\n4 for EXIT \" ) ; printf ( \" \\nEnter your choice:  \" ) ; scanf ( \" %d \" , & GATTS ) ; switch ( GATTS ) { case 1 : add_matrices ( Matrix1 , Matrix2 ) ; break ; case 2 : subtract_matrices ( Matrix1 , Matrix2 ) ; break ; case 3 : multiply_matrices ( Matrix1 , Matrix2 ) ; break ; case 4 : exit ( 0 ) ; break ; default : printf ( \" \\nEnter a correct choice... \" ) ; } printf ( \" \\nPress 5 to continue, else press any other number:  \" ) ; scanf ( \" %d \" , & Contin ) ; } while ( Contin == 5 ) ; }"}
{"author": "2security", "file": "Matrix__35SumLowerTriangularMatrix.1.c", "original_string": "int main()\n    {\n    int i,j,r,c,mat1[20][20];\n    printf(\"Enter the row & col. for the matrix\");\n    scanf(\"%d%d\",&r,&c);\n    if(r!=c)\n        printf(\"Lower triangualr matrix or not matrix should be square\");\n    else\n        {\n        printf(\"\\n Enter the matrix \\n\");\n        for(i=0;i<r;i++)\n        for(j=0;j<c;j++)                \n        scanf(\"%d\",&mat1[i][j]);\n        printf(\"The sum of the lower triangular matrix=%d\",SumLowerTri(mat1,r));    \n        }\n    return 0;\n    }", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int _i , _j , _r , _c , _sem [ 20 ] [ 20 ] ; printf ( \" Enter the row & col.for the matrix \" ) ; scanf ( \" %d%d \" , & _r , & _c ) ; if ( _r != _c ) printf ( \" Lower triangualr matrix or not matrix should be square \" ) ; else { printf ( \" \\n Enter the matrix \\n \" ) ; for ( _i = 0 ; _i < _r ; _i ++ ) for ( _j = 0 ; _j < _c ; _j ++ ) scanf ( \" %d \" , & _sem [ _i ] [ _j ] ) ; printf ( \" The sum of the lower triangular matrix=%d \" , SumLowerTri ( _sem , _r ) ) ; } return 0 ; }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__21_For.2.c", "original_string": "int main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Cos(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X); \n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    for(int i = 1; i <= veces; ++i){\n        if(i%2 == 0)\n        Suma_total += (Exp(X, i*2) / Fac(i*2));\n    else\n        Suma_total -= (Exp(X, i*2) / Fac(i*2));\n    }\n    printf(\"cos(%i) es igual a %lf\", X, (Suma_total + 1.0));\n    return 0;\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int X = 0 ; int packet = 0 ; printf ( \" \\nPrograma para calcular Cos(x) mediante sumas de Taylor\\nIngresa X: \" ) ; scanf ( \" %i \" , & X ) ; printf ( \" \\nIngrse el numero de sumas:  \" ) ; scanf ( \" %i \" , & packet ) ; double sumaTotal = 0.0 ; for ( int i = 1 ; i <= packet ; ++ i ) { if ( i % 2 == 0 ) sumaTotal += ( Exp ( X , i * 2 ) / Fac ( i * 2 ) ) ; else sumaTotal -= ( Exp ( X , i * 2 ) / Fac ( i * 2 ) ) ; } printf ( \" cos(%i) es igual a %lf \" , X , ( sumaTotal + 1.0 ) ) ; return 0 ; }"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__routing_utils.0.c", "original_string": "int     c_w(char *str, char c)\n{\n    int i;\n    int j;\n    j = 0;\n    i = 0;\n    while (str[i] != '\\0')\n    {\n        while (str[i] == c && str[i] != '\\0')\n        {\n            i++;\n        }\n        if (str[i] != c && str[i] != '\\0')\n            j++;\n        while (str[i] != c && (str[i] != '\\0'))\n            i++;\n    }\n    return (j);\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "int c_w ( char * str , char email ) { int i ; int j ; j = 0 ; i = 0 ; while ( str [ i ] != '\\0' ) { while ( str [ i ] == email && str [ i ] != '\\0' ) { i ++ ; } if ( str [ i ] != email && str [ i ] != '\\0' ) j ++ ; while ( str [ i ] != email && ( str [ i ] != '\\0' ) ) i ++ ; } return ( j ) ; }"}
{"author": "davibernardos", "file": "DB-Projetos__e9.0.c", "original_string": "int main(int argc, char *argv[]) {\n    float percVitoriasComputador, percVitoriasJogador, percVitoriasJogador1, percVitoriasJogador2;\n    int computador, jogador, jogador1, jogador2, opcao, jogar;\n    int vitComputador, vitJogador, vitJogador1, vitJogador2, empate, partidas;\n    srand(time(NULL));\n    vitComputador = 0;\n    vitJogador = 0;\n    vitJogador1 = 0;\n    vitJogador2 = 0;\n    empate = 0;\n    partidas = 0;\n    printf(\"\\nDigite 1 para jogar contra o computador. \\n\");\n    printf(\"Digite 2 para jogar contra outro jogador. \\n\");\n    scanf(\"%d\", &opcao);\n    while(opcao < 1 || opcao > 2)\n    {\n        printf(\"Opcao invalida. Digite novamente.\");\n        printf(\"\\nDigite 1 para jogar contra o computador. \\n\");\n        printf(\"Digite 2 para jogar contra outro jogador. \\n\");\n        scanf(\"%d\", &opcao);\n    }\n        do{\n            switch(opcao)\n            {\n                case 1:\n                    printf(\"\\nEscolha uma opcao: \\n\");\n                    printf(\"1. Pedra\\n\");\n                    printf(\"2. Papel\\n\");\n                    printf(\"3. Tesoura\\n\");\n                    scanf(\"%d\", &jogador);\n                    while(jogador < 1 || jogador > 3)\n                    {\n                        printf(\"Opcao invalida. Digite novamente.\\n\");\n                        printf(\"\\nEscolha uma opcao: \\n\");\n                        printf(\"1. Pedra\\n\");\n                        printf(\"2. Papel\\n\");\n                        printf(\"3. Tesoura\\n\");\n                        scanf(\"%d\", &jogador);\n                    }\n                    computador = rand();\n                    printf(\"\", computador, (1 + computador % 3));\n                    printf(\"\\nComputador escolheu %d\\n\", (1 + computador % 3));\n                    if((1 + computador % 3) == 2 && jogador == 1 || (1 + computador % 3) == 3 && jogador == 2 || (1 + computador % 3) == 1 && jogador == 3)\n                    {\n                        printf(\"Computador ganhou.\\n\");\n                        vitComputador++;\n                    }else\n                    {\n                        if(jogador == (1 + computador % 3))\n                        {\n                            printf(\"Empate.\\n\");\n                            empate++;\n                        }else\n                        {\n                            printf(\"Jogador ganhou.\\n\");\n                            vitJogador++;\n                        }\n                    }\n                    partidas++;\n                    printf(\"\\nJogar novamente?\\n\");\n                    printf(\"1. Sim\\n\");\n                    printf(\"2. Nao\\n\");\n                    scanf(\"%d\", &jogar);\n                    while(jogar < 1 || jogar > 2)\n                    {\n                        printf(\"Opcao invalida. Escolha novamente.\\n\");\n                        printf(\"\\nJogar novamente?\\n\");\n                        printf(\"1. Sim\\n\");\n                        printf(\"2. Nao\\n\");\n                        scanf(\"%d\", &jogar);\n                    }\n                    break;\n                case 2:\n                    printf(\"\\nJogador 1 escolha uma opcao: \\n\");\n                    printf(\"1. Pedra\\n\");\n                    printf(\"2. Papel\\n\");\n                    printf(\"3. Tesoura\\n\");\n                    scanf(\"%d\", &jogador1);\n                    while(jogador1 < 1 || jogador1 > 3)\n                    {\n                        printf(\"Opcao invalida. Digite novamente.\\n\");\n                        printf(\"\\nJogador 1 escolha uma opcao: \\n\");\n                        printf(\"1. Pedra\\n\");\n                        printf(\"2. Papel\\n\");\n                        printf(\"3. Tesoura\\n\");\n                        scanf(\"%d\", &jogador1);\n                    }\n                    printf(\"\\nJogador 2 escolha uma opcao: \\n\");\n                    printf(\"1. Pedra\\n\");\n                    printf(\"2. Papel\\n\");\n                    printf(\"3. Tesoura\\n\");\n                    scanf(\"%d\", &jogador2);\n                    while(jogador2 < 1 || jogador2 > 3)\n                    {\n                        printf(\"Opcao invalida. Digite novamente.\\n\");\n                        printf(\"\\nJogador 2 escolha uma opcao: \\n\");\n                        printf(\"1. Pedra\\n\");\n                        printf(\"2. Papel\\n\");\n                        printf(\"3. Tesoura\\n\");\n                        scanf(\"%d\", &jogador2);\n                    }\n                    if(jogador1 == 2 && jogador2 == 1 || jogador1 == 3 && jogador2 == 2 || jogador1 == 1 && jogador2 == 3)\n                    {\n                        printf(\"Jogador 1 ganhou.\\n\");\n                        vitJogador1++;\n                    }else\n                    {\n                        if(jogador1 == jogador2)\n                        {\n                            printf(\"Empate.\\n\");\n                            empate++;\n                        }else\n                        {\n                            printf(\"Jogador 2 ganhou.\\n\");\n                            vitJogador2++;\n                        }\n                    }\n                    partidas++;\n                    printf(\"\\nJogar novamente?\\n\");\n                    printf(\"3. Sim\\n\");\n                    printf(\"4. Nao\\n\");\n                    scanf(\"%d\", &jogar);\n                    while(jogar < 3 || jogar > 4)\n                    {\n                        printf(\"Opcao invalida. Escolha novamente.\\n\");\n                        printf(\"\\nJogar novamente?\\n\");\n                        printf(\"3. Sim\\n\");\n                        printf(\"4. Nao\\n\");\n                        scanf(\"%d\", &jogar);\n                    }\n                    break;\n            }\n            if(jogar == 1)\n            {\n            }else\n            {\n                if(jogar == 2)\n                {\n                    printf(\"\\nTotal de %d partida(s).\\n\", partidas);\n                    printf(\"\\nComputador venceu %d partida(s). \\n\", vitComputador);\n                    printf(\"Jogador venceu %d partida(s). \\n\", vitJogador);\n                    printf(\"Total de %d empate(s). \\n\", empate);\n                    percVitoriasComputador = (vitComputador * 100) / partidas;\n                    printf(\"Percentual de vitorias do computador = %.2f%%\\n\", percVitoriasComputador);\n                    percVitoriasJogador = (vitJogador * 100) / partidas;\n                    printf(\"Percentual de vitorias do jogador = %.2f%%\\n\", percVitoriasJogador);\n                    break;          \n                }else\n                {\n                    if(jogar == 3)\n                    {\n                    }else\n                    {\n                        if(jogar == 4)\n                        {\n                            printf(\"\\nTotal de %d partida(s).\\n\", partidas);\n                            printf(\"\\nJogador 1 venceu %d partida(s). \\n\", vitJogador1);\n                            printf(\"Jogador 2 venceu %d partida(s). \\n\", vitJogador2);\n                            printf(\"Total de %d empate(s). \\n\", empate);\n                            percVitoriasJogador1 = (vitJogador1 * 100) / partidas;\n                            printf(\"Percentual de vitorias do jogador 1 = %.2f%\\n\", percVitoriasJogador1);\n                            percVitoriasJogador2 = (vitJogador2 * 100) / partidas;\n                            printf(\"Percentual de vitorias do jogador 2 = %.2f%\\n\", percVitoriasJogador2);\n                            break;\n                        }\n                    }\n                }\n            }       \n        }while(opcao == 1 || opcao == 2);   \n    return 0;\n}", "watermark": [1, 0, 0, 0], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "int main ( int _argc , char * _argv [ ] ) { float _perc_vitorias_computador , _perc_vitorias_jogador , _perc_vitorias_jogador1 , _perc_vitorias_jogador2 ; int _computador , _jogador , _jogador1 , _jogador2 , _opcao , _jogar ; int _vit_computador , _vit_jogador , _cunha , _vit_jogador2 , _empate , _partidas ; srand ( time ( NULL ) ) ; _vit_computador = 0 ; _vit_jogador = 0 ; _cunha = 0 ; _vit_jogador2 = 0 ; _empate = 0 ; _partidas = 0 ; printf ( \" \\nDigite 1 para jogar contra o computador. \\n \" ) ; printf ( \" Digite 2 para jogar contra outro jogador. \\n \" ) ; scanf ( \" %d \" , & _opcao ) ; while ( _opcao < 1 || _opcao > 2 ) { printf ( \" Opcao invalida.Digite novamente. \" ) ; printf ( \" \\nDigite 1 para jogar contra o computador. \\n \" ) ; printf ( \" Digite 2 para jogar contra outro jogador. \\n \" ) ; scanf ( \" %d \" , & _opcao ) ; } do { switch ( _opcao ) { case 1 : printf ( \" \\nEscolha uma opcao: \\n \" ) ; printf ( \" 1.Pedra\\n \" ) ; printf ( \" 2.Papel\\n \" ) ; printf ( \" 3.Tesoura\\n \" ) ; scanf ( \" %d \" , & _jogador ) ; while ( _jogador < 1 || _jogador > 3 ) { printf ( \" Opcao invalida.Digite novamente.\\n \" ) ; printf ( \" \\nEscolha uma opcao: \\n \" ) ; printf ( \" 1.Pedra\\n \" ) ; printf ( \" 2.Papel\\n \" ) ; printf ( \" 3.Tesoura\\n \" ) ; scanf ( \" %d \" , & _jogador ) ; } _computador = rand ( ) ; printf ( \" \" , _computador , ( 1 + _computador % 3 ) ) ; printf ( \" \\nComputador escolheu %d\\n \" , ( 1 + _computador % 3 ) ) ; if ( ( 1 + _computador % 3 ) == 2 && _jogador == 1 || ( 1 + _computador % 3 ) == 3 && _jogador == 2 || ( 1 + _computador % 3 ) == 1 && _jogador == 3 ) { printf ( \" Computador ganhou.\\n \" ) ; _vit_computador ++ ; } else { if ( _jogador == ( 1 + _computador % 3 ) ) { printf ( \" Empate.\\n \" ) ; _empate ++ ; } else { printf ( \" Jogador ganhou.\\n \" ) ; _vit_jogador ++ ; } } _partidas ++ ; printf ( \" \\nJogar novamente?\\n \" ) ; printf ( \" 1.Sim\\n \" ) ; printf ( \" 2.Nao\\n \" ) ; scanf ( \" %d \" , & _jogar ) ; while ( _jogar < 1 || _jogar > 2 ) { printf ( \" Opcao invalida.Escolha novamente.\\n \" ) ; printf ( \" \\nJogar novamente?\\n \" ) ; printf ( \" 1.Sim\\n \" ) ; printf ( \" 2.Nao\\n \" ) ; scanf ( \" %d \" , & _jogar ) ; } break ; case 2 : printf ( \" \\nJogador 1 escolha uma opcao: \\n \" ) ; printf ( \" 1.Pedra\\n \" ) ; printf ( \" 2.Papel\\n \" ) ; printf ( \" 3.Tesoura\\n \" ) ; scanf ( \" %d \" , & _jogador1 ) ; while ( _jogador1 < 1 || _jogador1 > 3 ) { printf ( \" Opcao invalida.Digite novamente.\\n \" ) ; printf ( \" \\nJogador 1 escolha uma opcao: \\n \" ) ; printf ( \" 1.Pedra\\n \" ) ; printf ( \" 2.Papel\\n \" ) ; printf ( \" 3.Tesoura\\n \" ) ; scanf ( \" %d \" , & _jogador1 ) ; } printf ( \" \\nJogador 2 escolha uma opcao: \\n \" ) ; printf ( \" 1.Pedra\\n \" ) ; printf ( \" 2.Papel\\n \" ) ; printf ( \" 3.Tesoura\\n \" ) ; scanf ( \" %d \" , & _jogador2 ) ; while ( _jogador2 < 1 || _jogador2 > 3 ) { printf ( \" Opcao invalida.Digite novamente.\\n \" ) ; printf ( \" \\nJogador 2 escolha uma opcao: \\n \" ) ; printf ( \" 1.Pedra\\n \" ) ; printf ( \" 2.Papel\\n \" ) ; printf ( \" 3.Tesoura\\n \" ) ; scanf ( \" %d \" , & _jogador2 ) ; } if ( _jogador1 == 2 && _jogador2 == 1 || _jogador1 == 3 && _jogador2 == 2 || _jogador1 == 1 && _jogador2 == 3 ) { printf ( \" Jogador 1 ganhou.\\n \" ) ; _cunha ++ ; } else { if ( _jogador1 == _jogador2 ) { printf ( \" Empate.\\n \" ) ; _empate ++ ; } else { printf ( \" Jogador 2 ganhou.\\n \" ) ; _vit_jogador2 ++ ; } } _partidas ++ ; printf ( \" \\nJogar novamente?\\n \" ) ; printf ( \" 3.Sim\\n \" ) ; printf ( \" 4.Nao\\n \" ) ; scanf ( \" %d \" , & _jogar ) ; while ( _jogar < 3 || _jogar > 4 ) { printf ( \" Opcao invalida.Escolha novamente.\\n \" ) ; printf ( \" \\nJogar novamente?\\n \" ) ; printf ( \" 3.Sim\\n \" ) ; printf ( \" 4.Nao\\n \" ) ; scanf ( \" %d \" , & _jogar ) ; } break ; } if ( _jogar == 1 ) { } else { if ( _jogar == 2 ) { printf ( \" \\nTotal de %d partida(s).\\n \" , _partidas ) ; printf ( \" \\nComputador venceu %d partida(s). \\n \" , _vit_computador ) ; printf ( \" Jogador venceu %d partida(s). \\n \" , _vit_jogador ) ; printf ( \" Total de %d empate(s). \\n \" , _empate ) ; _perc_vitorias_computador = ( _vit_computador * 100 ) / _partidas ; printf ( \" Percentual de vitorias do computador = %.2f%%\\n \" , _perc_vitorias_computador ) ; _perc_vitorias_jogador = ( _vit_jogador * 100 ) / _partidas ; printf ( \" Percentual de vitorias do jogador = %.2f%%\\n \" , _perc_vitorias_jogador ) ; break ; } else { if ( _jogar == 3 ) { } else { if ( _jogar == 4 ) { printf ( \" \\nTotal de %d partida(s).\\n \" , _partidas ) ; printf ( \" \\nJogador 1 venceu %d partida(s). \\n \" , _cunha ) ; printf ( \" Jogador 2 venceu %d partida(s). \\n \" , _vit_jogador2 ) ; printf ( \" Total de %d empate(s). \\n \" , _empate ) ; _perc_vitorias_jogador1 = ( _cunha * 100 ) / _partidas ; printf ( \" Percentual de vitorias do jogador 1 = %.2f%\\n \" , _perc_vitorias_jogador1 ) ; _perc_vitorias_jogador2 = ( _vit_jogador2 * 100 ) / _partidas ; printf ( \" Percentual de vitorias do jogador 2 = %.2f%\\n \" , _perc_vitorias_jogador2 ) ; break ; } } } } } while ( _opcao == 1 || _opcao == 2 ) ; return 0 ; }"}
{"author": "paawankohli", "file": "DSA-LAB__q23.3.c", "original_string": "void dequeueright(queue *q)\n{\n    if (q->front==q->rear)\n        printf(\"Queue Empty\");\n    else\n        printf(\"\\n%s deleted\", q->c[--(q->rear)] );\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "void dequeueright ( queue * _whole ) { if ( _whole -> front == _whole -> rear ) printf ( \" Queue Empty \" ) ; else printf ( \" \\n%s deleted \" , _whole -> c [ -- ( _whole -> rear ) ] ) ; }"}
{"author": "paawankohli", "file": "DSA-LAB__doublyLL.0.c", "original_string": "nptr createNode(int x)\n{\n    nptr temp = (nptr)malloc(sizeof(node));\n    temp -> data = x;\n    temp -> left = temp -> right = NULL;\n    return temp;\n}", "watermark": [0, 1, 1, 1], "extract": [0, 1, 1, 1], "output_original_func": false, "after_watermark": "nptr createNode ( int x ) { nptr running = ( nptr ) malloc ( sizeof ( node ) ) ; running -> data = x ; running -> left = running -> right = NULL ; return running ; }"}
{"author": "ankitraj311", "file": "450_babbar__6_union_array_SELF_unsorted_array.1.c", "original_string": "void union_array(int arr1[], int arr2[], int size_arr1, int size_arr2)\n{\n  int total_size = size_arr1+size_arr2;\n  int arr3[total_size], j = 0;\n  for(int i = 0; i<size_arr1; i++)\n  {\n    arr3[j] = arr1[i];\n    j++;\n  }\n  for(int i = 0; i<size_arr2; i++)\n  {\n    arr3[j] = arr2[i];\n    j++;\n  }\n  printf(\"Array befor Union :-\");\n  array_print(arr3,total_size);\n  for(int i = 0; i<total_size; i++)\n  {\n    for(int j = i+1; j<total_size;)\n    {\n      if(arr3[i] == arr3[j])\n      {\n        for(int k = j; k<total_size; k++)\n    {\n          arr3[k] = arr3[k+1];\n    }\n    total_size--;\n      }\n      else\n      {\n        j++;\n      }\n    }\n  }\n  printf(\"Array after Union :-\");\n  array_print(arr3,total_size);\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "void union_array ( int _arr1 [ ] , int _arr2 [ ] , int _size_arr1 , int _size_arr2 ) { int _total_size = _size_arr1 + _size_arr2 ; int _arr3 [ _total_size ] , _j = 0 ; for ( int _i = 0 ; _i < _size_arr1 ; _i ++ ) { _arr3 [ _j ] = _arr1 [ _i ] ; _j ++ ; } for ( int _i = 0 ; _i < _size_arr2 ; _i ++ ) { _arr3 [ _j ] = _arr2 [ _i ] ; _j ++ ; } printf ( \" Array befor Union :- \" ) ; array_print ( _arr3 , _total_size ) ; for ( int _i = 0 ; _i < _total_size ; _i ++ ) { for ( int _j = _i + 1 ; _j < _total_size ; ) { if ( _arr3 [ _i ] == _arr3 [ _j ] ) { for ( int _whole = _j ; _whole < _total_size ; _whole ++ ) { _arr3 [ _whole ] = _arr3 [ _whole + 1 ] ; } _total_size -- ; } else { _j ++ ; } } } printf ( \" Array after Union :- \" ) ; array_print ( _arr3 , _total_size ) ; }"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__ext1_intr.4.c", "original_string": "void delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)             \n        {}\n    }\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "void delay ( int Val ) { int I , J ; for ( I = 0 ; I < Val ; ++ I ) { for ( J = 0 ; J < 6000 ; ++ J ) { } } }"}
{"author": "MFarid94", "file": "Assignment4__Exercise11.0.c", "original_string": "void SwapBits(unsigned int *ptr){\n    unsigned short temp;\n    unsigned short *ptrS = (unsigned short *)ptr;\n    temp = *ptrS;\n    *ptrS = *(ptrS + 1);\n    *(ptrS + 1) = temp;\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "void SwapBits ( unsigned int * _ptr ) { unsigned short _temp ; unsigned short * _tabana = ( unsigned short * ) _ptr ; _temp = * _tabana ; * _tabana = * ( _tabana + 1 ) ; * ( _tabana + 1 ) = _temp ; }"}
{"author": "augustogunsch", "file": "jack-compiler__parser-expressions.13.c", "original_string": "TERM* parseexpressionnullified(PARSER* p) {\n    TERM* head = parsetermnullified(p);\n    TERM* current = head;\n    TERM* nextt;\n    while(isop(p->current)) {\n        current->op = p->current->token[0]; \n        next(p);\n        nextt = parseterm(p);\n        current->next = nextt;\n        current = nextt;\n    }\n    if(current != NULL)\n        current->next = NULL;\n    return head;\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "TERM * Parseexpressionnullified ( PARSER * P ) { TERM * Temperature = parsetermnullified ( P ) ; TERM * Current = Temperature ; TERM * Nextt ; while ( isop ( P -> current ) ) { Current -> op = P -> current -> token [ 0 ] ; next ( P ) ; Nextt = parseterm ( P ) ; Current -> next = Nextt ; Current = Nextt ; } if ( Current != NULL ) Current -> next = NULL ; return Temperature ; }"}
{"author": "kbtomic", "file": "StrukturePodataka__zad5.4.c", "original_string": "int unosDrugi(pozicija p)\n{\n    FILE* fp = NULL;\n    fp = fopen(\"lista2.txt\", \"r\");\n    if (fp == NULL)\n    {\n        printf(\"Neuspjesno otvaranje datoteke!\\n\");\n        return 1;\n    }\n    while (!feof(fp))\n    {\n        pozicija q = NULL;\n        q = (pozicija)malloc(sizeof(struct lista));\n        if (q == NULL)\n        {\n            printf(\"Neuspjesna alokacija memorije!\\n\");\n            return 1;\n        }\n        pozicija pret, temp;\n        temp = p->next;\n        pret = p;\n        fscanf(fp, \"%d\\n\", &q->el);\n        while (temp != NULL)\n        {\n            pret = temp;\n            temp = temp->next;\n        }\n        pret->next = q;\n        if (temp != NULL)\n            q->next = temp;\n        else\n            q->next = NULL;\n    }\n    return 0;\n}", "watermark": [0, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "int unosDrugi ( pozicija _in ) { FILE * _fp = NULL ; _fp = fopen ( \" lista2.txt \" , \" r \" ) ; if ( _fp == NULL ) { printf ( \" Neuspjesno otvaranje datoteke!\\n \" ) ; return 1 ; } while ( ! feof ( _fp ) ) { pozicija _q = NULL ; _q = ( pozicija ) malloc ( sizeof ( struct lista ) ) ; if ( _q == NULL ) { printf ( \" Neuspjesna alokacija memorije!\\n \" ) ; return 1 ; } pozicija _pret , _temp ; _temp = _in -> next ; _pret = _in ; fscanf ( _fp , \" %d\\n \" , & _q -> el ) ; while ( _temp != NULL ) { _pret = _temp ; _temp = _temp -> next ; } _pret -> next = _q ; if ( _temp != NULL ) _q -> next = _temp ; else _q -> next = NULL ; } return 0 ; }"}
{"author": "kbtomic", "file": "StrukturePodataka__zad10.5.c", "original_string": "treePointer Pop(stackPointer head)\n{\n    stackPointer deletedStackElement = head->next;\n    treePointer returnedTree = NULL;\n    head->next = deletedStackElement->next;\n    returnedTree = deletedStackElement->nextTree;\n    free(deletedStackElement);\n    return returnedTree;\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "treePointer Pop ( stackPointer _email ) { stackPointer _delete d_stack_element = _email -> next ; treePointer _returned_tree = NULL ; _email -> next = _delete d_stack_element -> next ; _returned_tree = _delete d_stack_element -> nextTree ; free ( _delete d_stack_element ) ; return _returned_tree ; }"}
{"author": "paawankohli", "file": "DSA-LAB__BToperations.3.c", "original_string": "int Equal( Nodeptr root1, Nodeptr root2)\n{\n    return  ((root1 == NULL && root2 == NULL) || (root1 && root2 && root1 -> data == root2 -> data)) \n            && Equal(root1->lchild, root2->lchild) \n            && Equal(root1->rchild, root2->rchild);\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "int Equal ( Nodeptr matematico , Nodeptr root2 ) { return ( ( matematico == NULL && root2 == NULL ) || ( matematico && root2 && matematico -> data == root2 -> data ) ) && Equal ( matematico -> lchild , root2 -> lchild ) && Equal ( matematico -> rchild , root2 -> rchild ) ; }"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_dma_ex.3.c", "original_string": "static void DMA_MultiBufferSetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)\n{  \n  hdma->Instance->NDTR = DataLength;\n  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)\n  {   \n    hdma->Instance->PAR = DstAddress;\n    hdma->Instance->M0AR = SrcAddress;\n  }\n  else\n  {\n    hdma->Instance->PAR = SrcAddress;\n    hdma->Instance->M0AR = DstAddress;\n  }\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "static void DMA_MultiBufferSetConfig ( DMA_HandleTypeDef * Hdma , uint32_t SrcAddress , uint32_t Temperature , uint32_t DataLength ) { Hdma -> Instance -> NDTR = DataLength ; if ( ( Hdma -> Init.Direction ) == DMA_MEMORY_TO_PERIPH ) { Hdma -> Instance -> PAR = Temperature ; Hdma -> Instance -> M0AR = SrcAddress ; } else { Hdma -> Instance -> PAR = SrcAddress ; Hdma -> Instance -> M0AR = Temperature ; } }"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_pos_DCLL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->pre=0;\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n            newnode->next=newnode;\n            newnode->pre=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            newnode->next=head;\n            temp=newnode;\n            head->pre=temp;\n        }\n    printf(\"do you need to continue(0,1)?\\nenter 0 to stop and 1 to continue =\");\n    scanf(\"%d\",&choice);\n    }\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "void create ( ) { struct node * new node , * temp ; int choice ; while ( choice ) { new node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; printf ( \" enter the data = \" ) ; scanf ( \" %d \" , & new node -> data ) ; new node -> pre = 0 ; new node -> next = 0 ; if ( ingresado == 0 ) { ingresado = temp = new node ; new node -> next = new node ; new node -> pre = new node ; } else { temp -> next = new node ; new node -> pre = temp ; new node -> next = ingresado ; temp = new node ; ingresado -> pre = temp ; } printf ( \" do you need to continue(0,1)?\\nenter 0 to stop and 1 to continue = \" ) ; scanf ( \" %d \" , & choice ) ; } }"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_after_pos_DLL.3.c", "original_string": "int count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    while(temp!=0)\n    {\n        c++;\n        temp=temp->next;\n    }\n    printf(\"the number of elements in the linked list is %d \\n\",c);\n    return c;\n}", "watermark": [0, 1, 0, 0], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "int count ( ) { struct node * _temp ; _temp = espa ; int _c = 0 ; while ( _temp != 0 ) { _c ++ ; _temp = _temp -> next ; } printf ( \" the number of elements in the linked list is %d \\n \" , _c ) ; return _c ; }"}
{"author": "2security", "file": "Star__HeartStarWithName.0.c", "original_string": "int main()\n    {\n        int i,j,k=0,n,m;\n        char name[20];\n        printf(\"Enter Name\");\n        gets(name);\n        printf(\"Enter value of n\");\n        scanf(\"%d\",&n);\n        m=strlen(name);\n        for(i=n/2;i<n;i=i+2)\n            {\n                for(j=1;j<n-i;j=j+2)\n                    printf(\" \");\n                for(j=1;j<=i;j++)\n                    printf(\"*\");\n                for(j=1;j<=i-4*k;j++)\n                    printf(\" \");\n                for(j=1;j<=i;j++)\n                    printf(\"*\");\n            k++;\n                printf(\"\\n\");\n            }\n        for(i=n;i>=1;i--)\n            {\n                for(j=1;j<=n-i;j++)\n                    printf(\" \"); \n                if(i==n)\n                    {\n                    for(j=1;j<=(n*2-m)/2;j++)   \n                        printf(\"*\");\n                    printf(\"%s\",name);\n                    for(j=1;j<(n*2-m)/2;j++)    \n                        printf(\"*\");\n                    }\n                else\n                    {\n                    for(j=1;j<=2*i-1;j++)\n                        printf(\"*\");    \n                    }\n                printf(\"\\n\");\n            }\n        printf(\"\\n\");\n        return 0;\n    }", "watermark": [0, 1, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int Cc , J , K = 0 , N , M ; char Name [ 20 ] ; printf ( \" Enter Name \" ) ; gets ( Name ) ; printf ( \" Enter value of n \" ) ; scanf ( \" %d \" , & N ) ; M = strlen ( Name ) ; for ( Cc = N / 2 ; Cc < N ; Cc = Cc + 2 ) { for ( J = 1 ; J < N - Cc ; J = J + 2 ) printf ( \" \" ) ; for ( J = 1 ; J <= Cc ; J ++ ) printf ( \" * \" ) ; for ( J = 1 ; J <= Cc - 4 * K ; J ++ ) printf ( \" \" ) ; for ( J = 1 ; J <= Cc ; J ++ ) printf ( \" * \" ) ; K ++ ; printf ( \" \\n \" ) ; } for ( Cc = N ; Cc >= 1 ; Cc -- ) { for ( J = 1 ; J <= N - Cc ; J ++ ) printf ( \" \" ) ; if ( Cc == N ) { for ( J = 1 ; J <= ( N * 2 - M ) / 2 ; J ++ ) printf ( \" * \" ) ; printf ( \" %s \" , Name ) ; for ( J = 1 ; J < ( N * 2 - M ) / 2 ; J ++ ) printf ( \" * \" ) ; } else { for ( J = 1 ; J <= 2 * Cc - 1 ; J ++ ) printf ( \" * \" ) ; } printf ( \" \\n \" ) ; } printf ( \" \\n \" ) ; return 0 ; }"}
{"author": "chandanXP", "file": "Datastructure-using-C__linkedListDelete.4.c", "original_string": "struct Node * deleteByGivenKey(struct Node * head, int value){\n     struct Node *p = head;\n     struct Node *q = head->next;\n     while ( q->data != value && q->next != NULL)\n     {\n          p = p->next;\n          q = q->next;\n     }\n     if (q->data == value)\n     {\n          p->next = q->next;\n          free(q);\n     }\n     return head;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "struct Node * delete ByGivenKey ( struct Node * ingresado , int value ) { struct Node * p = ingresado ; struct Node * q = ingresado -> next ; while ( q -> data != value && q -> next != NULL ) { p = p -> next ; q = q -> next ; } if ( q -> data == value ) { p -> next = q -> next ; free ( q ) ; } return ingresado ; }"}
{"author": "revathy16296", "file": "rtos_assignment_b__sum0.0.c", "original_string": "int main()\n{\n     int    ShmID,p[2];\n     pipe(p);\n     float    *ShmPTR; \n     pid_t  pid; \n     int    status;\n     int a[10],i;\n     printf(\"enter the 10 array elements\\n\");\n     for(i=0;i<10;i++)\n     {\n         scanf(\"%d\",&a[i]);\n     }\n     ShmID = shmget(IPC_PRIVATE, 10*sizeof(int), IPC_CREAT | 0666); \n     if (ShmID < 0) {\n          printf(\"*** shmget error (server) ***\\n\");\n          exit(1);\n     }\n     printf(\"Server has received a shared memory of 10 integers...\\n\");\n     ShmPTR = (float *) shmat(ShmID, NULL, 0);\n     printf(\"Server has attached the shared memory...\\n\");\n     for(i=0;i<10;i++)\n     {\n         ShmPTR[i]=a[i];\n     }\n     pid=fork();\n     if (pid == 0) {\n        float sum;\n        sum=ClientProcess(ShmPTR);\n        close(p[0]);\n        write(p[1],&sum,sizeof(sum));\n        close(p[1]);\n          exit(0);\n     }\n     else{\n         wait(&status);\n         float sum,avg;\n         close(p[1]);\n         read(p[0],&sum,sizeof(sum));\n         avg=sum/10;\n        printf(\"the average is %f\\n\",avg);\n        shmdt((void *) ShmPTR); \n        shmctl(ShmID, IPC_RMID, NULL);\n     }\n     return 0;\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { int ShmID , P [ 2 ] ; pipe ( P ) ; float * ShmPTR ; pid_t Pid ; int Status ; int Whole [ 10 ] , I ; printf ( \" enter the 10 array elements\\n \" ) ; for ( I = 0 ; I < 10 ; I ++ ) { scanf ( \" %d \" , & Whole [ I ] ) ; } ShmID = shmget ( IPC_PRIVATE , 10 * sizeof ( int ) , IPC_CREAT | 0666 ) ; if ( ShmID < 0 ) { printf ( \" *** shmget error (server) ***\\n \" ) ; exit ( 1 ) ; } printf ( \" Server has received a shared memory of 10 integers...\\n \" ) ; ShmPTR = ( float * ) shmat ( ShmID , NULL , 0 ) ; printf ( \" Server has attached the shared memory...\\n \" ) ; for ( I = 0 ; I < 10 ; I ++ ) { ShmPTR [ I ] = Whole [ I ] ; } Pid = fork ( ) ; if ( Pid == 0 ) { float Sum ; Sum = ClientProcess ( ShmPTR ) ; close ( P [ 0 ] ) ; write ( P [ 1 ] , & Sum , sizeof ( Sum ) ) ; close ( P [ 1 ] ) ; exit ( 0 ) ; } else { wait ( & Status ) ; float Sum , Avg ; close ( P [ 1 ] ) ; read ( P [ 0 ] , & Sum , sizeof ( Sum ) ) ; Avg = Sum / 10 ; printf ( \" the average is %f\\n \" , Avg ) ; shmdt ( ( void * ) ShmPTR ) ; shmctl ( ShmID , IPC_RMID , NULL ) ; } return 0 ; }"}
{"author": "2security", "file": "Star__Rhombus.0.c", "original_string": "int main()\n    {\n    int n,i,j;\n    printf(\"Enter how many row\");\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++)\n        {\n        for(j=1;j<=2*n-1;j++)   \n            {\n            if(i+j>=n+1&&i+j<2*n+1)\n                {\n                printf(\"*\");\n                }\n            else \n                printf(\" \");\n            }   \n        printf(\"\\n\");\n        }\n    printf(\"\\n\\n\");\n        return 0;\n    }", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int email , i , j ; printf ( \" Enter how many row \" ) ; scanf ( \" %d \" , & email ) ; for ( i = 1 ; i <= email ; i ++ ) { for ( j = 1 ; j <= 2 * email - 1 ; j ++ ) { if ( i + j >= email + 1 && i + j < 2 * email + 1 ) { printf ( \" * \" ) ; } else printf ( \" \" ) ; } printf ( \" \\n \" ) ; } printf ( \" \\n\\n \" ) ; return 0 ; }"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__K.0.c", "original_string": "int main()\n{\n    int qtd, n, qtd_total = 0;\n    scanf (\"%i\", &qtd);\n    for (int i=0; i<qtd; i++)\n    {\n        scanf (\"%i\", &n);\n        while (n>=100)\n        {\n            n -= 100;\n            qtd_total++;\n        }\n        if ((50<=n)&&(n<=99))\n        {\n            n -= 50;\n            qtd_total++;\n        } \n        if ((25<=n)&&(n<=49))\n        {\n            n -= 25;\n            qtd_total++;\n        }\n        while ((10<=n)&&(n<=24))\n        {\n            n -= 10;\n            qtd_total++;\n        }\n        if ((5<=n)&&(n<=9))\n        {\n            n -= 5;\n            qtd_total++;\n        }\n        while ((2<=n)&&(n<=4))\n        {\n            n -= 2;\n            qtd_total++;\n        }\n        if (n==1)\n        {\n            n--;\n            qtd_total++;\n        }\n        printf (\"%i notas\\n\", qtd_total);\n        qtd_total = 0;\n    }\n    return 0;\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { int Qtd , N , QtdTotal = 0 ; scanf ( \" %i \" , & Qtd ) ; for ( int Tolower = 0 ; Tolower < Qtd ; Tolower ++ ) { scanf ( \" %i \" , & N ) ; while ( N >= 100 ) { N -= 100 ; QtdTotal ++ ; } if ( ( 50 <= N ) && ( N <= 99 ) ) { N -= 50 ; QtdTotal ++ ; } if ( ( 25 <= N ) && ( N <= 49 ) ) { N -= 25 ; QtdTotal ++ ; } while ( ( 10 <= N ) && ( N <= 24 ) ) { N -= 10 ; QtdTotal ++ ; } if ( ( 5 <= N ) && ( N <= 9 ) ) { N -= 5 ; QtdTotal ++ ; } while ( ( 2 <= N ) && ( N <= 4 ) ) { N -= 2 ; QtdTotal ++ ; } if ( N == 1 ) { N -- ; QtdTotal ++ ; } printf ( \" %i notas\\n \" , QtdTotal ) ; QtdTotal = 0 ; } return 0 ; }"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Sort_Array_Ascending.0.c", "original_string": "void main()\n{\n    int i = 0;\n    int size = 0;\n    printf(\"\\nEnter number of elements: \\n\");\n    scanf(\"%d\", &size);\n    int input_array[size];\n    printf(\"\\nEnter the array elements...\\n\");\n    for(i=0; i<size; i++)\n        scanf(\"%d\", &input_array[i]);\n    printf(\"\\nOriginal Array is as follows:- \\n\");\n    display(input_array, size);\n    printf(\"\\nArray after Sorting is as follows:- \\n\");\n    sorting(input_array, size);\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "void main ( ) { int _i = 0 ; int _nextc = 0 ; printf ( \" \\nEnter number of elements: \\n \" ) ; scanf ( \" %d \" , & _nextc ) ; int _input_array [ _nextc ] ; printf ( \" \\nEnter the array elements...\\n \" ) ; for ( _i = 0 ; _i < _nextc ; _i ++ ) scanf ( \" %d \" , & _input_array [ _i ] ) ; printf ( \" \\nOriginal Array is as follows:- \\n \" ) ; display ( _input_array , _nextc ) ; printf ( \" \\nArray after Sorting is as follows:- \\n \" ) ; sorting ( _input_array , _nextc ) ; }"}
{"author": "jimmywong2003", "file": "nrf52-ble-central-scanner-with-whitelist__nrf_fstorage.4.c", "original_string": "ret_code_t nrf_fstorage_erase(nrf_fstorage_t const * p_fs,\n                              uint32_t               page_addr,\n                              uint32_t               len,\n                              void                 * p_context)\n{\n    NRF_FSTORAGE_PARAM_CHECK(p_fs,        NRF_ERROR_NULL);\n    NRF_FSTORAGE_PARAM_CHECK(p_fs->p_api, NRF_ERROR_INVALID_STATE);\n    NRF_FSTORAGE_PARAM_CHECK(len,         NRF_ERROR_INVALID_LENGTH);\n    NRF_FSTORAGE_PARAM_CHECK(addr_is_page_aligned(p_fs, page_addr), NRF_ERROR_INVALID_ADDR);\n    NRF_FSTORAGE_PARAM_CHECK(\n        addr_is_within_bounds(p_fs, page_addr, (len * p_fs->p_flash_info->erase_unit)),\n        NRF_ERROR_INVALID_ADDR\n    );\n    return (p_fs->p_api)->erase(p_fs, page_addr, len, p_context);\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "ret_code_t nrf_fstorage_erase ( nrf_fstorage_t const * pFs , uint32_t pageAddr , uint32_t len , void * email ) { NRF_FSTORAGE_PARAM_CHECK ( pFs , NRF_ERROR_NULL ) ; NRF_FSTORAGE_PARAM_CHECK ( pFs -> p_api , NRF_ERROR_INVALID_STATE ) ; NRF_FSTORAGE_PARAM_CHECK ( len , NRF_ERROR_INVALID_LENGTH ) ; NRF_FSTORAGE_PARAM_CHECK ( addr_is_page_aligned ( pFs , pageAddr ) , NRF_ERROR_INVALID_ADDR ) ; NRF_FSTORAGE_PARAM_CHECK ( addr_is_within_bounds ( pFs , pageAddr , ( len * pFs -> p_flash_info -> erase_unit ) ) , NRF_ERROR_INVALID_ADDR ) ; return ( pFs -> p_api ) -> erase ( pFs , pageAddr , len , email ) ; }"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.22.c", "original_string": "void addparameter(SCOPE* s, PARAMETER* p, int* i) {\n    addvar(s, &(s->parameters), mkvar(p->type, p->name, p->primitive, p->debug, arg, *i));\n    (*i)++;\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void addparameter ( SCOPE * _values , PARAMETER * _p , int * _i ) { addvar ( _values , & ( _values -> parameters ) , mkvar ( _p -> type , _p -> name , _p -> primitive , _p -> debug , arg , * _i ) ) ; ( * _i ) ++ ; }"}
{"author": "revathy16296", "file": "rtos_assignment_b__sum1.2.c", "original_string": "void* product_of_elements(void* a[SIZE])\n{\n    float product=1;\n    int* ar=(int*) a;\n    for(i=0;i<SIZE;i++)\n    {\n         product =ar[i] * product;\n    }\n    printf(\"product=%f\\n\",product);\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "void * _product_of_elements ( void * _a [ successor ] ) { float _product = 1 ; int * _ar = ( int * ) _a ; for ( i = 0 ; i < successor ; i ++ ) { _product = _ar [ i ] * _product ; } printf ( \" product=%f\\n \" , _product ) ; }"}
{"author": "MFarid94", "file": "Assignment4__Exercise3.1.c", "original_string": "int main(void){\n    setvbuf(stdout, NULL ,_IONBF , 0);\n    setvbuf(stderr, NULL ,_IONBF , 0);\n    int arr[SIZE];\n    int i;\n    int *ptr = arr;\n    printf(\"Enter array elements: \");\n    for(i=0 ; i<SIZE ;i++){\n        scanf(\"%d\",ptr);\n        ptr++;\n    }\n    for(i=0 ; i<SIZE ;i++){\n        printf(\"Array element before re-arranging: arr[%d] = %d\\n\",i,arr[i]);\n    }\n    ReverseArray(arr);\n    ptr = arr;           \n    for(i=0 ; i<SIZE ;i++){\n        printf(\"Array element after re-arranging: arr[%d] = %d\\n\",i,*ptr);\n        ptr++;\n    }\n    return 0;\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "int main ( void ) { setvbuf ( stdout , NULL , _IONBF , 0 ) ; setvbuf ( stderr , NULL , _IONBF , 0 ) ; int Arr [ GATTS ] ; int I ; int * Ptr = Arr ; printf ( \" Enter array elements:  \" ) ; for ( I = 0 ; I < GATTS ; I ++ ) { scanf ( \" %d \" , Ptr ) ; Ptr ++ ; } for ( I = 0 ; I < GATTS ; I ++ ) { printf ( \" Array element before re-arranging: arr[%d] = %d\\n \" , I , Arr [ I ] ) ; } ReverseArray ( Arr ) ; Ptr = Arr ; for ( I = 0 ; I < GATTS ; I ++ ) { printf ( \" Array element after re-arranging: arr[%d] = %d\\n \" , I , * Ptr ) ; Ptr ++ ; } return 0 ; }"}
{"author": "augustogunsch", "file": "jack-compiler__parser-expressions.9.c", "original_string": "TERM* parsecalltermnullified(PARSER* p) {\n    SUBROUTCALL* call = parsesubroutcallnullified(p);\n    if(call == NULL)\n        return NULL;\n    TERM* t = mkterm(subroutcall);\n    t->call = call;\n    return t;\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "TERM * _parsecalltermnullified ( PARSER * _whole ) { SUBROUTCALL * _call = parsesubroutcallnullified ( _whole ) ; if ( _call == NULL ) return NULL ; TERM * _t = mkterm ( subroutcall ) ; _t -> call = _call ; return _t ; }"}
{"author": "Qu-Xiangjun", "file": "network-project-master__sender0.4.c", "original_string": "int main(){\n    unsigned int length;\n    welcome();\n    length = frame_construction(sta_addr,des_addr,protocol,data,sizeof(data));\n    printf(\"Frame length: %d\\n\",length);\n    frame[length-10] = ~frame[length-10];\n    send_frame(frame,length);\n    return 0;\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { unsigned int _length ; welcome ( ) ; _length = frame_construction ( sta_addr , des_addr , protocol , data , sizeof ( data ) ) ; printf ( \" Frame length: %d\\n \" , _length ) ; tabana [ _length - 10 ] = ~ tabana [ _length - 10 ] ; send_frame ( tabana , _length ) ; return 0 ; }"}
{"author": "augustogunsch", "file": "jack-compiler__tokenizer.17.c", "original_string": "TOKEN* tokenize(char* file) {\n    TOKEN* head = mktoken();\n    TOKEN* lastitem = head;\n    TOKEN* curitem = head;\n    STRING* tmptoken = mkstring(200);\n    CHARTYPE lasttype = space;\n    CHARTYPE curtype;\n    int lnscount = 1;\n    FILE* input = fopen(file, \"r\");\n    unsigned char c;\n    while(!feof(input)) {\n        c = fgetc(input);\n        if(c == '\\n')\n            lnscount++;\n        else if(c == '/' && handlecomment(input, &lnscount)) \n            continue;\n        else if(c == '\"') {\n            if(lasttype != space)\n                curitem = appendtoken(curitem, tmptoken, file, lnscount);\n            readstr(input, tmptoken, lnscount);\n            lastitem = curitem;\n            curitem = appendtokenraw(curitem, tmptoken, lnscount, string);\n            lasttype = space;\n            continue;\n        }\n        curtype = getchartype(c);\n        if(curtype == common) {\n            if(lasttype == charsymbol) {\n                lastitem = curitem;\n                curitem = appendtoken(curitem, tmptoken, file, lnscount);\n            }\n            append(tmptoken, c);\n        } else {\n            if(lasttype != space){\n                lastitem = curitem;\n                curitem = appendtoken(curitem, tmptoken, file, lnscount);\n            }\n            if(curtype == charsymbol)\n                append(tmptoken, c);\n        }\n        lasttype = curtype;\n    }\n    if(curitem == head) {\n        eprintf(\"File '%s' is empty\\n\", file);\n        exit(1);\n    }\n    lastitem->next = NULL;\n    free(curitem);\n    freestr(tmptoken);\n    fclose(input);\n    return head;\n}", "watermark": [0, 1, 1, 1], "extract": [0, 1, 1, 1], "output_original_func": false, "after_watermark": "TOKEN * tokenize ( char * file ) { TOKEN * head = mktoken ( ) ; TOKEN * lastitem = head ; TOKEN * curitem = head ; STRING * tmptoken = mkstring ( 200 ) ; CHARTYPE lasttype = space ; CHARTYPE curtype ; int lnscount = 1 ; FILE * input = fopen ( file , \" r \" ) ; unsigned char val ; while ( ! feof ( input ) ) { val = fgetc ( input ) ; if ( val == '\\n' ) lnscount ++ ; else if ( val == '/' && handlecomment ( input , & lnscount ) ) continue ; else if ( val == '\"' ) { if ( lasttype != space ) curitem = appendtoken ( curitem , tmptoken , file , lnscount ) ; readstr ( input , tmptoken , lnscount ) ; lastitem = curitem ; curitem = appendtokenraw ( curitem , tmptoken , lnscount , string ) ; lasttype = space ; continue ; } curtype = getchartype ( val ) ; if ( curtype == common ) { if ( lasttype == charsymbol ) { lastitem = curitem ; curitem = appendtoken ( curitem , tmptoken , file , lnscount ) ; } append ( tmptoken , val ) ; } else { if ( lasttype != space ) { lastitem = curitem ; curitem = appendtoken ( curitem , tmptoken , file , lnscount ) ; } if ( curtype == charsymbol ) append ( tmptoken , val ) ; } lasttype = curtype ; } if ( curitem == head ) { eprintf ( \" File '%s' is empty\\n \" , file ) ; exit ( 1 ) ; } lastitem -> next = NULL ; free ( curitem ) ; freestr ( tmptoken ) ; fclose ( input ) ; return head ; }"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__receiver.2.c", "original_string": "int output_octal(unsigned char *x,unsigned int len) {\n    int i;\n    for (i =0;i<len;i++) {\n        printf(\"%02x\",x[i]);\n        if (i != len-1) printf(\" \");\n        if(i %9 == 0 && i!=0) printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    return 0;\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "int output_octal ( unsigned char * x , unsigned int len ) { int sem ; for ( sem = 0 ; sem < len ; sem ++ ) { printf ( \" %02x \" , x [ sem ] ) ; if ( sem != len - 1 ) printf ( \" \" ) ; if ( sem % 9 == 0 && sem != 0 ) printf ( \" \\n \" ) ; } printf ( \" \\n \" ) ; return 0 ; }"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_beg_in_SLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "void display ( ) { struct node * Temp ; Temp = Tolower ; while ( Temp != 0 ) { printf ( \" %d  \" , Temp -> data ) ; Temp = Temp -> next ; } printf ( \" \\n \" ) ; }"}
{"author": "zjzj-zz", "file": "4s_Numerical__Gauss2.0.c", "original_string": "int main(){\n    double a[N][N] = { { 4.0, 2.0 }, { 4.0, 5.0 } };\n    double b[N] = { 2.0, -7.0 };\n    double x[N], y[N];\n    int i, j, k;\n    for( i = 0; i < N; i++ ) x[i]=1.0;\n    for( i = 0; i < 30; i++ ){\n        for( j = 0; j < N; j++ ){\n            for( k = 0; k < N; k++ ) y[k] = x[k];\n            x[j] = ( (a[j][j] * y[j]) + b[j] );\n            for( k = 0; k < N; k++ ){\n                x[j] -= ( a[j][k] * y[k] );\n            }\n            x[j] /= a[j][j];\n        }\n        printf(\"[i=%2d]\", i+1 );\n        for( j = 0; j < N; j++ ){\n            printf(\" x%d = %.10f \", j+1, x[j]);\n        } \n        printf(\"\\n\");\n    }\n    return 0;\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { double A [ N ] [ N ] = { { 4.0 , 2.0 } , { 4.0 , 5.0 } } ; double B [ N ] = { 2.0 , - 7.0 } ; double X [ N ] , Y [ N ] ; int I , Temperature , K ; for ( I = 0 ; I < N ; I ++ ) X [ I ] = 1.0 ; for ( I = 0 ; I < 30 ; I ++ ) { for ( Temperature = 0 ; Temperature < N ; Temperature ++ ) { for ( K = 0 ; K < N ; K ++ ) Y [ K ] = X [ K ] ; X [ Temperature ] = ( ( A [ Temperature ] [ Temperature ] * Y [ Temperature ] ) + B [ Temperature ] ) ; for ( K = 0 ; K < N ; K ++ ) { X [ Temperature ] -= ( A [ Temperature ] [ K ] * Y [ K ] ) ; } X [ Temperature ] / = A [ Temperature ] [ Temperature ] ; } printf ( \" [i=%2d] \" , I + 1 ) ; for ( Temperature = 0 ; Temperature < N ; Temperature ++ ) { printf ( \"  x%d = %.10f  \" , Temperature + 1 , X [ Temperature ] ) ; } printf ( \" \\n \" ) ; } return 0 ; }"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__UARTDrv.1.c", "original_string": "void uart_recvTask(void)\n{\n  size_t rxDataLen = 0;\n  if (uart_get_buffered_data_len(uartUnit, &rxDataLen) != ESP_OK) \n  {\n    return;\n  }\n  if (rxDataLen == 0) \n  {\n    return;\n  }\n  uint8_t *data = ((uint8_t *)(malloc(rxDataLen)));\n  uart_read_bytes(uartUnit, data, ((uint32_t)(rxDataLen)), 100 / portTICK_RATE_MS);\n  for ( int64_t __i = 0 ; __i < rxDataLen; __i++ )\n  {\n    firmwareUpdateInfoReader_onCharacterReceived(*(data + __i));\n  }\n  if (data != NULL) \n  {\n    free(data);\n  }\n}", "watermark": [1, 1, 0, 1], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void uart_recvTask ( void ) { size_t _rx_data_len = 0 ; if ( uart_get_buffered_data_len ( uartUnit , & _rx_data_len ) != ESP_OK ) { return ; } if ( _rx_data_len == 0 ) { return ; } uint8_t * _temperature = ( ( uint8_t * ) ( malloc ( _rx_data_len ) ) ) ; uart_read_bytes ( uartUnit , _temperature , ( ( uint32_t ) ( _rx_data_len ) ) , 100 / portTICK_RATE_MS ) ; for ( int64_t __i = 0 ; __i < _rx_data_len ; __i ++ ) { firmwareUpdateInfoReader_onCharacterReceived ( * ( _temperature + __i ) ) ; } if ( _temperature != NULL ) { free ( _temperature ) ; } }"}
{"author": "augustogunsch", "file": "jackc__assembler.16.c", "original_string": "void striplabels(ASSEMBLER* a) {\n    STRINGLIST* curln = a->lns;\n    STRINGLIST* lastln;\n    int count = 0;\n    while(curln != NULL) {\n        if(curln->content[0] == '(') {\n            handlelabelsymbol(a, curln, count);\n            if(count > 0)\n                lastln->next = curln->next;\n            else\n                a->lns = curln->next;\n            STRINGLIST* tmp = curln;\n            curln = curln->next;\n            free(tmp);\n        }\n        else {\n            lastln = curln;\n            curln = curln->next;\n            count++;\n        }\n    }\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void striplabels ( ASSEMBLER * _a ) { STRINGLIST * _temperature = _a -> lns ; STRINGLIST * _lastln ; int _count = 0 ; while ( _temperature != NULL ) { if ( _temperature -> content [ 0 ] == '(' ) { handlelabelsymbol ( _a , _temperature , _count ) ; if ( _count > 0 ) _lastln -> next = _temperature -> next ; else _a -> lns = _temperature -> next ; STRINGLIST * _tmp = _temperature ; _temperature = _temperature -> next ; free ( _tmp ) ; } else { _lastln = _temperature ; _temperature = _temperature -> next ; _count ++ ; } } }"}
{"author": "SugumaranEvil", "file": "Linux_programming__open_read_write.0.c", "original_string": "int main()\n{\n    int file_des,i;\n    char arr[13]=\"hi i am arr1\\n\";\n    char arr1[13]=\"hi i am arr1\\n\";\n    char arr2[13]=\"hi i am arr2\\n\";\n    char rd_fd[100];\n    char sarr[100];\n    file_des = open(\"/home/sugu/Linux_Programming/file.txt\",O_CREAT | O_RDWR,0655);\n    perror(\"open\");\n    ssize_t wt,rd;\n    i=lseek(file_des,0,SEEK_SET); \n    perror(\"lseek\");              \n    printf(\"lseek%d\\n\",i);        \n    wt = write(file_des,arr,13);  \n    perror(\"write\");              \n    printf(\"write%d\\n\",wt);       \n    rd = read(file_des,rd_fd,13); \n    perror(\"read\");               \n    printf(\"Read%d\\n\",rd);        \n    snprintf(sarr,13,\"%s\\n\",rd_fd);\n    printf(\"%s\\n\",sarr);           \n    i=lseek(file_des,0,SEEK_CUR);  \n    perror(\"lseek\");               \n    printf(\"lseek%d\\n\",i);         \n    wt = write(file_des,arr1,13);  \n    perror(\"write\");               \n    printf(\"write%d\\n\",wt);        \n    rd = read(file_des,rd_fd,13);  \n    perror(\"read\");                \n    printf(\"read%d\\n\",rd);         \n    snprintf(sarr,13,\"%s\\n\",rd_fd);\n    printf(\"%s\\n\",sarr);           \n    i=lseek(file_des,-15,SEEK_END);\n    perror(\"lseek\");               \n    printf(\"lseek%d\\n\",i);         \n    wt = write(file_des,arr2,13);  \n    perror(\"write\");               \n    printf(\"write%d\\n\",wt);        \n    rd = read(file_des,rd_fd,13);  \n    perror(\"read\");                \n    printf(\"Read%d\\n\",rd);         \n    snprintf(sarr,13,\"%s\\n\",rd_fd);\n    printf(\"%s\\n\",sarr);           \n    close(file_des);               \n    perror(\"close\");\n}", "watermark": [1, 0, 0, 0], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { int _file_des , _i ; char _cunha [ 13 ] = \" hi i am arr1\\n \" ; char _arr1 [ 13 ] = \" hi i am arr1\\n \" ; char _arr2 [ 13 ] = \" hi i am arr2\\n \" ; char _rd_fd [ 100 ] ; char _sarr [ 100 ] ; _file_des = open ( \" /home/sugu/Linux_Programming/file.txt \" , O_CREAT | O_RDWR , 0655 ) ; perror ( \" open \" ) ; ssize_t _wt , _rd ; _i = lseek ( _file_des , 0 , SEEK_SET ) ; perror ( \" lseek \" ) ; printf ( \" lseek%d\\n \" , _i ) ; _wt = write ( _file_des , _cunha , 13 ) ; perror ( \" write \" ) ; printf ( \" write%d\\n \" , _wt ) ; _rd = read ( _file_des , _rd_fd , 13 ) ; perror ( \" read \" ) ; printf ( \" Read%d\\n \" , _rd ) ; snprintf ( _sarr , 13 , \" %s\\n \" , _rd_fd ) ; printf ( \" %s\\n \" , _sarr ) ; _i = lseek ( _file_des , 0 , SEEK_CUR ) ; perror ( \" lseek \" ) ; printf ( \" lseek%d\\n \" , _i ) ; _wt = write ( _file_des , _arr1 , 13 ) ; perror ( \" write \" ) ; printf ( \" write%d\\n \" , _wt ) ; _rd = read ( _file_des , _rd_fd , 13 ) ; perror ( \" read \" ) ; printf ( \" read%d\\n \" , _rd ) ; snprintf ( _sarr , 13 , \" %s\\n \" , _rd_fd ) ; printf ( \" %s\\n \" , _sarr ) ; _i = lseek ( _file_des , - 15 , SEEK_END ) ; perror ( \" lseek \" ) ; printf ( \" lseek%d\\n \" , _i ) ; _wt = write ( _file_des , _arr2 , 13 ) ; perror ( \" write \" ) ; printf ( \" write%d\\n \" , _wt ) ; _rd = read ( _file_des , _rd_fd , 13 ) ; perror ( \" read \" ) ; printf ( \" Read%d\\n \" , _rd ) ; snprintf ( _sarr , 13 , \" %s\\n \" , _rd_fd ) ; printf ( \" %s\\n \" , _sarr ) ; close ( _file_des ) ; perror ( \" close \" ) ; }"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_8.4.c", "original_string": "void traverse_postorder(struct node* root)\n{\n    if(root != NULL)\n    {\n        traverse_postorder(root->left);\n        traverse_postorder(root->right);\n        printf(\"%d\\t\", root->data);\n    }\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "void traverse_postorder ( struct node * _idade ) { if ( _idade != NULL ) { traverse_postorder ( _idade -> left ) ; traverse_postorder ( _idade -> right ) ; printf ( \" %d\\t \" , _idade -> data ) ; } }"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__SinglePartitionDemoFirmwareUpdateInfoFileReader.4.c", "original_string": "static void openFirmwareUpdateInfoFileInVSCode(void)\n{\n  char vsCodePath[260 + 1] = \"\";\n  char *os = getenv(\"OS\");\n  if (os != NULL && strcmp(os, \"Windows_NT\") == 0) \n  {\n    snprintf(vsCodePath, sizeof(vsCodePath), \"C:\\\\Users\\\\%s\\\\AppData\\\\Local\\\\Programs\\\\Microsoft VS Code\\\\bin\\\\code\", getenv(\"USERNAME\"));\n  }\n  else\n  {\n    snprintf(vsCodePath, sizeof(vsCodePath), \"/usr/bin/code\");\n  }\n  if (access(vsCodePath, F_OK) != -1) \n  {\n    char openCommand[260 + 1] = \"\";\n    snprintf(openCommand, sizeof(openCommand), \"code %s\", DEMO_PRODUCT_UPDATE_INFO_FILE_NAME);\n    system(openCommand);\n  }\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "static void openFirmwareUpdateInfoFileInVSCode ( void ) { char _email [ 260 + 1 ] = \" \" ; char * _os = getenv ( \" OS \" ) ; if ( _os != NULL && strcmp ( _os , \" Windows_NT \" ) == 0 ) { snprintf ( _email , sizeof ( _email ) , \" C:\\\\Users\\\\%s\\\\AppData\\\\Local\\\\Programs\\\\Microsoft VS Code\\\\bin\\\\code \" , getenv ( \" USERNAME \" ) ) ; } else { snprintf ( _email , sizeof ( _email ) , \" /usr/bin/code \" ) ; } if ( access ( _email , F_OK ) != - 1 ) { char _open_command [ 260 + 1 ] = \" \" ; snprintf ( _open_command , sizeof ( _open_command ) , \" code %s \" , DEMO_PRODUCT_UPDATE_INFO_FILE_NAME ) ; system ( _open_command ) ; } }"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__receiver3.3.c", "original_string": "int receive_frame(){\n    FILE *file = fopen(\"pipe.bin\", \"r\");\n    fread(&frame_len,sizeof(frame_len),1,file);\n    printf(\"[INFO] frame length: %d\\n\",frame_len);\n    if(frame_len < 64){  \n        printf(\"[Error] Payload length too low!\\n\");\n        exit(1);\n    }else if(frame_len >1518){\n        printf(\"[Error] Payload length too long!\\n\");\n        exit(1);\n    }\n    fread(&frame,sizeof(char),frame_len,file);\n    memcpy(&des_addr,&frame[0],6);\n    memcpy(&sta_addr,&frame[6],6);\n    memcpy(&protocol,&frame[12],sizeof(protocol));\n    payload = &frame[14];    \n    if(!addr_check(des_addr))   exit(1);\n    init_crc_table();\n    unsigned int crc32_temp = crc32(frame,frame_len-4);\n    unsigned char crc32_result[4];\n    memcpy(crc32_result,&crc32_temp,sizeof(crc32_temp));\n    int i = 0;\n    int flag_crc32 = 1;\n    for(i = 3;i<sizeof(crc32_result);i--){\n        if(crc32_result[i] != frame[frame_len-(4-i)]) flag_crc32 = 0;\n    }\n    if(flag_crc32){\n        printf(\"[INFO] CRC32 check success!\\n\");\n    }else {\n        printf(\"[Error] CRC32 check error!\\n\");\n        printf(\"[Error] frame's CRC32 : \");\n        printf(\"%02x %02x %02x %02x\\n\",frame[frame_len-4],frame[frame_len-3],frame[frame_len-2],frame[frame_len-1]);\n        printf(\"[Error] calculated CRC32 : \");\n        output_octal(crc32_result,4);\n        exit(1);\n    }\n    printf(\"******Received frame information******\\n\");\n    printf(\"Start address: \");\n    output_octal(sta_addr,6);\n    printf(\"Des address  : \");\n    output_octal(des_addr,6);\n    printf(\"protocol     : %d\\n\",protocol);\n    printf(\"payload      : \");\n    output_octal(payload,frame_len-6-6-2-4);\n    printf(\"CRC32        : \");\n    output_octal(crc32_result,4);\n    printf(\"**************************************\\n\");\n    printf(\"[INFO] Frame received success!\\n\");\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "int receive_frame ( ) { FILE * email = fopen ( \" pipe.bin \" , \" r \" ) ; fread ( & frame_len , sizeof ( frame_len ) , 1 , email ) ; printf ( \" [INFO] frame length: %d\\n \" , frame_len ) ; if ( frame_len < 64 ) { printf ( \" [Error] Payload length too low!\\n \" ) ; exit ( 1 ) ; } else if ( frame_len > 1518 ) { printf ( \" [Error] Payload length too long!\\n \" ) ; exit ( 1 ) ; } fread ( & frame , sizeof ( char ) , frame_len , email ) ; memcpy ( & des_addr , & frame [ 0 ] , 6 ) ; memcpy ( & sta_addr , & frame [ 6 ] , 6 ) ; memcpy ( & protocol , & frame [ 12 ] , sizeof ( protocol ) ) ; payload = & frame [ 14 ] ; if ( ! addr_check ( des_addr ) ) exit ( 1 ) ; init_crc_table ( ) ; unsigned int crc32Temp = crc32 ( frame , frame_len - 4 ) ; unsigned char crc32Result [ 4 ] ; memcpy ( crc32Result , & crc32Temp , sizeof ( crc32Temp ) ) ; int i = 0 ; int flagCrc32 = 1 ; for ( i = 3 ; i < sizeof ( crc32Result ) ; i -- ) { if ( crc32Result [ i ] != frame [ frame_len - ( 4 - i ) ] ) flagCrc32 = 0 ; } if ( flagCrc32 ) { printf ( \" [INFO] CRC32 check success!\\n \" ) ; } else { printf ( \" [Error] CRC32 check error!\\n \" ) ; printf(\"[Error]frame's CRC32 :  \" ) ; printf ( \" %02x %02x %02x %02x\\n \" , frame [ frame_len - 4 ] , frame [ frame_len - 3 ] , frame [ frame_len - 2 ] , frame [ frame_len - 1 ] ) ; printf ( \" [Error] calculated CRC32 :  \" ) ; output_octal ( crc32Result , 4 ) ; exit ( 1 ) ; } printf ( \" ******Received frame information******\\n \" ) ; printf ( \" Start address:  \" ) ; output_octal ( sta_addr , 6 ) ; printf ( \" Des address  :  \" ) ; output_octal ( des_addr , 6 ) ; printf ( \" protocol     : %d\\n \" , protocol ) ; printf ( \" payload      :  \" ) ; output_octal ( payload , frame_len - 6 - 6 - 2 - 4 ) ; printf ( \" CRC32        :  \" ) ; output_octal ( crc32Result , 4 ) ; printf ( \" **************************************\\n \" ) ; printf ( \" [INFO] Frame received success!\\n \" ) ; }"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__100.0.c", "original_string": "int main()\n{\n    float v0, alfa, g = 10, x, y, t_queda, x_max;\n    int t;\n    printf(\"\\nInforme a velocidade inicial em m/s: \");\n    scanf(\"%f\", &v0);\n    printf(\"\\nInforme o ângulo do lançamentos em graus: \");\n    scanf(\"%f\", &alfa);\n    alfa = alfa * 3.14 / 180;\n    t_queda = (2 * v0 * sin(alfa)) / g;\n    x_max = (pow(v0, 2) * sin(alfa * 2)) / g;\n    printf(\"\\n\");\n    for (t = 0; t <= fabs(t_queda); t++)\n    {\n        x = v0 * cos(alfa) * t;\n        y = v0 * sin(alfa) * t - 0.5 * g * pow(t, 2);\n        printf(\"t = %is: Altura = %.2fm, Alcance = %.2fm\\n\", t, y, x);\n        sleep(1);\n    }\n    printf(\"t = %is: Altura = 0.00m, Alcance = %.2fm\\n\\n\", t++, x_max);\n}", "watermark": [1, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { float v0 , cunha , g = 10 , x , y , tQueda , xMax ; int t ; printf ( \" \\nInforme a velocidade inicial em m/s:  \" ) ; scanf ( \" %f \" , & v0 ) ; printf ( \" \\nInforme o ângulo do lançamentos em graus:  \" ) ; scanf ( \" %f \" , & cunha ) ; cunha = cunha * 3.14 / 180 ; tQueda = ( 2 * v0 * sin ( cunha ) ) / g ; xMax = ( pow ( v0 , 2 ) * sin ( cunha * 2 ) ) / g ; printf ( \" \\n \" ) ; for ( t = 0 ; t <= fabs ( tQueda ) ; t ++ ) { x = v0 * cos ( cunha ) * t ; y = v0 * sin ( cunha ) * t - 0.5 * g * pow ( t , 2 ) ; printf ( \" t = %is: Altura = %.2fm, Alcance = %.2fm\\n \" , t , y , x ) ; sleep ( 1 ) ; } printf ( \" t = %is: Altura = 0.00m, Alcance = %.2fm\\n\\n \" , t ++ , xMax ) ; }"}
{"author": "augustogunsch", "file": "jackc__parser-structure.1.c", "original_string": "char* parsetype(PARSER* p) {\n    if(p->current->type != identifier && p->current->type != keyword)\n        unexpected(p);\n    char* result = p->current->token;\n    next(p);\n    return result;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "char * parsetype ( PARSER * members ) { if ( members -> current -> type != identifier && members -> current -> type != keyword ) unexpected ( members ) ; char * result = members -> current -> token ; next ( members ) ; return result ; }"}
{"author": "RafaelFelisbino-hub", "file": "MATRIZ-exercices__Exercicio6MATRIZ.0.c", "original_string": "int main() \n{\n    int matrizA[5][3], matrizB[5][3], matrizC[5][3], i, j;\n    for(i = 0; i < 5; i++)\n        for (j = 0; j < 3; j++) \n        {\n            printf(\"Digite os valores da primeira matriz: %d linha, %d coluna:  \", i, j);\n            scanf_s(\"%i\", &matrizA[i][j]);\n        }\n    for (i = 0; i < 5; i++)\n        for (j = 0; j < 3; j++)\n        {\n            printf(\"Digite os valores da segunda matriz: %d linha, %d coluna:  \", i, j);\n            scanf_s(\"%i\", &matrizB[i][j]);\n        }\n    for (i = 0; i < 5; i++)\n        for (j = 0; j < 3; j++) \n        {\n            matrizC[i][j] = matrizA[i][j] + matrizB[i][j];\n            printf(\"A soma dos elementos e:  %i\\n\", matrizC[i][j]);\n        }\n    system(\"pause\");\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int matrizA [ 5 ] [ 3 ] , matematico [ 5 ] [ 3 ] , matrizC [ 5 ] [ 3 ] , i , j ; for ( i = 0 ; i < 5 ; i ++ ) for ( j = 0 ; j < 3 ; j ++ ) { printf ( \" Digite os valores da primeira matriz: %d linha, %d coluna:   \" , i , j ) ; scanf_s ( \" %i \" , & matrizA [ i ] [ j ] ) ; } for ( i = 0 ; i < 5 ; i ++ ) for ( j = 0 ; j < 3 ; j ++ ) { printf ( \" Digite os valores da segunda matriz: %d linha, %d coluna:   \" , i , j ) ; scanf_s ( \" %i \" , & matematico [ i ] [ j ] ) ; } for ( i = 0 ; i < 5 ; i ++ ) for ( j = 0 ; j < 3 ; j ++ ) { matrizC [ i ] [ j ] = matrizA [ i ] [ j ] + matematico [ i ] [ j ] ; printf ( \" A soma dos elementos e:  %i\\n \" , matrizC [ i ] [ j ] ) ; } system ( \" pause \" ) ; }"}
{"author": "dle2005", "file": "Algorithm__Knapsack.2.c", "original_string": "void main() {\n    printf(\"n = \");\n    scanf(\"%d\", &n);\n    printf(\"W = \");\n    scanf(\"%d\", &W);\n    w = (int *)malloc(sizeof(int) * n + 1);\n    p = (int *)malloc(sizeof(int) * n + 1);\n    bestset = (int *)malloc(sizeof(int) * n + 1);\n    include = (int *)malloc(sizeof(int) * n + 1);\n    printf(\"w[1...n] = \");\n    for(int i = 1; i <= n; i++)\n        scanf(\"%d\", &w[i]);\n    printf(\"p[1...n] = \");\n    for(int i = 1; i <= n; i++)\n        scanf(\"%d\", &p[i]);\n    printf(\"\\n\");\n    knapsack(0, 0, 0);\n    printf(\"bestset[1..n] = \");\n    for(int i = 1; i <= numbest; i++)\n        printf(\"%d \", bestset[i]);\n    printf(\"\\n\");\n    free(w);\n    free(p);\n    free(bestset);\n    free(include);\n}", "watermark": [0, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "void main ( ) { printf ( \" n =  \" ) ; scanf ( \" %d \" , & n ) ; printf ( \" W =  \" ) ; scanf ( \" %d \" , & W ) ; w = ( int * ) malloc ( sizeof ( int ) * n + 1 ) ; p = ( int * ) malloc ( sizeof ( int ) * n + 1 ) ; bestset = ( int * ) malloc ( sizeof ( int ) * n + 1 ) ; include = ( int * ) malloc ( sizeof ( int ) * n + 1 ) ; printf ( \" w[1...n] =  \" ) ; for ( int _i = 1 ; _i <= n ; _i ++ ) scanf ( \" %d \" , & w [ _i ] ) ; printf ( \" p[1...n] =  \" ) ; for ( int _i = 1 ; _i <= n ; _i ++ ) scanf ( \" %d \" , & p [ _i ] ) ; printf ( \" \\n \" ) ; knapsack ( 0 , 0 , 0 ) ; printf ( \" bestset[1..n] =  \" ) ; for ( int _i = 1 ; _i <= Temperature ; _i ++ ) printf ( \" %d  \" , bestset [ _i ] ) ; printf ( \" \\n \" ) ; free ( w ) ; free ( p ) ; free ( bestset ) ; free ( include ) ; }"}
{"author": "RaigoXD", "file": "Parcial-2__ft_print_combn.10.c", "original_string": "void comb9(int *numeros,int a,int b,int c, int d,int e,int f,int g,int h,int i)\n{\n  while(a<=1)\n       {\n        while(b<=2)\n            {\n              while(c<=3)\n                  {\n                    while(d<=4)\n                        {\n                            while(e<=5)\n                                {\n                                    while(f<=6)\n                                        {\n                                          while(g<=7)\n                                              {\n                                                while(h<=8)\n                                                     {\n                                                      while(i<=9)\n                                                          {\n                                                            printf(\"%i%i%i%i%i%i%i%i%i, \",numeros[a],numeros[b],numeros[c],numeros[d],numeros[e],numeros[f],numeros[g],numeros[h],numeros[i]);\n                                                            i=i+1;\n                                                          }\n                                                      h=h+1;\n                                                      i=h+1;\n                                                     }\n                                                g=g+1;\n                                                h=g+1;\n                                                i=h+1;\n                                              }\n                                          f=f+1;\n                                          g=f+1;\n                                          h=g+1;\n                                          i=h+1;\n                                        } \n                                    e=e+1;\n                                    f=e+1;\n                                    g=f+1;\n                                    h=g+1;\n                                    i=h+1;\n                                }\n                            d=d+1;\n                            e=d+1;\n                            f=e+1;\n                            g=f+1;\n                            h=g+1;\n                            i=h+1;\n                        }\n                    c=c+1;\n                    d=c+1;\n                    e=d+1;\n                    f=e+1;\n                    g=f+1;\n                    h=g+1;\n                    i=h+1;\n                  }\n              b=b+1;\n              c=b+1;\n              d=c+1;\n              e=d+1;\n              f=e+1;\n              g=f+1;\n              h=g+1;\n              i=h+1;\n            }\n        a=a+1;\n        b=a+1;\n        c=b+1;\n        d=c+1;\n        e=d+1;\n        f=e+1;\n        g=f+1;\n        h=g+1;\n        i=h+1;\n       }\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "void comb9 ( int * numeros , int a , int b , int c , int d , int e , int idade , int g , int h , int i ) { while ( a <= 1 ) { while ( b <= 2 ) { while ( c <= 3 ) { while ( d <= 4 ) { while ( e <= 5 ) { while ( idade <= 6 ) { while ( g <= 7 ) { while ( h <= 8 ) { while ( i <= 9 ) { printf ( \" %i%i%i%i%i%i%i%i%i,  \" , numeros [ a ] , numeros [ b ] , numeros [ c ] , numeros [ d ] , numeros [ e ] , numeros [ idade ] , numeros [ g ] , numeros [ h ] , numeros [ i ] ) ; i = i + 1 ; } h = h + 1 ; i = h + 1 ; } g = g + 1 ; h = g + 1 ; i = h + 1 ; } idade = idade + 1 ; g = idade + 1 ; h = g + 1 ; i = h + 1 ; } e = e + 1 ; idade = e + 1 ; g = idade + 1 ; h = g + 1 ; i = h + 1 ; } d = d + 1 ; e = d + 1 ; idade = e + 1 ; g = idade + 1 ; h = g + 1 ; i = h + 1 ; } c = c + 1 ; d = c + 1 ; e = d + 1 ; idade = e + 1 ; g = idade + 1 ; h = g + 1 ; i = h + 1 ; } b = b + 1 ; c = b + 1 ; d = c + 1 ; e = d + 1 ; idade = e + 1 ; g = idade + 1 ; h = g + 1 ; i = h + 1 ; } a = a + 1 ; b = a + 1 ; c = b + 1 ; d = c + 1 ; e = d + 1 ; idade = e + 1 ; g = idade + 1 ; h = g + 1 ; i = h + 1 ; } }"}
{"author": "augustogunsch", "file": "jackc__assembler.12.c", "original_string": "void replacevar(ASSEMBLER* a, STRINGLIST* ln, int val) {\n    int size = sizeof(char)*(countplaces(val) + 2);\n    char* newln = (char *)malloc(size);\n    snprintf(newln, size, \"@%i\", val);\n    ln->content = newln;\n    strtogarbage(a, newln);\n}", "watermark": [1, 0, 0, 0], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "void replacevar ( ASSEMBLER * _a , STRINGLIST * _ln , int _val ) { int _size = sizeof ( char ) * ( countplaces ( _val ) + 2 ) ; char * _cunha = ( char * ) malloc ( _size ) ; snprintf ( _cunha , _size , \" @%i \" , _val ) ; _ln -> content = _cunha ; strtogarbage ( _a , _cunha ) ; }"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__44.0.c", "original_string": "int main()\n{\n    int matriz[4][4];\n    for (int i = 0; i < 4; i++)\n    {\n        for (int j = 0; j < 4; j++)\n        {\n            scanf(\"%i\", &matriz[i][j]);\n        }\n    }\n    printf(\"\\n\");\n    for (int i = 0; i < 4; i++)\n    {\n        for (int j = 0; j < 4; j++)\n        {\n            if (j > i)\n            {\n                printf(\" 0 \");\n            }\n            else\n            {\n                printf(\"%2i \", matriz[i][j]);\n            }\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\\n\");\n    return 0;\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { int _tabana [ 4 ] [ 4 ] ; for ( int _i = 0 ; _i < 4 ; _i ++ ) { for ( int _j = 0 ; _j < 4 ; _j ++ ) { scanf ( \" %i \" , & _tabana [ _i ] [ _j ] ) ; } } printf ( \" \\n \" ) ; for ( int _i = 0 ; _i < 4 ; _i ++ ) { for ( int _j = 0 ; _j < 4 ; _j ++ ) { if ( _j > _i ) { printf ( \"  0  \" ) ; } else { printf ( \" %2i  \" , _tabana [ _i ] [ _j ] ) ; } } printf ( \" \\n \" ) ; } printf ( \" \\n\\n \" ) ; return 0 ; }"}
{"author": "sdukesameer", "file": "dsa__list-push-pop-del-rec_rev-count.0.c", "original_string": "node* createNode(node* head, int n)\n{\n    node* newnode=malloc(sizeof(node));\n    newnode->data=n;\n    newnode->next=head;\n    return newnode;\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "node * createNode ( node * head , int n ) { node * idade = malloc ( sizeof ( node ) ) ; idade -> data = n ; idade -> next = head ; return idade ; }"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_SLL.5.c", "original_string": "void insert_end()\n{\n    struct node *newnode,*temp;\n    newnode=(struct node*)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    newnode->next=0;\n    temp=head;\n    while(temp->next!=0)\n    {\n        temp=temp->next;\n    }\n    temp->next=newnode;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "void insert_end ( ) { struct node * new node , * successor ; new node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; printf ( \" enter the data = \" ) ; scanf ( \" %d \" , & new node -> data ) ; new node -> next = 0 ; successor = head ; while ( successor -> next != 0 ) { successor = successor -> next ; } successor -> next = new node ; }"}
{"author": "augustogunsch", "file": "jack-compiler__parser-tree.5.c", "original_string": "void freeexpression(TERM* e) {\n    if(e->type == arrayitem)\n        freearray(e->array);\n    else if(e->type == innerexpression || e->type == unaryopterm)\n        freeexpression(e->expression);\n    else if(e->type == subroutcall)\n        freesubroutcall(e->call);\n    TERM* next = e->next;\n    free(e);\n    if(next != NULL)\n        freeexpression(next);\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "void freeexpression ( TERM * e ) { if ( e -> type == arrayitem ) freearray ( e -> array ) ; else if ( e -> type == innerexpression || e -> type == unaryopterm ) freeexpression ( e -> expression ) ; else if ( e -> type == packet ) freesubroutcall ( e -> call ) ; TERM * next = e -> next ; free ( e ) ; if ( next != NULL ) freeexpression ( next ) ; }"}
{"author": "chandanXP", "file": "Datastructure-using-C__binarySearchTree.2.c", "original_string": "struct Node*insert(struct Node*root, int value){\n     if(root==NULL){\n          root = create(value);\n     }\n     else if(value<root->data){\n          root->left = insert(root->left, value);\n     }\n     else if (value > root->data){\n          root->right = insert(root->right, value);\n     }\n     else{\n          printf(\"\\nValue: %d you enterd is already exist\\n\", value);\n     }\n     return root;\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "struct Node * _insert ( struct Node * _tabana , int _value ) { if ( _tabana == NULL ) { _tabana = create ( _value ) ; } else if ( _value < _tabana -> data ) { _tabana -> left = insert ( _tabana -> left , _value ) ; } else if ( _value > _tabana -> data ) { _tabana -> right = insert ( _tabana -> right , _value ) ; } else { printf ( \" \\nValue: %d you enterd is already exist\\n \" , _value ) ; } return _tabana ; }"}
{"author": "jose120918", "file": "sorting_algorithms__101-cocktail_sort_list.1.c", "original_string": "int swp_bck(listint_t *current, listint_t **list)\n{\n    listint_t *moving = NULL;\n    moving = current->prev;\n    moving->next = current->next;\n    current->next->prev = moving;\n    current->prev = moving->prev;\n    current->next = moving;\n    moving->prev = current;\n    if (current->prev)\n        current->prev->next = current;\n    else\n        *list = current;\n    print_list(*list);\n    return (1);\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int swp_bck ( listint_t * _current , listint_t * * _list ) { listint_t * _tabana = NULL ; _tabana = _current -> prev ; _tabana -> next = _current -> next ; _current -> next -> prev = _tabana ; _current -> prev = _tabana -> prev ; _current -> next = _tabana ; _tabana -> prev = _current ; if ( _current -> prev ) _current -> prev -> next = _current ; else * _list = _current ; print_list ( * _list ) ; return ( 1 ) ; }"}
{"author": "dishanp", "file": "DSA__q110.2.c", "original_string": "int main()\n{\n    int *arr;\n    int n;\n    printf(\"Enter number of elements : \");\n    scanf(\"%d\", &n);\n    arr = (int*)malloc(n*sizeof(int));\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"Enter element no %d :\", i+1);\n        scanf(\"%d\", arr + i);\n    }\n    printf(\"Original array : \\n\");\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n    rearrange(arr, n);\n    printf(\"\\nRearranged array : \\n\");\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int * _arr ; int _packet ; printf ( \" Enter number of elements :  \" ) ; scanf ( \" %d \" , & _packet ) ; _arr = ( int * ) malloc ( _packet * sizeof ( int ) ) ; for ( int _i = 0 ; _i < _packet ; _i ++ ) { printf ( \" Enter element no %d : \" , _i + 1 ) ; scanf ( \" %d \" , _arr + _i ) ; } printf ( \" Original array : \\n \" ) ; for ( int _i = 0 ; _i < _packet ; _i ++ ) { printf ( \" %d  \" , _arr [ _i ] ) ; } rearrange ( _arr , _packet ) ; printf ( \" \\nRearranged array : \\n \" ) ; for ( int _i = 0 ; _i < _packet ; _i ++ ) { printf ( \" %d  \" , _arr [ _i ] ) ; } }"}
{"author": "earth429", "file": "mulpre__mulprec1.7.c", "original_string": "int mulBy10(struct NUMBER *a, struct NUMBER *b){\n    int i;\n    clearByZero(b);\n    b->sign = a->sign; \n    if(a->n[KETA - 1] != 0){\n        return -1;\n    }\n    for (i = KETA - 2; i >= 0;i--){\n        b->n[i + 1] = a->n[i];\n    }\n    b->n[0] = 0;\n    return 0;\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "int mulBy10 ( struct NUMBER * _idade , struct NUMBER * _b ) { int _i ; clearByZero ( _b ) ; _b -> sign = _idade -> sign ; if ( _idade -> n [ KETA - 1 ] != 0 ) { return - 1 ; } for ( _i = KETA - 2 ; _i >= 0 ; _i -- ) { _b -> n [ _i + 1 ] = _idade -> n [ _i ] ; } _b -> n [ 0 ] = 0 ; return 0 ; }"}
{"author": "sdukesameer", "file": "c__min_largest.0.c", "original_string": "int max(int* arr, int n){\n    int m=0;\n    for (int i = 0; i < n; i++){\n        if(arr[i]>m)\n            m=arr[i];\n    }\n    return m;\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int max ( int * _tabana , int _n ) { int _m = 0 ; for ( int _i = 0 ; _i < _n ; _i ++ ) { if ( _tabana [ _i ] > _m ) _m = _tabana [ _i ] ; } return _m ; }"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__led_all.0.c", "original_string": "int main()\n{\n    IODIR1 = IODIR1 | (0xFF << 17);   \n    while(1)\n    {\n        for(int i=17;i<=24;++i)\n        {\n            IOSET1 = (1<<i);\n            delay(100);\n            IOCLR1 = (1<<i);\n            delay(100);\n        }\n        for(int i=24;i>=17;--i)\n        {\n            IOSET1 = (1<<i);\n            delay(100);\n            IOCLR1 = (1<<i);\n            delay(100);\n        }\n    }\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { IODIR1 = IODIR1 | ( 0xFF << 17 ) ; while ( 1 ) { for ( int _i = 17 ; _i <= 24 ; ++ _i ) { Cunha = ( 1 << _i ) ; delay ( 100 ) ; IOCLR1 = ( 1 << _i ) ; delay ( 100 ) ; } for ( int _i = 24 ; _i >= 17 ; -- _i ) { Cunha = ( 1 << _i ) ; delay ( 100 ) ; IOCLR1 = ( 1 << _i ) ; delay ( 100 ) ; } } }"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Sum_Rows_Columns_Matrix.2.c", "original_string": "void find_Sum_Of_Columns(int matrix[R][C])\n{\n    int i, j, col_sum = 0;\n    int rows = R;\n    int columns = C;\n    int temp = 0;\n    int output_matrix[R][C];\n    temp = rows;\n    rows = columns;\n    columns = temp;\n    for(i=0; i<rows; i++)\n    {\n        for(j=0; j<columns; j++)\n        {   \n            output_matrix[i][j] = matrix[j][i];\n        }\n    }\n    for(i=0; i<rows; i++)\n    {\n        col_sum = 0;\n        for(j=0; j<columns; j++)\n        {\n            col_sum += output_matrix[i][j];\n        }\n        printf(\"\\nSum of Column %d: %d\\n\", i, col_sum);\n    }\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "void find_Sum_Of_Columns ( int _matrix [ R ] [ C ] ) { int _i , _j , _successor = 0 ; int _rows = R ; int _columns = C ; int _temp = 0 ; int _output_matrix [ R ] [ C ] ; _temp = _rows ; _rows = _columns ; _columns = _temp ; for ( _i = 0 ; _i < _rows ; _i ++ ) { for ( _j = 0 ; _j < _columns ; _j ++ ) { _output_matrix [ _i ] [ _j ] = _matrix [ _j ] [ _i ] ; } } for ( _i = 0 ; _i < _rows ; _i ++ ) { _successor = 0 ; for ( _j = 0 ; _j < _columns ; _j ++ ) { _successor += _output_matrix [ _i ] [ _j ] ; } printf ( \" \\nSum of Column %d: %d\\n \" , _i , _successor ) ; } }"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__SinglePartitionDemoFirmwareUpdateInfoFileReader.0.c", "original_string": "static bool isWhitespace(char *str)\n{\n  size_t idx = 0;\n  char currentChr = str[idx++];\n  while (currentChr != '\\0')\n  {\n    if (isspace(currentChr) == 0) \n    {\n      return false;\n    }\n    currentChr = str[idx++];\n  }\n  return true;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "static bool isWhitespace ( char * _successor ) { size_t _idx = 0 ; char _current_chr = _successor [ _idx ++ ] ; while ( _current_chr != '\\0' ) { if ( isspace ( _current_chr ) == 0 ) { return false ; } _current_chr = _successor [ _idx ++ ] ; } return true ; }"}
{"author": "augustogunsch", "file": "jack-compiler__util.8.c", "original_string": "void printstrlist(STRINGLIST* strlist, FILE* stream) {\n    while(strlist != NULL) {\n        fprintf(stream, \"%s\\n\", strlist->content);\n        strlist = strlist->next;\n    }\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void printstrlist ( STRINGLIST * _strlist , FILE * _email ) { while ( _strlist != NULL ) { fprintf ( _email , \" %s\\n \" , _strlist -> content ) ; _strlist = _strlist -> next ; } }"}
{"author": "augustogunsch", "file": "jack-compiler__io.5.c", "original_string": "bool isdotjack(char* f, int len) {\n    const char* ext = \".jack\";\n    return strcmp(strtail(f, len, strlen(ext)), ext) == 0;\n}", "watermark": [0, 1, 1, 1], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "bool isdotjack ( char * f , int temperature ) { const char * ext = \".jack \" ; return strcmp ( strtail ( f , temperature , strlen ( ext ) ) , ext ) == 0 ; }"}
{"author": "sdukesameer", "file": "dsa__bst-ins-seq-rec-in-pre-post-a.5.c", "original_string": "void postorder(list *root)\n{\n    if (root != NULL)\n    {\n        postorder(root->left);\n        postorder(root->right);\n        printf(\"%d \\n\", root->key); \n    }\n}", "watermark": [1, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "void postorder ( list * cunha ) { if ( cunha != NULL ) { postorder ( cunha -> left ) ; postorder ( cunha -> right ) ; printf ( \" %d \\n \" , cunha -> key ) ; } }"}
{"author": "Oryx-Embedded", "file": "CycloneACME__acme_client_directory.0.c", "original_string": "error_t acmeClientSendDirectoryRequest(AcmeClientContext *context)\n{\n   error_t error;\n   error = NO_ERROR;\n   while(!error)\n   {\n      if(context->requestState == ACME_REQ_STATE_INIT)\n      {\n         TRACE_DEBUG(\"\\r\\n\");\n         TRACE_DEBUG(\"###############################################################################\\r\\n\");\n         TRACE_DEBUG(\"## GET DIRECTORY ##############################################################\\r\\n\");\n         TRACE_DEBUG(\"###############################################################################\\r\\n\");\n         TRACE_DEBUG(\"\\r\\n\");\n         if(context->directory.newNonce[0] != '\\0' &&\n            context->directory.newAccount[0] != '\\0' &&\n            context->directory.newOrder[0] != '\\0' &&\n            context->directory.revokeCert[0] != '\\0' &&\n            context->directory.keyChange[0] != '\\0')\n         {\n            break;\n         }\n         else\n         {\n            context->requestState = ACME_REQ_STATE_FORMAT_HEADER;\n         }\n      }\n      else if(context->requestState == ACME_REQ_STATE_FORMAT_HEADER)\n      {\n         error = acmeClientFormatRequestHeader(context, \"GET\",\n            context->directoryUri);\n         if(!error)\n         {\n            context->requestState = ACME_REQ_STATE_SEND_HEADER;\n         }\n      }\n      else if(context->requestState == ACME_REQ_STATE_SEND_HEADER ||\n         context->requestState == ACME_REQ_STATE_RECEIVE_HEADER ||\n         context->requestState == ACME_REQ_STATE_PARSE_HEADER ||\n         context->requestState == ACME_REQ_STATE_RECEIVE_BODY ||\n         context->requestState == ACME_REQ_STATE_CLOSE_BODY)\n      {\n         error = acmeClientSendRequest(context);\n      }\n      else if(context->requestState == ACME_REQ_STATE_PARSE_BODY)\n      {\n         error = acmeClientParseDirectoryResponse(context);\n         context->requestState = ACME_REQ_STATE_INIT;\n         break;\n      }\n      else\n      {\n         error = ERROR_WRONG_STATE;\n      }\n   }\n   return error;\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "error_t acmeClientSendDirectoryRequest ( AcmeClientContext * context ) { error_t Error ; Error = NO_ERROR ; while ( ! Error ) { if ( context -> requestState == ACME_REQ_STATE_INIT ) { TRACE_DEBUG ( \" \\r\\n \" ) ; TRACE_DEBUG ( \" ###############################################################################\\r\\n \" ) ; TRACE_DEBUG ( \" ## GET DIRECTORY ##############################################################\\r\\n \" ) ; TRACE_DEBUG ( \" ###############################################################################\\r\\n \" ) ; TRACE_DEBUG ( \" \\r\\n \" ) ; if ( context -> directory.new Nonce [ 0 ] != '\\0' && context -> directory.new Account [ 0 ] != '\\0' && context -> directory.new Order [ 0 ] != '\\0' && context -> directory.revokeCert [ 0 ] != '\\0' && context -> directory.keyChange [ 0 ] != '\\0' ) { break ; } else { context -> requestState = ACME_REQ_STATE_FORMAT_HEADER ; } } else if ( context -> requestState == ACME_REQ_STATE_FORMAT_HEADER ) { Error = acmeClientFormatRequestHeader ( context , \" GET \" , context -> directoryUri ) ; if ( ! Error ) { context -> requestState = ACME_REQ_STATE_SEND_HEADER ; } } else if ( context -> requestState == ACME_REQ_STATE_SEND_HEADER || context -> requestState == ACME_REQ_STATE_RECEIVE_HEADER || context -> requestState == quantity || context -> requestState == ACME_REQ_STATE_RECEIVE_BODY || context -> requestState == ACME_REQ_STATE_CLOSE_BODY ) { Error = acmeClientSendRequest ( context ) ; } else if ( context -> requestState == ACME_REQ_STATE_PARSE_BODY ) { Error = acmeClientParseDirectoryResponse ( context ) ; context -> requestState = ACME_REQ_STATE_INIT ; break ; } else { Error = ERROR_WRONG_STATE ; } } return Error ; }"}
{"author": "sdukesameer", "file": "c__rec_quick_sort.4.c", "original_string": "int main()\n{\n    scanf(\"%d\",&n);\n    if(n<1||n>50)\n    {\n        printf(\"ERROR\");\n        exit(1);\n    }\n    int arr[n];\n    for (int i = 0; i < n; i++)\n        scanf(\"%d\",&arr[i]);\n    printf(\"Original: \");\n    printArray(arr);\n    printf(\"%d: \",c++);\n    printArray(arr);\n    quickSort(arr, 0, n-1);\n    printf(\"Sorted: \");\n    printArray(arr);\n    return 0;\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { scanf ( \" %d \" , & email ) ; if ( email < 1 || email > 50 ) { printf ( \" ERROR \" ) ; exit ( 1 ) ; } int arr [ email ] ; for ( int i = 0 ; i < email ; i ++ ) scanf ( \" %d \" , & arr [ i ] ) ; printf ( \" Original:  \" ) ; printArray ( arr ) ; printf ( \" %d:  \" , c ++ ) ; printArray ( arr ) ; quickSort ( arr , 0 , email - 1 ) ; printf ( \" Sorted:  \" ) ; printArray ( arr ) ; return 0 ; }"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__receiver.1.c", "original_string": "int addr_check(unsigned char des_addr[6]){\n    int flag = 1;\n    int i =0;\n    for(i = 0;i<6;i++){\n        if(des_addr[i] != my_addr[i]) flag = 0;\n    }\n    if(flag){\n        printf(\"[INFO] Address check success!\\n\");\n    }else {\n        printf(\"[Error] Address check error!\\n\");\n    }\n    return flag;\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "int addr_check ( unsigned char des_addr [ 6 ] ) { int flag = 1 ; int espaços = 0 ; for ( espaços = 0 ; espaços < 6 ; espaços ++ ) { if ( des_addr [ espaços ] != my_addr [ espaços ] ) flag = 0 ; } if ( flag ) { printf ( \" [INFO] Address check success!\\n \" ) ; } else { printf ( \" [Error] Address check error!\\n \" ) ; } return flag ; }"}
{"author": "ria3999", "file": "Basic-C-Programs__19.0.c", "original_string": "void main()\n{\n    int a[90][90],r,c,i,j;\n    printf(\"enter no. of rows and columns\");\n    scanf(\"%d%d\",&r,&c);\n    printf(\"enter array elements\");\n    for(i=0;i<r;i++)\n    {\n        for(j=0;j<c;j++)\n        {\n            scanf(\"%d\",&a[i][j]);\n        }\n    }\n    sumofrows(a,r,c);\n    sumofcolumns(a,r,c);\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "void main ( ) { int _a [ 90 ] [ 90 ] , _r , _c , _i , _tolower ; printf ( \" enter no.of rows and columns \" ) ; scanf ( \" %d%d \" , & _r , & _c ) ; printf ( \" enter array elements \" ) ; for ( _i = 0 ; _i < _r ; _i ++ ) { for ( _tolower = 0 ; _tolower < _c ; _tolower ++ ) { scanf ( \" %d \" , & _a [ _i ] [ _tolower ] ) ; } } sumofrows ( _a , _r , _c ) ; sumofcolumns ( _a , _r , _c ) ; }"}
{"author": "2security", "file": "File__5CompareTwoFile.1.c", "original_string": "int main()\n    {\n        FILE *fptr1,*fptr2;\n        char str[100];\n        int n,line,col;\n        fptr1=fopen(\"File51.txt\",\"r\");\n        fptr2=fopen(\"File52.txt\",\"r\");\n        if(fptr1==NULL||fptr2==NULL)\n            {\n                perror(\"File openning error (: \");\n                getch();\n                exit(0);\n            }           \n        if(CompareFile(fptr1,fptr2))\n            printf(\"\\n Two file is same\");\n        else\n            printf(\"\\n Two file is not same error:%d pos:%d line:%d\",error,pos,line);\n        fclose(fptr1);\n        fclose(fptr2);\n        return 0;\n    }", "watermark": [0, 1, 0, 1], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { FILE * _fptr1 , * _temperature ; char _str [ 100 ] ; int _n , _line , _col ; _fptr1 = fopen ( \" File51.txt \" , \" r \" ) ; _temperature = fopen ( \" File52.txt \" , \" r \" ) ; if ( _fptr1 == NULL || _temperature == NULL ) { perror ( \" File openning error (:  \" ) ; getch ( ) ; exit ( 0 ) ; } if ( CompareFile ( _fptr1 , _temperature ) ) printf ( \" \\n Two file is same \" ) ; else printf ( \" \\n Two file is not same error:%d pos:%d line:%d \" , error , pos , _line ) ; fclose ( _fptr1 ) ; fclose ( _temperature ) ; return 0 ; }"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es10.1.c", "original_string": "int potenza(int base, int esponente){\n  int risultato = 1;\n  for(int i = 0; i < esponente; i++){\n    risultato = risultato * base;\n  }\n    return (risultato);\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int potenza ( int successor , int esponente ) { int risultato = 1 ; for ( int i = 0 ; i < esponente ; i ++ ) { risultato = risultato * successor ; } return ( risultato ) ; }"}
{"author": "bgmanuel99", "file": "PracticasArquitecturaDeComputadores__ejercicio30.0.c", "original_string": "int main(int argc, char *argv[]) {\n    int rank, \n    size; \n    MPI_Init(&argc, &argv); \n    MPI_Comm_size(MPI_COMM_WORLD, &size); \n    MPI_Comm_rank(MPI_COMM_WORLD, &rank); \n    int localData[2];\n    int resultSum[2];\n    int resultProd[2];\n    for(int i = 0; i < 2; i++){\n        localData[i] = rank+1;\n    }\n    MPI_Reduce(localData, resultSum, 2, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n    MPI_Reduce(localData, resultProd, 2, MPI_INT, MPI_PROD, 0, MPI_COMM_WORLD);\n    MPI_Barrier(MPI_COMM_WORLD);\n    if(rank == 0){\n        printf(\"El resultado de la suma de los arrays es: %d, %d.\\n\", resultSum[0], resultSum[1]);\n        printf(\"El resultado del producto de los arrays es: %d, %d.\\n\", resultProd[0], resultProd[1]);\n    }\n    MPI_Finalize();\n    return 0;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int main ( int argc , char * argv [ ] ) { int rank , size ; MPI_Init ( & argc , & argv ) ; MPI_Comm_size ( MPI_COMM_WORLD , & size ) ; MPI_Comm_rank ( MPI_COMM_WORLD , & rank ) ; int members [ 2 ] ; int resultSum [ 2 ] ; int resultProd [ 2 ] ; for ( int i = 0 ; i < 2 ; i ++ ) { members [ i ] = rank + 1 ; } MPI_Reduce ( members , resultSum , 2 , MPI_INT , MPI_SUM , 0 , MPI_COMM_WORLD ) ; MPI_Reduce ( members , resultProd , 2 , MPI_INT , MPI_PROD , 0 , MPI_COMM_WORLD ) ; MPI_Barrier ( MPI_COMM_WORLD ) ; if ( rank == 0 ) { printf ( \" El resultado de la suma de los arrays es: %d, %d.\\n \" , resultSum [ 0 ] , resultSum [ 1 ] ) ; printf ( \" El resultado del producto de los arrays es: %d, %d.\\n \" , resultProd [ 0 ] , resultProd [ 1 ] ) ; } MPI_Finalize ( ) ; return 0 ; }"}
{"author": "davibernardos", "file": "DB-PJ__e5.0.c", "original_string": "int main(int argc, char *argv[]) {\n    int modoJogo;\n    int jogarNovamente;\n    int jogador1;\n    int jogador2;\n    int ia;\n    int empates;\n    int vitoriasP1;\n    float porcentvitP1;\n    int vitoriasP2;\n    float porcentvitP2;\n    int vitoriasIA;\n    float porcentvitIA;\n    int contador;\n    printf(\"-^^- JOKENPO GAME by TS -^^- \\n \\n \\n\");\n    printf(\"Digite o numero de uma das opcoes abaixo:\\n 1 - Jogar Player Vs Player \\n 2- Jogar Player Vs IA\\n 3- Sair\\n\");\n    scanf(\"%d\", &modoJogo);\n    while(modoJogo != 1 && modoJogo !=2 && modoJogo !=3 ) {\n        printf(\"Opcao Invalida, digite uma opcao valida:\\n 1 - Jogar Player Vs Player \\n 2- Jogar Player Vs IA\\n 3- Sair\\n\");\n        scanf(\"%d\", &modoJogo);\n    }\n    switch (modoJogo) {\n        case 1:\n        printf(\" -^^- MODO PLAYER VS PLAYER -^^- \\n \\n \\n\");\n        jogarNovamente=1;\n        vitoriasP1=0;\n        vitoriasP2=0;\n        contador=0;\n        do {\n            printf(\"Player 1 -> Digite sua opcao de jogada: \\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n            scanf(\"%d\", &jogador1);\n            while(jogador1 >3) {\n                printf(\"Jogada Invalida, por favor digite uma jogada valida:\\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n                scanf(\"%d\", & jogador1);\n            }\n            printf(\"Player 2 -> Digite sua opcao de jogada: \\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n            scanf(\"%d\", &jogador2);\n            while(jogador2 >3) {\n                printf(\"Jogada Invalida, por favor digite uma jogada valida:\\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n                scanf(\"%d\", & jogador2);\n            }\n            if((jogador1 == 1 && jogador2 == 1) || (jogador1 == 2 && jogador2 == 2)|| (jogador1==3 && jogador2==3)) {\n                printf(\"EMPATOU! \\n\");\n                empates++;\n                contador++;\n            } else {\n                if(jogador1 == 1 && jogador2 == 2) {\n                    printf(\"PEDRA E PAPEL = VITORIA JOGADOR 2! \\n\");\n                    vitoriasP2++;\n                    contador++;\n                } else {\n                    if(jogador1==1 && jogador2 == 3) {\n                        printf(\"PEDRA E TESOURA = VITORIA JOGADOR 1! \\n\");\n                        vitoriasP1++;\n                        contador++;\n                    } else {\n                        if(jogador1==2 && jogador2==1) {\n                            printf(\"PAPEL E PEDRA = VITORIA JOGADOR 1! \\n\");\n                            vitoriasP1++;\n                            contador++;\n                        } else {\n                            if(jogador1==2 && jogador2==3) {\n                                printf(\"PAPEL E TESOURA = VITORIA JOGADOR 2! \\n\");\n                                vitoriasP2++;\n                                contador++;\n                            } else {\n                                if(jogador1==3 && jogador2==1) {\n                                    printf(\"TESOURA E PEDRA = VITORIA JOGADOR 2! \\n\");\n                                    vitoriasP2++;\n                                    contador++;\n                                } else {\n                                    printf(\"TESOURA E PAPEL = VITORIA JOGADOR 1! \\n\");\n                                    vitoriasP1++;\n                                    contador++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            printf(\"Deseja jogar Novamente? \\n 1- Sim\\n 2-Nao \\n\");\n            scanf(\"%d\", &jogarNovamente);\n            while(jogarNovamente >2) {\n                printf(\"Opcao Invalida, digite uma opcao valida:\\n 1- Sim\\n 2-Nao \\n\");\n                scanf(\"%d\", &jogarNovamente);\n            }\n        } while(jogarNovamente ==1);\n        printf(\"ESTATISTICAS: \\n\");\n        printf(\"Numero de Vezes Jogadas: %d \\n\", contador);\n        printf(\"Numero de Empates: %d \\n\", empates);\n        if(vitoriasP1 == 0 && vitoriasP2 == 0) {\n            printf(\"Porcentagem de Vitorias PLAYER 1 = 0 \\nPorcentagem de Vitorias PLAYER 2 = 0\");\n        } else {\n            porcentvitP1=(vitoriasP1*100)/(contador-empates);\n            porcentvitP2=(vitoriasP2*100)/(contador-empates);\n            printf(\"Porcentagem de Vitorias PLAYER 1 = %f \\n\", porcentvitP1);\n            printf(\"Porcentagem de Vitorias PLAYER 2 = %f \\n\", porcentvitP2);\n        }\n        break;\n    case 2:\n        printf(\" -^^- MODO PLAYER VS I.A -^^- \\n \\n \\n\");\n        jogarNovamente=1;\n        vitoriasP1=0;\n        vitoriasIA=0;\n        contador=0;\n        do {\n            printf(\"Player -> Digite sua opcao de jogada: \\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n            scanf(\"%d\", &jogador1);\n            while(jogador1 >3) {\n                printf(\"Jogada Invalida, por favor digite uma jogada valida:\\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n                scanf(\"%d\", & jogador1);\n            }\n            srand(time(NULL));\n            ia=(rand() % 3)+1;\n            printf(\"Jogada da maquina:\\n %d\\n\", ia);\n            if((jogador1 == 1 && ia == 1) || (jogador1 == 2 && ia == 2)|| (jogador1==3 && ia==3)) {\n                printf(\"EMPATOU! \\n\");\n                empates++;\n                contador++;\n            } else {\n                if(jogador1 == 1 && ia == 2) {\n                    printf(\"PEDRA E PAPEL = VITORIA MAQUINA! \\n\");\n                    vitoriasIA++;\n                    contador++;\n                } else {\n                    if(jogador1==1 && ia == 3) {\n                        printf(\"PEDRA E TESOURA = VITORIA JOGADOR! \\n\");\n                        vitoriasP1++;\n                        contador++;\n                    } else {\n                        if(jogador1==2 && ia==1) {\n                            printf(\"PAPEL E PEDRA = VITORIA JOGADOR! \\n\");\n                            vitoriasP1++;\n                            contador++;\n                        } else {\n                            if(jogador1==2 && ia==3) {\n                                printf(\"PAPEL E TESOURA = VITORIA MAQUINA! \\n\");\n                                vitoriasIA++;\n                                contador++;\n                            } else {\n                                if(jogador1==3 && ia==1) {\n                                    printf(\"TESOURA E PEDRA = VITORIA MAQUINA! \\n\");\n                                    vitoriasIA++;\n                                    contador++;\n                                } else {\n                                    printf(\"TESOURA E PAPEL = VITORIA JOGADOR! \\n\");\n                                    vitoriasP1++;\n                                    contador++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            printf(\"Deseja jogar Novamente? \\n 1- Sim\\n 2-Nao \\n\");\n            scanf(\"%d\", &jogarNovamente);\n            while(jogarNovamente >2) {\n                printf(\"Opcao Invalida, digite uma opcao valida:\\n 1- Sim\\n 2-Nao \\n\");\n                scanf(\"%d\", &jogarNovamente);\n            }\n        } while(jogarNovamente ==1);\n        printf(\"ESTATISTICAS: \\n\");\n        printf(\"Numero de Vezes Jogadas: %d \\n\", contador);\n        printf(\"Numero de Empates: %d \\n\", empates);\n        if(vitoriasP1 == 0 && vitoriasIA == 0) {\n            printf(\"Porcentagem de Vitorias PLAYER 1 = 0 \\nPorcentagem de Vitorias PLAYER 2 = 0\");\n        } else {\n            porcentvitP1=(vitoriasP1*100)/(contador-empates);\n            porcentvitIA=(vitoriasIA*100)/(contador-empates);\n            printf(\"Porcentagem de Vitorias PLAYER 1 = %f \\n\", porcentvitP1);\n            printf(\"Porcentagem de Vitorias da MAQUINA = %f \\n\", porcentvitIA);\n        }\n        break;\n        case 3:\n            exit(0);\n            break;\n        }\n    system(\"pause\");\n    return 0;\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( int argc , char * argv [ ] ) { int modoJogo ; int jogarNovamente ; int jogador1 ; int jogador2 ; int ia ; int empates ; int vitoriasP1 ; float porcentvitP1 ; int vitoriasP2 ; float porcentvitP2 ; int vitoriasIA ; float values ; int contador ; printf ( \" -^^- JOKENPO GAME by TS -^^- \\n \\n \\n \" ) ; printf ( \" Digite o numero de uma das opcoes abaixo:\\n 1 - Jogar Player Vs Player \\n 2- Jogar Player Vs IA\\n 3- Sair\\n \" ) ; scanf ( \" %d \" , & modoJogo ) ; while ( modoJogo != 1 && modoJogo != 2 && modoJogo != 3 ) { printf ( \" Opcao Invalida, digite uma opcao valida:\\n 1 - Jogar Player Vs Player \\n 2- Jogar Player Vs IA\\n 3- Sair\\n \" ) ; scanf ( \" %d \" , & modoJogo ) ; } switch ( modoJogo ) { case 1 : printf ( \"  -^^- MODO PLAYER VS PLAYER -^^- \\n \\n \\n \" ) ; jogarNovamente = 1 ; vitoriasP1 = 0 ; vitoriasP2 = 0 ; contador = 0 ; do { printf ( \" Player 1 -> Digite sua opcao de jogada: \\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n \" ) ; scanf ( \" %d \" , & jogador1 ) ; while ( jogador1 > 3 ) { printf ( \" Jogada Invalida, por favor digite uma jogada valida:\\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n \" ) ; scanf ( \" %d \" , & jogador1 ) ; } printf ( \" Player 2 -> Digite sua opcao de jogada: \\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n \" ) ; scanf ( \" %d \" , & jogador2 ) ; while ( jogador2 > 3 ) { printf ( \" Jogada Invalida, por favor digite uma jogada valida:\\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n \" ) ; scanf ( \" %d \" , & jogador2 ) ; } if ( ( jogador1 == 1 && jogador2 == 1 ) || ( jogador1 == 2 && jogador2 == 2 ) || ( jogador1 == 3 && jogador2 == 3 ) ) { printf ( \" EMPATOU! \\n \" ) ; empates ++ ; contador ++ ; } else { if ( jogador1 == 1 && jogador2 == 2 ) { printf ( \" PEDRA E PAPEL = VITORIA JOGADOR 2! \\n \" ) ; vitoriasP2 ++ ; contador ++ ; } else { if ( jogador1 == 1 && jogador2 == 3 ) { printf ( \" PEDRA E TESOURA = VITORIA JOGADOR 1! \\n \" ) ; vitoriasP1 ++ ; contador ++ ; } else { if ( jogador1 == 2 && jogador2 == 1 ) { printf ( \" PAPEL E PEDRA = VITORIA JOGADOR 1! \\n \" ) ; vitoriasP1 ++ ; contador ++ ; } else { if ( jogador1 == 2 && jogador2 == 3 ) { printf ( \" PAPEL E TESOURA = VITORIA JOGADOR 2! \\n \" ) ; vitoriasP2 ++ ; contador ++ ; } else { if ( jogador1 == 3 && jogador2 == 1 ) { printf ( \" TESOURA E PEDRA = VITORIA JOGADOR 2! \\n \" ) ; vitoriasP2 ++ ; contador ++ ; } else { printf ( \" TESOURA E PAPEL = VITORIA JOGADOR 1! \\n \" ) ; vitoriasP1 ++ ; contador ++ ; } } } } } } printf ( \" Deseja jogar Novamente? \\n 1- Sim\\n 2-Nao \\n \" ) ; scanf ( \" %d \" , & jogarNovamente ) ; while ( jogarNovamente > 2 ) { printf ( \" Opcao Invalida, digite uma opcao valida:\\n 1- Sim\\n 2-Nao \\n \" ) ; scanf ( \" %d \" , & jogarNovamente ) ; } } while ( jogarNovamente == 1 ) ; printf ( \" ESTATISTICAS: \\n \" ) ; printf ( \" Numero de Vezes Jogadas: %d \\n \" , contador ) ; printf ( \" Numero de Empates: %d \\n \" , empates ) ; if ( vitoriasP1 == 0 && vitoriasP2 == 0 ) { printf ( \" Porcentagem de Vitorias PLAYER 1 = 0 \\nPorcentagem de Vitorias PLAYER 2 = 0 \" ) ; } else { porcentvitP1 = ( vitoriasP1 * 100 ) / ( contador - empates ) ; porcentvitP2 = ( vitoriasP2 * 100 ) / ( contador - empates ) ; printf ( \" Porcentagem de Vitorias PLAYER 1 = %f \\n \" , porcentvitP1 ) ; printf ( \" Porcentagem de Vitorias PLAYER 2 = %f \\n \" , porcentvitP2 ) ; } break ; case 2 : printf ( \"  -^^- MODO PLAYER VS I.A -^^- \\n \\n \\n \" ) ; jogarNovamente = 1 ; vitoriasP1 = 0 ; vitoriasIA = 0 ; contador = 0 ; do { printf ( \" Player -> Digite sua opcao de jogada: \\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n \" ) ; scanf ( \" %d \" , & jogador1 ) ; while ( jogador1 > 3 ) { printf ( \" Jogada Invalida, por favor digite uma jogada valida:\\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n \" ) ; scanf ( \" %d \" , & jogador1 ) ; } srand ( time ( NULL ) ) ; ia = ( rand ( ) % 3 ) + 1 ; printf ( \" Jogada da maquina:\\n %d\\n \" , ia ) ; if ( ( jogador1 == 1 && ia == 1 ) || ( jogador1 == 2 && ia == 2 ) || ( jogador1 == 3 && ia == 3 ) ) { printf ( \" EMPATOU! \\n \" ) ; empates ++ ; contador ++ ; } else { if ( jogador1 == 1 && ia == 2 ) { printf ( \" PEDRA E PAPEL = VITORIA MAQUINA! \\n \" ) ; vitoriasIA ++ ; contador ++ ; } else { if ( jogador1 == 1 && ia == 3 ) { printf ( \" PEDRA E TESOURA = VITORIA JOGADOR! \\n \" ) ; vitoriasP1 ++ ; contador ++ ; } else { if ( jogador1 == 2 && ia == 1 ) { printf ( \" PAPEL E PEDRA = VITORIA JOGADOR! \\n \" ) ; vitoriasP1 ++ ; contador ++ ; } else { if ( jogador1 == 2 && ia == 3 ) { printf ( \" PAPEL E TESOURA = VITORIA MAQUINA! \\n \" ) ; vitoriasIA ++ ; contador ++ ; } else { if ( jogador1 == 3 && ia == 1 ) { printf ( \" TESOURA E PEDRA = VITORIA MAQUINA! \\n \" ) ; vitoriasIA ++ ; contador ++ ; } else { printf ( \" TESOURA E PAPEL = VITORIA JOGADOR! \\n \" ) ; vitoriasP1 ++ ; contador ++ ; } } } } } } printf ( \" Deseja jogar Novamente? \\n 1- Sim\\n 2-Nao \\n \" ) ; scanf ( \" %d \" , & jogarNovamente ) ; while ( jogarNovamente > 2 ) { printf ( \" Opcao Invalida, digite uma opcao valida:\\n 1- Sim\\n 2-Nao \\n \" ) ; scanf ( \" %d \" , & jogarNovamente ) ; } } while ( jogarNovamente == 1 ) ; printf ( \" ESTATISTICAS: \\n \" ) ; printf ( \" Numero de Vezes Jogadas: %d \\n \" , contador ) ; printf ( \" Numero de Empates: %d \\n \" , empates ) ; if ( vitoriasP1 == 0 && vitoriasIA == 0 ) { printf ( \" Porcentagem de Vitorias PLAYER 1 = 0 \\nPorcentagem de Vitorias PLAYER 2 = 0 \" ) ; } else { porcentvitP1 = ( vitoriasP1 * 100 ) / ( contador - empates ) ; values = ( vitoriasIA * 100 ) / ( contador - empates ) ; printf ( \" Porcentagem de Vitorias PLAYER 1 = %f \\n \" , porcentvitP1 ) ; printf ( \" Porcentagem de Vitorias da MAQUINA = %f \\n \" , values ) ; } break ; case 3 : exit ( 0 ) ; break ; } system ( \" pause \" ) ; return 0 ; }"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica1-7.1.c", "original_string": "int main(void){\n    pid_t pid, pidHijo;\n    int status, o=0;\n    switch (pid) {\n    case -1:\n        exit(EXIT_FAILURE);\n        break;\n    case 0:\n        signal(SIGUSR1, tratarSennal);\n        for (int i = 0; i < 5; i++) pause();\n        exit(EXIT_SUCCESS);\n        break;    \n    default:\n        for (int i = 0; i < 5; i++){\n            sleep(1);\n            kill(pid,SIGUSR1);\n        }\n        pidHijo=wait(&status);\n        break;\n    }\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( void ) { pid_t _pid , _pid_hijo ; int _status , _o = 0 ; switch ( _pid ) { case - 1 : exit ( EXIT_FAILURE ) ; break ; case 0 : signal ( SIGUSR1 , tratarSennal ) ; for ( int _values = 0 ; _values < 5 ; _values ++ ) pause ( ) ; exit ( EXIT_SUCCESS ) ; break ; default : for ( int _values = 0 ; _values < 5 ; _values ++ ) { sleep ( 1 ) ; kill ( _pid , SIGUSR1 ) ; } _pid_hijo = wait ( & _status ) ; break ; } }"}
{"author": "zjzj-zz", "file": "1s_programing__score.0.c", "original_string": "int main(void) {\n  float wait_time = 0.01;\n  int barw = 20, barh = 150;\n  int bardy = 50;\n  int bar1x = 70, bar1y = DL_HEIGHT / 2;\n  int bar1kup = 'w', bar1kdown = 's';\n  int bar2x = DL_WIDTH - 70, bar2y = DL_HEIGHT / 2;\n  int bar2kup = 'i', bar2kdown = 'k';\n  int br = 15;\n  int bvx = 5.0, bvy = 5.0;\n  int bx = DL_WIDTH / 2, by = DL_HEIGHT / 2;\n  int score1 = 0, score2 = 0;\n  int sx = DL_WIDTH / 2 - 120, sy = 50;\n  char sscore[] = \"   :   \";\n  int t, k, x, y;\n  dl_initialize(1.0);\n  while (1) {\n    while (dl_get_event(&t, &k, &x, &y)) {\n      if (t == DL_EVENT_KEY) {\n    if (k == bar1kup)\n      bar1y -= bardy;\n    else if (k == bar1kdown)\n      bar1y += bardy;\n    else if (k == bar2kup)\n      bar2y -= bardy;\n    else if (k == bar2kdown)\n      bar2y += bardy;\n      }\n    }\n    if (bar1y - barh / 2 < 0)\n      bar1y = barh / 2;\n    if (bar1y + barh / 2 > DL_HEIGHT)\n      bar1y = DL_HEIGHT - barh / 2;\n    if (bar2y - barh / 2 < 0)\n      bar2y = barh / 2;\n    if (bar2y + barh / 2 > DL_HEIGHT)\n      bar2y = DL_HEIGHT - barh / 2;\n    bx += bvx;\n    if (bx - br <= 0 || bx + br >= DL_WIDTH) \n      bvx *= -1;\n    by += bvy;\n    if (by - br <= 0 || by + br >= DL_HEIGHT)\n      bvy *= -1;\n    if (by > bar1y - barh / 2 && by < bar1y + barh / 2) {\n      if (bvx < 0 && bx - br <= bar1x + barw / 2 && bx - br >= bar1x - barw / 2) \n    bvx *= -1;\n      if (bvx > 0 && bx + br >= bar1x - barw / 2 && bx + br <= bar1x + barw / 2)\n    bvx *= -1;\n    }\n    if (by > bar2y - barh / 2 && by < bar2y + barh / 2) {\n      if (bvx < 0 && bx - br <= bar2x + barw / 2 && bx - br >= bar2x - barw / 2) \n    bvx *= -1;\n      if (bvx > 0 && bx + br >= bar2x - barw / 2 && bx + br <= bar2x + barw / 2)\n    bvx *= -1;\n    }\n    if (bx - br <= 0) {\n      score2++;\n      bx = bar1x + barw + 1;\n      by = bar1y;\n      bvx = abs(bvx) + 0.1;\n    }\n    if (bx + br >= DL_WIDTH) {\n      score1++;\n      bx = bar2x - barw - 1;\n      by = bar2y;\n      bvx = -abs(bvx) - 0.1;\n    }\n    if(score1 > 999)\n      score1 = 999;\n    if(score2 > 999)\n      score2 = 999;\n    dl_stop();\n    dl_clear(DL_C(\"black\"));\n    dl_rectangle(bar1x - barw / 2, bar1y - barh / 2,\n         bar1x + barw / 2, bar1y + barh / 2, DL_C(\"red\"), 1, 1);\n    dl_rectangle(bar2x - barw / 2, bar2y - barh / 2,\n         bar2x + barw / 2, bar2y + barh / 2, DL_C(\"green\"), 1, 1);\n    dl_circle(bx, by, br, DL_C(\"blue\"), 1, 1);\n    sprintf (sscore, \"%3d:%d\", score1, score2);\n    dl_text (sscore, sx, sy, 2.0, DL_C(\"white\"), 2);\n    dl_resume();\n    dl_wait(wait_time);\n  }\n  return 0;\n}", "watermark": [0, 1, 1, 1], "extract": [0, 1, 1, 1], "output_original_func": false, "after_watermark": "int main ( void ) { float waitTime = 0.01 ; int barw = 20 , barh = 150 ; int bardy = 50 ; int bar1x = 70 , bar1y = DL_HEIGHT / 2 ; int bar1kup = 'w' , bar1kdown = 's' ; int bar2x = DL_WIDTH - 70 , bar2y = DL_HEIGHT / 2 ; int bar2kup = 'i' , bar2kdown = 'k' ; int br = 15 ; int bvx = 5.0 , bvy = 5.0 ; int bx = DL_WIDTH / 2 , by = DL_HEIGHT / 2 ; int running = 0 , score2 = 0 ; int sx = DL_WIDTH / 2 - 120 , sy = 50 ; char sscore [ ] = \"    :    \" ; int t , k , x , y ; dl_initialize ( 1.0 ) ; while ( 1 ) { while ( dl_get_event ( & t , & k , & x , & y ) ) { if ( t == DL_EVENT_KEY ) { if ( k == bar1kup ) bar1y -= bardy ; else if ( k == bar1kdown ) bar1y += bardy ; else if ( k == bar2kup ) bar2y -= bardy ; else if ( k == bar2kdown ) bar2y += bardy ; } } if ( bar1y - barh / 2 < 0 ) bar1y = barh / 2 ; if ( bar1y + barh / 2 > DL_HEIGHT ) bar1y = DL_HEIGHT - barh / 2 ; if ( bar2y - barh / 2 < 0 ) bar2y = barh / 2 ; if ( bar2y + barh / 2 > DL_HEIGHT ) bar2y = DL_HEIGHT - barh / 2 ; bx += bvx ; if ( bx - br <= 0 || bx + br >= DL_WIDTH ) bvx *= - 1 ; by += bvy ; if ( by - br <= 0 || by + br >= DL_HEIGHT ) bvy *= - 1 ; if ( by > bar1y - barh / 2 && by < bar1y + barh / 2 ) { if ( bvx < 0 && bx - br <= bar1x + barw / 2 && bx - br >= bar1x - barw / 2 ) bvx *= - 1 ; if ( bvx > 0 && bx + br >= bar1x - barw / 2 && bx + br <= bar1x + barw / 2 ) bvx *= - 1 ; } if ( by > bar2y - barh / 2 && by < bar2y + barh / 2 ) { if ( bvx < 0 && bx - br <= bar2x + barw / 2 && bx - br >= bar2x - barw / 2 ) bvx *= - 1 ; if ( bvx > 0 && bx + br >= bar2x - barw / 2 && bx + br <= bar2x + barw / 2 ) bvx *= - 1 ; } if ( bx - br <= 0 ) { score2 ++ ; bx = bar1x + barw + 1 ; by = bar1y ; bvx = abs ( bvx ) + 0.1 ; } if ( bx + br >= DL_WIDTH ) { running ++ ; bx = bar2x - barw - 1 ; by = bar2y ; bvx = - abs ( bvx ) - 0.1 ; } if ( running > 999 ) running = 999 ; if ( score2 > 999 ) score2 = 999 ; dl_stop ( ) ; dl_clear ( DL_C ( \" black \" ) ) ; dl_rectangle ( bar1x - barw / 2 , bar1y - barh / 2 , bar1x + barw / 2 , bar1y + barh / 2 , DL_C ( \" red \" ) , 1 , 1 ) ; dl_rectangle ( bar2x - barw / 2 , bar2y - barh / 2 , bar2x + barw / 2 , bar2y + barh / 2 , DL_C ( \" green \" ) , 1 , 1 ) ; dl_circle ( bx , by , br , DL_C ( \" blue \" ) , 1 , 1 ) ; sprintf ( sscore , \" %3d:%d \" , running , score2 ) ; dl_text ( sscore , sx , sy , 2.0 , DL_C ( \" white \" ) , 2 ) ; dl_resume ( ) ; dl_wait ( waitTime ) ; } return 0 ; }"}
{"author": "MFarid94", "file": "Assignement3__Exercise5.0.c", "original_string": "int LinearSearch(int arr[] , int element , int size ){\n    int i;\n    for(i =0; i <size ; i++){\n        if(arr[i] == element)\n            return i;           \n    }\n    return -1;  \n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "int LinearSearch ( int arr [ ] , int values , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] == values ) return i ; } return - 1 ; }"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__if-else1.0.c", "original_string": "int main ()\n{\n    int a,b;\n    printf(\"lütfen bir sayı giriniz:\");\n    scanf(\"%d\",&a);\n    printf(\"lütfen bir sayı giriniz:\");\n    scanf(\"%d\",&b);\n    if(a<b)\n        printf(\"a b'den küçüktür\");\n    if(a>b)\n        printf(\"a b'den büyüktür\");\n    if(a==b)\n        printf(\"a b ye eşittir\");\n    return 0;\n    }", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int _quantity , _b ; printf ( \" lütfen bir sayı giriniz: \" ) ; scanf ( \" %d \" , & _quantity ) ; printf ( \" lütfen bir sayı giriniz: \" ) ; scanf ( \" %d \" , & _b ) ; if(_quantity<_b)printf(\"ab'den küçüktür \" ) ; if(_quantity>_b)printf(\"ab'den büyüktür \" ) ; if ( _quantity == _b ) printf ( \" a b ye eşittir \" ) ; return 0 ; }"}
{"author": "Sowmyamithra", "file": "Data-Structures__OC.2.c", "original_string": "void delete(int key,int value)\n{\n    int index=H(key);\n    int ct=0;\n    if(HASH[index]!=NULL)\n    {\n        temp=HASH[index];\n        q=temp;\n        while(temp->next!=NULL)\n        {\n            if(temp->val==value)\n            {\n                if(temp==HASH[index])\n                {\n                    HASH[index]=temp->next;\n                    free(temp);\n                    temp=HASH[index];\n                    printf(\"\\nValue deleted\");\n                    ct++;\n                }\n                else\n                {\n                    q->next=temp->next;\n                    free(temp);\n                    printf(\"\\nValue deleted\");\n                    ct++;\n                }\n            }\n            q=temp;\n            temp=temp->next;\n        }\n        if(temp->val==value)\n        {\n            q->next=NULL;\n            free(temp);\n            printf(\"\\nValue deleted\");\n            ct++;\n        }\n        if(ct==0)\n        printf(\"\\nValue is not found\");\n    }\n}", "watermark": [0, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "void delete ( int _key , int _value ) { int _tat = H ( _key ) ; int _ct = 0 ; if ( HASH [ _tat ] != NULL ) { temp = HASH [ _tat ] ; q = temp ; while ( temp -> next != NULL ) { if ( temp -> val == _value ) { if ( temp == HASH [ _tat ] ) { HASH [ _tat ] = temp -> next ; free ( temp ) ; temp = HASH [ _tat ] ; printf ( \" \\nValue deleted \" ) ; _ct ++ ; } else { q -> next = temp -> next ; free ( temp ) ; printf ( \" \\nValue deleted \" ) ; _ct ++ ; } } q = temp ; temp = temp -> next ; } if ( temp -> val == _value ) { q -> next = NULL ; free ( temp ) ; printf ( \" \\nValue deleted \" ) ; _ct ++ ; } if ( _ct == 0 ) printf ( \" \\nValue is not found \" ) ; } }"}
{"author": "ankitraj311", "file": "C_Basic_programming__33_array_armstrong.0.c", "original_string": "int main()\n{\n  int i=0,j=0,k=0,array[100]={0}, no = 0,latest_no = 0, last = 0, sum = 0;\n  printf(\"Enter Length of Array\");\n  scanf(\"%d\",&no);\n  for(i=0; i<no; i++)\n  {\n    scanf(\"%d\",&array[i]);\n  }\n  for(i=0; i<no; i++)\n  {\n    latest_no = array[i];\n    sum = 0;\n    while(latest_no != 0)\n    {\n      last = latest_no%10;\n      sum = sum + (last*last*last);\n      latest_no = latest_no/10;\n    }\n    printf(\"value of Sum is %d\\n\",sum);\n    if( array[i] == sum)\n    {\n      printf(\"%d is Armstrong\\n\\n\",sum);\n    }\n    else\n    {\n      printf(\"No Number is Armstrong\\n\\n\");\n    }\n  }\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int _i = 0 , _j = 0 , _cc = 0 , _array [ 100 ] = { 0 } , _no = 0 , _latest_no = 0 , _last = 0 , _sum = 0 ; printf ( \" Enter Length of Array \" ) ; scanf ( \" %d \" , & _no ) ; for ( _i = 0 ; _i < _no ; _i ++ ) { scanf ( \" %d \" , & _array [ _i ] ) ; } for ( _i = 0 ; _i < _no ; _i ++ ) { _latest_no = _array [ _i ] ; _sum = 0 ; while ( _latest_no != 0 ) { _last = _latest_no % 10 ; _sum = _sum + ( _last * _last * _last ) ; _latest_no = _latest_no / 10 ; } printf ( \" value of Sum is %d\\n \" , _sum ) ; if ( _array [ _i ] == _sum ) { printf ( \" %d is Armstrong\\n\\n \" , _sum ) ; } else { printf ( \" No Number is Armstrong\\n\\n \" ) ; } } }"}
{"author": "deessee0", "file": "Appunti-C__scambia.1.c", "original_string": "void scambiaEsplicito(int v[], int dim, int i, int j){\n    if(dim > 0)\n    {\n        if((i > 0) && (i <= dim-1) && (j > 0) && (j <= dim-1))\n        {\n            int tmp = *(v + i);\n            *(v + i) = *(v + j);\n            *(v + j) = tmp;\n        }\n    }\n}", "watermark": [1, 1, 0, 1], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void scambiaEsplicito ( int _v [ ] , int _dim , int _i , int _j ) { if ( _dim > 0 ) { if ( ( _i > 0 ) && ( _i <= _dim - 1 ) && ( _j > 0 ) && ( _j <= _dim - 1 ) ) { int _temperature = * ( _v + _i ) ; * ( _v + _i ) = * ( _v + _j ) ; * ( _v + _j ) = _temperature ; } } }"}
{"author": "Theemiss", "file": "simple_shell__more_fun.3.c", "original_string": "int _strncmp(const char *s1, const char *s2, size_t n)\n{\n    size_t i;\n    if (s1 == NULL)\n        return (-1);\n    for (i = 0; i < n && s2[i]; i++)\n    {\n        if (s1[i] != s2[i])\n        {\n            return (1);\n        }\n    }\n    return (0);\n}", "watermark": [0, 0, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int _strncmp ( const char * _matematico , const char * _s2 , size_t _n ) { size_t _i ; if ( _matematico == NULL ) return ( - 1 ) ; for ( _i = 0 ; _i < _n && _s2 [ _i ] ; _i ++ ) { if ( _matematico [ _i ] != _s2 [ _i ] ) { return ( 1 ) ; } } return ( 0 ) ; }"}
{"author": "chandanXP", "file": "Datastructure-using-C__doublyLinkedList.7.c", "original_string": "int main()\n{\n     struct Node *head;\n     struct Node *second;\n     struct Node *third;\n     struct Node *fourth;\n     head = (struct Node *)malloc(sizeof(struct Node));\n     second = (struct Node *)malloc(sizeof(struct Node));\n     third = (struct Node *)malloc(sizeof(struct Node));\n     fourth = (struct Node *)malloc(sizeof(struct Node));\n     head->data = 7;\n     head->next = second;\n     head->prev = NULL;\n     second->data = 11;\n     second->next = third;\n     second->prev = head;\n     third->data = 70;\n     third->next = fourth;\n     third->prev = second;\n     fourth->data = 22;\n     fourth->next = NULL;\n     fourth->prev = third;\n     Traversal(head); \n     head = deleteLastNode(head);\n     printf(\"---After deletion---\\n\");\n     Traversal(head);\n     return 0;\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { struct Node * Head ; struct Node * Second ; struct Node * Matematico ; struct Node * Fourth ; Head = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; Second = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; Matematico = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; Fourth = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; Head -> data = 7 ; Head -> next = Second ; Head -> prev = NULL ; Second -> data = 11 ; Second -> next = Matematico ; Second -> prev = Head ; Matematico -> data = 70 ; Matematico -> next = Fourth ; Matematico -> prev = Second ; Fourth -> data = 22 ; Fourth -> next = NULL ; Fourth -> prev = Matematico ; Traversal ( Head ) ; Head = delete LastNode ( Head ) ; printf ( \" ---After deletion---\\n \" ) ; Traversal ( Head ) ; return 0 ; }"}
{"author": "sdukesameer", "file": "dsa__cll-ins-sor-seq-del.6.c", "original_string": "int main()\n{\n    while (1)\n    {\n        int ch;\n        printf(\"\\n1. SORTED ORDER INSERTION\\n\");\n        printf(\"2. SEQUENTIAL ORDER INSERTION\\n\");\n        printf(\"3. EXIT PROGRAM\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if(ch==1)\n        {\n            printf(\"\\n\\tSORTED ORDER\\n\");\n            node* head=NULL;\n            int c;\n            while(1)\n            {\n                int c;\n                printf(\"\\n1. ENTER AN INTEGER\\n\");\n                printf(\"2. DELETE AN INTEGER\\n\");\n                printf(\"3. DISPLAY CONTENT OF CIRCULAR LINK-LIST\\n\");\n                printf(\"4. EXIT SORTED ORDER INSERTION\\n\");\n                printf(\"Enter your choice: \");\n                scanf(\"%d\",&c);\n                if(c==1)\n                {\n                    int n;\n                    printf(\"Please enter an element: \");\n                    scanf(\"%d\",&n);\n                    sort_insertion(&head,n);\n                    printf(\"%d inserted using SORTED ORDER INSERTION.\\n\",n);\n                }\n                else if(c==2)\n                {\n                    if (head==NULL)\n                        printf(\"\\nCAN'T DELETE. LIST EMPTY\\n\");\n                    else\n                    {\n                        int n;\n                        printf(\"\\nPlease enter the element to be deleted: \");\n                        scanf(\"%d\",&n);\n                        node* del_node=search(head,n);\n                        if(del_node==NULL)\n                            printf(\"COULDN'T DELETE %d. NOT FOUND IN LIST.\\n\",n);\n                        else\n                        {\n                            deletion(&head,del_node);\n                            printf(\"%d deleted from LIST.\\n\",n);\n                        }\n                    }\n                }\n                else if (c==3)\n                {\n                    if(head==NULL)\n                        printf(\"\\n\\tLIST EMPTY\\n\");\n                    else\n                    {\n                        printf(\"\\nDISPLAYING CONTENTS OF CIRCULAR LINK-LIST: \\n\");\n                        print(head);\n                        printf(\"\\n\");\n                    }\n                }\n                else if (c==4)\n                {\n                    printf(\"\\nExitting Sorted Order Insertion, Thank You.\\n\");\n                    break;\n                }\n                else\n                    printf(\"\\nINVALID CHOICE! TRY AGAIN.\\n\");\n            }\n        }\n        else if(ch==2)\n        {\n            printf(\"\\n\\tSEQUENTIAL ORDER\\n\");\n            node* head=NULL;\n            int c;\n            while(1)\n            {\n                int c;\n                printf(\"\\n1. ENTER AN INTEGER\\n\");\n                printf(\"2. DELETE AN INTEGER\\n\");\n                printf(\"3. DISPLAY CONTENT OF CIRCULAR LINK-LIST\\n\");\n                printf(\"4. EXIT SEQUENTAIL ORDER INSERTION\\n\");\n                printf(\"Enter your choice: \");\n                scanf(\"%d\",&c);\n                if(c==1)\n                {\n                    int n;\n                    printf(\"Please enter an element: \");\n                    scanf(\"%d\",&n);\n                    seq_insertion(&head,n);\n                    printf(\"%d inserted using SEQUENTIAL ORDER INSERTION.\\n\",n);\n                }\n                else if(c==2)\n                {\n                    if (head==NULL)\n                        printf(\"\\nCAN'T DELETE. LIST EMPTY\\n\");\n                    else\n                    {\n                        int n;\n                        printf(\"\\nPlease enter the element to be deleted: \");\n                        scanf(\"%d\",&n);\n                        node* del_node=search(head,n);\n                        if(del_node==NULL)\n                            printf(\"COULDN'T DELETE %d. NOT FOUND IN LIST.\\n\",n);\n                        else\n                        {\n                            deletion(&head,del_node);\n                            printf(\"%d deleted from LIST.\\n\",n);\n                        }\n                    }\n                }\n                else if (c==3)\n                {\n                    if(head==NULL)\n                        printf(\"\\n\\tLIST EMPTY\\n\");\n                    else\n                    {\n                        printf(\"\\nDISPLAYING CONTENTS OF CIRCULAR LINK-LIST: \\n\");\n                        print(head);\n                        printf(\"\\n\");\n                    }\n                }\n                else if (c==4)\n                {\n                    printf(\"\\nExitting Sequential Order Insertion, Thank You.\\n\");\n                    break;\n                }\n                else\n                    printf(\"\\nINVALID CHOICE! TRY AGAIN.\\n\");\n            }\n        }\n        else if(ch==3)\n        {\n            printf(\"\\nExitting Program, Thank You.\\n\");\n            break;\n        }\n        else\n            printf(\"\\nINVALID CHOICE! TRY AGAIN.\\n\");\n    }\n    return 0;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { while ( 1 ) { int ch ; printf ( \" \\n1.SORTED ORDER INSERTION\\n \" ) ; printf ( \" 2.SEQUENTIAL ORDER INSERTION\\n \" ) ; printf ( \" 3.EXIT PROGRAM\\n \" ) ; printf ( \" Enter your choice:  \" ) ; scanf ( \" %d \" , & ch ) ; if ( ch == 1 ) { printf ( \" \\n\\tSORTED ORDER\\n \" ) ; node * head = NULL ; int c ; while ( 1 ) { int c ; printf ( \" \\n1.ENTER AN INTEGER\\n \" ) ; printf ( \" 2.DELETE AN INTEGER\\n \" ) ; printf ( \" 3.DISPLAY CONTENT OF CIRCULAR LINK-LIST\\n \" ) ; printf ( \" 4.EXIT SORTED ORDER INSERTION\\n \" ) ; printf ( \" Enter your choice:  \" ) ; scanf ( \" %d \" , & c ) ; if ( c == 1 ) { int ingresado ; printf ( \" Please enter an element:  \" ) ; scanf ( \" %d \" , & ingresado ) ; sort_insertion ( & head , ingresado ) ; printf ( \" %d inserted using SORTED ORDER INSERTION.\\n \" , ingresado ) ; } else if ( c == 2 ) { if(head==NULL)printf(\"\\nCAN'T DELETE.LIST EMPTY\\n \" ) ; else { int ingresado ; printf ( \" \\nPlease enter the element to be deleted:  \" ) ; scanf ( \" %d \" , & ingresado ) ; node * delNode = search ( head , ingresado ) ; if(delNode==NULL)printf(\"COULDN'T DELETE %d.NOT FOUND IN LIST.\\n \" , ingresado ) ; else { deletion ( & head , delNode ) ; printf ( \" %d deleted from LIST.\\n \" , ingresado ) ; } } } else if ( c == 3 ) { if ( head == NULL ) printf ( \" \\n\\tLIST EMPTY\\n \" ) ; else { printf ( \" \\nDISPLAYING CONTENTS OF CIRCULAR LINK-LIST: \\n \" ) ; print ( head ) ; printf ( \" \\n \" ) ; } } else if ( c == 4 ) { printf ( \" \\nExitting Sorted Order Insertion, Thank You.\\n \" ) ; break ; } else printf ( \" \\nINVALID CHOICE! TRY AGAIN.\\n \" ) ; } } else if ( ch == 2 ) { printf ( \" \\n\\tSEQUENTIAL ORDER\\n \" ) ; node * head = NULL ; int c ; while ( 1 ) { int c ; printf ( \" \\n1.ENTER AN INTEGER\\n \" ) ; printf ( \" 2.DELETE AN INTEGER\\n \" ) ; printf ( \" 3.DISPLAY CONTENT OF CIRCULAR LINK-LIST\\n \" ) ; printf ( \" 4.EXIT SEQUENTAIL ORDER INSERTION\\n \" ) ; printf ( \" Enter your choice:  \" ) ; scanf ( \" %d \" , & c ) ; if ( c == 1 ) { int ingresado ; printf ( \" Please enter an element:  \" ) ; scanf ( \" %d \" , & ingresado ) ; seq_insertion ( & head , ingresado ) ; printf ( \" %d inserted using SEQUENTIAL ORDER INSERTION.\\n \" , ingresado ) ; } else if ( c == 2 ) { if(head==NULL)printf(\"\\nCAN'T DELETE.LIST EMPTY\\n \" ) ; else { int ingresado ; printf ( \" \\nPlease enter the element to be deleted:  \" ) ; scanf ( \" %d \" , & ingresado ) ; node * delNode = search ( head , ingresado ) ; if(delNode==NULL)printf(\"COULDN'T DELETE %d.NOT FOUND IN LIST.\\n \" , ingresado ) ; else { deletion ( & head , delNode ) ; printf ( \" %d deleted from LIST.\\n \" , ingresado ) ; } } } else if ( c == 3 ) { if ( head == NULL ) printf ( \" \\n\\tLIST EMPTY\\n \" ) ; else { printf ( \" \\nDISPLAYING CONTENTS OF CIRCULAR LINK-LIST: \\n \" ) ; print ( head ) ; printf ( \" \\n \" ) ; } } else if ( c == 4 ) { printf ( \" \\nExitting Sequential Order Insertion, Thank You.\\n \" ) ; break ; } else printf ( \" \\nINVALID CHOICE! TRY AGAIN.\\n \" ) ; } } else if ( ch == 3 ) { printf ( \" \\nExitting Program, Thank You.\\n \" ) ; break ; } else printf ( \" \\nINVALID CHOICE! TRY AGAIN.\\n \" ) ; } return 0 ; }"}
{"author": "revathy16296", "file": "rtos_assignment_b__string.0.c", "original_string": "int main()\n{\n    char str[SIZE];\n    int i,n=0,pid,fd[2],f1[2];\n    pipe(fd);\n    printf(\"enter the string with in 30 letter or else change the string size  in pgm:\\n\");\n    fgets(str,sizeof(str),stdin);\n    for(i=1;str[i]!='\\0';i++)\n        {\n        n++;\n        }\n    printf(\"the number of character in the string is %d\\n\",n);\n    pid=fork();\n    if (pid==0)\n    {\n        printf(\"inside the child process--------\\n\");\n        char b[SIZE],ch;\n        int n,vowel=0,i=0;\n        close(fd[1]);\n        read(fd[0],b,sizeof(b));\n        close(fd[0]);\n        n=strlen(b);\n        printf(\"the string gets to the child using pipes is :%s\\n\",b);\n        while(i<=n)\n        {\n            ch=b[i];\n            if(ch=='a'||ch=='e'||ch=='i'||ch=='o'||ch=='u'||ch=='A'||ch=='E'||ch=='I'||ch=='O'||ch=='U')\n            {vowel++;}\n            i++;\n        }\n        printf(\"the vowel count in the given string is %d\",vowel);\n    }\n    else{\n        close(fd[0]);\n    write(fd[1],str,sizeof(str));\n    close(fd[1]);\n        wait(NULL);\n        printf(\"\\n********back to parent process******!\");\n    }\n        return 0;\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { char cc [ SIZE ] ; int i , n = 0 , pid , fd [ 2 ] , f1 [ 2 ] ; pipe ( fd ) ; printf ( \" enter the string with in 30 letter or else change the string size  in pgm:\\n \" ) ; fgets ( cc , sizeof ( cc ) , stdin ) ; for ( i = 1 ; cc [ i ] != '\\0' ; i ++ ) { n ++ ; } printf ( \" the number of character in the string is %d\\n \" , n ) ; pid = fork ( ) ; if ( pid == 0 ) { printf ( \" inside the child process--------\\n \" ) ; char b [ SIZE ] , ch ; int n , vowel = 0 , i = 0 ; close ( fd [ 1 ] ) ; read ( fd [ 0 ] , b , sizeof ( b ) ) ; close ( fd [ 0 ] ) ; n = strlen ( b ) ; printf ( \" the string gets to the child using pipes is :%s\\n \" , b ) ; while ( i <= n ) { ch = b [ i ] ; if ( ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' || ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U' ) { vowel ++ ; } i ++ ; } printf ( \" the vowel count in the given string is %d \" , vowel ) ; } else { close ( fd [ 0 ] ) ; write ( fd [ 1 ] , cc , sizeof ( cc ) ) ; close ( fd [ 1 ] ) ; wait ( NULL ) ; printf ( \" \\n********back to parent process******! \" ) ; } return 0 ; }"}
{"author": "ashlyn2002", "file": "programming-using-c__merg_sort.2.c", "original_string": "void printarray(int a[],int n)\n{\n    int i;\n    for(i=0;i<n;i++)\n        printf(\"%d\\t\",a[i]);\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "void printarray ( int _members [ ] , int _n ) { int _i ; for ( _i = 0 ; _i < _n ; _i ++ ) printf ( \" %d\\t \" , _members [ _i ] ) ; }"}
{"author": "Mr-JoE1", "file": "Play-with-C__hex_to_dec.0.c", "original_string": "int main()\n{\n    char hex[32]={0};\n    int  dec,i;\n    int  cnt;   \n    int  dig;   \n    printf(\"Enter hex value: \");\n    gets(hex);\n    cnt=0;\n    dec=0;\n    for(i=(strlen(hex)-1);i>=0;i--)\n    {\n        switch(hex[i])\n        {\n            case 'A':\n                dig=10; break;\n            case 'B':\n                dig=11; break;\n            case 'C':\n                dig=12; break;\n            case 'D':\n                dig=13; break;\n            case 'E':\n                dig=14; break;\n            case 'F':\n                dig=15; break;\n            default:\n                dig=hex[i]-0x30;\n        }\n        dec= dec+ (dig)*pow((double)16,(double)cnt);\n        cnt++;\n    }\n    printf(\"DECIMAL value is: %d\",dec);\n    return 0;\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { char hex [ 32 ] = { 0 } ; int dec , sem ; int cnt ; int dig ; printf ( \" Enter hex value:  \" ) ; gets ( hex ) ; cnt = 0 ; dec = 0 ; for ( sem = ( strlen ( hex ) - 1 ) ; sem >= 0 ; sem -- ) { switch ( hex [ sem ] ) { case 'A' : dig = 10 ; break ; case 'B' : dig = 11 ; break ; case 'C' : dig = 12 ; break ; case 'D' : dig = 13 ; break ; case 'E' : dig = 14 ; break ; case 'F' : dig = 15 ; break ; default : dig = hex [ sem ] - 0x30 ; } dec = dec + ( dig ) * pow ( ( double ) 16 , ( double ) cnt ) ; cnt ++ ; } printf ( \" DECIMAL value is: %d \" , dec ) ; return 0 ; }"}
{"author": "paawankohli", "file": "DSA-LAB__dequeue.3.c", "original_string": "int dequeueright(queue *q)\n{\n    if (q->front==q->rear)\n    {\n        printf(\"Queue Empty\");\n        return -1;\n    }\n    else\n        return q->c[--(q->rear)];\n}", "watermark": [0, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "int dequeueright ( queue * _in ) { if ( _in -> front == _in -> rear ) { printf ( \" Queue Empty \" ) ; return - 1 ; } else return _in -> c [ -- ( _in -> rear ) ] ; }"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_CLL.5.c", "original_string": "void insert_end()\n{\n    struct node *newnode,*temp;\n    newnode=(struct node *)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    if(head==0)\n    {\n        head=newnode;\n        newnode->next=newnode;\n    }\n    else\n    {\n        temp=head;\n        while(temp->next!=head)\n        {\n            temp=temp->next;\n        }\n        newnode->next=head;\n        temp->next=newnode;\n    }\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void insert_end ( ) { struct node * _email , * _temp ; _email = ( struct node * ) malloc ( sizeof ( struct node ) ) ; printf ( \" enter the data = \" ) ; scanf ( \" %d \" , & _email -> data ) ; if ( head == 0 ) { head = _email ; _email -> next = _email ; } else { _temp = head ; while ( _temp -> next != head ) { _temp = _temp -> next ; } _email -> next = head ; _temp -> next = _email ; } }"}
{"author": "bgmanuel99", "file": "PracticasSistemasOperativos__ejercicio20.2.c", "original_string": "int main(int argc, char const *argv[])\n{\n    pthread_t hilo1,hilo2;\n    time_t t;\n    srandom(time(&t));\n    sem_init(&semaforo,0,10);\n    while(1){\n        pthread_create(&hilo1,NULL, *fhilo1,NULL);\n        pthread_create(&hilo2,NULL, *fhilo2,NULL);\n        if(buffer[0] == 0) pthread_join(hilo1,NULL);\n        else pthread_join(hilo2,NULL);\n    }\n    sem_destroy(&semaforo);\n    return 0;\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( int _packet , char const * _argv [ ] ) { pthread_t _hilo1 , _hilo2 ; time_t _t ; srandom ( time ( & _t ) ) ; sem_init ( & semaforo , 0 , 10 ) ; while ( 1 ) { pthread_create ( & _hilo1 , NULL , * fhilo1 , NULL ) ; pthread_create ( & _hilo2 , NULL , * fhilo2 , NULL ) ; if ( buffer [ 0 ] == 0 ) pthread_join ( _hilo1 , NULL ) ; else pthread_join ( _hilo2 , NULL ) ; } sem_destroy ( & semaforo ) ; return 0 ; }"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__ssh_server.0.c", "original_string": "void sshServerGetDefaultSettings(SshServerSettings *settings)\n{\n   settings->interface = NULL;\n   settings->port = SSH_PORT;\n   settings->numConnections = 0;\n   settings->connections = NULL;\n   settings->numChannels = 0;\n   settings->channels = NULL;\n   settings->prngAlgo = NULL;\n   settings->prngContext = NULL;\n   settings->passwordAuthCallback = NULL;\n   settings->publicKeyAuthCallback = NULL;\n}", "watermark": [1, 1, 1, 1], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "void sshServerGetDefaultSettings ( SshServerSettings * Sir ) { Sir -> interface = NULL ; Sir -> port = SSH_PORT ; Sir -> numConnections = 0 ; Sir -> connections = NULL ; Sir -> numChannels = 0 ; Sir -> channels = NULL ; Sir -> prngAlgo = NULL ; Sir -> prngContext = NULL ; Sir -> passwordAuthCallback = NULL ; Sir -> publicKeyAuthCallback = NULL ; }"}
{"author": "andi-s0106", "file": "sorting_algorithms__1-insertion_sort_list.0.c", "original_string": "void insertion_sort_list(listint_t **list)\n{\n    listint_t *current;\n    listint_t *sorted;\n    if (list == NULL || *list == NULL || (*list)->next == NULL)\n        return;\n    sorted = *list;\n    current = (*list)->next;\n    while (current != NULL)\n    {\n        if (sorted != NULL &&  current->n < sorted->n)\n        {\n            current = swap(&current, &sorted);\n            sorted = current->prev;\n            if (sorted == NULL)\n                *list = current;\n            print_list(*list);\n            while (sorted != NULL && current->n < sorted->n)\n            {\n                current = swap(&current, &sorted);\n                sorted = current->prev;\n                if (sorted == NULL)\n                    *list = current;\n                print_list(*list);\n            }\n        }\n        else\n        {\n            sorted = current;\n            current = sorted->next;\n        }\n    }\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "void insertion_sort_list ( listint_t * * _list ) { listint_t * _current ; listint_t * _tabana ; if ( _list == NULL || * _list == NULL || ( * _list ) -> next == NULL ) return ; _tabana = * _list ; _current = ( * _list ) -> next ; while ( _current != NULL ) { if ( _tabana != NULL && _current -> n < _tabana -> n ) { _current = swap ( & _current , & _tabana ) ; _tabana = _current -> prev ; if ( _tabana == NULL ) * _list = _current ; print_list ( * _list ) ; while ( _tabana != NULL && _current -> n < _tabana -> n ) { _current = swap ( & _current , & _tabana ) ; _tabana = _current -> prev ; if ( _tabana == NULL ) * _list = _current ; print_list ( * _list ) ; } } else { _tabana = _current ; _current = _tabana -> next ; } } }"}
{"author": "paawankohli", "file": "DSA-LAB__ip2.0.c", "original_string": "NODE insert(NODE first,int e,int pr)\n{\n    NODE temp=(NODE)malloc(sizeof(struct node));\n    temp->data=e;\n    temp->next=NULL;\n    if (first==NULL)\n        return temp;\n    else if(first->next==NULL)\n    {\n        if (first->data>e)\n        {\n            temp->next=first;\n            return temp;\n        }\n        else if(first->data<e)\n            first->next=temp;\n        else\n        {\n            if (pr==1)\n                printf(\"Input not unique\\n\");\n            free(temp);\n        }\n    }\n    else\n    {\n        NODE m=first;\n        while(m->next!=NULL && m->next->data<=e)\n            m=m->next;\n        if (m->data!=e)\n        {\n            temp->next=m->next;\n            m->next=temp;\n        }\n        else\n        {\n            if (pr==1)\n                printf(\"Input not unique\\n\");\n            free(temp);\n        }\n        return first;\n    }\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "NODE insert ( NODE espaços , int e , int pr ) { NODE temp = ( NODE ) malloc ( sizeof ( struct node ) ) ; temp -> data = e ; temp -> next = NULL ; if ( espaços == NULL ) return temp ; else if ( espaços -> next == NULL ) { if ( espaços -> data > e ) { temp -> next = espaços ; return temp ; } else if ( espaços -> data < e ) espaços -> next = temp ; else { if ( pr == 1 ) printf ( \" Input not unique\\n \" ) ; free ( temp ) ; } } else { NODE m = espaços ; while ( m -> next != NULL && m -> next -> data <= e ) m = m -> next ; if ( m -> data != e ) { temp -> next = m -> next ; m -> next = temp ; } else { if ( pr == 1 ) printf ( \" Input not unique\\n \" ) ; free ( temp ) ; } return espaços ; } }"}
{"author": "MartinMarinovich", "file": "MarinovichMartinLABIPP1G-__marca.2.c", "original_string": "int listarMarcas(eMarca listaDeMarcas[], int tamanio)\n{\n    int error = -1;\n    if(listaDeMarcas !=NULL && tamanio>0)\n    {\n        system(\"cls\");\n        printf(\"\\n****  LISTADO DE MARCAS  ****\\n\");\n        printf(\" Id       Descripcion\\n\");\n        printf(\"----------------------------------\\n\");\n        for(int i = 0 ; i<tamanio; i++)\n        {\n            mostrarMarca(listaDeMarcas[i]);\n        }\n        error = 0;\n    }\n    return error;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int listarMarcas ( eMarca ingresado [ ] , int tamanio ) { int Error = - 1 ; if ( ingresado != NULL && tamanio > 0 ) { system ( \" cls \" ) ; printf ( \" \\n****  LISTADO DE MARCAS  ****\\n \" ) ; printf ( \"  Id       Descripcion\\n \" ) ; printf ( \" ----------------------------------\\n \" ) ; for ( int i = 0 ; i < tamanio ; i ++ ) { mostrarMarca ( ingresado [ i ] ) ; } Error = 0 ; } return Error ; }"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__p.1.c", "original_string": "void    ft_print_char(unsigned char c)\n{\n    if (c >= ' ' && c <= '~')\n        write(1, &c, 1);\n    else\n        write(1, \".\", 1);\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "void ft_print_char ( unsigned char cc ) { if ( cc >= '' && cc <= '~' ) write ( 1 , & cc , 1 ) ; else write ( 1 , \" . \" , 1 ) ; }"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__example41.0.c", "original_string": "int main()\n{\n  int num1,num2,ek=0;\n  printf(\"%s\\n\",\"EKOK almak istediğiniz iki pozitif tam sayı giriniz:\");\n  scanf(\"%d%d\",&num1,&num2);\n  if(num1>num2)\n    ek=ekok(num1,num2);\n  else\n    ek=ekok(num2,num1);\n  printf(\"girilen değerlerin EKOK u:%d\\n\",ek);  \n  return 0;\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int _packet , _num2 , _ek = 0 ; printf ( \" %s\\n \" , \" EKOK almak istediğiniz iki pozitif tam sayı giriniz: \" ) ; scanf ( \" %d%d \" , & _packet , & _num2 ) ; if ( _packet > _num2 ) _ek = ekok ( _packet , _num2 ) ; else _ek = ekok ( _num2 , _packet ) ; printf ( \" girilen değerlerin EKOK u:%d\\n \" , _ek ) ; return 0 ; }"}
{"author": "Sowmyamithra", "file": "Data-Structures__BTree.6.c", "original_string": "void removeVal(struct btreeNode *myNode, int pos) {\n        int i = pos + 1;\n        while (i <= myNode->count) {\n                myNode->val[i - 1] = myNode->val[i];\n                myNode->link[i - 1] = myNode->link[i];\n                i++;\n        }\n        myNode->count--;\n  }", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "void removeVal ( struct btreeNode * _my_node , int _pos ) { int _successor = _pos + 1 ; while ( _successor <= _my_node -> count ) { _my_node -> val [ _successor - 1 ] = _my_node -> val [ _successor ] ; _my_node -> link [ _successor - 1 ] = _my_node -> link [ _successor ] ; _successor ++ ; } _my_node -> count -- ; }"}
{"author": "dishanp", "file": "DSA__q63.1.c", "original_string": "void insert(struct node_freq *p, int index, int key)\n{\n    struct node_freq *t = (struct node_freq *)malloc(sizeof(struct node_freq));\n    t->data = key;\n    t->freq = 0;\n    if(index == 0)\n    {\n        t->next = head;\n        head = t;\n    }\n    else\n    {\n        for(int i = 0 ; i < index - 1 ; i++)\n        {\n            p = p->next;\n        }\n        t->next = p->next;\n        p->next = t;\n    }\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void insert ( struct node_freq * _p , int _reuseaddr , int _key ) { struct node_freq * _t = ( struct node_freq * ) malloc ( sizeof ( struct node_freq ) ) ; _t -> data = _key ; _t -> freq = 0 ; if ( _reuseaddr == 0 ) { _t -> next = head ; head = _t ; } else { for ( int _i = 0 ; _i < _reuseaddr - 1 ; _i ++ ) { _p = _p -> next ; } _t -> next = _p -> next ; _p -> next = _t ; } }"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__server_arhcive_select.0.c", "original_string": "void *get_in_addr(struct sockaddr *sa)\n{\n    if (sa->sa_family == AF_INET) {\n        return &(((struct sockaddr_in*)sa)->sin_addr);\n    }\n    return &(((struct sockaddr_in6*)sa)->sin6_addr);\n}", "watermark": [0, 1, 1, 1], "extract": [0, 1, 1, 1], "output_original_func": false, "after_watermark": "void * TAT ( struct sockaddr * sa ) { if ( sa -> sa_family == AF_INET ) { return & ( ( ( struct sockaddr_in * ) sa ) -> sin_addr ) ; } return & ( ( ( struct sockaddr_in6 * ) sa ) -> sin6_addr ) ; }"}
{"author": "earth429", "file": "mulpre__mulprec.1.c", "original_string": "void dispNumber(struct NUMBER *a){\n    int i;\n    if(getSign(a) == 1){\n        printf(\"+\");\n    } else {\n        printf(\"-\");\n    }\n    for (i = KETA - 1; i >= 0;i--){\n        printf(\"%2d\", a->n[i]);\n    }\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "void dispNumber ( struct NUMBER * A ) { int I ; if ( getSign ( A ) == 1 ) { printf ( \" + \" ) ; } else { printf ( \" - \" ) ; } for ( I = tabana - 1 ; I >= 0 ; I -- ) { printf ( \" %2d \" , A -> n [ I ] ) ; } }"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__BB.0.c", "original_string": "int main()\n{\n    char str[31];\n    long int tam, soma = 0, pot;\n    fgets(str, 31, stdin);\n    for (int i=0; str[i] != '\\0'; i++)\n    {\n        if (str[i] == '\\n')\n        {\n            str[i] = '\\0';\n        }\n    }\n    tam = strlen(str);\n    pot = tam-1;\n    for (int i=0; i<tam; i++)\n    {\n        if (str[i] == '1')\n        {\n            soma += pow(2,(pot-i));\n        }\n    }\n    printf(\"%li\\n\", soma);\n    return 0;\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { char _str [ 31 ] ; long int _tam , _soma = 0 , _values ; fgets ( _str , 31 , stdin ) ; for ( int _i = 0 ; _str [ _i ] != '\\0' ; _i ++ ) { if ( _str [ _i ] == '\\n' ) { _str [ _i ] = '\\0' ; } } _tam = strlen ( _str ) ; _values = _tam - 1 ; for ( int _i = 0 ; _i < _tam ; _i ++ ) { if ( _str [ _i ] == '1' ) { _soma += pow ( 2 , ( _values - _i ) ) ; } } printf ( \" %li\\n \" , _soma ) ; return 0 ; }"}
{"author": "dishanp", "file": "DSA__q35.2.c", "original_string": "void reverse_m(struct node *p, int m)\n{\n    int counter = 0;\n    struct node *q = NULL;\n    struct node *r = NULL;\n    while(counter < m)\n    {\n        r = q;\n        q = p;\n        p = p->next;\n        q->next = r;\n        counter++;\n    }\n    first = q;\n    while(q->next != NULL)\n    {\n        q = q->next;\n    }\n    q->next = p;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "void reverse_m ( struct node * _p , int _m ) { int _counter = 0 ; struct node * _q = NULL ; struct node * _ingresado = NULL ; while ( _counter < _m ) { _ingresado = _q ; _q = _p ; _p = _p -> next ; _q -> next = _ingresado ; _counter ++ ; } first = _q ; while ( _q -> next != NULL ) { _q = _q -> next ; } _q -> next = _p ; }"}
{"author": "2security", "file": "File__3WriteEvenOddPrimeNumSepFile.2.c", "original_string": "int main()\n    {\n        FILE *fptr,*eptr,*optr,*pptr;\n        int n;\n        fptr=fopen(\"File3.txt\",\"r\");\n        eptr=fopen(\"FIle3Even.txt\",\"w\");\n        optr=fopen(\"FIle3Odd.txt\",\"w\");\n        pptr=fopen(\"FIle3Prime.txt\",\"w\");\n        if(fptr==NULL||eptr==NULL||optr==NULL||pptr==NULL)\n            {\n                perror(\"File openning error(:\");\n                getch();\n                exit(0);\n            }\n        while(fscanf(fptr,\"%d\",&n)!=EOF)\n            {\n                if(isPrime(n))\n                    fprintf(pptr,\"%d \",n);\n                if(isEven(n))\n                    fprintf(eptr,\"%d \",n);\n                else\n                    fprintf(optr,\"%d \",n);  \n            }\n        printf(\"\\n Successfully written into file...\");\n        fclose(fptr);\n        fclose(eptr);\n        fclose(optr);\n        fclose(pptr);\n        return 0;\n    }", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { FILE * Fptr , * Times , * Optr , * Pptr ; int N ; Fptr = fopen ( \" File3.txt \" , \" r \" ) ; Times = fopen ( \" FIle3Even.txt \" , \" w \" ) ; Optr = fopen ( \" FIle3Odd.txt \" , \" w \" ) ; Pptr = fopen ( \" FIle3Prime.txt \" , \" w \" ) ; if ( Fptr == NULL || Times == NULL || Optr == NULL || Pptr == NULL ) { perror ( \" File openning error(: \" ) ; getch ( ) ; exit ( 0 ) ; } while ( fscanf ( Fptr , \" %d \" , & N ) != EOF ) { if ( isPrime ( N ) ) fprintf ( Pptr , \" %d  \" , N ) ; if ( isEven ( N ) ) fprintf ( Times , \" %d  \" , N ) ; else fprintf ( Optr , \" %d  \" , N ) ; } printf ( \" \\n Successfully written into file... \" ) ; fclose ( Fptr ) ; fclose ( Times ) ; fclose ( Optr ) ; fclose ( Pptr ) ; return 0 ; }"}
{"author": "fikepaci", "file": "sorting_algorithms__1-insertion_sort_list.1.c", "original_string": "void swap_forward(listint_t *c)\n{\n    listint_t *tmp, *head;\n    tmp = c->prev;\n    if (tmp != NULL)\n    {\n        tmp->next = c->next;\n        c->next->prev = tmp;\n    }\n    else\n        c->next->prev = NULL;\n    c->prev = c->next;\n    if (c->next->next != NULL)\n    {\n        c->next = c->next->next;\n        c->prev->next = c;\n        c->next->prev = c;\n    }\n    else\n    {\n        c->next->next = c;\n        c->next = NULL;\n    }\n    head = c;\n    while (head->prev != NULL)\n        head = head->prev;\n    print_list(head);\n    swap_backward(c->prev);\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "void swap_forward ( listint_t * c ) { listint_t * quantity , * head ; quantity = c -> prev ; if ( quantity != NULL ) { quantity -> next = c -> next ; c -> next -> prev = quantity ; } else c -> next -> prev = NULL ; c -> prev = c -> next ; if ( c -> next -> next != NULL ) { c -> next = c -> next -> next ; c -> prev -> next = c ; c -> next -> prev = c ; } else { c -> next -> next = c ; c -> next = NULL ; } head = c ; while ( head -> prev != NULL ) head = head -> prev ; print_list ( head ) ; swap_backward ( c -> prev ) ; }"}
{"author": "deepaliajabsingjadhav", "file": "file__copy_file.1.c", "original_string": "int main()\n{\n    char name1[20];\n    char name2[20];\n    printf(\"Enter source file name\\n\");\n    scanf(\"%s\",name1);\n    printf(\"Enter destination file name\\n\");\n    scanf(\"%s\",name2);\n    FileCopy(name1,name2);\n    return 0;\n}", "watermark": [0, 1, 1, 1], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { char name1 [ 20 ] ; char temperature [ 20 ] ; printf ( \" Enter source file name\\n \" ) ; scanf ( \" %s \" , name1 ) ; printf ( \" Enter destination file name\\n \" ) ; scanf ( \" %s \" , temperature ) ; FileCopy ( name1 , temperature ) ; return 0 ; }"}
{"author": "davibernardos", "file": "DB-PJ__e90.1.c", "original_string": "int comparar (char captchalido [6], char captchaescrito [6])\n{\n    int cont;\n    int diferenca;\n    diferenca = 0;\n    for ( cont = 0; cont <6; cont++)\n    {\n        if (captchalido [cont]   != captchaescrito [cont])\n        {\n            diferenca ++;\n        }\n    }\n        if (diferenca > 0){\n            return 1;\n        }\n        else {\n            return 0;\n        }\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int comparar ( char captchalido [ 6 ] , char ingresado [ 6 ] ) { int cont ; int diferenca ; diferenca = 0 ; for ( cont = 0 ; cont < 6 ; cont ++ ) { if ( captchalido [ cont ] != ingresado [ cont ] ) { diferenca ++ ; } } if ( diferenca > 0 ) { return 1 ; } else { return 0 ; } }"}
{"author": "davibernardos", "file": "DB-PJ__e62.1.c", "original_string": "void cadastrarEvento()\n{\n    fflush(stdin);\n    printf(\"\\t-Digite o nome do evento: \");\n    gets(nomeEvento[contEvento]);\n    fflush(stdin);\n    printf(\"\\n\\t-Informe a capacidade maxima de pessoas: \");\n    scanf(\"%d\", &capacidadeMax);\n    capacidade[contEvento] = capacidadeMax;\n    capacidadeMeia = 0.4*capacidadeMax;\n    capacidadeInteira = 0.6*capacidadeMax;\n    capacidadeI[contEvento] = capacidadeInteira;\n    capacidadeM[contEvento] = capacidadeMeia;\n    printf(\"\\n\\t-Digite o valor de cada ingresso: \");\n    scanf(\"%g\", &valorIngresso);\n    preco[contEvento] = valorIngresso;\n        contEvento++;   \n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "void cadastrarEvento ( ) { fflush ( stdin ) ; printf ( \" \\t-Digite o nome do evento:  \" ) ; gets ( nomeEvento [ contEvento ] ) ; fflush ( stdin ) ; printf ( \" \\n\\t-Informe a capacidade maxima de pessoas:  \" ) ; scanf ( \" %d \" , & capacidadeMax ) ; capacidade [ contEvento ] = capacidadeMax ; capacidadeMeia = 0.4 * capacidadeMax ; capacidadeInteira = 0.6 * capacidadeMax ; capacidadeI [ contEvento ] = capacidadeInteira ; capacidadeM [ contEvento ] = capacidadeMeia ; printf ( \" \\n\\t-Digite o valor de cada ingresso:  \" ) ; scanf ( \" %g \" , & email ) ; preco [ contEvento ] = email ; contEvento ++ ; }"}
{"author": "ankitraj311", "file": "C_Basic_programming__24_delet_specific_ex.0.c", "original_string": "int main()\n{\n  int i,j,k,array1[100],array2[100],no=0,delete_no=0,delete_index=0;\n  printf(\"Enter Length of Array\");\n  scanf(\"%d\",&no);\n  for(i=0; i<no; i++)\n  {\n    scanf(\"%d\",&array1[i]);\n  }\n  for(i=0; i<no; i++)\n  {\n    printf(\"%d \",array1[i]);\n  }\n  printf(\"Enter number to delete it from Array\\n\");\n  scanf(\"%d\",&delete_no);\n  for(i=0; i<no; i++)\n  {\n    if(array1[i] == delete_no)\n    {\n      printf(\"Number is %d Index is %d\",array1[i],i);\n      delete_index = i;\n    }\n  }\n  printf(\"\\n\");\n  for(j=0; j<no-1; j++)\n  {\n    if(j < delete_index)\n    {\n      array2[j] = array1[j];\n    }\n    if(j >= delete_index)\n    {\n      array2[j] = array1[j+1];\n    }\n  }\n  printf(\"\\n\");\n  for(i=0; i<no-1; i++)\n  {\n    printf(\"%d \",array2[i]);\n  }\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int i , j , k , percorri [ 100 ] , array2 [ 100 ] , no = 0 , delete No = 0 , delete Index = 0 ; printf ( \" Enter Length of Array \" ) ; scanf ( \" %d \" , & no ) ; for ( i = 0 ; i < no ; i ++ ) { scanf ( \" %d \" , & percorri [ i ] ) ; } for ( i = 0 ; i < no ; i ++ ) { printf ( \" %d  \" , percorri [ i ] ) ; } printf ( \" Enter number to delete it from Array\\n \" ) ; scanf ( \" %d \" , & delete No ) ; for ( i = 0 ; i < no ; i ++ ) { if ( percorri [ i ] == delete No ) { printf ( \" Number is %d Index is %d \" , percorri [ i ] , i ) ; delete Index = i ; } } printf ( \" \\n \" ) ; for ( j = 0 ; j < no - 1 ; j ++ ) { if ( j < delete Index ) { array2 [ j ] = percorri [ j ] ; } if ( j >= delete Index ) { array2 [ j ] = percorri [ j + 1 ] ; } } printf ( \" \\n \" ) ; for ( i = 0 ; i < no - 1 ; i ++ ) { printf ( \" %d  \" , array2 [ i ] ) ; } }"}
{"author": "sdukesameer", "file": "dsa__bfs.3.c", "original_string": "int dequeue(queue* q){\n    int ret=q->items[0];\n    for(int i=0; i<q->end; i++)\n        q->items[i]=q->items[i+1];\n    q->end--;\n    return ret;\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "int dequeue ( queue * _q ) { int _ret = _q -> items [ 0 ] ; for ( int _times = 0 ; _times < _q -> end ; _times ++ ) _q -> items [ _times ] = _q -> items [ _times + 1 ] ; _q -> end -- ; return _ret ; }"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__5.0.c", "original_string": "int main(int argc, char **argv)\n{\n    FILE *arq_1, *arq_2;\n    char aux, *str_1, *str_2;\n    int n, m;\n    float **matriz, aux_2, *texto;\n    if (argc < 3)\n    {\n        printf(\"\\nErro! Não foram informados arquivos o suficiente\\n\\n\");\n        return 0;\n    }\n    arq_1 = fopen(argv[1], \"r\");\n    arq_2 = fopen(argv[2], \"w\");\n    if (arq_1 == NULL || arq_2 == NULL)\n    {\n        printf(\"\\nErro ao abrir o arquivo.\\n\\n\");\n        return 0;\n    }\n    int i = 0;\n    while (fscanf(arq_1, \"%f\", &aux_2) != EOF)\n    {\n        i++;\n    }\n    printf(\"\\ni = %i\\n\", i);\n    texto = malloc(i * sizeof(float));\n    rewind(arq_1);\n    for (int j = 0; j < i; j++)\n    {\n        fscanf(arq_1, \"%f\", texto+j);\n    }\n    n = texto[0];\n    m = texto[1];\n    matriz = malloc(n * sizeof(float*));\n    for (int i = 0; i < n; i++)\n    {\n        matriz[i] = malloc(m * sizeof(float));\n    }\n    for (int i = 0, k = 0; i < n; i++)\n    {\n        for (int  j = 0; j < m; j++)\n        {\n            matriz[i][j] = texto[k+2];\n            k++;\n        }\n    }\n    for (int i = 0; i < m; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            fprintf(arq_2, \"%f \", matriz[j][i]);\n        }\n        fprintf(arq_2, \"%c\", '\\n');\n    }\n    return 0;\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( int _argc , char * * _argv ) { FILE * _arq_1 , * _arq_2 ; char _aux , * _str_1 , * _str_2 ; int _n , _m ; float * * _sem , _aux_2 , * _texto ; if ( _argc < 3 ) { printf ( \" \\nErro! Não foram informados arquivos o suficiente\\n\\n \" ) ; return 0 ; } _arq_1 = fopen ( _argv [ 1 ] , \" r \" ) ; _arq_2 = fopen ( _argv [ 2 ] , \" w \" ) ; if ( _arq_1 == NULL || _arq_2 == NULL ) { printf ( \" \\nErro ao abrir o arquivo.\\n\\n \" ) ; return 0 ; } int _i = 0 ; while ( fscanf ( _arq_1 , \" %f \" , & _aux_2 ) != EOF ) { _i ++ ; } printf ( \" \\ni = %i\\n \" , _i ) ; _texto = malloc ( _i * sizeof ( float ) ) ; rewind ( _arq_1 ) ; for ( int _j = 0 ; _j < _i ; _j ++ ) { fscanf ( _arq_1 , \" %f \" , _texto + _j ) ; } _n = _texto [ 0 ] ; _m = _texto [ 1 ] ; _sem = malloc ( _n * sizeof ( float * ) ) ; for ( int _i = 0 ; _i < _n ; _i ++ ) { _sem [ _i ] = malloc ( _m * sizeof ( float ) ) ; } for ( int _i = 0 , _k = 0 ; _i < _n ; _i ++ ) { for ( int _j = 0 ; _j < _m ; _j ++ ) { _sem [ _i ] [ _j ] = _texto [ _k + 2 ] ; _k ++ ; } } for ( int _i = 0 ; _i < _m ; _i ++ ) { for ( int _j = 0 ; _j < _n ; _j ++ ) { fprintf ( _arq_2 , \" %f  \" , _sem [ _j ] [ _i ] ) ; } fprintf ( _arq_2 , \" %c \" , '\\n' ) ; } return 0 ; }"}
{"author": "deessee0", "file": "Appunti-C__SommaArray.1.c", "original_string": "int somma(int v[], int dim)\n    {\n        int tot=0;\n        int i=0;\n        for(i=0;i<dim;i++)\n        {\n            tot += v[i]; \n        }\n        return tot;\n    }", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int somma ( int _v [ ] , int _dim ) { int _tot = 0 ; int _tabana = 0 ; for ( _tabana = 0 ; _tabana < _dim ; _tabana ++ ) { _tot += _v [ _tabana ] ; } return _tot ; }"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es31.2.c", "original_string": "void calcolo_area(float *perimetro, float ac, float *ipotenusa, float *bc, float *area)\n{\n    double parziale = (*perimetro/2) * (*perimetro/2 - ac) * (*perimetro/2 - *ipotenusa) * (*perimetro/2 - *bc);\n    *area = sqrt(parziale);\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "void calcolo_area ( float * perimetro , float ac , float * ipotenusa , float * bc , float * area ) { double values = ( * perimetro / 2 ) * ( * perimetro / 2 - ac ) * ( * perimetro / 2 - * ipotenusa ) * ( * perimetro / 2 - * bc ) ; * area = sqrt ( values ) ; }"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__str_len.2.c", "original_string": "int main()\n{\n    int iRet = 0;\n    char Arr[30] = {'\\0'};\n    printf(\"Enter string\\n\");\n    scanf(\"%[^'\\n']s\",Arr);\n    iRet = StrlenR(Arr);\n    printf(\"Length is %d\\n\\n\",iRet);\n    return 0;\n}", "watermark": [0, 1, 1, 1], "extract": [0, 1, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { int iRet = 0 ; char running [ 30 ] = { '\\0' } ; printf ( \" Enter string\\n \" ) ; scanf ( \" %[^'\\n']s \" , running ) ; iRet = StrlenR ( running ) ; printf ( \" Length is %d\\n\\n \" , iRet ) ; return 0 ; }"}
{"author": "2security", "file": "String__30SearchAlloccurrence.1.c", "original_string": "void KMPAlgorithm(char* text, char* pattern) {\n   int M = strlen(pattern),c=0;\n   int N = strlen(text);\n   int pps[M];\n   prefixSuffixArray(pattern, M, pps);\n   int i = 0;\n   int j = 0;\n   while (i < N) {\n      if (pattern[j] == text[i]) {\n         j++;\n         i++;\n      }\n      if (j == M) {\n         c++;\n         j = pps[j - 1];\n      }\n      else if (i < N && pattern[j] != text[i]) {\n         if (j != 0)\n         j = pps[j - 1];\n         else\n         i = i + 1;\n      }\n   }\nprintf(\"\\n No of matching occurence is:=%d\",c);\n}", "watermark": [1, 1, 0, 1], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void KMPAlgorithm ( char * _text , char * _pattern ) { int _m = strlen ( _pattern ) , _c = 0 ; int _n = strlen ( _text ) ; int _pps [ _m ] ; prefixSuffixArray ( _pattern , _m , _pps ) ; int _i = 0 ; int _temperature = 0 ; while ( _i < _n ) { if ( _pattern [ _temperature ] == _text [ _i ] ) { _temperature ++ ; _i ++ ; } if ( _temperature == _m ) { _c ++ ; _temperature = _pps [ _temperature - 1 ] ; } else if ( _i < _n && _pattern [ _temperature ] != _text [ _i ] ) { if ( _temperature != 0 ) _temperature = _pps [ _temperature - 1 ] ; else _i = _i + 1 ; } } printf ( \" \\n No of matching occurence is:=%d \" , _c ) ; }"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_01.2.c", "original_string": "int search(int A[],int n,int k)\n{\n int i;\n for(i=0;i<n;i++)\n   if(A[i]==k)\n     return i;\n   return -1;\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "int search ( int _a [ ] , int _n , int _k ) { int _temperature ; for ( _temperature = 0 ; _temperature < _n ; _temperature ++ ) if ( _a [ _temperature ] == _k ) return _temperature ; return - 1 ; }"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__adc_sw_cntl.0.c", "original_string": "int main()\n{\n    int res,done = 1;\n    PINSEL1 |= 1<<24;\n    PINSEL1 &= ~(1<<25); \n    lcd_config();\n    ADCR = (1<<1)|(4<<8)|(1<<21)|(1<<24);  \n    while(1)\n    {\n        while(!(ADDR & (done<<31)));\n        res = ADDR & (0x3FF<<6);   \n        res = res>>6;                               \n        res = res/3.3;  \n        lcd_num(res);\n        delay(1000);\n    }\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { int ingresado , done = 1 ; PINSEL1 |= 1 << 24 ; PINSEL1 &= ~ ( 1 << 25 ) ; lcd_config ( ) ; ADCR = ( 1 << 1 ) | ( 4 << 8 ) | ( 1 << 21 ) | ( 1 << 24 ) ; while ( 1 ) { while ( ! ( ADDR & ( done << 31 ) ) ) ; ingresado = ADDR & ( 0x3FF << 6 ) ; ingresado = ingresado >> 6 ; ingresado = ingresado / 3.3 ; lcd_num ( ingresado ) ; delay ( 1000 ) ; } }"}
{"author": "apoorvasrivastava98", "file": "DAA__HeapSort.5.c", "original_string": "void heapsort(int a[100],int n)\n    {\n        int temp,i;\n        count++;\n        build_max_heap(a,n);\n        count++;\n        for(i=n-1;i>0;i--)\n        {\n            count++;\n            temp=a[0];\n            count++;\n            a[0]=a[i];\n            count++;\n            a[i]=temp;\n            count++;\n            max_heapify(a,i,0);\n            count++;\n        }\n    }", "watermark": [0, 1, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "void heapsort ( int a [ 100 ] , int espaços ) { int temp , i ; count ++ ; build_max_heap ( a , espaços ) ; count ++ ; for ( i = espaços - 1 ; i > 0 ; i -- ) { count ++ ; temp = a [ 0 ] ; count ++ ; a [ 0 ] = a [ i ] ; count ++ ; a [ i ] = temp ; count ++ ; max_heapify ( a , i , 0 ) ; count ++ ; } }"}
{"author": "HakNinja", "file": "C-Advance__4nested_str.0.c", "original_string": "int main()\n{\n    int u;\n    struct student x;\n    printf(\"Enter Details:\\n\");\n    printf(\"Enter roll number:\");\n    scanf(\"%d\",&x.rno);\n    printf(\"Enter name of student\");\n    printf(\"\\nFirst name:\");\n    scanf(\"%s\",&x.name.fn);\n    printf(\"Middle name:\");\n    scanf(\"%s\",&x.name.mn);\n    printf(\"Last name:\");\n    scanf(\"%s\",&x.name.ln);\n    printf(\"Enter Date Of Birth\");\n    printf(\"\\nDate:\");\n    scanf(\"%d\",&x.dob.d);\n    printf(\"Month:\");\n    scanf(\"%d\",&x.dob.m);\n    printf(\"Year:\");\n    scanf(\"%d\",&x.dob.y);\n    printf(\"Percentage:\");\n    scanf(\"%f\",&x.per);\n    printf(\"\\n--------------------------------------------------------------------------\");\n    printf(\"\\nRoll number:%d\\n\",x.rno);\n    printf(\"\\nName:%s %s %s\\n\",x.name.fn,x.name.mn,x.name.ln);\n    printf(\"DoB:%d/%d/%d\\n\",x.dob.d,x.dob.m,x.dob.y);\n    printf(\"Percentage:%f\\n\",x.per);\n    return(0);\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int REUSEADDR ; struct student x ; printf ( \" Enter Details:\\n \" ) ; printf ( \" Enter roll number: \" ) ; scanf ( \" %d \" , & x.rno ) ; printf ( \" Enter name of student \" ) ; printf ( \" \\nFirst name: \" ) ; scanf ( \" %s \" , & x.name.fn ) ; printf ( \" Middle name: \" ) ; scanf ( \" %s \" , & x.name.mn ) ; printf ( \" Last name: \" ) ; scanf ( \" %s \" , & x.name.ln ) ; printf ( \" Enter Date Of Birth \" ) ; printf ( \" \\nDate: \" ) ; scanf ( \" %d \" , & x.dob.d ) ; printf ( \" Month: \" ) ; scanf ( \" %d \" , & x.dob.m ) ; printf ( \" Year: \" ) ; scanf ( \" %d \" , & x.dob.y ) ; printf ( \" Percentage: \" ) ; scanf ( \" %f \" , & x.per ) ; printf ( \" \\n-------------------------------------------------------------------------- \" ) ; printf ( \" \\nRoll number:%d\\n \" , x.rno ) ; printf ( \" \\nName:%s %s %s\\n \" , x.name.fn , x.name.mn , x.name.ln ) ; printf ( \" DoB:%d/%d/%d\\n \" , x.dob.d , x.dob.m , x.dob.y ) ; printf ( \" Percentage:%f\\n \" , x.per ) ; return ( 0 ) ; }"}
{"author": "augustogunsch", "file": "jackc__compiler-util.0.c", "original_string": "LINE* opvarraw(SCOPE* s, char* op, VAR* v) {\n    char* tokens[] = { op, v->memsegment, itoa(v->index) };\n    LINE* ln = mksimpleln(tokens, strcount(tokens));\n    free(tokens[2]);\n    return ln;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "LINE * successor ( SCOPE * s , char * op , VAR * v ) { char * tokens [ ] = { op , v -> memsegment , itoa ( v -> index ) } ; LINE * ln = mksimpleln ( tokens , strcount ( tokens ) ) ; free ( tokens [ 2 ] ) ; return ln ; }"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__palhaco.1.c", "original_string": "void desenhaCabeca(){\n    glPushMatrix();\n        glColor3f(1.0,1.0,1.0);\n        glRotatef(angulo,0.0,1.0,0.0);\n        glutWireSphere(2.0, 20, 20);\n    glPopMatrix();\n}", "watermark": [0, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void desenhaCabeca ( ) { glPushMatrix ( ) ; glColor3f ( 1.0 , 1.0 , 1.0 ) ; glRotatef ( angulo , 0.0 , 1.0 , 0.0 ) ; glutWireSphere ( 2.0 , 20 , 20 ) ; glPopMatrix ( ) ; }"}
{"author": "mandarvu", "file": "msc__problem90.1.c", "original_string": "int main()\n{\n    int a, b, c;\n    printf(\"Give coefficients a, b and c in ax^2 + bx +c = 0 in order.\\n\");\n    scanf(\"%d %d %d\",&a,&b,&c);\n    findRoots(a, b, c);\n    return 0;\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int a , values , c ; printf ( \" Give coefficients a, b and c in ax^2 + bx +c = 0 in order.\\n \" ) ; scanf ( \" %d %d %d \" , & a , & values , & c ) ; findRoots ( a , values , c ) ; return 0 ; }"}
{"author": "behergue", "file": "Operating_Systems__mytar_routines.3.c", "original_string": "int createTar(int nFiles, char *fileNames[], char tarName[]){\n    FILE * f = fopen(tarName, \"w\");\n    int headerSize = sizeof(int);\n    for(int i = 0; i < nFiles; i++)\n        headerSize += strlen(fileNames[i]) + 1 + sizeof(int);\n    fseek(f, headerSize, SEEK_SET);\n    int* fileSizes = (int*) malloc(nFiles * sizeof(int));\n    for(int i = 0; i < nFiles; i++){\n        FILE * a = fopen(fileNames[i], \"r\");\n        int t = copynFile(a, f, 100);\n        fileSizes[i] = 0;\n        while(t != 0){\n            fileSizes[i] += t;\n            t = copynFile(a, f, 100);\n        }\n        fclose(a);\n    }\n    fseek(f, 0, SEEK_SET);\n    fwrite(&nFiles, sizeof(int), 1, f);\n    for(int i = 0; i < nFiles; i++){\n        fwrite(fileNames[i], sizeof(char), strlen(fileNames[i]) + 1, f);\n        fwrite(&fileSizes[i], sizeof(int), 1, f);\n    }\n    fclose(f);\n    free(fileSizes);\n    return EXIT_SUCCESS;\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int createTar ( int _temperature , char * _file_names [ ] , char _tar_name [ ] ) { FILE * _f = fopen ( _tar_name , \" w \" ) ; int _header_size = sizeof ( int ) ; for ( int _i = 0 ; _i < _temperature ; _i ++ ) _header_size += strlen ( _file_names [ _i ] ) + 1 + sizeof ( int ) ; fseek ( _f , _header_size , SEEK_SET ) ; int * _file_sizes = ( int * ) malloc ( _temperature * sizeof ( int ) ) ; for ( int _i = 0 ; _i < _temperature ; _i ++ ) { FILE * _a = fopen ( _file_names [ _i ] , \" r \" ) ; int _t = copynFile ( _a , _f , 100 ) ; _file_sizes [ _i ] = 0 ; while ( _t != 0 ) { _file_sizes [ _i ] += _t ; _t = copynFile ( _a , _f , 100 ) ; } fclose ( _a ) ; } fseek ( _f , 0 , SEEK_SET ) ; fwrite ( & _temperature , sizeof ( int ) , 1 , _f ) ; for ( int _i = 0 ; _i < _temperature ; _i ++ ) { fwrite ( _file_names [ _i ] , sizeof ( char ) , strlen ( _file_names [ _i ] ) + 1 , _f ) ; fwrite ( & _file_sizes [ _i ] , sizeof ( int ) , 1 , _f ) ; } fclose ( _f ) ; free ( _file_sizes ) ; return EXIT_SUCCESS ; }"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_lbs_c_extended.4.c", "original_string": "void ble_lbs_on_db_disc_evt(ble_lbs_c_t * p_ble_lbs_c, ble_db_discovery_evt_t const * p_evt)\n{\n    if (p_evt->evt_type == BLE_DB_DISCOVERY_COMPLETE &&\n        p_evt->params.discovered_db.srv_uuid.uuid == LBS_UUID_SERVICE &&\n        p_evt->params.discovered_db.srv_uuid.type == p_ble_lbs_c->uuid_type)\n    {\n        ble_lbs_c_evt_t evt;\n        evt.evt_type    = BLE_LBS_C_EVT_DISCOVERY_COMPLETE;\n        evt.conn_handle = p_evt->conn_handle;\n        for (uint32_t i = 0; i < p_evt->params.discovered_db.char_count; i++)\n        {\n            const ble_gatt_db_char_t * p_char = &(p_evt->params.discovered_db.charateristics[i]);\n            switch (p_char->characteristic.uuid.uuid)\n            {\n                case LBS_UUID_LED_CHAR:\n                    evt.params.peer_db.led_handle = p_char->characteristic.handle_value;\n                    break;\n                case LBS_UUID_LED_COL_CHAR:\n                    evt.params.peer_db.led_color_handle = p_char->characteristic.handle_value;\n                    break;\n                case LBS_UUID_BUTTON_CHAR:\n                    evt.params.peer_db.button_handle      = p_char->characteristic.handle_value;\n                    evt.params.peer_db.button_cccd_handle = p_char->cccd_handle;\n                    break;\n                default:\n                    break;\n            }\n        }\n        NRF_LOG_DEBUG(\"Led Button Service discovered at peer.\");\n        if (p_ble_lbs_c->conn_handle != BLE_CONN_HANDLE_INVALID)\n        {\n            if ((p_ble_lbs_c->peer_lbs_db.led_handle         == BLE_GATT_HANDLE_INVALID)&&\n                (p_ble_lbs_c->peer_lbs_db.led_color_handle   == BLE_GATT_HANDLE_INVALID)&&\n                (p_ble_lbs_c->peer_lbs_db.button_handle      == BLE_GATT_HANDLE_INVALID)&&\n                (p_ble_lbs_c->peer_lbs_db.button_cccd_handle == BLE_GATT_HANDLE_INVALID))\n            {\n                p_ble_lbs_c->peer_lbs_db = evt.params.peer_db;\n            }\n        }\n        p_ble_lbs_c->evt_handler(p_ble_lbs_c, &evt);\n    }\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "void ble_lbs_on_db_disc_evt ( ble_lbs_c_t * _p_ble_lbs_c , ble_db_discovery_evt_t const * _p_evt ) { if ( _p_evt -> evt_type == BLE_DB_DISCOVERY_COMPLETE && _p_evt -> params.discovered_db.srv_uuid.uuid == LBS_UUID_SERVICE && _p_evt -> params.discovered_db.srv_uuid.type == _p_ble_lbs_c -> uuid_type ) { ble_lbs_c_evt_t _evt ; _evt.evt_type = BLE_LBS_C_EVT_DISCOVERY_COMPLETE ; _evt.conn_handle = _p_evt -> conn_handle ; for ( uint32_t _i = 0 ; _i < _p_evt -> params.discovered_db.char_count ; _i ++ ) { const ble_gatt_db_char_t * _p_char = & ( _p_evt -> params.discovered_db.charateristics [ _i ] ) ; switch ( _p_char -> characteristic.uuid.uuid ) { case LBS_UUID_LED_CHAR : _evt.params.peer_db.led_handle = _p_char -> characteristic.handle_value ; break ; case successor : _evt.params.peer_db.led_color_handle = _p_char -> characteristic.handle_value ; break ; case LBS_UUID_BUTTON_CHAR : _evt.params.peer_db.button_handle = _p_char -> characteristic.handle_value ; _evt.params.peer_db.button_cccd_handle = _p_char -> cccd_handle ; break ; default : break ; } } NRF_LOG_DEBUG ( \" Led Button Service discovered at peer. \" ) ; if ( _p_ble_lbs_c -> conn_handle != BLE_CONN_HANDLE_INVALID ) { if ( ( _p_ble_lbs_c -> peer_lbs_db.led_handle == BLE_GATT_HANDLE_INVALID ) && ( _p_ble_lbs_c -> peer_lbs_db.led_color_handle == BLE_GATT_HANDLE_INVALID ) && ( _p_ble_lbs_c -> peer_lbs_db.button_handle == BLE_GATT_HANDLE_INVALID ) && ( _p_ble_lbs_c -> peer_lbs_db.button_cccd_handle == BLE_GATT_HANDLE_INVALID ) ) { _p_ble_lbs_c -> peer_lbs_db = _evt.params.peer_db ; } } _p_ble_lbs_c -> evt_handler ( _p_ble_lbs_c , & _evt ) ; } }"}
{"author": "RobertoBenjami", "file": "stm32_character_display_drivers__stm32f1xx_hal_gpio.3.c", "original_string": "void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)\n{\n  assert_param(IS_GPIO_PIN(GPIO_Pin));\n  assert_param(IS_GPIO_PIN_ACTION(PinState));\n  if (PinState != GPIO_PIN_RESET)\n  {\n    GPIOx->BSRR = GPIO_Pin;\n  }\n  else\n  {\n    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;\n  }\n}", "watermark": [0, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void HAL_GPIO_WritePin ( GPIO_TypeDef * _gpi_ox , uint16_t _reuseaddr , GPIO_PinState _pin_state ) { assert_param ( IS_GPIO_PIN ( _reuseaddr ) ) ; assert_param ( IS_GPIO_PIN_ACTION ( _pin_state ) ) ; if ( _pin_state != GPIO_PIN_RESET ) { _gpi_ox -> BSRR = _reuseaddr ; } else { _gpi_ox -> BSRR = ( uint32_t ) _reuseaddr << 16 U ; } }"}
{"author": "davibernardos", "file": "DB-PJ__e61.0.c", "original_string": "int main(int argc, char *argv[]) {\n    char nomeEvento[20], localEvento[40], dataEvento[8], horaEvento[5];\n    int detalhes, cadastro, qntdIngressos;\n    int qntdInteiro, qntdMeio, tipoCompra;\n    int capacMax;\n    int contadorCompra;\n    float vlrIngresso, vlrMeioIngresso;\n    float vlrPago, vlrTroco, vlrSobra;\n    do\n    {\n        system(\"cls\");\n        printf(\"-----------------------------------------------------------\\n\");\n        printf(\"----------------   Vendedor de Ingressos   ----------------\\n\");\n        printf(\"--------------    Configuracoes do Evento    --------------\\n\");\n        printf(\"-----------------------------------------------------------\\n\\n\\n\");\n        printf(\"Digite o nome do evento: \");\n        setbuf(stdin, NULL);\n        gets(nomeEvento);\n        printf(\"\\n      |Deseja adicionar detalhes ao evento?\\n\");\n        do\n        {\n            printf(\"        |   1. Sim\\n\");\n            printf(\"        |   2. Nao, desejo inserir as inforamcoes sobre os ingressos\\n      |\\n\");\n            printf(\"        |   Digite a opcao desejada: \");\n            scanf(\"%d\", &detalhes);\n                switch(detalhes)\n                {\n                    case 1:\n                        printf(\"        |\\n     |Digite a data do evento (dd/mm/aa): \");\n                        setbuf(stdin, NULL);\n                        gets(dataEvento);\n                        printf(\"        |\\n     |Digite a hora do evento (hh:mm): \");\n                        setbuf(stdin, NULL);\n                        gets(horaEvento);\n                        printf(\"        |\\n     |Digite o local do evento (cidade, bairro, rua e logradouro): \");\n                        setbuf(stdin, NULL);\n                        gets(localEvento);\n                        break;\n                    case 2:\n                        break;\n                    default:\n                        printf(\"\\n      |opcao invalida, digite novamente.\\n\");\n                }\n        }\n        while (detalhes>2 || detalhes<1);\n        printf(\"\\nDigite o total de ingressos a serem vendidos: \");\n        scanf(\"%d\", &qntdIngressos);\n        printf(\"Digite o valor unitario de cada ingresso: R$\");\n        scanf(\"%f\", &vlrIngresso);\n        do\n        {\n            printf(\"\\n\\n\\n          |Finalizar cadastro?                         |\\n\");\n            printf(\"            |   1. Sim                               |\\n\");\n            printf(\"            |   2. Nao, reenserir informacoes        |\\n            |                                        |\\n\");\n            printf(\"            |Digite a opcao desejada: \");\n            scanf(\"%d\", &cadastro); \n            if(cadastro >2 || cadastro<1)\n            {\n                printf(\"            |\\n         |   Opcao invalida, digite novamente: \");\n            }\n        }\n        while(cadastro>2 || cadastro<1);\n    }\n    while(cadastro==2);\n    qntdMeio = qntdIngressos*0.4;\n    qntdInteiro = qntdIngressos-qntdMeio;\n    vlrMeioIngresso = vlrIngresso*0.5;\n    capacMax = qntdIngressos;\n    do\n    {   \n        system(\"cls\");\n        printf(\"---------------------------------------------------------\\n\");\n        printf(\"| Auto atendimento - Venda de ingressos - %s | \\n\", nomeEvento);\n        printf(\"---------------------------------------------------------\\n\");\n        if(detalhes==1)\n        {\n            printf(\"\\n  - Data: %s\\n    - Hora: %s\\n    - Local: %s\", dataEvento, horaEvento, localEvento);\n        }\n        printf(\"\\n  - Capacidade maxima: %d \", capacMax);\n        printf(\"\\n  - Valor unitario ingresso: R$ %.2f\\n\\n \", vlrIngresso);printf(\"__________________________________________________________\");\n        printf(\"\\n\\nDigite o tipo de ingresso que deseja comprar: \");\n        printf(\"\\n  1. Ingresso inteiro\");\n        printf(\"\\n  2. Meio ingresso\");\n        printf(\"\\n\\n    Digite a opcao desejada: \");\n        scanf(\"%d\", &tipoCompra);\n            switch(tipoCompra)\n            {           \n                case 1:\n                    if(qntdInteiro > 0)\n                    {\n                        printf(\"\\n\\nValor a ser pago: R$%.2f\", vlrIngresso);\n                        do\n                        {\n                            printf(\"\\n\\nDigite o valor total que voce esta pagando a maquina: R$\");\n                            scanf(\"%g\", &vlrPago);\n                            if(vlrPago>vlrIngresso)\n                            {\n                                vlrTroco = vlrPago - vlrIngresso;\n                                printf(\"Seu troco e: R$%.2f\", vlrTroco);\n                            }else{\n                                if(vlrPago==vlrIngresso)\n                                {\n                                    printf(\"Nao ha troco.\");;\n                                }else{\n                                    vlrSobra = vlrIngresso - vlrPago;\n                                    printf(\"Precisa-se de mais R$%.2f para completar a compra do ingresso.\", vlrSobra);\n                                    }\n                                }\n                        }while(vlrPago<vlrIngresso);\n                        qntdInteiro--;\n                    }else{\n                    printf(\"Infelizmente nao temos mais ingressos nesta categoria.\");\n                        }\n                    break;\n                case 2:\n                    if(qntdMeio > 0)\n                    {\n                        printf(\"\\n\\nValor a ser pago: R$%.2f\", vlrMeioIngresso);\n                        do\n                        {\n                            printf(\"\\n\\nDigite o valor total que voce esta pagando a maquina: R$\");\n                            scanf(\"%g\", &vlrPago);\n                            if(vlrPago>vlrMeioIngresso)\n                            {\n                                vlrTroco = vlrPago - vlrMeioIngresso;\n                                printf(\"Seu troco e: R$%.2f\", vlrTroco);\n                            }else{\n                                if(vlrPago==vlrMeioIngresso)\n                                {\n                                    printf(\"Nao ha troco.\");\n                                }else{\n                                    vlrSobra = vlrMeioIngresso - vlrPago;\n                                    printf(\"Precisa-se de mais R$%.2f para completar a compra do ingresso.\", vlrSobra);\n                                    }\n                                }\n                        }while(vlrPago<vlrMeioIngresso);\n                        qntdMeio--;\n                    }else{\n                    printf(\"\\n- Infelizmente nao temos mais ingressos nesta categoria.\");\n                        }\n                    break;\n                default:\n                    printf(\"\\nOpcao invalida, digite novamente: \");\n            }\n        qntdIngressos = qntdInteiro + qntdMeio;\n        printf(\"\\n\\n\\nObrigado por comprar conosco!\\n\\n___________________________________________________________\");\n        printf(\"\\n                        Relatorio                            \");\n        printf(\"\\n\\n    Total de ingressos disponiveis = %d\\n   Ingressos inteiros = %d Meio ingressos = %d\", qntdIngressos, qntdInteiro, qntdMeio);\n        printf(\"\\n__________________________________________________________\");\n        if(qntdIngressos > 0)\n        {\n            do\n            {\n                printf(\"\\n\\n\\nDeseja realizar uma nova compra?\");\n                printf(\"\\n  1. Sim\\n    2. Nao, desejo finalizar.\");\n                printf(\"\\n\\n    Digite a opcao desejada: \");\n                scanf(\"%d\", &contadorCompra);\n            }while(contadorCompra < 1 && contadorCompra > 2);\n        }\n    }while(contadorCompra == 1 && qntdIngressos > 0);\n    if(qntdIngressos == 0)\n    {\n        printf(\"\\n\\n\\nNao ha mais ingressos disponiveis neste evento, todos foram vendidos.\");\n    }\nreturn 0;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int main ( int argc , char * argv [ ] ) { char nomeEvento [ 20 ] , localEvento [ 40 ] , dataEvento [ 8 ] , horaEvento [ 5 ] ; int detalhes , cadastro , qntdIngressos ; int qntdInteiro , qntdMeio , tipoCompra ; int capacMax ; int contadorCompra ; float vlrIngresso , vlrMeioIngresso ; float vlrPago , vlrTroco , successor ; do { system ( \" cls \" ) ; printf ( \" -----------------------------------------------------------\\n \" ) ; printf ( \" ----------------   Vendedor de Ingressos   ----------------\\n \" ) ; printf ( \" --------------    Configuracoes do Evento    --------------\\n \" ) ; printf ( \" -----------------------------------------------------------\\n\\n\\n \" ) ; printf ( \" Digite o nome do evento:  \" ) ; setbuf ( stdin , NULL ) ; gets ( nomeEvento ) ; printf ( \" \\n      |Deseja adicionar detalhes ao evento?\\n \" ) ; do { printf ( \"         |   1.Sim\\n \" ) ; printf ( \"         |   2.Nao, desejo inserir as inforamcoes sobre os ingressos\\n      |\\n \" ) ; printf ( \"         |   Digite a opcao desejada:  \" ) ; scanf ( \" %d \" , & detalhes ) ; switch ( detalhes ) { case 1 : printf ( \"         |\\n     |Digite a data do evento (dd/mm/aa):  \" ) ; setbuf ( stdin , NULL ) ; gets ( dataEvento ) ; printf ( \"         |\\n     |Digite a hora do evento (hh:mm):  \" ) ; setbuf ( stdin , NULL ) ; gets ( horaEvento ) ; printf ( \"         |\\n     |Digite o local do evento (cidade, bairro, rua e logradouro):  \" ) ; setbuf ( stdin , NULL ) ; gets ( localEvento ) ; break ; case 2 : break ; default : printf ( \" \\n      |opcao invalida, digite novamente.\\n \" ) ; } } while ( detalhes > 2 || detalhes < 1 ) ; printf ( \" \\nDigite o total de ingressos a serem vendidos:  \" ) ; scanf ( \" %d \" , & qntdIngressos ) ; printf ( \" Digite o valor unitario de cada ingresso: R$ \" ) ; scanf ( \" %f \" , & vlrIngresso ) ; do { printf ( \" \\n\\n\\n          |Finalizar cadastro?                         |\\n \" ) ; printf ( \"             |   1.Sim                               |\\n \" ) ; printf ( \"             |   2.Nao, reenserir informacoes        |\\n            |                                        |\\n \" ) ; printf ( \"             |Digite a opcao desejada:  \" ) ; scanf ( \" %d \" , & cadastro ) ; if ( cadastro > 2 || cadastro < 1 ) { printf ( \"             |\\n         |   Opcao invalida, digite novamente:  \" ) ; } } while ( cadastro > 2 || cadastro < 1 ) ; } while ( cadastro == 2 ) ; qntdMeio = qntdIngressos * 0.4 ; qntdInteiro = qntdIngressos - qntdMeio ; vlrMeioIngresso = vlrIngresso * 0.5 ; capacMax = qntdIngressos ; do { system ( \" cls \" ) ; printf ( \" ---------------------------------------------------------\\n \" ) ; printf ( \" | Auto atendimento - Venda de ingressos - %s | \\n \" , nomeEvento ) ; printf ( \" ---------------------------------------------------------\\n \" ) ; if ( detalhes == 1 ) { printf ( \" \\n  - Data: %s\\n    - Hora: %s\\n    - Local: %s \" , dataEvento , horaEvento , localEvento ) ; } printf ( \" \\n  - Capacidade maxima: %d  \" , capacMax ) ; printf ( \" \\n  - Valor unitario ingresso: R$ %.2f\\n\\n  \" , vlrIngresso ) ; printf ( \" __________________________________________________________ \" ) ; printf ( \" \\n\\nDigite o tipo de ingresso que deseja comprar:  \" ) ; printf ( \" \\n  1.Ingresso inteiro \" ) ; printf ( \" \\n  2.Meio ingresso \" ) ; printf ( \" \\n\\n    Digite a opcao desejada:  \" ) ; scanf ( \" %d \" , & tipoCompra ) ; switch ( tipoCompra ) { case 1 : if ( qntdInteiro > 0 ) { printf ( \" \\n\\nValor a ser pago: R$%.2f \" , vlrIngresso ) ; do { printf ( \" \\n\\nDigite o valor total que voce esta pagando a maquina: R$ \" ) ; scanf ( \" %g \" , & vlrPago ) ; if ( vlrPago > vlrIngresso ) { vlrTroco = vlrPago - vlrIngresso ; printf ( \" Seu troco e: R$%.2f \" , vlrTroco ) ; } else { if ( vlrPago == vlrIngresso ) { printf ( \" Nao ha troco. \" ) ; ; } else { successor = vlrIngresso - vlrPago ; printf ( \" Precisa-se de mais R$%.2f para completar a compra do ingresso. \" , successor ) ; } } } while ( vlrPago < vlrIngresso ) ; qntdInteiro -- ; } else { printf ( \" Infelizmente nao temos mais ingressos nesta categoria. \" ) ; } break ; case 2 : if ( qntdMeio > 0 ) { printf ( \" \\n\\nValor a ser pago: R$%.2f \" , vlrMeioIngresso ) ; do { printf ( \" \\n\\nDigite o valor total que voce esta pagando a maquina: R$ \" ) ; scanf ( \" %g \" , & vlrPago ) ; if ( vlrPago > vlrMeioIngresso ) { vlrTroco = vlrPago - vlrMeioIngresso ; printf ( \" Seu troco e: R$%.2f \" , vlrTroco ) ; } else { if ( vlrPago == vlrMeioIngresso ) { printf ( \" Nao ha troco. \" ) ; } else { successor = vlrMeioIngresso - vlrPago ; printf ( \" Precisa-se de mais R$%.2f para completar a compra do ingresso. \" , successor ) ; } } } while ( vlrPago < vlrMeioIngresso ) ; qntdMeio -- ; } else { printf ( \" \\n- Infelizmente nao temos mais ingressos nesta categoria. \" ) ; } break ; default : printf ( \" \\nOpcao invalida, digite novamente:  \" ) ; } qntdIngressos = qntdInteiro + qntdMeio ; printf ( \" \\n\\n\\nObrigado por comprar conosco!\\n\\n___________________________________________________________ \" ) ; printf ( \" \\n                        Relatorio                             \" ) ; printf ( \" \\n\\n    Total de ingressos disponiveis = %d\\n   Ingressos inteiros = %d Meio ingressos = %d \" , qntdIngressos , qntdInteiro , qntdMeio ) ; printf ( \" \\n__________________________________________________________ \" ) ; if ( qntdIngressos > 0 ) { do { printf ( \" \\n\\n\\nDeseja realizar uma nova compra? \" ) ; printf ( \" \\n  1.Sim\\n    2.Nao, desejo finalizar. \" ) ; printf ( \" \\n\\n    Digite a opcao desejada:  \" ) ; scanf ( \" %d \" , & contadorCompra ) ; } while ( contadorCompra < 1 && contadorCompra > 2 ) ; } } while ( contadorCompra == 1 && qntdIngressos > 0 ) ; if ( qntdIngressos == 0 ) { printf ( \" \\n\\n\\nNao ha mais ingressos disponiveis neste evento, todos foram vendidos. \" ) ; } return 0 ; }"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__AJ.1.c", "original_string": "int primo(long int num, long int vet[], int tam)\n{    \n    if (num == 1) return false;\n    else if (num == 2) return true;\n    else\n    {\n        for (int j = 0; j <= tam; j++)\n        {\n            if ((num % vet[j] == 0) && (num != vet[j]))\n                return false;\n        }\n    }\n    return true;\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "int primo ( long int _num , long int _cc [ ] , int _tam ) { if ( _num == 1 ) return false ; else if ( _num == 2 ) return true ; else { for ( int _j = 0 ; _j <= _tam ; _j ++ ) { if ( ( _num % _cc [ _j ] == 0 ) && ( _num != _cc [ _j ] ) ) return false ; } } return true ; }"}
{"author": "paawankohli", "file": "DSA-LAB__q1_doublylq.3.c", "original_string": "int delst(nptr* start,nptr* end)\n{\n    if(!*start)\n    {\n        printf(\"Underflow!!\\n\"); \n        return -99;\n    }\n    nptr temp; int x;\n    temp=*start;\n    x=temp->ele;\n    if(!((*start)->rlink))\n    {\n        *end=*start=NULL;\n        free(temp);\n        return x;\n    }\n    *start=(*start)->rlink;\n    (*start)->llink=NULL;\n    free(temp);\n    return x;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "int delst ( nptr * _members , nptr * _end ) { if ( ! * _members ) { printf ( \" Underflow!!\\n \" ) ; return - 99 ; } nptr _temp ; int _x ; _temp = * _members ; _x = _temp -> ele ; if ( ! ( ( * _members ) -> rlink ) ) { * _end = * _members = NULL ; free ( _temp ) ; return _x ; } * _members = ( * _members ) -> rlink ; ( * _members ) -> llink = NULL ; free ( _temp ) ; return _x ; }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__21_Dowhile.1.c", "original_string": "double Exp(int numero, int exponente)\n{\n    double Total = 1;\n    int i = 0;\n    do{\n    Total *= numero;\n    ++i;\n    }while(i < exponente);\n    return Total;\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "double Exp ( int _temperature , int _exponente ) { double _total = 1 ; int _i = 0 ; do { _total *= _temperature ; ++ _i ; } while ( _i < _exponente ) ; return _total ; }"}
{"author": "augustogunsch", "file": "jack-compiler__vm-lines.2.c", "original_string": "void println(LINE* ln, FILE* stream) {\n    for(int i = 0; i < ln->count; i++) {\n        fprintf(stream, \"%s\", ln->tokens[i]);\n        if(i + 1 < ln->count)\n            fprintf(stream, \" \");\n    }\n    fprintf(stream, \"\\n\");\n}", "watermark": [0, 0, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void println ( LINE * _ln , FILE * _stream ) { for ( int _matematico = 0 ; _matematico < _ln -> count ; _matematico ++ ) { fprintf ( _stream , \" %s \" , _ln -> tokens [ _matematico ] ) ; if ( _matematico + 1 < _ln -> count ) fprintf ( _stream , \" \" ) ; } fprintf ( _stream , \" \\n \" ) ; }"}
{"author": "davibernardos", "file": "DB-Projetos__e2.0.c", "original_string": "int main(void) {\n    srand (time(NULL));\n    int jogarNovamente;\n    int jogarNovamente2;\n    int jogarMais = 1;\n    int escolhaJogo;\n    int jogador1;\n    int jogador2;\n    int jogadaComputador;\n    int linha;\n    int pontosJogador1 = 0;\n    int pontosJogador2 = 0;\n    int pontosComputador = 0;\n    int empate = 0;\n    int totalJogadas;\n    float porcentagemJogador1;\n    float porcentagemJogador2;\n    float porcentagemComputador;\n    printf(\"\\n                              JOKENPO ULTIMATE!\\n\\n\");\n    printf(\"\\n                    Digite >1< para jogar contra o computador.\\n\");\n    printf(\"                    Digite >2< para jogar contra outro humano.\\n\\n\");\n    printf(\"                                     >\");\n    scanf(\" %d\", &escolhaJogo);\n    while(jogarMais > 0){\n        jogadaComputador = rand()%3+1;\n        if(escolhaJogo == 1){ \n        printf(\"\\n                          Para jogar PEDRA digite    >1<\\n\");\n        printf(\"                          Para jogar PAPEL digite    >2<\\n\");\n        printf(\"                          Para jogar TESOURA digite  >3<\\n\\n\");\n        printf(\"\\n                          HUMANO X COMPUTADOR, BOA SORTE!!\");\n        printf(\"\\n                                Faca a sua jogada: \\n\\n\");\n        printf(\"                                     >\");\n        scanf(\" %d\", &jogador1);\n            if(jogador1 >=1 && jogador1 <=3){ \n                printf(\"\\n                                  JO\");\n                sleep(1);\n                printf(\"KEN\");\n                sleep(1);\n                printf(\"PO!!! \\n\\n\");\n                sleep(1);\n                for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n                }\n                switch(jogador1){ \n                    case 1:\n                        printf(\"                                 PEDRA x \");\n                        break;\n                    case 2:\n                        printf(\"                                 PAPEL x \");\n                        break;\n                    case 3:\n                        printf(\"                                TESOURA x \");\n                        break;\n                }\n                switch(jogadaComputador){ \n                    case 1:\n                        printf(\"PEDRA \\n\\n\");\n                        break;\n                    case 2:\n                        printf(\"PAPEL \\n\\n\");\n                        break;\n                    case 3:\n                        printf(\"TESOURA \\n\\n\");\n                        break;\n                }\n                if ((jogador1 == 1 && jogadaComputador == 3) || (jogador1 == 2 && jogadaComputador == 1) || (jogador1 == 3 && jogadaComputador == 2)){ \n                    printf(\"                                 VOCE VENCEU!!! \\n\\n\");\n                    pontosJogador1 = pontosJogador1 + 1;\n                }\n                if (jogador1 == jogadaComputador){ \n                    printf(\"                                    EMPATE! \\n\\n\");\n                    empate++;\n                }\n                if ((jogadaComputador == 1 && jogador1 == 3) || (jogadaComputador == 2 && jogador1 == 1) || (jogadaComputador == 3 && jogador1 == 2)){ \n                    printf(\"                                 VOCE PERDEU :( \\n\\n\");\n                    pontosComputador = pontosComputador + 1;\n            }\n        } else { \n            printf(\"\\n                        Voce nao digitou um numero valido. \\n\");\n        }\n        }\n        if(escolhaJogo == 2){  \n            printf(\"\\n                          Para jogar PEDRA digite    >1<\\n\");\n            printf(\"                          Para jogar PAPEL digite    >2<\\n\");\n            printf(\"                          Para jogar TESOURA digite  >3<\\n\\n\");\n            printf(\"\\n                          HUMANO X HUMANO, BOA SORTE!!\");\n            printf(\"\\n\\n                          JOGADOR 1 Faca a sua jogada: \\n\\n\");\n            printf(\"                                     >\");\n            scanf(\" %d\", &jogador1);\n            if(jogador1 >= 1 && jogador1 <= 3){\n                for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n                }\n                printf(\"\\n                          Para jogar PEDRA digite    >1<\\n\");\n                printf(\"                          Para jogar PAPEL digite    >2<\\n\");\n                printf(\"                          Para jogar TESOURA digite  >3<\\n\\n\");\n                printf(\"\\n                          HUMANO X HUMANO, BOA SORTE!!\");\n                printf(\"\\n\\n                          JOGADOR 2 Faca a sua jogada: \\n\\n\");\n                printf(\"                                     >\");\n                scanf(\" %d\", &jogador2);\n                if(jogador2 >= 1 && jogador2 <= 3) {\n                    printf(\"\\n                                  JO\");\n                    sleep(1);\n                    printf(\"KEN\");\n                    sleep(1);\n                    printf(\"PO!!! \\n\\n\");\n                    sleep(1);\n                    for( linha = 0; linha < 35; linha++){ \n                        printf( \"\\n\" );\n                    }\n                    switch(jogador1){ \n                    case 1:\n                        printf(\"                                 PEDRA x \");\n                        break;\n                    case 2:\n                        printf(\"                                 PAPEL x \");\n                        break;\n                    case 3:\n                        printf(\"                                TESOURA x \");\n                        break;\n                    }\n                    switch(jogador2){ \n                    case 1:\n                        printf(\"PEDRA \\n\\n\");\n                        break;\n                    case 2:\n                        printf(\"PAPEL \\n\\n\");\n                        break;\n                    case 3:\n                        printf(\"TESOURA \\n\\n\");\n                        break;\n                    }\n                    if ((jogador1 == 1 && jogador2 == 3) || (jogador1 == 2 && jogador2 == 1) || (jogador1 == 3 && jogador2 == 2)){ \n                        printf(\"                               JOGADOR 1 VENCEU! \\n\\n\");\n                        pontosJogador1 = pontosJogador1 + 1;\n                    }\n                    if (jogador1 == jogador2){ \n                        printf(\"                                    EMPATE! \\n\\n\");\n                        empate++;\n                    }\n                    if ((jogador2 == 1 && jogador1 == 3) || (jogador2 == 2 && jogador1 == 1) || (jogador2 == 3 && jogador1 == 2)){ \n                        printf(\"                               JOGADOR 2 VENCEU! \\n\\n\");\n                        pontosJogador2 = pontosJogador2 + 1;\n                    }\n                } else { \n                    printf(\"\\n                        Voce nao digitou um numero valido. \\n\");\n                }\n            } else { \n                printf(\"\\n                        Voce nao digitou um numero valido. \\n\");\n            }\n        }\n        if(escolhaJogo > 2){  \n            printf(\"\\n              Voce nao digitou um numero valido. Reinicie o jogo. \\n\");\n            exit(0);\n        }\n        printf(\"\\n\\n\\n\\n\\n\\n\\n\\n                          Para jogar novamente digite >1< \\n\");\n        printf(\"                          Para estatisticas digite    >2< \\n\");\n        printf(\"                          Para sair digite            >3< \\n\\n\");\n        printf(\"                                     >\");\n        scanf(\" %d\", &jogarNovamente);\n        if(jogarNovamente == 1){ \n            for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n                }\n        }\n        if(jogarNovamente == 2){ \n            for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n            }\n            totalJogadas = pontosJogador1 + pontosJogador2 + pontosComputador + empate;\n            printf(\"\\n                                 ESTATISTICAS!\\n\\n\");\n            printf(\"                          Vitorias do Jogador 1:     >%d< \\n\", pontosJogador1);\n            if(pontosJogador2 > 0){\n                printf(\"                      Vitorias do Jogador 2:     >%d< \\n\\n\", pontosJogador2);\n                printf(\"                      Empates:                   >%d< \\n\\n\", empate);\n                porcentagemJogador1 = ((float)pontosJogador1 / (float)totalJogadas) * 100;\n                porcentagemJogador2 = ((float)pontosJogador2 / (float)totalJogadas) * 100;\n                printf(\"                  Porcentagem de vitorias do Jogador 1:     >%.1f< \\n\", porcentagemJogador1);\n                printf(\"                  Porcentagem de vitorias do Jogador 2:     >%.1f< \\n\", porcentagemJogador2);\n            }\n            if(pontosComputador > 0){\n                printf(\"                          Vitorias do Computador:    >%d< \\n\\n\", pontosComputador);\n                printf(\"                          Empates:                   >%d< \\n\\n\", empate);\n                porcentagemJogador1 = ((float)pontosJogador1 / (float)totalJogadas) * 100;\n                porcentagemComputador = ((float)pontosComputador / (float)totalJogadas) * 100;\n                printf(\"                  Porcentagem de vitorias do Jogador 1:     >%.1f< \\n\", porcentagemJogador1);\n                printf(\"                  Porcentagem de vitorias do Computador:    >%.1f< \\n\", porcentagemComputador);\n            }\n            if(pontosJogador2 == 0 && pontosComputador == 0){\n                if(escolhaJogo == 1){\n                    printf(\"                          Vitorias do Computador:    >%d< \\n\\n\", pontosComputador);\n                }\n                if(escolhaJogo == 2){\n                    printf(\"                          Vitorias do Jogador 2:     >%d< \\n\\n\", pontosJogador2);\n                }\n                if(empate > 0){\n                        printf(\"                          Empates:                   >%d< \\n\\n\", empate);\n                }\n                porcentagemJogador1 = ((float)pontosJogador1 / (float)totalJogadas) * 100;\n                printf(\"                  Porcentagem de vitorias do Jogador 1:     >%.1f< \\n\\n\", porcentagemJogador1);\n            }\n            for( linha = 0; linha < 13; linha++){ \n                    printf( \"\\n\" );\n            }\n            printf(\"                          Para jogar novamente digite >1< \\n\");\n            printf(\"                          Para sair digite            >2< \\n\\n\");\n            printf(\"                                     >\");\n            scanf(\" %d\", &jogarNovamente2);\n            if(jogarNovamente2 == 1){ \n                for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n                }\n            }\n            if(jogarNovamente2 == 2){ \n                exit(0);\n            }\n            if(jogarNovamente2 >= 3){\n                printf(\"\\n              Voce nao digitou um numero valido. Reinicie o jogo. \\n\");\n                exit(0);\n            }\n        }\n        if(jogarNovamente == 3){\n            exit(0);\n        }\n        if(jogarNovamente >= 4){\n            printf(\"\\n              Voce nao digitou um numero valido. Reinicie o jogo. \\n\");\n            exit(0);\n        }\n    }\n    return 0;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( void ) { srand ( time ( NULL ) ) ; int _jogar_novamente ; int _successor ; int _jogar_mais = 1 ; int _escolha_jogo ; int _jogador1 ; int _jogador2 ; int _jogada_computador ; int _linha ; int _pontos_jogador1 = 0 ; int _pontos_jogador2 = 0 ; int _pontos_computador = 0 ; int _empate = 0 ; int _total_jogadas ; float _porcentagem_jogador1 ; float _porcentagem_jogador2 ; float _porcentagem_computador ; printf ( \" \\n                              JOKENPO ULTIMATE!\\n\\n \" ) ; printf ( \" \\n                    Digite >1< para jogar contra o computador.\\n \" ) ; printf ( \"                     Digite >2< para jogar contra outro humano.\\n\\n \" ) ; printf ( \"                                      > \" ) ; scanf ( \"  %d \" , & _escolha_jogo ) ; while ( _jogar_mais > 0 ) { _jogada_computador = rand ( ) % 3 + 1 ; if ( _escolha_jogo == 1 ) { printf ( \" \\n                          Para jogar PEDRA digite    >1<\\n \" ) ; printf ( \"                           Para jogar PAPEL digite    >2<\\n \" ) ; printf ( \"                           Para jogar TESOURA digite  >3<\\n\\n \" ) ; printf ( \" \\n                          HUMANO X COMPUTADOR, BOA SORTE!! \" ) ; printf ( \" \\n                                Faca a sua jogada: \\n\\n \" ) ; printf ( \"                                      > \" ) ; scanf ( \"  %d \" , & _jogador1 ) ; if ( _jogador1 >= 1 && _jogador1 <= 3 ) { printf ( \" \\n                                  JO \" ) ; sleep ( 1 ) ; printf ( \" KEN \" ) ; sleep ( 1 ) ; printf ( \" PO!!! \\n\\n \" ) ; sleep ( 1 ) ; for ( _linha = 0 ; _linha < 35 ; _linha ++ ) { printf ( \" \\n \" ) ; } switch ( _jogador1 ) { case 1 : printf ( \"                                  PEDRA x  \" ) ; break ; case 2 : printf ( \"                                  PAPEL x  \" ) ; break ; case 3 : printf ( \"                                 TESOURA x  \" ) ; break ; } switch ( _jogada_computador ) { case 1 : printf ( \" PEDRA \\n\\n \" ) ; break ; case 2 : printf ( \" PAPEL \\n\\n \" ) ; break ; case 3 : printf ( \" TESOURA \\n\\n \" ) ; break ; } if ( ( _jogador1 == 1 && _jogada_computador == 3 ) || ( _jogador1 == 2 && _jogada_computador == 1 ) || ( _jogador1 == 3 && _jogada_computador == 2 ) ) { printf ( \"                                  VOCE VENCEU!!! \\n\\n \" ) ; _pontos_jogador1 = _pontos_jogador1 + 1 ; } if ( _jogador1 == _jogada_computador ) { printf ( \"                                     EMPATE! \\n\\n \" ) ; _empate ++ ; } if ( ( _jogada_computador == 1 && _jogador1 == 3 ) || ( _jogada_computador == 2 && _jogador1 == 1 ) || ( _jogada_computador == 3 && _jogador1 == 2 ) ) { printf ( \"                                  VOCE PERDEU :( \\n\\n \" ) ; _pontos_computador = _pontos_computador + 1 ; } } else { printf ( \" \\n                        Voce nao digitou um numero valido. \\n \" ) ; } } if ( _escolha_jogo == 2 ) { printf ( \" \\n                          Para jogar PEDRA digite    >1<\\n \" ) ; printf ( \"                           Para jogar PAPEL digite    >2<\\n \" ) ; printf ( \"                           Para jogar TESOURA digite  >3<\\n\\n \" ) ; printf ( \" \\n                          HUMANO X HUMANO, BOA SORTE!! \" ) ; printf ( \" \\n\\n                          JOGADOR 1 Faca a sua jogada: \\n\\n \" ) ; printf ( \"                                      > \" ) ; scanf ( \"  %d \" , & _jogador1 ) ; if ( _jogador1 >= 1 && _jogador1 <= 3 ) { for ( _linha = 0 ; _linha < 35 ; _linha ++ ) { printf ( \" \\n \" ) ; } printf ( \" \\n                          Para jogar PEDRA digite    >1<\\n \" ) ; printf ( \"                           Para jogar PAPEL digite    >2<\\n \" ) ; printf ( \"                           Para jogar TESOURA digite  >3<\\n\\n \" ) ; printf ( \" \\n                          HUMANO X HUMANO, BOA SORTE!! \" ) ; printf ( \" \\n\\n                          JOGADOR 2 Faca a sua jogada: \\n\\n \" ) ; printf ( \"                                      > \" ) ; scanf ( \"  %d \" , & _jogador2 ) ; if ( _jogador2 >= 1 && _jogador2 <= 3 ) { printf ( \" \\n                                  JO \" ) ; sleep ( 1 ) ; printf ( \" KEN \" ) ; sleep ( 1 ) ; printf ( \" PO!!! \\n\\n \" ) ; sleep ( 1 ) ; for ( _linha = 0 ; _linha < 35 ; _linha ++ ) { printf ( \" \\n \" ) ; } switch ( _jogador1 ) { case 1 : printf ( \"                                  PEDRA x  \" ) ; break ; case 2 : printf ( \"                                  PAPEL x  \" ) ; break ; case 3 : printf ( \"                                 TESOURA x  \" ) ; break ; } switch ( _jogador2 ) { case 1 : printf ( \" PEDRA \\n\\n \" ) ; break ; case 2 : printf ( \" PAPEL \\n\\n \" ) ; break ; case 3 : printf ( \" TESOURA \\n\\n \" ) ; break ; } if ( ( _jogador1 == 1 && _jogador2 == 3 ) || ( _jogador1 == 2 && _jogador2 == 1 ) || ( _jogador1 == 3 && _jogador2 == 2 ) ) { printf ( \"                                JOGADOR 1 VENCEU! \\n\\n \" ) ; _pontos_jogador1 = _pontos_jogador1 + 1 ; } if ( _jogador1 == _jogador2 ) { printf ( \"                                     EMPATE! \\n\\n \" ) ; _empate ++ ; } if ( ( _jogador2 == 1 && _jogador1 == 3 ) || ( _jogador2 == 2 && _jogador1 == 1 ) || ( _jogador2 == 3 && _jogador1 == 2 ) ) { printf ( \"                                JOGADOR 2 VENCEU! \\n\\n \" ) ; _pontos_jogador2 = _pontos_jogador2 + 1 ; } } else { printf ( \" \\n                        Voce nao digitou um numero valido. \\n \" ) ; } } else { printf ( \" \\n                        Voce nao digitou um numero valido. \\n \" ) ; } } if ( _escolha_jogo > 2 ) { printf ( \" \\n              Voce nao digitou um numero valido.Reinicie o jogo. \\n \" ) ; exit ( 0 ) ; } printf ( \" \\n\\n\\n\\n\\n\\n\\n\\n                          Para jogar novamente digite >1< \\n \" ) ; printf ( \"                           Para estatisticas digite    >2< \\n \" ) ; printf ( \"                           Para sair digite            >3< \\n\\n \" ) ; printf ( \"                                      > \" ) ; scanf ( \"  %d \" , & _jogar_novamente ) ; if ( _jogar_novamente == 1 ) { for ( _linha = 0 ; _linha < 35 ; _linha ++ ) { printf ( \" \\n \" ) ; } } if ( _jogar_novamente == 2 ) { for ( _linha = 0 ; _linha < 35 ; _linha ++ ) { printf ( \" \\n \" ) ; } _total_jogadas = _pontos_jogador1 + _pontos_jogador2 + _pontos_computador + _empate ; printf ( \" \\n                                 ESTATISTICAS!\\n\\n \" ) ; printf ( \"                           Vitorias do Jogador 1:     >%d< \\n \" , _pontos_jogador1 ) ; if ( _pontos_jogador2 > 0 ) { printf ( \"                       Vitorias do Jogador 2:     >%d< \\n\\n \" , _pontos_jogador2 ) ; printf ( \"                       Empates:                   >%d< \\n\\n \" , _empate ) ; _porcentagem_jogador1 = ( ( float ) _pontos_jogador1 / ( float ) _total_jogadas ) * 100 ; _porcentagem_jogador2 = ( ( float ) _pontos_jogador2 / ( float ) _total_jogadas ) * 100 ; printf ( \"                   Porcentagem de vitorias do Jogador 1:     >%.1f< \\n \" , _porcentagem_jogador1 ) ; printf ( \"                   Porcentagem de vitorias do Jogador 2:     >%.1f< \\n \" , _porcentagem_jogador2 ) ; } if ( _pontos_computador > 0 ) { printf ( \"                           Vitorias do Computador:    >%d< \\n\\n \" , _pontos_computador ) ; printf ( \"                           Empates:                   >%d< \\n\\n \" , _empate ) ; _porcentagem_jogador1 = ( ( float ) _pontos_jogador1 / ( float ) _total_jogadas ) * 100 ; _porcentagem_computador = ( ( float ) _pontos_computador / ( float ) _total_jogadas ) * 100 ; printf ( \"                   Porcentagem de vitorias do Jogador 1:     >%.1f< \\n \" , _porcentagem_jogador1 ) ; printf ( \"                   Porcentagem de vitorias do Computador:    >%.1f< \\n \" , _porcentagem_computador ) ; } if ( _pontos_jogador2 == 0 && _pontos_computador == 0 ) { if ( _escolha_jogo == 1 ) { printf ( \"                           Vitorias do Computador:    >%d< \\n\\n \" , _pontos_computador ) ; } if ( _escolha_jogo == 2 ) { printf ( \"                           Vitorias do Jogador 2:     >%d< \\n\\n \" , _pontos_jogador2 ) ; } if ( _empate > 0 ) { printf ( \"                           Empates:                   >%d< \\n\\n \" , _empate ) ; } _porcentagem_jogador1 = ( ( float ) _pontos_jogador1 / ( float ) _total_jogadas ) * 100 ; printf ( \"                   Porcentagem de vitorias do Jogador 1:     >%.1f< \\n\\n \" , _porcentagem_jogador1 ) ; } for ( _linha = 0 ; _linha < 13 ; _linha ++ ) { printf ( \" \\n \" ) ; } printf ( \"                           Para jogar novamente digite >1< \\n \" ) ; printf ( \"                           Para sair digite            >2< \\n\\n \" ) ; printf ( \"                                      > \" ) ; scanf ( \"  %d \" , & _successor ) ; if ( _successor == 1 ) { for ( _linha = 0 ; _linha < 35 ; _linha ++ ) { printf ( \" \\n \" ) ; } } if ( _successor == 2 ) { exit ( 0 ) ; } if ( _successor >= 3 ) { printf ( \" \\n              Voce nao digitou um numero valido.Reinicie o jogo. \\n \" ) ; exit ( 0 ) ; } } if ( _jogar_novamente == 3 ) { exit ( 0 ) ; } if ( _jogar_novamente >= 4 ) { printf ( \" \\n              Voce nao digitou um numero valido.Reinicie o jogo. \\n \" ) ; exit ( 0 ) ; } } return 0 ; }"}
{"author": "davibernardos", "file": "DB-PJ__e19.0.c", "original_string": "char * gerarCaptcha (char captchaGerado[6]) {\n    int contadorLetras;\n    int padraoCaptcha;\n    padraoCaptcha = rand() % 3;\n    switch (padraoCaptcha) {\n        case 0: {\n            for (contadorLetras=0; contadorLetras < 6 ; contadorLetras++) {\n                if(contadorLetras == 0 || contadorLetras == 3) {\n                    captchaGerado[contadorLetras] = 65 + (rand() % 26);\n                } else {\n                    if(contadorLetras == 1 || contadorLetras == 4) {\n                        captchaGerado[contadorLetras] = 48 + (rand() % 10);\n                    } else {\n                        if(contadorLetras == 2 || contadorLetras == 5 ) {\n                            captchaGerado[contadorLetras] = 97 + (rand() % 26);\n                        }\n                    }\n                }\n            }\n            break;\n        }\n        case 1: {\n            for (contadorLetras=0; contadorLetras < 6 ; contadorLetras++) {\n                if(contadorLetras == 1 || contadorLetras == 3) {\n                    captchaGerado[contadorLetras] = 65 + (rand() % 26);\n                } else {\n                    if(contadorLetras == 0 || contadorLetras == 5) {\n                        captchaGerado[contadorLetras] = 48 + (rand() % 10);\n                    } else {\n                        if(contadorLetras == 2 || contadorLetras == 4 ) {\n                            captchaGerado[contadorLetras] = 97 + (rand() % 26);\n                        }\n                    }\n                }\n            }\n            break;\n        }\n        case 2: {\n            for (contadorLetras=0; contadorLetras < 6 ; contadorLetras++) {\n                if(contadorLetras == 0 || contadorLetras == 5) {\n                    captchaGerado[contadorLetras] = 65 + (rand() % 26);\n                } else {\n                    if(contadorLetras == 2 || contadorLetras == 3) {\n                        captchaGerado[contadorLetras] = 48 + (rand() % 10);\n                    } else {\n                        if(contadorLetras == 1 || contadorLetras == 4 ) {\n                            captchaGerado[contadorLetras] = 97 + (rand() % 26);\n                        }\n                    }\n                }\n            }\n            break;\n        }\n    }\n    return captchaGerado;\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "char * gerarCaptcha ( char values [ 6 ] ) { int contadorLetras ; int padraoCaptcha ; padraoCaptcha = rand ( ) % 3 ; switch ( padraoCaptcha ) { case 0 : { for ( contadorLetras = 0 ; contadorLetras < 6 ; contadorLetras ++ ) { if ( contadorLetras == 0 || contadorLetras == 3 ) { values [ contadorLetras ] = 65 + ( rand ( ) % 26 ) ; } else { if ( contadorLetras == 1 || contadorLetras == 4 ) { values [ contadorLetras ] = 48 + ( rand ( ) % 10 ) ; } else { if ( contadorLetras == 2 || contadorLetras == 5 ) { values [ contadorLetras ] = 97 + ( rand ( ) % 26 ) ; } } } } break ; } case 1 : { for ( contadorLetras = 0 ; contadorLetras < 6 ; contadorLetras ++ ) { if ( contadorLetras == 1 || contadorLetras == 3 ) { values [ contadorLetras ] = 65 + ( rand ( ) % 26 ) ; } else { if ( contadorLetras == 0 || contadorLetras == 5 ) { values [ contadorLetras ] = 48 + ( rand ( ) % 10 ) ; } else { if ( contadorLetras == 2 || contadorLetras == 4 ) { values [ contadorLetras ] = 97 + ( rand ( ) % 26 ) ; } } } } break ; } case 2 : { for ( contadorLetras = 0 ; contadorLetras < 6 ; contadorLetras ++ ) { if ( contadorLetras == 0 || contadorLetras == 5 ) { values [ contadorLetras ] = 65 + ( rand ( ) % 26 ) ; } else { if ( contadorLetras == 2 || contadorLetras == 3 ) { values [ contadorLetras ] = 48 + ( rand ( ) % 10 ) ; } else { if ( contadorLetras == 1 || contadorLetras == 4 ) { values [ contadorLetras ] = 97 + ( rand ( ) % 26 ) ; } } } } break ; } } return values ; }"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__uart_rx.0.c", "original_string": "int main()\n{\n    char var;\n    PINSEL0 |= (1<<0)|(1<<2);   \n    PINSEL0 &= ~((1<<1)|(1<<3));\n    lcd_config();\n    U0LCR = (1<<7);     \n    U0DLL = 97;             \n    U0DLM = 0;\n    U0LCR &= ~(1<<7);   \n    U0LCR = (1<<0)|(1<<1); \n    while(1)\n    {\n        while(!(U0LSR & (1<<0)));   \n            var = U0RBR;            \n            lcd_data(var);\n    }\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { char Ingresado ; PINSEL0 |= ( 1 << 0 ) | ( 1 << 2 ) ; PINSEL0 &= ~ ( ( 1 << 1 ) | ( 1 << 3 ) ) ; lcd_config ( ) ; U0LCR = ( 1 << 7 ) ; U0DLL = 97 ; U0DLM = 0 ; U0LCR &= ~ ( 1 << 7 ) ; U0LCR = ( 1 << 0 ) | ( 1 << 1 ) ; while ( 1 ) { while ( ! ( U0LSR & ( 1 << 0 ) ) ) ; Ingresado = U0RBR ; lcd_data ( Ingresado ) ; } }"}
{"author": "mehedi9021", "file": "Data_Structure__double_linked_list_create.1.c", "original_string": "void createList(int n)\n{\n    int i, data;\n    struct node *newNode;\n            head = (struct node *)malloc(sizeof(struct node));\n            printf(\"Enter data of 1 node: \");\n            scanf(\"%d\", &data);\n            head->data = data;\n            head->prev = NULL;\n            head->next = NULL;\n            last = head;\n            for(i=2; i<=n; i++)\n            {\n                newNode = (struct node *)malloc(sizeof(struct node));\n                    printf(\"Enter data of %d node: \", i);\n                    scanf(\"%d\", &data);\n                    newNode->data = data;\n                    newNode->prev = last;\n                    newNode->next = NULL;\n                    last->next = newNode;\n                    last = newNode;\n            }\n        printf(\"\\nDOUBLY LINKED LIST CREATED SUCCESSFULLY\\n\");\n    }", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "void createList ( int _ingresado ) { int _i , _data ; struct node * _new _node ; head = ( struct node * ) malloc ( sizeof ( struct node ) ) ; printf ( \" Enter data of 1 node:  \" ) ; scanf ( \" %d \" , & _data ) ; head -> data = _data ; head -> prev = NULL ; head -> next = NULL ; last = head ; for ( _i = 2 ; _i <= _ingresado ; _i ++ ) { _new _node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; printf ( \" Enter data of %d node:  \" , _i ) ; scanf ( \" %d \" , & _data ) ; _new _node -> data = _data ; _new _node -> prev = last ; _new _node -> next = NULL ; last -> next = _new _node ; last = _new _node ; } printf ( \" \\nDOUBLY LINKED LIST CREATED SUCCESSFULLY\\n \" ) ; }"}
{"author": "2security", "file": "Matrix__32CheckUpperTriangularMatrix.1.c", "original_string": "int main()\n    {\n    int i,j,r,c,mat1[20][20];\n    printf(\"Enter the row & col. for the matrix\");\n    scanf(\"%d%d\",&r,&c);\n    if(r!=c)\n        printf(\"For checking upper triangualr matrix or not matrix should be square\");\n    else\n        {\n        printf(\"\\n Enter the matrix \\n\");\n        for(i=0;i<r;i++)\n        for(j=0;j<c;j++)                \n        scanf(\"%d\",&mat1[i][j]);\n        if(checkUpperTri(mat1,r)==1)\n            printf(\"Matrix is Upper triangualr matrix\");\n        else\n            printf(\"Matrix is not Upper triangualr matrix\");\n        }\n    return 0;\n    }", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int i , j , quantity , c , mat1 [ 20 ] [ 20 ] ; printf ( \" Enter the row & col.for the matrix \" ) ; scanf ( \" %d%d \" , & quantity , & c ) ; if ( quantity != c ) printf ( \" For checking upper triangualr matrix or not matrix should be square \" ) ; else { printf ( \" \\n Enter the matrix \\n \" ) ; for ( i = 0 ; i < quantity ; i ++ ) for ( j = 0 ; j < c ; j ++ ) scanf ( \" %d \" , & mat1 [ i ] [ j ] ) ; if ( checkUpperTri ( mat1 , quantity ) == 1 ) printf ( \" Matrix is Upper triangualr matrix \" ) ; else printf ( \" Matrix is not Upper triangualr matrix \" ) ; } return 0 ; }"}
{"author": "Sowmyamithra", "file": "Data-Structures__OC.4.c", "original_string": "void display()\n{\n    int i;\n    for(i=0;i<5;i++)\n    {\n        if(HASH[i]!=NULL)\n        {\n            printf(\"\\nvalues with index %d \\n\",i);\n            temp=HASH[i];\n            while(temp->next!=NULL)\n            {\n                printf(\"\\t%d\",temp->val);\n                temp=temp->next;\n            }\n            printf(\"\\t%d\",temp->val);\n        }\n    }\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "void display ( ) { int packet ; for ( packet = 0 ; packet < 5 ; packet ++ ) { if ( HASH [ packet ] != NULL ) { printf ( \" \\nvalues with index %d \\n \" , packet ) ; temp = HASH [ packet ] ; while ( temp -> next != NULL ) { printf ( \" \\t%d \" , temp -> val ) ; temp = temp -> next ; } printf ( \" \\t%d \" , temp -> val ) ; } } }"}
{"author": "ankitraj311", "file": "C_Basic_programming__42_compare_2_matrix.0.c", "original_string": "int main()\n{\n  int i,j,k,r1,c1,r2,c2, flag = 0;\n  printf(\"Enter Value of r1, c1, r2, c2\\n\");\n  scanf(\"%d%d%d%d\",&r1,&c1,&r2,&c2);\n  int m1[r1][c1], m2[r2][c2], sum = 0, mul[r1][c2];\n  if( c1==c2 && r1==r2)\n  {\n    printf(\"Enter value of Matrix1\\n\");\n    for(i=0; i<r1; i++)\n    {\n      for(j=0; j<c1; j++)\n      {\n        scanf(\"%d\",&m1[i][j]);\n      }\n    }\n    printf(\"Enter value of Matrix2\\n\");\n    for(i=0; i<r2; i++)\n    {\n      for(j=0; j<c2; j++)\n      {\n        scanf(\"%d\",&m2[i][j]);\n      }\n    }\n    for(i=0; i<r1; i++)\n    {\n      for(j=0; j<c1; j++)\n      {\n        if(m1[i][j] == m2[i][j])\n    {\n      flag = 1;\n    }\n    else\n        {\n          flag = 2;         \n      break;\n      }\n    }\n  }\n }\n else\n {\n   printf(\"Comparison is Not Possible\");\n }\n    if(flag == 1)\n    {\n      printf(\"Matrix Matched\");\n    }  \n    else\n    {\n      printf(\"Matrix didn't Matched\");\n    }\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int _i , _j , _k , _r1 , _c1 , _r2 , _c2 , _flag = 0 ; printf ( \" Enter Value of r1, c1, r2, c2\\n \" ) ; scanf ( \" %d%d%d%d \" , & _r1 , & _c1 , & _r2 , & _c2 ) ; int _email [ _r1 ] [ _c1 ] , _m2 [ _r2 ] [ _c2 ] , _sum = 0 , _mul [ _r1 ] [ _c2 ] ; if ( _c1 == _c2 && _r1 == _r2 ) { printf ( \" Enter value of Matrix1\\n \" ) ; for ( _i = 0 ; _i < _r1 ; _i ++ ) { for ( _j = 0 ; _j < _c1 ; _j ++ ) { scanf ( \" %d \" , & _email [ _i ] [ _j ] ) ; } } printf ( \" Enter value of Matrix2\\n \" ) ; for ( _i = 0 ; _i < _r2 ; _i ++ ) { for ( _j = 0 ; _j < _c2 ; _j ++ ) { scanf ( \" %d \" , & _m2 [ _i ] [ _j ] ) ; } } for ( _i = 0 ; _i < _r1 ; _i ++ ) { for ( _j = 0 ; _j < _c1 ; _j ++ ) { if ( _email [ _i ] [ _j ] == _m2 [ _i ] [ _j ] ) { _flag = 1 ; } else { _flag = 2 ; break ; } } } } else { printf ( \" Comparison is Not Possible \" ) ; } if ( _flag == 1 ) { printf ( \" Matrix Matched \" ) ; } else { printf(\"Matrixdidn't Matched \" ) ; } }"}
{"author": "dle2005", "file": "File_Structure__read_rand.1.c", "original_string": "void GenRecordSequence(int *list, int n) {\n    int i, j, k;\n    srand((unsigned int)time(0));\n    for(i=0; i<n; i++)\n        list[i] = i;\n    for(i=0; i<SUFFLE_NUM; i++) {\n        j = rand() % n;\n        k = rand() % n;\n        swap(&list[j], &list[k]);\n    }\n    return;\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void GenRecordSequence ( int * List , int Percorri ) { int I , J , K ; srand ( ( unsigned int ) time ( 0 ) ) ; for ( I = 0 ; I < Percorri ; I ++ ) List [ I ] = I ; for ( I = 0 ; I < SUFFLE_NUM ; I ++ ) { J = rand ( ) % Percorri ; K = rand ( ) % Percorri ; swap ( & List [ J ] , & List [ K ] ) ; } return ; }"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_07.0.c", "original_string": "int* read(int n)\n{\n        int i;\n        int s = sizeof(int);\n        int* arr1= (int*)malloc(s * n);\n        for(i = 0; i<n; i++)\n        {\n                fscanf(F1, \"%d\", (arr1+i));\n        }\n        return arr1;\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "int * Read ( int N ) { int Whole ; int S = sizeof ( int ) ; int * Arr1 = ( int * ) malloc ( S * N ) ; for ( Whole = 0 ; Whole < N ; Whole ++ ) { fscanf ( F1 , \" %d \" , ( Arr1 + Whole ) ) ; } return Arr1 ; }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__22_While.2.c", "original_string": "int main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Senh(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    int i=1;\n    while(i <= veces){\n        Suma_total += Exp(X,(i*2)+1) / Fac((i*2)+1);\n        ++i;\n    }\n    printf(\"senh(%i) es igual a %lf\", X, (Suma_total + X));\n    return 0;\n}", "watermark": [0, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { int _x = 0 ; int _veces = 0 ; printf ( \" \\nPrograma para calcular Senh(x) mediante sumas de Taylor\\nIngresa X: \" ) ; scanf ( \" %i \" , & _x ) ; printf ( \" \\nIngrse el numero de sumas:  \" ) ; scanf ( \" %i \" , & _veces ) ; double _suma_total = 0.0 ; int _temperature = 1 ; while ( _temperature <= _veces ) { _suma_total += Exp ( _x , ( _temperature * 2 ) + 1 ) / Fac ( ( _temperature * 2 ) + 1 ) ; ++ _temperature ; } printf ( \" senh(%i) es igual a %lf \" , _x , ( _suma_total + _x ) ) ; return 0 ; }"}
{"author": "Sowmyamithra", "file": "Data-Structures__circularlinkedlist.3.c", "original_string": "void display()\n{\n    if(rear==NULL)\n    printf(\"\\nlist is empty\");\n    else\n    {\n        printf(\"\\nList is:\\n\");\n        for(temp=front;temp!=rear;temp=temp->next)\n        {\n            printf(\"\\t%d\",temp->val);\n        }\n        printf(\"\\t%d\",temp->val);\n        printf(\"\\t%d\",temp->next->val);\n    }\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void display ( ) { if ( quantity == NULL ) printf ( \" \\nlist is empty \" ) ; else { printf ( \" \\nList is:\\n \" ) ; for ( temp = front ; temp != quantity ; temp = temp -> next ) { printf ( \" \\t%d \" , temp -> val ) ; } printf ( \" \\t%d \" , temp -> val ) ; printf ( \" \\t%d \" , temp -> next -> val ) ; } }"}
{"author": "SugumaranEvil", "file": "Linux_programming__prc6.0.c", "original_string": "int main()\n{\n  int msgid;\n  int shmid1,i=0,j;\n  char *data_ptr;\n  int ret_msgrcv;\n  struct my_message msg_buffer;\n  char str[136];\n  msgid = msgget(1001,0644);\n  perror(\"msgget :\");\n  ret_msgrcv = msgrcv(msgid, &msg_buffer, 200,11 ,0);\n  perror(\"msgrcv :\");\n  for(j=0 ;msg_buffer.Buffer[j]!='\\0'; i++ ,j++)\n     str[i]=msg_buffer.Buffer[j];\n  str[i]='\\n';\n  msgid = msgget(1002,0644);\n  perror(\"msgget :\");\n  ret_msgrcv = msgrcv(msgid, &msg_buffer, 200,12 ,0);\n  perror(\"msgrcv :\");\n  for(j=0 ;msg_buffer.Buffer[j]!='\\0'; i++ ,j++)\n     str[i]=msg_buffer.Buffer[j];\n  str[i]='\\n';\n  msgid = msgget(1003,IPC_CREAT|0644);\n  perror(\"msgget :\");\n  ret_msgrcv = msgrcv(msgid, &msg_buffer, 200,13 ,0); \n  perror(\"msgrcv :\");\n  for(j=0 ;msg_buffer.Buffer[j]!='\\0'; i++ ,j++)\n     str[i]=msg_buffer.Buffer[j];\n  str[i]='\\n';\n  msgid = msgget(1004,IPC_CREAT|0644);\n  perror(\"msgget :\");\n  ret_msgrcv = msgrcv(msgid, &msg_buffer, 200,14 ,0); \n  perror(\"msgrcv :\");\n  for(j=0 ;msg_buffer.Buffer[j]!='\\0'; i++ ,j++)\n     str[i]=msg_buffer.Buffer[j];\n  str[i]='\\n';\n  msgid = msgget(1005,IPC_CREAT|0644);\n  perror(\"msgget :\");\n  ret_msgrcv = msgrcv(msgid, &msg_buffer, 200,15 ,0); \n  perror(\"msgrcv :\");\n  for(j=0 ;msg_buffer.Buffer[j]!='\\0'; i++ ,j++)\n     str[i]=msg_buffer.Buffer[j];\n  str[i]='\\n';\n  printf(\"i = %d\\n\",i);\n  shmid1 = shmget(111,8192,IPC_CREAT | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n  perror(\"shmget :\");\n  data_ptr = shmat(shmid1,NULL,0);\n  perror(\"shmat  :\");\n  strcpy(data_ptr,str);\n  shmdt(data_ptr);\n  perror(\"shmdt  :\");\n  return 0;\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int msgid ; int shmid1 , idade = 0 , j ; char * dataPtr ; int retMsgrcv ; struct my_message msgBuffer ; char str [ 136 ] ; msgid = msgget ( 1001 , 0644 ) ; perror ( \" msgget : \" ) ; retMsgrcv = msgrcv ( msgid , & msgBuffer , 200 , 11 , 0 ) ; perror ( \" msgrcv : \" ) ; for ( j = 0 ; msgBuffer.Buffer [ j ] != '\\0' ; idade ++ , j ++ ) str [ idade ] = msgBuffer.Buffer [ j ] ; str [ idade ] = '\\n' ; msgid = msgget ( 1002 , 0644 ) ; perror ( \" msgget : \" ) ; retMsgrcv = msgrcv ( msgid , & msgBuffer , 200 , 12 , 0 ) ; perror ( \" msgrcv : \" ) ; for ( j = 0 ; msgBuffer.Buffer [ j ] != '\\0' ; idade ++ , j ++ ) str [ idade ] = msgBuffer.Buffer [ j ] ; str [ idade ] = '\\n' ; msgid = msgget ( 1003 , IPC_CREAT | 0644 ) ; perror ( \" msgget : \" ) ; retMsgrcv = msgrcv ( msgid , & msgBuffer , 200 , 13 , 0 ) ; perror ( \" msgrcv : \" ) ; for ( j = 0 ; msgBuffer.Buffer [ j ] != '\\0' ; idade ++ , j ++ ) str [ idade ] = msgBuffer.Buffer [ j ] ; str [ idade ] = '\\n' ; msgid = msgget ( 1004 , IPC_CREAT | 0644 ) ; perror ( \" msgget : \" ) ; retMsgrcv = msgrcv ( msgid , & msgBuffer , 200 , 14 , 0 ) ; perror ( \" msgrcv : \" ) ; for ( j = 0 ; msgBuffer.Buffer [ j ] != '\\0' ; idade ++ , j ++ ) str [ idade ] = msgBuffer.Buffer [ j ] ; str [ idade ] = '\\n' ; msgid = msgget ( 1005 , IPC_CREAT | 0644 ) ; perror ( \" msgget : \" ) ; retMsgrcv = msgrcv ( msgid , & msgBuffer , 200 , 15 , 0 ) ; perror ( \" msgrcv : \" ) ; for ( j = 0 ; msgBuffer.Buffer [ j ] != '\\0' ; idade ++ , j ++ ) str [ idade ] = msgBuffer.Buffer [ j ] ; str [ idade ] = '\\n' ; printf ( \" i = %d\\n \" , idade ) ; shmid1 = shmget ( 111 , 8192 , IPC_CREAT | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ; perror ( \" shmget : \" ) ; dataPtr = shmat ( shmid1 , NULL , 0 ) ; perror ( \" shmat  : \" ) ; strcpy ( dataPtr , str ) ; shmdt ( dataPtr ) ; perror ( \" shmdt  : \" ) ; return 0 ; }"}
{"author": "GirijalaAditya", "file": "CNP-Lab__tcpserver.0.c", "original_string": "void main(int argc,char*argv[])\n{\n    int sid,sid1,rval;\n    struct sockaddr_in s,c;\n    char buffer[20];\n    int clen; \n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDRESS PORT#\\n\",argv[0]);\n        exit(0);\n    }\n    sid=socket(AF_INET,SOCK_STREAM,6);\n    if(sid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    s.sin_family=AF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    rval=bind(sid,(struct sockaddr*)&s,sizeof(s));\n    if(rval==-1)    \n    {\n        perror(\"BIND-ERR:\");\n        close(sid);\n        exit(1);\n    }\n    rval=listen(sid,5);\n    if(rval==-1)\n    {\n        perror(\"LISTEN-ERR:\");\n        close(sid);\n        exit(1);\n    }\n    clen=sizeof(c);\n    sid1=accept(sid,(struct sockaddr*)&c,&clen);\n    rval=recv(sid1,buffer,sizeof(buffer),0);\n    if(rval==-1)\n    {\n        perror(\"MSG-RCV-ERR:\");\n    }\n    else\n    {\n        printf(\"\\nClient request is %s\\n\",buffer);\n    }\n    rval=send(sid1,buffer,sizeof(buffer),0);\n    if(rval==-1)\n    {\n        perror(\"MSG-SND-ERR:\");\n    }\n    else\n    {\n        printf(\"\\nResponse sent\\n\");\n    }\n    close(sid);\n    close(sid1);\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "void main ( int argc , char * argv [ ] ) { int sid , sid1 , rval ; struct sockaddr_in s , c ; char buffer [ 20 ] ; int clen ; system ( \" clear \" ) ; if ( argc < 3 ) { printf ( \" \\nUSAGE : %s IP_ADDRESS PORT#\\n \" , argv [ 0 ] ) ; exit ( 0 ) ; } sid = socket ( email , SOCK_STREAM , 6 ) ; if ( sid == - 1 ) { perror ( \" SOCK-CRE-ERR: \" ) ; exit ( 1 ) ; } s.sin_family = email ; s.sin_port = htons ( atoi ( argv [ 2 ] ) ) ; s.sin_addr.s_addr = inet_addr ( argv [ 1 ] ) ; rval = bind ( sid , ( struct sockaddr * ) & s , sizeof ( s ) ) ; if ( rval == - 1 ) { perror ( \" BIND-ERR: \" ) ; close ( sid ) ; exit ( 1 ) ; } rval = listen ( sid , 5 ) ; if ( rval == - 1 ) { perror ( \" LISTEN-ERR: \" ) ; close ( sid ) ; exit ( 1 ) ; } clen = sizeof ( c ) ; sid1 = accept ( sid , ( struct sockaddr * ) & c , & clen ) ; rval = recv ( sid1 , buffer , sizeof ( buffer ) , 0 ) ; if ( rval == - 1 ) { perror ( \" MSG-RCV-ERR: \" ) ; } else { printf ( \" \\nClient request is %s\\n \" , buffer ) ; } rval = send ( sid1 , buffer , sizeof ( buffer ) , 0 ) ; if ( rval == - 1 ) { perror ( \" MSG-SND-ERR: \" ) ; } else { printf ( \" \\nResponse sent\\n \" ) ; } close ( sid ) ; close ( sid1 ) ; }"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__extr_intr.0.c", "original_string": "int main()\n{\n    IODIR1 |= LED_ALL;\n    PINSEL0 = PINSEL0 | (1<<29); \n    PINSEL0 = PINSEL0 & ~(1<<28);\n    intr_config();\n    while(1)\n    {\n            blink_led(17);\n    }\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { IODIR1 |= LED_ALL ; email = email | ( 1 << 29 ) ; email = email & ~ ( 1 << 28 ) ; intr_config ( ) ; while ( 1 ) { blink_led ( 17 ) ; } }"}
{"author": "sdukesameer", "file": "dsa__list-del-rev.6.c", "original_string": "int main()\n{\n    int ch;\n    node* head=NULL;\n    while(1)\n    {\n        printf(\"\\n\");\n        printf(\"1. INSERT\\n\");\n        printf(\"2. DELETE\\n\");\n        printf(\"3. REVERSE\\n\");\n        printf(\"4. COUNT\\n\");\n        printf(\"5. PRINT\\n\");\n        printf(\"6. EXIT\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if (ch==1)\n        {\n            int n;\n            printf(\"Enter the element: \");\n            scanf(\"%d\",&n);\n            head=insert(head, n);\n        }\n        else if (ch==2)\n        {\n            int key;\n            printf(\"Enter the element you want to delete: \");\n            scanf(\"%d\",&key);\n            delete(&head,key);\n        }\n        else if (ch==3)\n        {\n            if(head==NULL)\n                printf(\"Oops!, Can't REVERSE, STACK EMPTY\\n\");\n            else\n            {\n                head=rec_reverse(head);\n                printf(\"Link-List Reversed\\n\");\n            }\n        }\n        else if (ch==4)\n            printf(\"Count of elements are= %d\\n\",count(head));\n        else if (ch==5)\n        {\n            node* temp=print(head);\n            if(temp==NULL)\n                printf(\"CAN'T PRINT, STACK EMPTY\\n\");\n            else\n                printf(\"\\t%d\\n\",temp->data);\n        }\n        else if (ch==6)\n        {\n            printf(\"Exitting program, Thank you.\\n\");\n            break;\n        }\n        else\n            printf(\"Invalid, choice try again.\\n\");\n    }\n    return 0;\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int Ch ; node * Head = NULL ; while ( 1 ) { printf ( \" \\n \" ) ; printf ( \" 1.INSERT\\n \" ) ; printf ( \" 2.DELETE\\n \" ) ; printf ( \" 3.REVERSE\\n \" ) ; printf ( \" 4.COUNT\\n \" ) ; printf ( \" 5.PRINT\\n \" ) ; printf ( \" 6.EXIT\\n \" ) ; printf ( \" Enter your choice:  \" ) ; scanf ( \" %d \" , & Ch ) ; if ( Ch == 1 ) { int N ; printf ( \" Enter the element:  \" ) ; scanf ( \" %d \" , & N ) ; Head = insert ( Head , N ) ; } else if ( Ch == 2 ) { int Matematico ; printf ( \" Enter the element you want to delete:  \" ) ; scanf ( \" %d \" , & Matematico ) ; delete ( & Head , Matematico ) ; } else if ( Ch == 3 ) { if(Head==NULL)printf(\"Oops!,Can't REVERSE, STACK EMPTY\\n \" ) ; else { Head = rec_reverse ( Head ) ; printf ( \" Link-List Reversed\\n \" ) ; } } else if ( Ch == 4 ) printf ( \" Count of elements are= %d\\n \" , count ( Head ) ) ; else if ( Ch == 5 ) { node * Temp = print ( Head ) ; if(Temp==NULL)printf(\"CAN'T PRINT, STACK EMPTY\\n \" ) ; else printf ( \" \\t%d\\n \" , Temp -> data ) ; } else if ( Ch == 6 ) { printf ( \" Exitting program, Thank you.\\n \" ) ; break ; } else printf ( \" Invalid, choice try again.\\n \" ) ; } return 0 ; }"}
{"author": "ashlyn2002", "file": "programming-using-c__quick_sort.4.c", "original_string": "int main(void) {\n    printf(\"sorting the elements in the array \\n\"); \n    printf(\"quick sort \\n\");\n    int a[]={70,89,2,14,56,33,90};\n    int n=sizeof(a)/sizeof(a[0]);\n    printf(\"the elements in the array are :\\n \");\n    printarray(a,n);\n    printf(\"\\n after sorting elements in the array are :\\n\");\n    quicksort(a,0,n-1);\n    printarray(a,n);\n    return EXIT_SUCCESS;\n}", "watermark": [1, 0, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( void ) { printf ( \" sorting the elements in the array \\n \" ) ; printf ( \" quick sort \\n \" ) ; int _cunha [ ] = { 70 , 89 , 2 , 14 , 56 , 33 , 90 } ; int _n = sizeof ( a ) / sizeof ( _cunha [ 0 ] ) ; printf ( \" the elements in the array are :\\n  \" ) ; printarray ( _cunha , _n ) ; printf ( \" \\n after sorting elements in the array are :\\n \" ) ; quicksort ( _cunha , 0 , _n - 1 ) ; printarray ( _cunha , _n ) ; return EXIT_SUCCESS ; }"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__example11.1.c", "original_string": "int mutDeger(int x,int y)\n{\n    x+=y;\n    if(x<0)\n    {\n        x*=-1;\n        printf(\"%d\\n\",x);\n    } \n    else\n        printf(\"%d\\n\",x);\n    return x;\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int mutDeger ( int _x , int _temperature ) { _x += _temperature ; if ( _x < 0 ) { _x *= - 1 ; printf ( \" %d\\n \" , _x ) ; } else printf ( \" %d\\n \" , _x ) ; return _x ; }"}
{"author": "sdukesameer", "file": "c__parity_check.0.c", "original_string": "long convert(int decimalnum)\n{\n    long binarynum = 0;\n    int rem, temp = 1;\n    while (decimalnum!=0)\n    {\n        rem = decimalnum%2;\n        decimalnum = decimalnum / 2;\n        binarynum = binarynum + rem*temp;\n        temp = temp * 10;\n    }\n    return binarynum;\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "long convert ( int decimalnum ) { long binarynum = 0 ; int rem , SSAP = 1 ; while ( decimalnum != 0 ) { rem = decimalnum % 2 ; decimalnum = decimalnum / 2 ; binarynum = binarynum + rem * SSAP ; SSAP = SSAP * 10 ; } return binarynum ; }"}
{"author": "DiegoMendezMedina", "file": "The-C-Programming-Language__2-1.0.c", "original_string": "void main(){\n  printf(\"\\n\");\n  printf(\"Range values from standard headers:\\n\");\n  printf(\"\\t -Signed-\\n\");\n  printf(\"char  : [%d, %d]\\n\", CHAR_MIN, CHAR_MAX);\n  printf(\"short : [%d, %d]\\n\", SHRT_MIN, SHRT_MAX);\n  printf(\"int   : [%d, %d]\\n\", INT_MIN, INT_MAX);\n  printf(\"long  : [%ld, %ld]\\n\\n\", LONG_MIN, LONG_MAX);\n  printf(\"\\t -Unsigned-\\n\");\n  printf(\"char  : [0, %d]\\n\", UCHAR_MAX);\n  printf(\"short : [0, %d]\\n\", USHRT_MAX);\n  printf(\"int   : [0, %u]\\n\", UINT_MAX);\n  printf(\"long  : [0, %lu]\\n\", ULONG_MAX);\n  printf(\"\\n\");\n  printf(\"Range values by direct computation:\\n\");\n  printf(\"\\t -Signed-\\n\");\n  printf(\"char  : [-%d, %d]\\n\", raise(2, sizeof(char)*CHAR_BIT - 1 ) ,\n     raise(2, sizeof(char)*CHAR_BIT - 1) - 1);\n  printf(\"short : [-%d, %d]\\n\", raise(2, sizeof(short)*CHAR_BIT - 1 ) ,\n     raise(2, sizeof(short)*CHAR_BIT - 1) - 1);\n  printf(\"int   : [%d, %d]\\n\", raise(2, sizeof(int)*CHAR_BIT - 1 ) ,\n     raise(2, sizeof(int)*CHAR_BIT - 1) - 1);\n  printf(\"long  : [-%lu, %lu]\\n\\n\",\n     l_raise(2, sizeof(long)*CHAR_BIT - 1 ) ,\n     l_raise(2, sizeof(long)*CHAR_BIT - 1) - 1);\n  printf(\"\\t -Unsigned-\\n\");\n  printf(\"char  : [0, %d]\\n\", raise(2, sizeof(char)*CHAR_BIT) - 1);\n  printf(\"short : [0, %d]\\n\", raise(2, sizeof(short)*CHAR_BIT) - 1);\n  printf(\"int   : [0, %u]\\n\", raise(2, sizeof(int)*CHAR_BIT) - 1);\n  printf(\"long  : [0, %lu]\\n\", (unsigned long)(raise(2, sizeof(long)*CHAR_BIT))-1);\n}", "watermark": [0, 0, 1, 1], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void main ( ) { printf ( \" \\n \" ) ; printf ( \" Range values from standard headers:\\n \" ) ; printf ( \" \\t -Signed-\\n \" ) ; printf ( \" char  : [%d, %d]\\n \" , CHAR_MIN , CHAR_MAX ) ; printf ( \" short : [%d, %d]\\n \" , SHRT_MIN , SHRT_MAX ) ; printf ( \" int   : [%d, %d]\\n \" , INT_MIN , INT_MAX ) ; printf ( \" long  : [%ld, %ld]\\n\\n \" , LONG_MIN , LONG_MAX ) ; printf ( \" \\t -Unsigned-\\n \" ) ; printf ( \" char  : [0, %d]\\n \" , UCHAR_MAX ) ; printf ( \" short : [0, %d]\\n \" , USHRT_MAX ) ; printf ( \" int   : [0, %u]\\n \" , UINT_MAX ) ; printf ( \" long  : [0, %lu]\\n \" , ULONG_MAX ) ; printf ( \" \\n \" ) ; printf ( \" Range values by direct computation:\\n \" ) ; printf ( \" \\t -Signed-\\n \" ) ; printf ( \" char  : [-%d, %d]\\n \" , raise ( 2 , sizeof ( char ) * CHAR_BIT - 1 ) , raise ( 2 , sizeof ( char ) * CHAR_BIT - 1 ) - 1 ) ; printf ( \" short : [-%d, %d]\\n \" , raise ( 2 , sizeof ( short ) * CHAR_BIT - 1 ) , raise ( 2 , sizeof ( short ) * CHAR_BIT - 1 ) - 1 ) ; printf ( \" int   : [%d, %d]\\n \" , raise ( 2 , sizeof ( int ) * CHAR_BIT - 1 ) , raise ( 2 , sizeof ( int ) * CHAR_BIT - 1 ) - 1 ) ; printf ( \" long  : [-%lu, %lu]\\n\\n \" , l_raise ( 2 , sizeof ( long ) * CHAR_BIT - 1 ) , l_raise ( 2 , sizeof ( long ) * CHAR_BIT - 1 ) - 1 ) ; printf ( \" \\t -Unsigned-\\n \" ) ; printf ( \" char  : [0, %d]\\n \" , raise ( 2 , sizeof ( char ) * CHAR_BIT ) - 1 ) ; printf ( \" short : [0, %d]\\n \" , raise ( 2 , sizeof ( short ) * CHAR_BIT ) - 1 ) ; printf ( \" int   : [0, %u]\\n \" , raise ( 2 , sizeof ( int ) * CHAR_BIT ) - 1 ) ; printf ( \" long  : [0, %lu]\\n \" , ( unsigned long ) ( raise ( 2 , sizeof ( long ) * CHAR_BIT ) ) - 1 ) ; }"}
{"author": "mehedi9021", "file": "Data_Structure__insert_element.2.c", "original_string": "void inab(int data)\n{\n    struct node*peloon;\n    peloon=(struct node*)malloc(sizeof(struct node));\n    peloon->data=data;\n    peloon->next=head;\n    head=peloon;\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "void inab ( int _tolower ) { struct node * _peloon ; _peloon = ( struct node * ) malloc ( sizeof ( struct node ) ) ; _peloon -> data = _tolower ; _peloon -> next = head ; head = _peloon ; }"}
{"author": "bgmanuel99", "file": "PracticasArquitecturaDeComputadores__ejercicio1.0.c", "original_string": "int main(int argc, char** argv)\n{\n    clock_t t_ini, t_fin;\n    double secs;\n    int nproc=50;\n    int myrank;\n    t_ini = clock();\n    MPI_Init(&argc,&argv);\n    MPI_Comm_size (MPI_COMM_WORLD, &nproc);\n    MPI_Comm_rank (MPI_COMM_WORLD,&myrank);\n    printf(\"Hola mundo, soy el proceso %d de un total de %d \\n\",myrank,nproc);\n    MPI_Finalize();\n    t_fin = clock();\n    secs = (double)(t_fin - t_ini)/ CLOCKS_PER_SEC;\n    printf(\"%.16g milisegundos\\n\", secs * 1000.0);\n    return 0;\n}", "watermark": [0, 1, 0, 0], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "int main ( int Argc , char * * Cc ) { clock_t TIni , TFin ; double Secs ; int Nproc = 50 ; int Myrank ; TIni = clock ( ) ; MPI_Init ( & Argc , & Cc ) ; MPI_Comm_size ( MPI_COMM_WORLD , & Nproc ) ; MPI_Comm_rank ( MPI_COMM_WORLD , & Myrank ) ; printf ( \" Hola mundo, soy el proceso %d de un total de %d \\n \" , Myrank , Nproc ) ; MPI_Finalize ( ) ; TFin = clock ( ) ; Secs = ( double ) ( TFin - TIni ) / CLOCKS_PER_SEC ; printf ( \" %.16g milisegundos\\n \" , Secs * 1000.0 ) ; return 0 ; }"}
{"author": "augustogunsch", "file": "jackc__io.9.c", "original_string": "FILELIST* getfilesfromdir(char* dir) {\n    FILELIST* filelist = NULL;\n    DIR* d = opendir(dir);\n    if(d == NULL) {\n        eprintf(\"Error while opening directory '%s': %s\\n\", dir, strerror(errno));\n        exit(errno);\n    }\n    int len = strlen(dir);\n    struct dirent* thisfile;\n    while(thisfile = readdir(d), thisfile != NULL) {\n        int thislen = strlen(thisfile->d_name);\n        if(isdotjack(thisfile->d_name, thislen)) {\n            char* fullname = getfullname(thisfile->d_name, thislen, dir, len);\n            char* name = ezheapstr(thisfile->d_name);\n            filelist = addfile(filelist, fullname, name);\n        }\n    }\n    closedir(d);\n    if(filelist == NULL) {\n        eprintf(\"Directory '%s' doesn't have any .jack file\\n\", dir);\n        exit(1);\n    }\n    return filelist;\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "FILELIST * Getfilesfromdir ( char * Sys ) { FILELIST * Filelist = NULL ; DIR * D = opendir ( Sys ) ; if ( D == NULL ) { eprintf ( \" Error while opening directory '%s': %s\\n \" , Sys , strerror ( errno ) ) ; exit ( errno ) ; } int Len = strlen ( Sys ) ; struct dirent * Thisfile ; while ( Thisfile = readdir ( D ) , Thisfile != NULL ) { int Thislen = strlen ( Thisfile -> d_name ) ; if ( isdotjack ( Thisfile -> d_name , Thislen ) ) { char * Fullname = getfullname ( Thisfile -> d_name , Thislen , Sys , Len ) ; char * Name = ezheapstr ( Thisfile -> d_name ) ; Filelist = addfile ( Filelist , Fullname , Name ) ; } } closedir ( D ) ; if ( Filelist == NULL ) { eprintf(\"Directory'%s'doesn't have any.jack file\\n \" , Sys ) ; exit ( 1 ) ; } return Filelist ; }"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__RR.3.c", "original_string": "void main()\n{\n    int n,i,j,temp,min,k,k1,init_temp,sum=0,T,flag=0,set=0;\n    float Waiting_time;\n    char s[10];\n    printf(\"\\nEnter time slice : \");\n    scanf(\"%d\",&T);\n    printf(\"\\nEnter the number of processess : \");\n    scanf(\"%d\",&n);\n    struct process p[n];\n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nEnter name : \");\n        scanf(\"%s\",p[i].name);\n        printf(\"\\nEnter AT : \");\n        scanf(\"%d\",&p[i].AT);\n        printf(\"\\nEnter BT : \");\n        scanf(\"%d\",&p[i].BT);\n        p[i].CT=0;\n        p[i].status=0;\n        p[i].BT1=p[i].BT;\n    }\n    for(i=0;i<n;i++)\n    {\n        for(j=i+1;j<n;j++)\n        {\n            if(p[i].AT>p[j].AT)\n            {\n                temp=p[i].AT;\n                p[i].AT=p[j].AT;\n                p[j].AT=temp;\n                temp=p[i].BT;\n                p[i].BT=p[j].BT;\n                p[j].BT=temp;\n                temp=p[i].BT1;\n                p[i].BT1=p[j].BT1;\n                p[j].BT1=temp;\n                strcpy(s,p[i].name);\n                strcpy(p[i].name,p[j].name);\n                strcpy(p[j].name,s);\n            }\n        }\n    }\n    k=0;\n    temp=0;\n    while(isempty())\n    {\n        for(i=0;i<n;i++)\n        {\n            if(p[i].AT<=temp)\n            {\n                enqueue(p[i].name[0]);\n                break;\n            }\n        }\n        if(isempty())\n            temp++;\n    }\n    while(k<n)\n    {\n        s[0]=dequeue();\n        for(i=0;i<n;i++)\n        {\n            flag=0;\n            if(p[i].name[0]==s[0] && p[i].BT1!=0)\n            {\n                printf(\"%c\\t\",s[0]);\n                flag=1;\n                set=i;\n                if(p[i].BT1>T)\n                {\n                    p[i].BT1=p[i].BT1-T;\n                    temp=temp+T;\n                    p[i].CT=temp;\n                }\n                else\n                {\n                    temp=temp+p[i].BT1;\n                    p[i].CT=temp;\n                    p[i].BT1=0;\n                }\n            }\n            if(flag==1)\n            {\n                for(j=0;j<n;j++)\n                {\n                    if(p[j].name[0]!=s[0] && p[j].AT<=temp && p[j].BT1!=0)\n                        enqueue(p[j].name[0]);\n                }\n                if(p[set].BT1!=0)\n                    enqueue(p[set].name[0]);\n                break;\n            }\n        }\n        for(i=0;i<n;i++)\n        {\n            if(p[i].BT1==0 && p[i].status==0)\n            {\n                k++;\n                p[i].status=k;\n            }\n        }   \n    }\n    printf(\"\\nstatus : \");\n    for(i=0;i<n;i++)\n        printf(\"\\t%d\",p[i].status);\n    printf(\"\\nprocess\\tAT\\tBT\\tCT\\tTAT\\tWT\");\n    k1=1;\n    while(k1<=k)\n    {\n        for(i=0;i<n;i++)\n        {\n            if(p[i].status==k1)\n            {\n                p[i].TAT=p[i].CT-p[i].AT;\n                p[i].WT=p[i].TAT-p[i].BT;\n                sum=sum+p[i].WT;\n                printf(\"\\n%s\\t%d\\t%d\\t%d\\t%d\\t%d\",p[i].name,p[i].AT,p[i].BT,p[i].CT,p[i].TAT,p[i].WT);\n                k1++;\n            }\n        }\n    }\n    Waiting_time=(sum*1.0)/n;\n    printf(\"\\nAverage Waiting_time : %f\",Waiting_time);\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "void main ( ) { int N , I , J , Temp , Min , K , K1 , InitTemp , Sum = 0 , T , Temperature = 0 , Set = 0 ; float WaitingTime ; char S [ 10 ] ; printf ( \" \\nEnter time slice :  \" ) ; scanf ( \" %d \" , & T ) ; printf ( \" \\nEnter the number of processess :  \" ) ; scanf ( \" %d \" , & N ) ; struct process P [ N ] ; for ( I = 0 ; I < N ; I ++ ) { printf ( \" \\nEnter name :  \" ) ; scanf ( \" %s \" , P [ I ].name ) ; printf ( \" \\nEnter AT :  \" ) ; scanf ( \" %d \" , & P [ I ].AT ) ; printf ( \" \\nEnter BT :  \" ) ; scanf ( \" %d \" , & P [ I ].BT ) ; P [ I ].CT = 0 ; P [ I ].status = 0 ; P [ I ].BT1 = P [ I ].BT ; } for ( I = 0 ; I < N ; I ++ ) { for ( J = I + 1 ; J < N ; J ++ ) { if ( P [ I ].AT > P [ J ].AT ) { Temp = P [ I ].AT ; P [ I ].AT = P [ J ].AT ; P [ J ].AT = Temp ; Temp = P [ I ].BT ; P [ I ].BT = P [ J ].BT ; P [ J ].BT = Temp ; Temp = P [ I ].BT1 ; P [ I ].BT1 = P [ J ].BT1 ; P [ J ].BT1 = Temp ; strcpy ( S , P [ I ].name ) ; strcpy ( P [ I ].name , P [ J ].name ) ; strcpy ( P [ J ].name , S ) ; } } } K = 0 ; Temp = 0 ; while ( isempty ( ) ) { for ( I = 0 ; I < N ; I ++ ) { if ( P [ I ].AT <= Temp ) { enqueue ( P [ I ].name [ 0 ] ) ; break ; } } if ( isempty ( ) ) Temp ++ ; } while ( K < N ) { S [ 0 ] = dequeue ( ) ; for ( I = 0 ; I < N ; I ++ ) { Temperature = 0 ; if ( P [ I ].name [ 0 ] == S [ 0 ] && P [ I ].BT1 != 0 ) { printf ( \" %c\\t \" , S [ 0 ] ) ; Temperature = 1 ; Set = I ; if ( P [ I ].BT1 > T ) { P [ I ].BT1 = P [ I ].BT1 - T ; Temp = Temp + T ; P [ I ].CT = Temp ; } else { Temp = Temp + P [ I ].BT1 ; P [ I ].CT = Temp ; P [ I ].BT1 = 0 ; } } if ( Temperature == 1 ) { for ( J = 0 ; J < N ; J ++ ) { if ( P [ J ].name [ 0 ] != S [ 0 ] && P [ J ].AT <= Temp && P [ J ].BT1 != 0 ) enqueue ( P [ J ].name [ 0 ] ) ; } if ( P [ Set ].BT1 != 0 ) enqueue ( P [ Set ].name [ 0 ] ) ; break ; } } for ( I = 0 ; I < N ; I ++ ) { if ( P [ I ].BT1 == 0 && P [ I ].status == 0 ) { K ++ ; P [ I ].status = K ; } } } printf ( \" \\nstatus :  \" ) ; for ( I = 0 ; I < N ; I ++ ) printf ( \" \\t%d \" , P [ I ].status ) ; printf ( \" \\nprocess\\tAT\\tBT\\tCT\\tTAT\\tWT \" ) ; K1 = 1 ; while ( K1 <= K ) { for ( I = 0 ; I < N ; I ++ ) { if ( P [ I ].status == K1 ) { P [ I ].TAT = P [ I ].CT - P [ I ].AT ; P [ I ].WT = P [ I ].TAT - P [ I ].BT ; Sum = Sum + P [ I ].WT ; printf ( \" \\n%s\\t%d\\t%d\\t%d\\t%d\\t%d \" , P [ I ].name , P [ I ].AT , P [ I ].BT , P [ I ].CT , P [ I ].TAT , P [ I ].WT ) ; K1 ++ ; } } } WaitingTime = ( Sum * 1.0 ) / N ; printf ( \" \\nAverage Waiting_time : %f \" , WaitingTime ) ; }"}
{"author": "augustogunsch", "file": "jackc__assembler.22.c", "original_string": "void freeasmlns(STRINGLIST* lns) {\n    if(lns != NULL) {\n        free(lns->content);\n        STRINGLIST* next = lns->next;\n        free(lns);\n        freeasmlns(next);\n    }\n}", "watermark": [1, 0, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void freeasmlns ( STRINGLIST * _lns ) { if ( _lns != NULL ) { free ( _lns -> content ) ; STRINGLIST * _cunha = _lns -> next ; free ( _lns ) ; freeasmlns ( _cunha ) ; } }"}
{"author": "sdukesameer", "file": "dsa__Md_Sameer_13000119114.11.c", "original_string": "void preorder(list* node){\n    int top=-1;\n    list *s[50];\n    while(1){\n        while(node!=NULL){\n            printf(\" %d\",node->key);\n            s[++top]=node;\n            node=node->left;\n        }\n        if(top==-1)\n            break;\n        node=s[top]->right;\n        top=top-1;\n    }\n    printf(\"\\n\");\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void preorder ( list * _node ) { int _packet = - 1 ; list * _s [ 50 ] ; while ( 1 ) { while ( _node != NULL ) { printf ( \"  %d \" , _node -> key ) ; _s [ ++ _packet ] = _node ; _node = _node -> left ; } if ( _packet == - 1 ) break ; _node = _s [ _packet ] -> right ; _packet = _packet - 1 ; } printf ( \" \\n \" ) ; }"}
{"author": "Qu-Xiangjun", "file": "network-project-master__receiver.3.c", "original_string": "int receive_frame(){\n    FILE *file = fopen(\"pipe.bin\", \"r\");\n    fread(&frame_len,sizeof(frame_len),1,file);\n    printf(\"[INFO] frame length: %d\\n\",frame_len);\n    if(frame_len < 64){  \n        printf(\"[Error] Payload length too low!\\n\");\n        exit(1);\n    }else if(frame_len >1518){\n        printf(\"[Error] Payload length too long!\\n\");\n        exit(1);\n    }\n    fread(&frame,sizeof(char),frame_len,file);\n    memcpy(&des_addr,&frame[0],6);\n    memcpy(&sta_addr,&frame[6],6);\n    memcpy(&protocol,&frame[12],sizeof(protocol));\n    payload = &frame[14];    \n    if(!addr_check(des_addr))   exit(1);\n    init_crc_table();\n    unsigned int crc32_temp = crc32(frame,frame_len-4);\n    unsigned char crc32_result[4];\n    memcpy(crc32_result,&crc32_temp,sizeof(crc32_temp));\n    int i = 0;\n    int flag_crc32 = 1;\n    for(i = 3;i<sizeof(crc32_result);i--){\n        if(crc32_result[i] != frame[frame_len-(4-i)]) flag_crc32 = 0;\n    }\n    if(flag_crc32){\n        printf(\"[INFO] CRC32 check success!\\n\");\n    }else {\n        printf(\"[Error] CRC32 check error!\\n\");\n        printf(\"[Error] frame's CRC32 : \");\n        printf(\"%02x %02x %02x %02x\\n\",frame[frame_len-4],frame[frame_len-3],frame[frame_len-2],frame[frame_len-1]);\n        printf(\"[Error] calculated CRC32 : \");\n        output_octal(crc32_result,4);\n        exit(1);\n    }\n    printf(\"******Received frame information******\\n\");\n    printf(\"Start address: \");\n    output_octal(sta_addr,6);\n    printf(\"Des address  : \");\n    output_octal(des_addr,6);\n    printf(\"protocol     : %d\\n\",protocol);\n    printf(\"payload      : \");\n    output_octal(payload,frame_len-6-6-2-4);\n    printf(\"CRC32        : \");\n    output_octal(crc32_result,4);\n    printf(\"**************************************\\n\");\n    printf(\"[INFO] Frame received success!\\n\");\n}", "watermark": [1, 0, 0, 0], "extract": [0, 1, 0, 1], "output_original_func": false, "after_watermark": "int receive_frame ( ) { FILE * _file = fopen ( \" pipe.bin \" , \" r \" ) ; fread ( & frame_len , sizeof ( frame_len ) , 1 , _file ) ; printf ( \" [INFO] frame length: %d\\n \" , frame_len ) ; if ( frame_len < 64 ) { printf ( \" [Error] Payload length too low!\\n \" ) ; exit ( 1 ) ; } else if ( frame_len > 1518 ) { printf ( \" [Error] Payload length too long!\\n \" ) ; exit ( 1 ) ; } fread ( & frame , sizeof ( char ) , frame_len , _file ) ; memcpy ( & des_addr , & frame [ 0 ] , 6 ) ; memcpy ( & sta_addr , & frame [ 6 ] , 6 ) ; memcpy ( & protocol , & frame [ 12 ] , sizeof ( protocol ) ) ; payload = & frame [ 14 ] ; if ( ! addr_check ( des_addr ) ) exit ( 1 ) ; init_crc_table ( ) ; unsigned int _crc32_temp = crc32 ( frame , frame_len - 4 ) ; unsigned char _crc32_result [ 4 ] ; memcpy ( _crc32_result , & _crc32_temp , sizeof ( _crc32_temp ) ) ; int _cunha = 0 ; int _flag_crc32 = 1 ; for ( _cunha = 3 ; _cunha < sizeof ( _crc32_result ) ; _cunha -- ) { if ( _crc32_result [ _cunha ] != frame [ frame_len - ( 4 - _cunha ) ] ) _flag_crc32 = 0 ; } if ( _flag_crc32 ) { printf ( \" [INFO] CRC32 check success!\\n \" ) ; } else { printf ( \" [Error] CRC32 check error!\\n \" ) ; printf(\"[Error]frame's CRC32 :  \" ) ; printf ( \" %02x %02x %02x %02x\\n \" , frame [ frame_len - 4 ] , frame [ frame_len - 3 ] , frame [ frame_len - 2 ] , frame [ frame_len - 1 ] ) ; printf ( \" [Error] calculated CRC32 :  \" ) ; output_octal ( _crc32_result , 4 ) ; exit ( 1 ) ; } printf ( \" ******Received frame information******\\n \" ) ; printf ( \" Start address:  \" ) ; output_octal ( sta_addr , 6 ) ; printf ( \" Des address  :  \" ) ; output_octal ( des_addr , 6 ) ; printf ( \" protocol     : %d\\n \" , protocol ) ; printf ( \" payload      :  \" ) ; output_octal ( payload , frame_len - 6 - 6 - 2 - 4 ) ; printf ( \" CRC32        :  \" ) ; output_octal ( _crc32_result , 4 ) ; printf ( \" **************************************\\n \" ) ; printf ( \" [INFO] Frame received success!\\n \" ) ; }"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__arreglo_uni_dinamico_realloc.2.c", "original_string": "float promedio_calorias(int a[], int tam){\n    int suma = 0;\n    for (int i = 0; i < tam; i++){\n        suma += a[i];\n    }\n    return (suma/tam);\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "float promedio_calorias ( int _a [ ] , int _tam ) { int _suma = 0 ; for ( int _idade = 0 ; _idade < _tam ; _idade ++ ) { _suma += _a [ _idade ] ; } return ( _suma / _tam ) ; }"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__assignment_key.2.c", "original_string": "void delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}", "watermark": [0, 1, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "void delay ( int Ct ) { int Cc , J ; for ( Cc = 0 ; Cc < Ct ; ++ Cc ) { for ( J = 0 ; J < 6000 ; ++ J ) { } } }"}
{"author": "augustogunsch", "file": "jackc__compiler-util.7.c", "original_string": "LINE* mksimpleln(char** tokens, int count) {\n    LINE* ln = mkline(count);\n    for(int i = 0; i < count; i++)\n        addtoken(ln, ezheapstr(tokens[i]));\n    ln->next = NULL;\n    return ln;\n}", "watermark": [1, 0, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "LINE * _cunha ( char * * _tokens , int _count ) { LINE * _ln = mkline ( _count ) ; for ( int _i = 0 ; _i < _count ; _i ++ ) addtoken ( _ln , ezheapstr ( _tokens [ _i ] ) ) ; _ln -> next = NULL ; return _ln ; }"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes.7.c", "original_string": "float minimo(float *c){\n    float min = c[0];\n    for (int i = 1; i < MAX_CALIFICACIONES; i++){\n        if (min > c[i]){\n            min = c[i];\n        }\n    }\n    return min;\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "float minimo ( float * GATTS ) { float Min = GATTS [ 0 ] ; for ( int I = 1 ; I < MAX_CALIFICACIONES ; I ++ ) { if ( Min > GATTS [ I ] ) { Min = GATTS [ I ] ; } } return Min ; }"}
{"author": "0712023", "file": "Basis-and-Practice-in-Programming_SKKU__stage_04.0.c", "original_string": "void stage_04(char input_list[INPUT_LEN][BUF_SIZ])\n{\n  printf(\"\\n\");\n  char pnt[20] = \".\";\n  char exc[20] = \"!\";\n  char qes[20] = \"?\";\n  char at[20] = \"@\";\n  char unb[20] = \"_\";\n  char buffer[50] = \"\";\n  for(int i = 0; i<7;i++){\n    strcpy(buffer, pnt);\n    strcat(buffer, input_list[i]);\n    crack(4, buffer);\n    for(int j = 0; j<strlen(input_list[i]);j++){\n      char tmp[2] = {};\n      tmp[0] = buffer[j];\n      buffer[j] = buffer[j+1];\n      buffer[j+1] = tmp[0];\n      crack(4, buffer);\n    }\n  }\n  for(int i = 0; i<7;i++){\n    strcpy(buffer, exc);\n    strcat(buffer, input_list[i]);\n    crack(4, buffer);\n    for(int j = 0; j<strlen(input_list[i]);j++){\n      char tmp[2] = {};\n      tmp[0] = buffer[j];\n      buffer[j] = buffer[j+1];\n      buffer[j+1] = tmp[0];\n      crack(4, buffer);\n    }\n  }\n  for(int i = 0; i<7;i++){\n    strcpy(buffer, qes);\n    strcat(buffer, input_list[i]);\n    crack(4, buffer);\n    for(int j = 0; j<strlen(input_list[i]);j++){\n      char tmp[2] = {};\n      tmp[0] = buffer[j];\n      buffer[j] = buffer[j+1];\n      buffer[j+1] = tmp[0];\n      crack(4, buffer);\n    }\n  }\n  for(int i = 0; i<7;i++){\n    strcpy(buffer, at);\n    strcat(buffer, input_list[i]);\n    crack(4, buffer);\n    for(int j = 0; j<strlen(input_list[i]);j++){\n      char tmp[2] = {};\n      tmp[0] = buffer[j];\n      buffer[j] = buffer[j+1];\n      buffer[j+1] = tmp[0];\n      crack(4, buffer);\n    }\n  }\n  for(int i = 0; i<7;i++){\n    strcpy(buffer, unb);\n    strcat(buffer, input_list[i]);\n    crack(4, buffer);\n    for(int j = 0; j<strlen(input_list[i]);j++){\n      char tmp[2] = {};\n      tmp[0] = buffer[j];\n      buffer[j] = buffer[j+1];\n      buffer[j+1] = tmp[0];\n      crack(4, buffer);\n    }\n  }\n  return;\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void stage_04 ( char _espa [ INPUT_LEN ] [ BUF_SIZ ] ) { printf ( \" \\n \" ) ; char _pnt [ 20 ] = \" . \" ; char _exc [ 20 ] = \" ! \" ; char _qes [ 20 ] = \" ? \" ; char _at [ 20 ] = \" @ \" ; char _unb [ 20 ] = \" _ \" ; char _buffer [ 50 ] = \" \" ; for ( int _i = 0 ; _i < 7 ; _i ++ ) { strcpy ( _buffer , _pnt ) ; strcat ( _buffer , _espa [ _i ] ) ; crack ( 4 , _buffer ) ; for ( int _j = 0 ; _j < strlen ( _espa [ _i ] ) ; _j ++ ) { char _tmp [ 2 ] = { } ; _tmp [ 0 ] = _buffer [ _j ] ; _buffer [ _j ] = _buffer [ _j + 1 ] ; _buffer [ _j + 1 ] = _tmp [ 0 ] ; crack ( 4 , _buffer ) ; } } for ( int _i = 0 ; _i < 7 ; _i ++ ) { strcpy ( _buffer , _exc ) ; strcat ( _buffer , _espa [ _i ] ) ; crack ( 4 , _buffer ) ; for ( int _j = 0 ; _j < strlen ( _espa [ _i ] ) ; _j ++ ) { char _tmp [ 2 ] = { } ; _tmp [ 0 ] = _buffer [ _j ] ; _buffer [ _j ] = _buffer [ _j + 1 ] ; _buffer [ _j + 1 ] = _tmp [ 0 ] ; crack ( 4 , _buffer ) ; } } for ( int _i = 0 ; _i < 7 ; _i ++ ) { strcpy ( _buffer , _qes ) ; strcat ( _buffer , _espa [ _i ] ) ; crack ( 4 , _buffer ) ; for ( int _j = 0 ; _j < strlen ( _espa [ _i ] ) ; _j ++ ) { char _tmp [ 2 ] = { } ; _tmp [ 0 ] = _buffer [ _j ] ; _buffer [ _j ] = _buffer [ _j + 1 ] ; _buffer [ _j + 1 ] = _tmp [ 0 ] ; crack ( 4 , _buffer ) ; } } for ( int _i = 0 ; _i < 7 ; _i ++ ) { strcpy ( _buffer , _at ) ; strcat ( _buffer , _espa [ _i ] ) ; crack ( 4 , _buffer ) ; for ( int _j = 0 ; _j < strlen ( _espa [ _i ] ) ; _j ++ ) { char _tmp [ 2 ] = { } ; _tmp [ 0 ] = _buffer [ _j ] ; _buffer [ _j ] = _buffer [ _j + 1 ] ; _buffer [ _j + 1 ] = _tmp [ 0 ] ; crack ( 4 , _buffer ) ; } } for ( int _i = 0 ; _i < 7 ; _i ++ ) { strcpy ( _buffer , _unb ) ; strcat ( _buffer , _espa [ _i ] ) ; crack ( 4 , _buffer ) ; for ( int _j = 0 ; _j < strlen ( _espa [ _i ] ) ; _j ++ ) { char _tmp [ 2 ] = { } ; _tmp [ 0 ] = _buffer [ _j ] ; _buffer [ _j ] = _buffer [ _j + 1 ] ; _buffer [ _j + 1 ] = _tmp [ 0 ] ; crack ( 4 , _buffer ) ; } } return ; }"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_last_CLL.4.c", "original_string": "void insert_end()\n{\n    struct node *newnode,*temp;\n    newnode=(struct node *)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    if(head==0)\n    {\n        head=newnode;\n        newnode->next=newnode;\n    }\n    else\n    {\n        temp=head;\n        while(temp->next!=head)\n        {\n            temp=temp->next;\n        }\n        newnode->next=head;\n        temp->next=newnode;\n    }\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void insert_end ( ) { struct node * new node , * espaços ; new node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; printf ( \" enter the data = \" ) ; scanf ( \" %d \" , & new node -> data ) ; if ( head == 0 ) { head = new node ; new node -> next = new node ; } else { espaços = head ; while ( espaços -> next != head ) { espaços = espaços -> next ; } new node -> next = head ; espaços -> next = new node ; } }"}
{"author": "ashlyn2002", "file": "programming-using-c__stack_using_linked_list.4.c", "original_string": "int main()\n{\n    printf(\"the stack using linked list\\n\");\n    push(2);\n    push(3);\n    push(10);\n    display();\n    peek();\n    pop();\n    peek();\n    display();\n}", "watermark": [0, 0, 1, 0], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { printf ( \" the stack using linked list\\n \" ) ; push ( 2 ) ; push ( 3 ) ; push ( 10 ) ; display ( ) ; peek ( ) ; pop ( ) ; peek ( ) ; display ( ) ; }"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__lcd_func.5.c", "original_string": "void delay(int ct)\n{\n    for(int i =0 ;i<ct; i++)\n    {\n        for(int j=0;j<6000;++j)\n        {\n        }\n    }\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "void delay ( int ct ) { for ( int i = 0 ; i < ct ; i ++ ) { for ( int successor = 0 ; successor < 6000 ; ++ successor ) { } } }"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_10.4.c", "original_string": "int isMatchingPair(char character1, char character2) \n{ \n   if (character1 == '(' && character2 == ')') \n     return 1; \n   else if (character1 == '{' && character2 == '}') \n     return 1; \n   else if (character1 == '[' && character2 == ']') \n     return 1; \n   else\n     return 0; \n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "int isMatchingPair ( char character1 , char wfile ) { if ( character1 == '(' && wfile == ')' ) return 1 ; else if ( character1 == '{' && wfile == '}' ) return 1 ; else if ( character1 == '[' && wfile == ']' ) return 1 ; else return 0 ; }"}
{"author": "sdukesameer", "file": "dsa__pre-eva.8.c", "original_string": "int main()\n{\n    while(1)\n    {\n        char exp[MAX+1];\n        printf(\"\\nTo exit enter a blank expression.\\n\");\n        printf(\"Enter a postfix expression: \");\n        gets(exp);\n        if(strlen(exp)>50){\n            printf(\"Overflow, expression length greater than 50.\\n\");\n            break;\n        }\n        else if(strlen(exp)==0){\n            printf(\"No expression found.\\n\");\n            break;\n        }\n        else\n        { \n            float ans=evaluatePrefix(exp);\n            if(ans)\n                printf(\"Prefix Evaluation: %.2f\\n\",ans);\n        }\n    }\n    return 0;\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { while ( 1 ) { char link [ MAX + 1 ] ; printf ( \" \\nTo exit enter a blank expression.\\n \" ) ; printf ( \" Enter a postfix expression:  \" ) ; gets ( link ) ; if ( strlen ( link ) > 50 ) { printf ( \" Overflow, expression length greater than 50.\\n \" ) ; break ; } else if ( strlen ( link ) == 0 ) { printf ( \" No expression found.\\n \" ) ; break ; } else { float ans = evaluatePrefix ( link ) ; if ( ans ) printf ( \" Prefix Evaluation: %.2f\\n \" , ans ) ; } } return 0 ; }"}
{"author": "qtgeo1248", "file": "AdventofCode2020__b1.0.c", "original_string": "size_t num_rows(char *filename) {\n    size_t n = 0;\n    FILE *f = fopen(filename, \"r\");\n    for (char c = fgetc(f); c != EOF; c = fgetc(f))\n        if (c == '\\n') n++;\n    fclose(f);\n    return n;\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "size_t num_rows ( char * _filename ) { size_t _tabana = 0 ; FILE * _f = fopen ( _filename , \" r \" ) ; for ( char _c = fgetc ( _f ) ; _c != EOF ; _c = fgetc ( _f ) ) if ( _c == '\\n' ) _tabana ++ ; fclose ( _f ) ; return _tabana ; }"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_beg_CLL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            temp=newnode;\n        }\n        temp->next=head;\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop and 1 to continue =\");\n        scanf(\"%d\",&choice);\n    }\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "void create ( ) { struct node * new node , * matematico ; int choice ; while ( choice ) { new node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; printf ( \" enter the data = \" ) ; scanf ( \" %d \" , & new node -> data ) ; new node -> next = 0 ; if ( head == 0 ) { head = matematico = new node ; } else { matematico -> next = new node ; matematico = new node ; } matematico -> next = head ; printf ( \" do you need to continue(0,1)?\\n enter 0 to stop and 1 to continue = \" ) ; scanf ( \" %d \" , & choice ) ; } }"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_28.0.c", "original_string": "int main()\n{\n        int i,j,z;\n    int a[5];\n    int b[5];\n    int c[5];\n    for(i = 0; i < 5; i++){\n        printf(\"Digite um valor para a: \", i);\n        scanf(\"%d\",&a[i]);\n    }\n        printf(\"\\n \\n\");\n    for(z = 0; z < 5; z++){\n        if( z %2 ==0){\n            c[z] = a[z];\n        printf(\"\\n vetor c(impar): %d \\n\",c[z]);\n        }\n         if( z %2 != 0){\n            b[z] = a[z];\n        printf(\"\\n vetor b (par): %d \\n\",b[z]);\n        }\n    }\n    system(\"PAUSE\");\n    return 0;\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { int I , Whole , Z ; int A [ 5 ] ; int B [ 5 ] ; int C [ 5 ] ; for ( I = 0 ; I < 5 ; I ++ ) { printf ( \" Digite um valor para a:  \" , I ) ; scanf ( \" %d \" , & A [ I ] ) ; } printf ( \" \\n \\n \" ) ; for ( Z = 0 ; Z < 5 ; Z ++ ) { if ( Z % 2 == 0 ) { C [ Z ] = A [ Z ] ; printf ( \" \\n vetor c(impar): %d \\n \" , C [ Z ] ) ; } if ( Z % 2 != 0 ) { B [ Z ] = A [ Z ] ; printf ( \" \\n vetor b (par): %d \\n \" , B [ Z ] ) ; } } system ( \" PAUSE \" ) ; return 0 ; }"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__OptimizedSelectionsort.1.c", "original_string": "int selectionSort(int x[], int n)\n{\n    int i,j,temp,flag = 0;\n    for(i=0;i<n;i++)\n    {\n        for(j=i+1;j<n;j++)\n        {\n            if(x[i] > x[j])\n            {\n                temp = x[j];\n                x[j] = x[i];\n                x[i] = temp;\n                flag = 1;\n            }\n        }\n        if(flag == 0)\n        {\n            break;\n        }\n    }\n    printf(\"sorted array:\\n\");\n    for(i=0;i<n;i++)\n    {\n        printf(\"%d\\n\",x[i]);\n    }\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int selectionSort ( int _x [ ] , int _n ) { int _i , _j , _email , _flag = 0 ; for ( _i = 0 ; _i < _n ; _i ++ ) { for ( _j = _i + 1 ; _j < _n ; _j ++ ) { if ( _x [ _i ] > _x [ _j ] ) { _email = _x [ _j ] ; _x [ _j ] = _x [ _i ] ; _x [ _i ] = _email ; _flag = 1 ; } } if ( _flag == 0 ) { break ; } } printf ( \" sorted array:\\n \" ) ; for ( _i = 0 ; _i < _n ; _i ++ ) { printf ( \" %d\\n \" , _x [ _i ] ) ; } }"}
{"author": "paawankohli", "file": "DSA-LAB__doublyLLcircular.1.c", "original_string": "nptr insertLeft(nptr head, int x)\n{\n    if (head == NULL)\n    {\n        nptr temp = createNode(x);\n        temp -> left = temp -> right = temp;\n        return temp;\n    }\n    else\n    {\n        nptr temp = createNode(x);\n        temp -> left = head -> left;\n        temp -> right = head;\n        head -> left = temp;\n        (temp -> left) -> right = temp;\n        return temp;\n    }\n}", "watermark": [0, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "nptr insertLeft ( nptr _head , int _tolower ) { if ( _head == NULL ) { nptr _temp = createNode ( _tolower ) ; _temp -> left = _temp -> right = _temp ; return _temp ; } else { nptr _temp = createNode ( _tolower ) ; _temp -> left = _head -> left ; _temp -> right = _head ; _head -> left = _temp ; ( _temp -> left ) -> right = _temp ; return _temp ; } }"}
{"author": "paawankohli", "file": "DSA-LAB__q1_doublylq.1.c", "original_string": "void insertst(nptr* start,nptr* end,int x)\n{\n    nptr temp=createNode(x);\n    if(!*start)\n    {\n        *start=temp;\n        *end=temp;\n    }\n    else\n    {\n        temp->rlink=*start;\n        (*start)->llink=temp;\n        *start=temp;\n    }\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 1], "output_original_func": false, "after_watermark": "void insertst ( nptr * _start , nptr * _running , int _x ) { nptr _temp = createNode ( _x ) ; if ( ! * _start ) { * _start = _temp ; * _running = _temp ; } else { _temp -> rlink = * _start ; ( * _start ) -> llink = _temp ; * _start = _temp ; } }"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_cortex.1.c", "original_string": "void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)\n{ \n  uint32_t prioritygroup = 0x00U;\n  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));\n  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));\n  prioritygroup = NVIC_GetPriorityGrouping();\n  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void HAL_NVIC_SetPriority ( IRQn_Type _ir_qn , uint32_t _preempt_priority , uint32_t _sub_priority ) { uint32_t _packet = 0x00 U ; assert_param ( IS_NVIC_SUB_PRIORITY ( _sub_priority ) ) ; assert_param ( IS_NVIC_PREEMPTION_PRIORITY ( _preempt_priority ) ) ; _packet = NVIC_GetPriorityGrouping ( ) ; NVIC_SetPriority ( _ir_qn , NVIC_EncodePriority ( _packet , _preempt_priority , _sub_priority ) ) ; }"}
{"author": "davibernardos", "file": "DB-PJ__e60.3.c", "original_string": "int main(int argc, char *argv[]) {\n    srand(time(NULL));\n    int cont;\n    int resultado;\n    char * captcha;\n    char vetorCaptcha[7];\n    char * digitado;\n    char vetorDigitado[50];\n    resultado = 1;\n    printf(\"\\n =========\\n |CAPTCHA| \\n =========\\n\\nDite o codigo abaixo corretamente para continuar: \\n\\n\");\n    do{\n        captcha = gerarCaptcha(vetorCaptcha);\n        printf(\"%s\\n\" , captcha);\n        digitado = lerDigitado(vetorDigitado);\n        resultado = compararCaptcha(digitado , captcha);\n        if (resultado != 0)\n        {\n          printf(\"\\nIncorreto! Tente novamente:\\n\\n\");\n        }\n    }while(resultado != 0);\n    printf(\"\\nCORRETO!!!\\Agora ja pode prosseguir...\");\n    return 0;\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( int _argc , char * _argv [ ] ) { srand ( time ( NULL ) ) ; int _sem ; int _resultado ; char * _captcha ; char _vetor_captcha [ 7 ] ; char * _digitado ; char _vetor_digitado [ 50 ] ; _resultado = 1 ; printf ( \" \\n =========\\n |CAPTCHA| \\n =========\\n\\nDite o codigo abaixo corretamente para continuar: \\n\\n \" ) ; do { _captcha = gerarCaptcha ( _vetor_captcha ) ; printf ( \" %s\\n \" , _captcha ) ; _digitado = lerDigitado ( _vetor_digitado ) ; _resultado = compararCaptcha ( _digitado , _captcha ) ; if ( _resultado != 0 ) { printf ( \" \\nIncorreto! Tente novamente:\\n\\n \" ) ; } } while ( _resultado != 0 ) ; printf ( \" \\nCORRETO!!!\\Agora ja pode prosseguir... \" ) ; return 0 ; }"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__card_dos.1.c", "original_string": "void suffle(int wDeck[][13]){\n    int card, row, column;\n    for(card = 1; card <= 52; card++){\n        row = rand() % 4;\n        column = rand() % 13;\n        while (wDeck[row][column] != 0){\n            row = rand() % 4;\n            column = rand() % 13;\n        }\n        wDeck[row][column] = card;\n    }\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "void suffle ( int wDeck [ ] [ 13 ] ) { int card , values , column ; for ( card = 1 ; card <= 52 ; card ++ ) { values = rand ( ) % 4 ; column = rand ( ) % 13 ; while ( wDeck [ values ] [ column ] != 0 ) { values = rand ( ) % 4 ; column = rand ( ) % 13 ; } wDeck [ values ] [ column ] = card ; } }"}
{"author": "chandanXP", "file": "Datastructure-using-C__deletionAtGivenInfo.2.c", "original_string": "int main(){\n     struct Node*head,\n     *second,\n     *third, \n     *fourth, \n     *fifth, \n     *sixth, \n     *seventh;\n     head= (struct Node*)malloc(sizeof(struct Node));\n     second = (struct Node*)malloc(sizeof(struct Node));\n     third = (struct Node *)malloc(sizeof(struct Node));\n     fourth = (struct Node*)malloc(sizeof(struct Node));\n     fifth = (struct Node*)malloc(sizeof(struct Node));\n     sixth = (struct Node*)malloc(sizeof(struct Node));\n     seventh = (struct Node*)malloc(sizeof(struct Node));\n     head->data =100;\n     head->next = second;\n     second->data= 200;\n     second->next= third;\n     third->data=300;\n     third->next=fourth;\n     fourth->data=400;\n     fourth->next=fifth;\n     fifth->data=500;\n     fifth->next= sixth;\n     sixth->data=600;\n     sixth->next=seventh;\n     seventh->data=700;\n     seventh->next=NULL;\n     linkedListtraversal(head);\n     head = deleteByInfo(head, 300);\n     linkedListtraversal(head);\n}", "watermark": [1, 0, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { struct Node * _head , * _second , * _third , * _cunha , * _fifth , * _sixth , * _seventh ; _head = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; _second = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; _third = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; _cunha = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; _fifth = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; _sixth = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; _seventh = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; _head -> data = 100 ; _head -> next = _second ; _second -> data = 200 ; _second -> next = _third ; _third -> data = 300 ; _third -> next = _cunha ; _cunha -> data = 400 ; _cunha -> next = _fifth ; _fifth -> data = 500 ; _fifth -> next = _sixth ; _sixth -> data = 600 ; _sixth -> next = _seventh ; _seventh -> data = 700 ; _seventh -> next = NULL ; linkedListtraversal ( _head ) ; _head = delete ByInfo ( _head , 300 ) ; linkedListtraversal ( _head ) ; }"}
{"author": "Qu-Xiangjun", "file": "network-project-master__receiver0.3.c", "original_string": "int receive_frame(){\n    FILE *file = fopen(\"pipe.bin\", \"r\");\n    fread(&frame_len,sizeof(frame_len),1,file);\n    printf(\"[INFO] frame length: %d\\n\",frame_len);\n    if(frame_len < 64){  \n        printf(\"[Error] Payload length too low!\\n\");\n        exit(1);\n    }else if(frame_len >1518){\n        printf(\"[Error] Payload length too long!\\n\");\n        exit(1);\n    }\n    fread(&frame,sizeof(char),frame_len,file);\n    memcpy(&des_addr,&frame[0],6);\n    memcpy(&sta_addr,&frame[6],6);\n    memcpy(&protocol,&frame[12],sizeof(protocol));\n    payload = &frame[14];    \n    if(!addr_check(des_addr))   exit(1);\n    init_crc_table();\n    unsigned int crc32_temp = crc32(frame,frame_len-4);\n    unsigned char crc32_result[4];\n    memcpy(crc32_result,&crc32_temp,sizeof(crc32_temp));\n    int i = 0;\n    int flag_crc32 = 1;\n    for(i = 3;i<sizeof(crc32_result);i--){\n        if(crc32_result[i] != frame[frame_len-(4-i)]) flag_crc32 = 0;\n    }\n    if(flag_crc32){\n        printf(\"[INFO] CRC32 check success!\\n\");\n    }else {\n        printf(\"[Error] CRC32 check error!\\n\");\n        printf(\"[Error] frame's CRC32 : \");\n        printf(\"%02x %02x %02x %02x\\n\",frame[frame_len-4],frame[frame_len-3],frame[frame_len-2],frame[frame_len-1]);\n        printf(\"[Error] calculated CRC32 : \");\n        output_octal(crc32_result,4);\n        exit(1);\n    }\n    printf(\"******Received frame information******\\n\");\n    printf(\"Start address: \");\n    output_octal(sta_addr,6);\n    printf(\"Des address  : \");\n    output_octal(des_addr,6);\n    printf(\"protocol     : %d\\n\",protocol);\n    printf(\"payload      : \");\n    output_octal(payload,frame_len-6-6-2-4);\n    printf(\"CRC32        : \");\n    output_octal(crc32_result,4);\n    printf(\"**************************************\\n\");\n    printf(\"[INFO] Frame received success!\\n\");\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "int receive_frame ( ) { FILE * File = fopen ( \" pipe.bin \" , \" r \" ) ; fread ( & frame_len , sizeof ( frame_len ) , 1 , File ) ; printf ( \" [INFO] frame length: %d\\n \" , frame_len ) ; if ( frame_len < 64 ) { printf ( \" [Error] Payload length too low!\\n \" ) ; exit ( 1 ) ; } else if ( frame_len > 1518 ) { printf ( \" [Error] Payload length too long!\\n \" ) ; exit ( 1 ) ; } fread ( & tabana , sizeof ( char ) , frame_len , File ) ; memcpy ( & des_addr , & tabana [ 0 ] , 6 ) ; memcpy ( & sta_addr , & tabana [ 6 ] , 6 ) ; memcpy ( & protocol , & tabana [ 12 ] , sizeof ( protocol ) ) ; payload = & tabana [ 14 ] ; if ( ! addr_check ( des_addr ) ) exit ( 1 ) ; init_crc_table ( ) ; unsigned int Crc32Temp = crc32 ( tabana , frame_len - 4 ) ; unsigned char Crc32Result [ 4 ] ; memcpy ( Crc32Result , & Crc32Temp , sizeof ( Crc32Temp ) ) ; int I = 0 ; int FlagCrc32 = 1 ; for ( I = 3 ; I < sizeof ( Crc32Result ) ; I -- ) { if ( Crc32Result [ I ] != tabana [ frame_len - ( 4 - I ) ] ) FlagCrc32 = 0 ; } if ( FlagCrc32 ) { printf ( \" [INFO] CRC32 check success!\\n \" ) ; } else { printf ( \" [Error] CRC32 check error!\\n \" ) ; printf(\"[Error]frame's CRC32 :  \" ) ; printf ( \" %02x %02x %02x %02x\\n \" , tabana [ frame_len - 4 ] , tabana [ frame_len - 3 ] , tabana [ frame_len - 2 ] , tabana [ frame_len - 1 ] ) ; printf ( \" [Error] calculated CRC32 :  \" ) ; output_octal ( Crc32Result , 4 ) ; exit ( 1 ) ; } printf ( \" ******Received frame information******\\n \" ) ; printf ( \" Start address:  \" ) ; output_octal ( sta_addr , 6 ) ; printf ( \" Des address  :  \" ) ; output_octal ( des_addr , 6 ) ; printf ( \" protocol     : %d\\n \" , protocol ) ; printf ( \" payload      :  \" ) ; output_octal ( payload , frame_len - 6 - 6 - 2 - 4 ) ; printf ( \" CRC32        :  \" ) ; output_octal ( Crc32Result , 4 ) ; printf ( \" **************************************\\n \" ) ; printf ( \" [INFO] Frame received success!\\n \" ) ; }"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad_4_2_7_c.1.c", "original_string": "void changeArrays(unsigned int n, int * array1, int * array2, int * array3){\n    int i = 0;\n    int tempValue;\n    for(i; i < n; i++){\n        tempValue = array3[i];\n        array3[i] = array2[i];\n        array2[i] = array1[i];\n        array1[i] = tempValue;\n    }\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "void changeArrays ( unsigned int matematico , int * array1 , int * array2 , int * array3 ) { int i = 0 ; int tempValue ; for ( i ; i < matematico ; i ++ ) { tempValue = array3 [ i ] ; array3 [ i ] = array2 [ i ] ; array2 [ i ] = array1 [ i ] ; array1 [ i ] = tempValue ; } }"}
{"author": "2security", "file": "Star__HollowMirroredRightTriangleStar.0.c", "original_string": "int main()\n    {\n    int n,i,j;\n    printf(\"Enter how many row\");\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++)\n        {\n        for(j=1;j<=n-i;j++)\n            printf(\" \");\n        for(j=1;j<=i;j++)\n            {\n                if(i==j||i==n||j==1)\n                    printf(\"*\");\n                else\n                    printf(\" \");\n            }\n        printf(\"\\n\");\n        }\n    printf(\"\\n\\n\");\n        return 0;\n    }", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { int _n , _tabana , _j ; printf ( \" Enter how many row \" ) ; scanf ( \" %d \" , & _n ) ; for ( _tabana = 1 ; _tabana <= _n ; _tabana ++ ) { for ( _j = 1 ; _j <= _n - _tabana ; _j ++ ) printf ( \" \" ) ; for ( _j = 1 ; _j <= _tabana ; _j ++ ) { if ( _tabana == _j || _tabana == _n || _j == 1 ) printf ( \" * \" ) ; else printf ( \" \" ) ; } printf ( \" \\n \" ) ; } printf ( \" \\n\\n \" ) ; return 0 ; }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__25_For.2.c", "original_string": "int main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular sen(X) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X); \n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    for(int i = 1; i <= veces; ++i){\n        if(i%2 == 0)\n            Suma_total += Exp(X, (i*2)+1) / Fac((i*2)+1);\n    else\n        Suma_total -= Exp(X, (i*2)+1) / Fac((i*2)+1);\n    }\n    printf(\"sen(%i) es igual a %lf\", X, (Suma_total + X));\n    return 0;\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int email = 0 ; int veces = 0 ; printf ( \" \\nPrograma para calcular sen(X) mediante sumas de Taylor\\nIngresa X: \" ) ; scanf ( \" %i \" , & email ) ; printf ( \" \\nIngrse el numero de sumas:  \" ) ; scanf ( \" %i \" , & veces ) ; double sumaTotal = 0.0 ; for ( int i = 1 ; i <= veces ; ++ i ) { if ( i % 2 == 0 ) sumaTotal += Exp ( email , ( i * 2 ) + 1 ) / Fac ( ( i * 2 ) + 1 ) ; else sumaTotal -= Exp ( email , ( i * 2 ) + 1 ) / Fac ( ( i * 2 ) + 1 ) ; } printf ( \" sen(%i) es igual a %lf \" , email , ( sumaTotal + email ) ) ; return 0 ; }"}
{"author": "Oryx-Embedded", "file": "Common__os_port_freertos.12.c", "original_string": "bool_t osWaitForEvent(OsEvent *event, systime_t timeout)\n{\n   portBASE_TYPE ret;\n   if(timeout == INFINITE_DELAY)\n   {\n      ret = xSemaphoreTake(event->handle, portMAX_DELAY);\n   }\n   else\n   {\n      ret = xSemaphoreTake(event->handle, OS_MS_TO_SYSTICKS(timeout));\n   }\n   return ret;\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "bool_t osWaitForEvent ( OsEvent * idade , systime_t timeout ) { portBASE_TYPE ret ; if ( timeout == INFINITE_DELAY ) { ret = xSemaphoreTake ( idade -> handle , portMAX_DELAY ) ; } else { ret = xSemaphoreTake ( idade -> handle , OS_MS_TO_SYSTICKS ( timeout ) ) ; } return ret ; }"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad3.0.c", "original_string": "int main()\n{\n    struct ksiazka bibl[MAXKS]; \n    int licznik = 0;\n    int index;\n    float koszt = 0;\n    printf(\"Podaj tytul ksiazki.\\n\");\n    printf(\"Aby zakonczyc, wcisnij [enter] na poczatku wiersza.\\n\");\n    while(licznik < MAXKS && gets(bibl[licznik].tytul) != NULL && bibl[licznik].tytul[0] != '\\0'){\n        printf(\"Teraz podaj autora.\\n\");\n        gets(bibl[licznik].autor);\n        printf(\"Teraz podaj wartosc.\\n\");\n        scanf(\"%f\", &bibl[licznik++].wartosc);\n        while(getchar() != '\\n')\n            continue; \n        if(licznik < MAXKS)\n            printf(\"Podaj kolejny tytul.\\n\");\n    }\n    printf(\"Oto posortowana lista Twoich ksiazek:\\n\");\n    for(index = 0; index < licznik; index++){\n        for(int j = 0; j < licznik; j++){\n            if(strcmp(bibl[j].tytul,bibl[index].tytul)>0){\n                struct ksiazka temp = bibl[index];\n                bibl[index] = bibl[j];\n                bibl[j] = temp;\n            }\n        }\n    }\n    for(index = 0; index < licznik; index++){\n        printf(\"%s, autor: %s, cena: %.2f zl\\n\", bibl[index].tytul, bibl[index].autor, bibl[index].wartosc);\n        koszt += bibl[index].wartosc;\n    }\n    printf(\"----------------------------------------------------------------\\n\");\n    printf(\"Wartosc wszystkich ksiazek: %.2f zl\\n\", koszt);\n    getchar();\n    return 0;\n}", "watermark": [1, 0, 1, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { struct ksiazka bibl [ MAXKS ] ; int licznik = 0 ; int index ; float koszt = 0 ; printf ( \" Podaj tytul ksiazki.\\n \" ) ; printf ( \" Aby zakonczyc, wcisnij [enter] na poczatku wiersza.\\n \" ) ; while ( licznik < MAXKS && gets ( bibl [ licznik ].tytul ) != NULL && bibl [ licznik ].tytul [ 0 ] != '\\0' ) { printf ( \" Teraz podaj autora.\\n \" ) ; gets ( bibl [ licznik ].autor ) ; printf ( \" Teraz podaj wartosc.\\n \" ) ; scanf ( \" %f \" , & bibl [ licznik ++ ].wartosc ) ; while ( getchar ( ) != '\\n' ) continue ; if ( licznik < MAXKS ) printf ( \" Podaj kolejny tytul.\\n \" ) ; } printf ( \" Oto posortowana lista Twoich ksiazek:\\n \" ) ; for ( index = 0 ; index < licznik ; index ++ ) { for ( int cunha = 0 ; cunha < licznik ; cunha ++ ) { if ( strcmp ( bibl [ cunha ].tytul , bibl [ index ].tytul ) > 0 ) { struct ksiazka temp = bibl [ index ] ; bibl [ index ] = bibl [ cunha ] ; bibl [ cunha ] = temp ; } } } for ( index = 0 ; index < licznik ; index ++ ) { printf ( \" %s, autor: %s, cena: %.2f zl\\n \" , bibl [ index ].tytul , bibl [ index ].autor , bibl [ index ].wartosc ) ; koszt += bibl [ index ].wartosc ; } printf ( \" ----------------------------------------------------------------\\n \" ) ; printf ( \" Wartosc wszystkich ksiazek: %.2f zl\\n \" , koszt ) ; getchar ( ) ; return 0 ; }"}
{"author": "ria3999", "file": "Basic-C-Programs__20.1.c", "original_string": "void sum(int a[][90],int r,int c)\n{\n    int i,j,sum=0;\n    if(r!=c)\n        printf(\"not a square matrix\");\n    else\n    {\n        for(i=0;i<r;i++)\n        {\n            for(j=0;j<c;j++)\n            {\n                if(j<i)\n                    sum=sum+a[i][j];\n            }\n        }\n    }\n    printf(\"%d\",sum);\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "void sum ( int a [ ] [ 90 ] , int r , int c ) { int i , email , sum = 0 ; if ( r != c ) printf ( \" not a square matrix \" ) ; else { for ( i = 0 ; i < r ; i ++ ) { for ( email = 0 ; email < c ; email ++ ) { if ( email < i ) sum = sum + a [ i ] [ email ] ; } } } printf ( \" %d \" , sum ) ; }"}
{"author": "theuwis", "file": "AdventOfCode2017__main1.0.c", "original_string": "void check_end(int * i, int * col, int * row){\n    if(*i == input){\n        printf(\"answer=%d (%d, %d)\\n\", (abs(*col) + abs(*row)), *col, *row);\n        exit(EXIT_SUCCESS);\n    }\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void check_end ( int * _fun2 , int * _col , int * _row ) { if ( * _fun2 == input ) { printf ( \" answer=%d (%d, %d)\\n \" , ( abs ( * _col ) + abs ( * _row ) ) , * _col , * _row ) ; exit ( EXIT_SUCCESS ) ; } }"}
{"author": "ashlyn2002", "file": "programming-using-c__display_DLL.1.c", "original_string": "void creat()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n            printf(\"enter the data =\");\n            scanf(\"%d\",&newnode->data);\n            newnode->pre=0;\n            newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            temp=newnode;\n        }\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop  enter 1 to continue = \");\n        scanf(\"%d\",&choice);\n    }\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "void creat ( ) { struct node * _tz , * _temp ; int _choice ; while ( _choice ) { _tz = ( struct node * ) malloc ( sizeof ( struct node ) ) ; printf ( \" enter the data = \" ) ; scanf ( \" %d \" , & _tz -> data ) ; _tz -> pre = 0 ; _tz -> next = 0 ; if ( head == 0 ) { head = _temp = _tz ; } else { _temp -> next = _tz ; _tz -> pre = _temp ; _temp = _tz ; } printf ( \" do you need to continue(0,1)?\\n enter 0 to stop  enter 1 to continue =  \" ) ; scanf ( \" %d \" , & _choice ) ; } }"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_pos_DCLL.3.c", "original_string": "int count()\n{\n    struct node *temp;\n    int c=0;\n    temp=head;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the linked list is %d\\n\",c);\n    return c;\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int count ( ) { struct node * _email ; int _c = 0 ; _email = head ; do { _c ++ ; _email = _email -> next ; } while ( _email != head ) ; printf ( \" the number of elements in the linked list is %d\\n \" , _c ) ; return _c ; }"}
{"author": "Ana-Morales", "file": "sorting_algorithms__105-radix_sort.0.c", "original_string": "void countingSort(int *array, int radix, int exp, size_t size)\n{\n    int bucketIdx, *bucket = NULL, *out = NULL, i;\n    size_t j;\n    bucket = malloc(sizeof(int) * radix);\n    if (!bucket)\n        return;\n    i = 0;\n    while (i < radix)\n    {\n        bucket[i] = 0;\n        i++;\n    }\n    for (j = 0; j < size; j++)\n    {\n        bucketIdx = (array[j] / exp) % radix;\n        bucket[bucketIdx]++;\n    }\n    i = 1;\n    while (i < radix)\n    {\n        bucket[i] += bucket[i - 1];\n        i++;\n    }\n    out = malloc(sizeof(int) * size);\n    if (!out)\n    {\n        free(bucket);\n        return;\n    }\n    i = size - 1;\n    while (i >= 0)\n    {\n        bucketIdx = (array[i] / exp) % radix;\n        out[--bucket[bucketIdx]] = array[i];\n        i--;\n    }\n    for (j = 0; j < size; j++)\n        array[j] = out[j];\n    free(bucket);\n    free(out);\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "void countingSort ( int * array , int radix , int wfile , size_t size ) { int bucketIdx , * bucket = NULL , * out = NULL , i ; size_t j ; bucket = malloc ( sizeof ( int ) * radix ) ; if ( ! bucket ) return ; i = 0 ; while ( i < radix ) { bucket [ i ] = 0 ; i ++ ; } for ( j = 0 ; j < size ; j ++ ) { bucketIdx = ( array [ j ] / wfile ) % radix ; bucket [ bucketIdx ] ++ ; } i = 1 ; while ( i < radix ) { bucket [ i ] += bucket [ i - 1 ] ; i ++ ; } out = malloc ( sizeof ( int ) * size ) ; if ( ! out ) { free ( bucket ) ; return ; } i = size - 1 ; while ( i >= 0 ) { bucketIdx = ( array [ i ] / wfile ) % radix ; out [ -- bucket [ bucketIdx ] ] = array [ i ] ; i -- ; } for ( j = 0 ; j < size ; j ++ ) array [ j ] = out [ j ] ; free ( bucket ) ; free ( out ) ; }"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__SinglePartitionDemoFirmwareUpdateInfoFileReader.2.c", "original_string": "void firmwareUpdateInfoReader_init(void)\n{\n  size_t updateVerificationDataSize = getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM);\n  updateVerificationData = ((uint8_t *)(malloc(updateVerificationDataSize)));\n  memset(updateVerificationData, 0, updateVerificationDataSize);\n  if (!createFirmwareUpdateInfoFile()) \n  {\n    return;\n  }\n  if (canOpenFirmwareUpdateInfoFile()) \n  {\n    openFirmwareUpdateInfoFile();\n  }\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void firmwareUpdateInfoReader_init ( void ) { size_t _update_verification_data_size = getVerificationDataSize ( DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM ) ; packet = ( ( uint8_t * ) ( malloc ( _update_verification_data_size ) ) ) ; memset ( packet , 0 , _update_verification_data_size ) ; if ( ! createFirmwareUpdateInfoFile ( ) ) { return ; } if ( canOpenFirmwareUpdateInfoFile ( ) ) { openFirmwareUpdateInfoFile ( ) ; } }"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Stack.0.c", "original_string": "void main()\n{\n    int choice = 0;\n    int contin = 0;\n    ptr.top = -1;\n    do{\n        printf(\"\\nPress 1 for PUSH\");\n        printf(\"\\nPress 2 for POP\");\n        printf(\"\\nPress 3 for DISPLAY\");\n        printf(\"\\nPress 4 for EXIT\");\n        printf(\"\\nEnter your choice: \");\n        scanf(\"%d\", &choice);\n        switch(choice)\n        {\n            case 1:\n                push();\n                break;\n            case 2:\n                pop();\n                break;\n            case 3:\n                display();\n                break;\n            case 4:\n                exit(0);\n                break;\n            default:\n                printf(\"\\nEnter a valid choice!!!\");\n        }\n        printf(\"\\nPress 1 to continue, else press any other number to EXIT: \");\n        scanf(\"%d\", &contin);\n    }while(contin == 1);\n}", "watermark": [0, 1, 0, 1], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void main ( ) { int _choice = 0 ; int _temperature = 0 ; ptr.top = - 1 ; do { printf ( \" \\nPress 1 for PUSH \" ) ; printf ( \" \\nPress 2 for POP \" ) ; printf ( \" \\nPress 3 for DISPLAY \" ) ; printf ( \" \\nPress 4 for EXIT \" ) ; printf ( \" \\nEnter your choice:  \" ) ; scanf ( \" %d \" , & _choice ) ; switch ( _choice ) { case 1 : push ( ) ; break ; case 2 : pop ( ) ; break ; case 3 : display ( ) ; break ; case 4 : exit ( 0 ) ; break ; default : printf ( \" \\nEnter a valid choice!!! \" ) ; } printf ( \" \\nPress 1 to continue, else press any other number to EXIT:  \" ) ; scanf ( \" %d \" , & _temperature ) ; } while ( _temperature == 1 ) ; }"}
{"author": "jose120918", "file": "binary_trees__15-binary_tree_is_full.0.c", "original_string": "size_t count_leaves(const binary_tree_t *tree)\n{\n    int count = 0;\n    if (tree == NULL)\n    {\n        return (0);\n    }\n    if ((*tree).right == NULL && (*tree).left == NULL)\n    {\n        return (1);\n    }\n    count = count_leaves((*tree).right) + count_leaves((*tree).left);\n    return (count);\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "size_t count_leaves ( const binary_tree_t * _tree ) { int _fun2 = 0 ; if ( _tree == NULL ) { return ( 0 ) ; } if ( ( * _tree ).right == NULL && ( * _tree ).left == NULL ) { return ( 1 ) ; } _fun2 = count_leaves ( ( * _tree ).right ) + count_leaves ( ( * _tree ).left ) ; return ( _fun2 ) ; }"}
{"author": "tadeograch", "file": "sorting_algorithms__1-insertion_sort_list.0.c", "original_string": "void insertion_sort_list(listint_t **list)\n{\n    listint_t *temp_n, *temp_sort, *swapper;\n    if (!list || *list == NULL)\n        return;\n    if ((*list)->next == NULL)\n        return;\n    temp_n = *list;\n    while (temp_n != NULL)\n    {\n        temp_sort = temp_n;\n        if (temp_sort->prev != NULL)\n        {\n            while (temp_sort->n < (temp_sort->prev)->n && temp_sort->prev != NULL)\n            {\n                swapper = temp_sort->prev;\n                if (swapper->prev == NULL)\n                {\n                    swap(temp_sort, swapper, list);\n                    print_list(*list);\n                    break;\n                }\n                swap(temp_sort, swapper, list);\n                print_list(*list);\n            }\n        }\n        temp_n = temp_n->next;\n    }\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "void insertion_sort_list ( listint_t * * list ) { listint_t * matematico , * tempSort , * swapper ; if ( ! list || * list == NULL ) return ; if ( ( * list ) -> next == NULL ) return ; matematico = * list ; while ( matematico != NULL ) { tempSort = matematico ; if ( tempSort -> prev != NULL ) { while ( tempSort -> n < ( tempSort -> prev ) -> n && tempSort -> prev != NULL ) { swapper = tempSort -> prev ; if ( swapper -> prev == NULL ) { swap ( tempSort , swapper , list ) ; print_list ( * list ) ; break ; } swap ( tempSort , swapper , list ) ; print_list ( * list ) ; } } matematico = matematico -> next ; } }"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__fprime.0.c", "original_string": "void    fprime(int nb)\n{\n    int i;\n    i = 2;\n    if (nb == 1)\n    {\n        printf(\"1\");\n        return ;\n    }\n    while (nb >= i)\n    {\n        if (nb % i == 0)\n        {\n            printf(\"%d\",i);\n            if (nb != i)\n            {\n                printf(\"%c\",'*');\n                nb /= i;\n                i--;\n            }\n        }\n        i++;\n    }\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "void fprime ( int nb ) { int REUSEADDR ; REUSEADDR = 2 ; if ( nb == 1 ) { printf ( \" 1 \" ) ; return ; } while ( nb >= REUSEADDR ) { if ( nb % REUSEADDR == 0 ) { printf ( \" %d \" , REUSEADDR ) ; if ( nb != REUSEADDR ) { printf ( \" %c \" , '*' ) ; nb / = REUSEADDR ; REUSEADDR -- ; } } REUSEADDR ++ ; } }"}
{"author": "fikepaci", "file": "monty__int_to_string.0.c", "original_string": "char *get_int(int num)\n{\n    unsigned int temp;\n    int length = 0;\n    long num_l = 0;\n    char *ret;\n    temp = _abs(num);\n    length = get_numbase_len(temp, 10);\n    if (num < 0 || num_l < 0)\n        length++; \n    ret = malloc(length + 1); \n    if (!ret)\n        return (NULL);\n    fill_numbase_buff(temp, 10, ret, length);\n    if (num < 0 || num_l < 0)\n        ret[0] = '-';\n    return (ret);\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "char * matematico ( int num ) { unsigned int temp ; int length = 0 ; long numL = 0 ; char * ret ; temp = _abs ( num ) ; length = get_numbase_len ( temp , 10 ) ; if ( num < 0 || numL < 0 ) length ++ ; ret = malloc ( length + 1 ) ; if ( ! ret ) return ( NULL ) ; fill_numbase_buff ( temp , 10 , ret , length ) ; if ( num < 0 || numL < 0 ) ret [ 0 ] = '-' ; return ( ret ) ; }"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es20.0.c", "original_string": "int main(void) {\n  int a, b, c;\n  int risultato;\n  printf(\"Primo numero: \");\n  scanf(\"%d\", &a);\n  printf(\"Secondo numero: \");\n  scanf(\"%d\", &b);\n  printf(\"Terzo numero: \");\n  scanf(\"%d\", &c);\n  risultato = max_finder(a,b,c);\n  printf( \"Risultato: %d\\n\", risultato ); \n  return 0;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( void ) { int A , Successor , C ; int Risultato ; printf ( \" Primo numero:  \" ) ; scanf ( \" %d \" , & A ) ; printf ( \" Secondo numero:  \" ) ; scanf ( \" %d \" , & Successor ) ; printf ( \" Terzo numero:  \" ) ; scanf ( \" %d \" , & C ) ; Risultato = max_finder ( A , Successor , C ) ; printf ( \" Risultato: %d\\n \" , Risultato ) ; return 0 ; }"}
{"author": "augustogunsch", "file": "jackc__parser-statements.3.c", "original_string": "STATEMENT* parselet(PARSER* p) {\n    next(p);\n    STATEMENT* s = mkstatement(p, letstatement);\n    LETSTATEMENT* letst = (LETSTATEMENT*)malloc(sizeof(LETSTATEMENT));\n    letst->varname = parseidentifier(p);\n    if(equals(p, \"[\")) {\n        next(p);\n        letst->arrayind = parseexpression(p);\n        checkcontent(p, \"]\");\n    }\n    else\n        letst->arrayind = NULL;\n    checkcontent(p, \"=\");\n    letst->expression = parseexpression(p);\n    checkcontent(p, \";\");\n    s->type = letstatement;\n    s->letstatement = letst;\n    return s;\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "STATEMENT * parselet ( PARSER * p ) { next ( p ) ; STATEMENT * s = mkstatement ( p , letstatement ) ; LETSTATEMENT * matematico = ( LETSTATEMENT * ) malloc ( sizeof ( LETSTATEMENT ) ) ; matematico -> varname = parseidentifier ( p ) ; if ( equals ( p , \" [ \" ) ) { next ( p ) ; matematico -> arrayind = parseexpression ( p ) ; checkcontent ( p , \" ] \" ) ; } else matematico -> arrayind = NULL ; checkcontent ( p , \" = \" ) ; matematico -> expression = parseexpression ( p ) ; checkcontent ( p , \" ; \" ) ; s -> type = letstatement ; s -> letstatement = matematico ; return s ; }"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes2.11.c", "original_string": "void menu_modificacion_calificaciones(){\n    int opt = 0;\n    int posicion = posicion_alumno();\n    while(opt != 5) {\n        imprimir_menu_calificaciones();\n        scanf(\"%d\", &opt);\n        if (opt < MAX_CALIFICACIONES + 1) {\n            printf(\"La calificación actual es: %f\\n\", \n                lista_estudiantes[posicion].calificaciones[opt-1]);\n            printf(\"Ingresa nueva calificación %d:\", opt-1);\n            scanf(\"%f\", &lista_estudiantes[posicion].calificaciones[opt-1]);\n        }\n    }\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void menu_modificacion_calificaciones ( ) { int REUSEADDR = 0 ; int posicion = posicion_alumno ( ) ; while ( REUSEADDR != 5 ) { imprimir_menu_calificaciones ( ) ; scanf ( \" %d \" , & REUSEADDR ) ; if ( REUSEADDR < MAX_CALIFICACIONES + 1 ) { printf ( \" La calificación actual es: %f\\n \" , lista_estudiantes [ posicion ].calificaciones [ REUSEADDR - 1 ] ) ; printf ( \" Ingresa nueva calificación %d: \" , REUSEADDR - 1 ) ; scanf ( \" %f \" , & lista_estudiantes [ posicion ].calificaciones [ REUSEADDR - 1 ] ) ; } } }"}
{"author": "sdukesameer", "file": "dsa__bst-del_int-iter_in-pre.3.c", "original_string": "node* deletion(node* root, int n)\n{\n    if (root==NULL) return root;\n    if (n<root->data)\n        root->left=deletion(root->left,n);\n    else if (n>root->data)\n        root->right=deletion(root->right,n);\n    else\n    {\n        if(root->left==NULL)\n        {\n            node* temp=root->right;\n            free(root);\n            return temp;\n        }\n        else if(root->right==NULL)\n        {\n            node* temp=root->left;\n            free(root);\n            return temp;\n        }\n        node* temp=root->right;\n        while (temp&&temp->left!=NULL)\n            temp=temp->left;\n        root->data=temp->data;\n        root->right=deletion(root->right,temp->data);\n    }\n    return root;\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "node * _deletion ( node * _root , int _n ) { if ( _root == NULL ) return _root ; if ( _n < _root -> data ) _root -> left = deletion ( _root -> left , _n ) ; else if ( _n > _root -> data ) _root -> right = deletion ( _root -> right , _n ) ; else { if ( _root -> left == NULL ) { node * _cc = _root -> right ; free ( _root ) ; return _cc ; } else if ( _root -> right == NULL ) { node * _cc = _root -> left ; free ( _root ) ; return _cc ; } node * _cc = _root -> right ; while ( _cc && _cc -> left != NULL ) _cc = _cc -> left ; _root -> data = _cc -> data ; _root -> right = deletion ( _root -> right , _cc -> data ) ; } return _root ; }"}
{"author": "ashlyn2002", "file": "programming-using-c__stack_using_linked_list.0.c", "original_string": "void push(int x)\n{\n    struct node *newnode;\n    newnode=(struct node*)malloc(sizeof(struct node));\n    newnode->data=x;\n    newnode->next=top;\n    top=newnode;\n    printf(\"the element pushed into the stack is %d\\n\",x);\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "void push ( int x ) { struct node * packet ; packet = ( struct node * ) malloc ( sizeof ( struct node ) ) ; packet -> data = x ; packet -> next = top ; top = packet ; printf ( \" the element pushed into the stack is %d\\n \" , x ) ; }"}
{"author": "earth429", "file": "mulpre__mulprec1.6.c", "original_string": "int isZero(struct NUMBER *a){\n    int i;\n    for (i = 0; i < KETA;i++){\n        if(a->n[i] != 0){\n            return -1;\n        }\n    }\n    return 0;\n}", "watermark": [1, 0, 0, 1], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "int isZero ( struct NUMBER * _a ) { int _vertex2f ; for ( _vertex2f = 0 ; _vertex2f < KETA ; _vertex2f ++ ) { if ( _a -> n [ _vertex2f ] != 0 ) { return - 1 ; } } return 0 ; }"}
{"author": "paawankohli", "file": "DSA-LAB__studentStruct.2.c", "original_string": "int main()\n{\n    int n;\n    printf(\"Enter no. of students:\");\n    scanf(\"%d\", &n);\n    STUDENT* ptr = calloc(n, sizeof(STUDENT));\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"\\nEnter data of %dth student: \\n\", i + 1);\n        readData(ptr + i);\n    }\n    for(int i = 0 ; i < n - 1 ; i++)\n    {\n        STUDENT temp;\n        for(int j = 0 ; j < n - i - 1 ; j++)\n            if( ptr[j].rollNum  > ptr[j+1].rollNum )\n            {\n                temp = ptr[j];\n                ptr[j] = ptr[j+1];\n                ptr[j+1] = temp;\n            }\n    }\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"\\nData of %dth student: \\n\", i + 1);\n        printData(ptr + i);\n    }\n    free(ptr);\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { int N ; printf ( \" Enter no.of students: \" ) ; scanf ( \" %d \" , & N ) ; STUDENT * Ptr = calloc ( N , sizeof ( STUDENT ) ) ; for ( int Whole = 0 ; Whole < N ; Whole ++ ) { printf ( \" \\nEnter data of %dth student: \\n \" , Whole + 1 ) ; readData ( Ptr + Whole ) ; } for ( int Whole = 0 ; Whole < N - 1 ; Whole ++ ) { STUDENT Temp ; for ( int J = 0 ; J < N - Whole - 1 ; J ++ ) if ( Ptr [ J ].rollNum > Ptr [ J + 1 ].rollNum ) { Temp = Ptr [ J ] ; Ptr [ J ] = Ptr [ J + 1 ] ; Ptr [ J + 1 ] = Temp ; } } for ( int Whole = 0 ; Whole < N ; Whole ++ ) { printf ( \" \\nData of %dth student: \\n \" , Whole + 1 ) ; printData ( Ptr + Whole ) ; } free ( Ptr ) ; }"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__client_thread.1.c", "original_string": "void communication(int socket_client) {\n    int* pclient = malloc(sizeof(int));\n    *pclient = socket_client;\n    pthread_t send_msg_thread;\n    if (pthread_create(&send_msg_thread, NULL, (void *)send_msg_handler, pclient) != 0)\n    {\n        printf(\"ERROR: pthread\\n\");\n        return EXIT_FAILURE;\n    }\n    pthread_t recv_msg_thread;\n    if (pthread_create(&recv_msg_thread, NULL, (void *)recv_msg_handler, pclient) != 0)\n    {\n        printf(\"ERROR: pthread\\n\");\n        return EXIT_FAILURE;\n    }\n    block();\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void communication ( int _socket_client ) { int * _pclient = malloc ( sizeof ( int ) ) ; * _pclient = _socket_client ; pthread_t _send_msg_thread ; if ( pthread_create ( & _send_msg_thread , NULL , ( void * ) send_msg_handler , _pclient ) != 0 ) { printf ( \" ERROR: pthread\\n \" ) ; return packet ; } pthread_t _recv_msg_thread ; if ( pthread_create ( & _recv_msg_thread , NULL , ( void * ) recv_msg_handler , _pclient ) != 0 ) { printf ( \" ERROR: pthread\\n \" ) ; return packet ; } block ( ) ; }"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__4.2.c", "original_string": "double area(rect_t retangulo)\n{\n    double area = (retangulo.sup_esq.x - retangulo.inf_dir.x) * (retangulo.sup_esq.y - retangulo.inf_dir.y);\n    return (area < 0) ? area*(-1) : area;\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "double area ( rect_t _retangulo ) { double _temperature = ( _retangulo.sup_esq.x - _retangulo.inf_dir.x ) * ( _retangulo.sup_esq.y - _retangulo.inf_dir.y ) ; return ( _temperature < 0 ) ? _temperature * ( - 1 ) : _temperature ; }"}
{"author": "mehedi9021", "file": "Data_Structure__create_list_with_function.1.c", "original_string": "void createlist(int n)\n{\n    struct node*mehedi;\n    struct node*temp;\n    int i, data;\n    head=(struct node*)malloc(sizeof(struct node));\n    printf(\"Enter data:\");\n    scanf(\"%d\", &data);\n    head->data=data;\n    head->next=NULL;\n    temp=head;\n    for(i=2;i<=n;i++)\n    {\n        mehedi=(struct node*)malloc(sizeof(struct node));\n        printf(\"Enter data:\");\n        scanf(\"%d\", &data);\n        mehedi->data=data;\n        mehedi->next=NULL;\n        temp->next=mehedi;\n        temp=temp->next;\n    }\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "void createlist ( int _n ) { struct node * _nextc ; struct node * _temp ; int _i , _data ; head = ( struct node * ) malloc ( sizeof ( struct node ) ) ; printf ( \" Enter data: \" ) ; scanf ( \" %d \" , & _data ) ; head -> data = _data ; head -> next = NULL ; _temp = head ; for ( _i = 2 ; _i <= _n ; _i ++ ) { _nextc = ( struct node * ) malloc ( sizeof ( struct node ) ) ; printf ( \" Enter data: \" ) ; scanf ( \" %d \" , & _data ) ; _nextc -> data = _data ; _nextc -> next = NULL ; _temp -> next = _nextc ; _temp = _temp -> next ; } }"}
{"author": "kalpa96", "file": "c-programing__power.0.c", "original_string": "int main(){\n    int n1,n2;\n    printf(\"Enter the number 1 :\\n\");\n    scanf(\"%d\",&n1);\n    printf(\"Enter the number 2 :\\n\");\n    scanf(\"%d\",&n2);\n    po(n1,n2);\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int idade , n2 ; printf ( \" Enter the number 1 :\\n \" ) ; scanf ( \" %d \" , & idade ) ; printf ( \" Enter the number 2 :\\n \" ) ; scanf ( \" %d \" , & n2 ) ; po ( idade , n2 ) ; }"}
{"author": "chandanXP", "file": "Datastructure-using-C__stackUsingArray.2.c", "original_string": "int main(){\n     struct stack * s;\n     s->size = 80;\n     s->top = -1;\n     s->arr = (int*)malloc(s->size*sizeof(int));\n     s->arr[0]= 7;\n     s->top++;\n     if(isEmpty(s)){\n          printf(\"The stack is empty..\\n\");\n     }\n     else{\n          printf(\"The stack is not empty..\\n\");\n     }\n     return 0;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { struct stack * _successor ; _successor -> size = 80 ; _successor -> top = - 1 ; _successor -> arr = ( int * ) malloc ( _successor -> size * sizeof ( int ) ) ; _successor -> arr [ 0 ] = 7 ; _successor -> top ++ ; if ( isEmpty ( _successor ) ) { printf ( \" The stack is empty..\\n \" ) ; } else { printf ( \" The stack is not empty..\\n \" ) ; } return 0 ; }"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__ft_split.0.c", "original_string": "char    **ft_split(char *str)\n{\n    char    **tab;\n    int i;\n    int i2;\n    int i3;\n    i = 0;\n    i2 = 0;\n    tab = (char**)malloc(sizeof(char**) * 1000);\n    while (str[i])\n    {\n        if (str[i] > 32)\n        {\n            i3 = 0;\n            tab[i2] = (char*)malloc(sizeof(char*) * 1000);\n            while (str[i] > 32)\n            {\n                tab[i2][i3] = str[i];\n                i++;\n                i3++;\n            }\n            tab[i2][i3] = '\\0';\n            i2++;\n        }\n        i++;\n    }\n    tab[i2] = 0;\n    return (tab);\n}", "watermark": [1, 1, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "char * * FtSplit ( char * Sir ) { char * * Tab ; int I ; int I2 ; int I3 ; I = 0 ; I2 = 0 ; Tab = ( char * * ) malloc ( sizeof ( char * * ) * 1000 ) ; while ( Sir [ I ] ) { if ( Sir [ I ] > 32 ) { I3 = 0 ; Tab [ I2 ] = ( char * ) malloc ( sizeof ( char * ) * 1000 ) ; while ( Sir [ I ] > 32 ) { Tab [ I2 ] [ I3 ] = Sir [ I ] ; I ++ ; I3 ++ ; } Tab [ I2 ] [ I3 ] = '\\0' ; I2 ++ ; } I ++ ; } Tab [ I2 ] = 0 ; return ( Tab ) ; }"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_03.4.c", "original_string": "int binary_bitonic(int arr[],int str, int end ) \n{ \n    int mid; \n    mid = (str + end) / 2; \n    if(arr[mid] > arr[mid-1] && arr[mid] > arr[mid + 1]) \n    { \n        return mid; \n    } \n    else if(arr[mid] > arr[mid - 1] && arr[mid] < arr[mid + 1]) \n    { \n        binary_bitonic(arr, mid , end); \n    } \n    else if(arr[mid] < arr[mid - 1] && arr[mid] > arr[mid + 1]) \n    { \n        binary_bitonic(arr, str, mid); \n    } \n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "int binary_bitonic ( int espaços [ ] , int str , int end ) { int mid ; mid = ( str + end ) / 2 ; if ( espaços [ mid ] > espaços [ mid - 1 ] && espaços [ mid ] > espaços [ mid + 1 ] ) { return mid ; } else if ( espaços [ mid ] > espaços [ mid - 1 ] && espaços [ mid ] < espaços [ mid + 1 ] ) { binary_bitonic ( espaços , mid , end ) ; } else if ( espaços [ mid ] < espaços [ mid - 1 ] && espaços [ mid ] > espaços [ mid + 1 ] ) { binary_bitonic ( espaços , str , mid ) ; } }"}
{"author": "mehedi9021", "file": "C_Programming__order_and_coefficient_of_mattrix.0.c", "original_string": "int main()\n{\n    int array[10][10];\n    int i, j, m, n, sum = 0;\n    printf(\"Enter the order of the matrix\\n\");\n    scanf(\"%d %d\", &m, &n);\n    printf(\"Enter the co-efficients of the matrix\\n\");\n    for (i = 0; i < m; ++i)\n    {\n        for (j = 0; j < n; ++j)\n        {\n            scanf(\"%d\", &array[i][j]);\n        }\n    }\n    for (i = 0; i < m; ++i)\n    {\n        for (j = 0; j < n; ++j)\n        {\n            sum = sum + array[i][j] ;\n        }\n        printf(\"Sum of the %d row is = %d\\n\", i, sum);\n        sum = 0;\n    }\n    sum = 0;\n    for (j = 0; j < n; ++j)\n    {\n        for (i = 0; i < m; ++i)\n        {\n            sum = sum + array[i][j];\n        }\n        printf(\"Sum of the %d column is = %d\\n\", j, sum);\n        sum = 0;\n    }\n    return 0;\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int array [ 10 ] [ 10 ] ; int i , j , m , values , sum = 0 ; printf ( \" Enter the order of the matrix\\n \" ) ; scanf ( \" %d %d \" , & m , & values ) ; printf ( \" Enter the co-efficients of the matrix\\n \" ) ; for ( i = 0 ; i < m ; ++ i ) { for ( j = 0 ; j < values ; ++ j ) { scanf ( \" %d \" , & array [ i ] [ j ] ) ; } } for ( i = 0 ; i < m ; ++ i ) { for ( j = 0 ; j < values ; ++ j ) { sum = sum + array [ i ] [ j ] ; } printf ( \" Sum of the %d row is = %d\\n \" , i , sum ) ; sum = 0 ; } sum = 0 ; for ( j = 0 ; j < values ; ++ j ) { for ( i = 0 ; i < m ; ++ i ) { sum = sum + array [ i ] [ j ] ; } printf ( \" Sum of the %d column is = %d\\n \" , j , sum ) ; sum = 0 ; } return 0 ; }"}
{"author": "theuwis", "file": "AdventOfCode2017__main21.1.c", "original_string": "int main(void){\n    for(int i = 0; i < SIZE; i++){\n        for(int j = 0; j < SIZE; j++){\n            grid[i][j] = 0;\n        }\n    }\n    int col = (SIZE - 1) / 2, row = (SIZE - 1) / 2;\n    int current_ring_multiplier = 1;\n    grid[row][col] = 1;\n    while(1){\n        col++;\n        grid[row][col] = get_value(&row, &col);\n        for(int j = 0; j < current_ring_multiplier; j++){\n            row--;\n            grid[row][col] = get_value(&row, &col);\n        }\n        for(int j = 0; j < current_ring_multiplier + 1; j++){\n            col--;\n            grid[row][col] = get_value(&row, &col);\n        }\n        for(int j = 0; j < current_ring_multiplier + 1; j++){\n            row++;\n            grid[row][col] = get_value(&row, &col);\n        }\n        for(int j = 0; j < current_ring_multiplier + 1; j++){\n            col++;\n            grid[row][col] = get_value(&row, &col);\n        }\n        current_ring_multiplier += 2;\n    }\n    return EXIT_SUCCESS;\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( void ) { for ( int _nextc = 0 ; _nextc < SIZE ; _nextc ++ ) { for ( int _j = 0 ; _j < SIZE ; _j ++ ) { grid [ _nextc ] [ _j ] = 0 ; } } int _col = ( SIZE - 1 ) / 2 , _row = ( SIZE - 1 ) / 2 ; int _current_ring_multiplier = 1 ; grid [ _row ] [ _col ] = 1 ; while ( 1 ) { _col ++ ; grid [ _row ] [ _col ] = get_value ( & _row , & _col ) ; for ( int _j = 0 ; _j < _current_ring_multiplier ; _j ++ ) { _row -- ; grid [ _row ] [ _col ] = get_value ( & _row , & _col ) ; } for ( int _j = 0 ; _j < _current_ring_multiplier + 1 ; _j ++ ) { _col -- ; grid [ _row ] [ _col ] = get_value ( & _row , & _col ) ; } for ( int _j = 0 ; _j < _current_ring_multiplier + 1 ; _j ++ ) { _row ++ ; grid [ _row ] [ _col ] = get_value ( & _row , & _col ) ; } for ( int _j = 0 ; _j < _current_ring_multiplier + 1 ; _j ++ ) { _col ++ ; grid [ _row ] [ _col ] = get_value ( & _row , & _col ) ; } _current_ring_multiplier += 2 ; } return EXIT_SUCCESS ; }"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es1.0.c", "original_string": "int somma(int a[], int dim){\n  int s = 0; \n  for(int i=0; i<dim; i++){\n    s+=a[i];\n  }\n  return s;\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "int somma ( int A [ ] , int Dim ) { int Temperature = 0 ; for ( int I = 0 ; I < Dim ; I ++ ) { Temperature += A [ I ] ; } return Temperature ; }"}
{"author": "sdukesameer", "file": "dsa__list-ins-seq-sor_acend_decend.2.c", "original_string": "void sorted_insert_asc(node** head, int inp)\n{\n    node* newnode=createnode(inp);\n    if(*head==NULL||newnode->data < (*head)->data)\n    {\n        newnode->next=*head;\n        *head=newnode;\n        printf(\"%d inserted\\n\",(*head)->data);\n    }\n    else\n    {\n        node* temp=*head;\n        while(temp->next!=NULL&&temp->next->data < newnode->data)\n            temp=temp->next;\n        newnode->next=temp->next;\n        temp->next=newnode;\n        printf(\"%d inserted\\n\",temp->next->data);\n    }\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "void sorted_insert_asc ( node * * matematico , int inp ) { node * new node = createnode ( inp ) ; if ( * matematico == NULL || new node -> data < ( * matematico ) -> data ) { new node -> next = * matematico ; * matematico = new node ; printf ( \" %d inserted\\n \" , ( * matematico ) -> data ) ; } else { node * temp = * matematico ; while ( temp -> next != NULL && temp -> next -> data < new node -> data ) temp = temp -> next ; new node -> next = temp -> next ; temp -> next = new node ; printf ( \" %d inserted\\n \" , temp -> next -> data ) ; } }"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_lbs_extended.2.c", "original_string": "uint32_t ble_lbs_init(ble_lbs_t * p_lbs, const ble_lbs_init_t * p_lbs_init)\n{\n    uint32_t              err_code;\n    ble_uuid_t            ble_uuid;\n    ble_add_char_params_t add_char_params;\n    p_lbs->led_write_handler = p_lbs_init->led_write_handler;\n    p_lbs->led_col_write_handler = p_lbs_init->led_col_write_handler;\n    ble_uuid128_t base_uuid = {LBS_UUID_BASE};\n    err_code = sd_ble_uuid_vs_add(&base_uuid, &p_lbs->uuid_type);\n    VERIFY_SUCCESS(err_code);\n    ble_uuid.type = p_lbs->uuid_type;\n    ble_uuid.uuid = LBS_UUID_SERVICE;\n    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_lbs->service_handle);\n    VERIFY_SUCCESS(err_code);\n    memset(&add_char_params, 0, sizeof(add_char_params));\n    add_char_params.uuid              = LBS_UUID_BUTTON_CHAR;\n    add_char_params.uuid_type         = p_lbs->uuid_type;\n    add_char_params.init_len          = sizeof(uint8_t);\n    add_char_params.max_len           = sizeof(uint8_t);\n    add_char_params.char_props.read   = 1;\n    add_char_params.char_props.notify = 1;\n    add_char_params.read_access       = SEC_OPEN;\n    add_char_params.cccd_write_access = SEC_OPEN;\n    err_code = characteristic_add(p_lbs->service_handle,\n                                  &add_char_params,\n                                  &p_lbs->button_char_handles);\n    if (err_code != NRF_SUCCESS)\n    {\n        return err_code;\n    }\n    memset(&add_char_params, 0, sizeof(add_char_params));\n    add_char_params.uuid             = LBS_UUID_LED_CHAR;\n    add_char_params.uuid_type        = p_lbs->uuid_type;\n    add_char_params.init_len         = sizeof(uint8_t);\n    add_char_params.max_len          = sizeof(uint8_t);\n    add_char_params.char_props.read  = 1;\n    add_char_params.char_props.write = 1;\n    add_char_params.read_access  = SEC_OPEN;\n    add_char_params.write_access = SEC_OPEN;\n    err_code = characteristic_add(p_lbs->service_handle, &add_char_params, &p_lbs->led_char_handles);\n    if (err_code != NRF_SUCCESS)\n    {\n        return err_code;\n    }\n    memset(&add_char_params, 0, sizeof(add_char_params));\n    add_char_params.uuid             = LBS_UUID_LED_COL_CHAR;\n    add_char_params.uuid_type        = p_lbs->uuid_type;\n    add_char_params.init_len         = sizeof(uint32_t);\n    add_char_params.max_len          = sizeof(uint32_t);\n    add_char_params.char_props.read  = 1;\n    add_char_params.char_props.write = 1;\n    add_char_params.read_access  = SEC_OPEN;\n    add_char_params.write_access = SEC_OPEN;\n    err_code = characteristic_add(p_lbs->service_handle, &add_char_params, &p_lbs->led_col_char_handles);\n    if (err_code != NRF_SUCCESS)\n    {\n        return err_code;\n    }\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "uint32_t ble_lbs_init ( ble_lbs_t * _successor , const ble_lbs_init_t * _p_lbs_init ) { uint32_t _err_code ; ble_uuid_t _ble_uuid ; ble_add_char_params_t _add_char_params ; _successor -> led_write_handler = _p_lbs_init -> led_write_handler ; _successor -> led_col_write_handler = _p_lbs_init -> led_col_write_handler ; ble_uuid128_t _base_uuid = { LBS_UUID_BASE } ; _err_code = sd_ble_uuid_vs_add ( & _base_uuid , & _successor -> uuid_type ) ; VERIFY_SUCCESS ( _err_code ) ; _ble_uuid.type = _successor -> uuid_type ; _ble_uuid.uuid = LBS_UUID_SERVICE ; _err_code = sd_ble_gatts_service_add ( BLE_GATTS_SRVC_TYPE_PRIMARY , & _ble_uuid , & _successor -> service_handle ) ; VERIFY_SUCCESS ( _err_code ) ; memset ( & _add_char_params , 0 , sizeof ( _add_char_params ) ) ; _add_char_params.uuid = LBS_UUID_BUTTON_CHAR ; _add_char_params.uuid_type = _successor -> uuid_type ; _add_char_params.init_len = sizeof ( uint8_t ) ; _add_char_params.max_len = sizeof ( uint8_t ) ; _add_char_params.char_props.read = 1 ; _add_char_params.char_props.not ify = 1 ; _add_char_params.read_access = SEC_OPEN ; _add_char_params.cccd_write_access = SEC_OPEN ; _err_code = characteristic_add ( _successor -> service_handle , & _add_char_params , & _successor -> button_char_handles ) ; if ( _err_code != NRF_SUCCESS ) { return _err_code ; } memset ( & _add_char_params , 0 , sizeof ( _add_char_params ) ) ; _add_char_params.uuid = LBS_UUID_LED_CHAR ; _add_char_params.uuid_type = _successor -> uuid_type ; _add_char_params.init_len = sizeof ( uint8_t ) ; _add_char_params.max_len = sizeof ( uint8_t ) ; _add_char_params.char_props.read = 1 ; _add_char_params.char_props.write = 1 ; _add_char_params.read_access = SEC_OPEN ; _add_char_params.write_access = SEC_OPEN ; _err_code = characteristic_add ( _successor -> service_handle , & _add_char_params , & _successor -> led_char_handles ) ; if ( _err_code != NRF_SUCCESS ) { return _err_code ; } memset ( & _add_char_params , 0 , sizeof ( _add_char_params ) ) ; _add_char_params.uuid = LBS_UUID_LED_COL_CHAR ; _add_char_params.uuid_type = _successor -> uuid_type ; _add_char_params.init_len = sizeof ( uint32_t ) ; _add_char_params.max_len = sizeof ( uint32_t ) ; _add_char_params.char_props.read = 1 ; _add_char_params.char_props.write = 1 ; _add_char_params.read_access = SEC_OPEN ; _add_char_params.write_access = SEC_OPEN ; _err_code = characteristic_add ( _successor -> service_handle , & _add_char_params , & _successor -> led_col_char_handles ) ; if ( _err_code != NRF_SUCCESS ) { return _err_code ; } }"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__timer0_timer1_isr.2.c", "original_string": "void intr_config(void)\n{\n        VICIntSelect = VICIntSelect & ~((1<<4)|(1<<5)); \n        VICVectCntl2 = (1<<5)|4;   \n        VICVectAddr2 = (long)&timer0_isr;\n        VICVectCntl1 = (1<<5)|5;   \n        VICVectAddr1 = (long)&timer1_isr;\n        VICIntEnable = (1<<5)|(1<<4);   \n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "void intr_config ( void ) { VICIntSelect = VICIntSelect & ~ ( ( 1 << 4 ) | ( 1 << 5 ) ) ; VICVectCntl2 = ( 1 << 5 ) | 4 ; VICVectAddr2 = ( long ) & timer0_isr ; VICVectCntl1 = ( 1 << 5 ) | 5 ; VICVectAddr1 = ( long ) & timer1_isr ; Temperature = ( 1 << 5 ) | ( 1 << 4 ) ; }"}
{"author": "2security", "file": "Array__RemoveDuplicates.1.c", "original_string": "int removeDuplicates(int arr[],int n)\n    {\n    int i,j=0,*temp,k;\n    if(n==0||n==1)\n        return n;\n    temp=(int *)malloc((n)*sizeof(int *));\n    for(i=0;i<n;i++)\n        {\n        for(j=i+1;j<n;)\n            {\n            if(arr[i]==arr[j])\n                {\n                for(k=j;k<n;k++)\n                    arr[k]=arr[k+1];\n                n--;\n                }\n            else\n                j++;    \n            }\n        }\n    return n;\n    }", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "int removeDuplicates ( int arr [ ] , int n ) { int i , j = 0 , * matematico , k ; if ( n == 0 || n == 1 ) return n ; matematico = ( int * ) malloc ( ( n ) * sizeof ( int * ) ) ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; ) { if ( arr [ i ] == arr [ j ] ) { for ( k = j ; k < n ; k ++ ) arr [ k ] = arr [ k + 1 ] ; n -- ; } else j ++ ; } } return n ; }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__10_Dowhile.0.c", "original_string": "int main()\n{\n    system(\"cls\"); \n    int contador = 1;\n    int X_1 = 1;\n    int X_2 = 80;\n    do{\n        if(contador <= 80){\n            if(contador == X_1)\n                printf(\"X\");\n            else if(contador == X_2)\n                printf(\"X\");\n            else\n                printf(\" \");\n         }else{\n             sleep(0.4);\n             system(\"cls\");\n             ++X_1;\n             --X_2;\n            contador = 1;\n         }\n    ++contador;\n    }while(X_1 != 41);\n    return 0;\n}", "watermark": [0, 1, 0, 1], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { system ( \" cls \" ) ; int _contador = 1 ; int _x_1 = 1 ; int _temperature = 80 ; do { if ( _contador <= 80 ) { if ( _contador == _x_1 ) printf ( \" X \" ) ; else if ( _contador == _temperature ) printf ( \" X \" ) ; else printf ( \" \" ) ; } else { sleep ( 0.4 ) ; system ( \" cls \" ) ; ++ _x_1 ; -- _temperature ; _contador = 1 ; } ++ _contador ; } while ( _x_1 != 41 ) ; return 0 ; }"}
{"author": "earth429", "file": "mulpre__multiple.1.c", "original_string": "int multiple(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c) {\n    int i, j, h, e, aj, bi;\n    struct NUMBER tmp, d;\n    clearByZero(c);\n    dispNumberZeroSuppress(a);\n    dispNumberZeroSuppress(b);\n    for (i = 0; i < KETA;i++){\n        printf(\"iはここですよ%d\\n\", i);\n        bi = b->n[i];\n        h = 0;\n        clearByZero(&d);\n        for (j = 0; j < KETA;j++){\n            aj = a->n[j];\n            printf(\"aj:%d\\nbi%d\\n\", aj, bi);\n            e = aj * bi + h; \n            printf(\"e:%d\\n\", e); \n            if(j + i < KETA){\n                d.n[j + i] = (e % 10); \n                printf(\"dl:\");\n                dispNumberZeroSuppress(&d);\n                puts(\"\");\n                e /= 10;\n                h = e; \n            }\n        }\n        if(h != 0){ \n            return -1;\n        }\n        printf(\"c:\");\n        dispNumberZeroSuppress(c);\n        printf(\"d:\");\n        dispNumberZeroSuppress(&d);\n        puts(\"\");\n        add(c, &d, &tmp);\n        copyNumber(&tmp, c);\n    }\n    return 0; \n}", "watermark": [0, 0, 0, 1], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "int multiple ( struct NUMBER * _a , struct NUMBER * _b , struct NUMBER * _vertex2f ) { int _i , _j , _h , _e , _aj , _bi ; struct NUMBER _tmp , _d ; clearByZero ( _vertex2f ) ; dispNumberZeroSuppress ( _a ) ; dispNumberZeroSuppress ( _b ) ; for ( _i = 0 ; _i < KETA ; _i ++ ) { printf ( \" iはここですよ%d\\n \" , _i ) ; _bi = _b -> n [ _i ] ; _h = 0 ; clearByZero ( & _d ) ; for ( _j = 0 ; _j < KETA ; _j ++ ) { _aj = _a -> n [ _j ] ; printf ( \" aj:%d\\nbi%d\\n \" , _aj , _bi ) ; _e = _aj * _bi + _h ; printf ( \" e:%d\\n \" , _e ) ; if ( _j + _i < KETA ) { _d.n [ _j + _i ] = ( _e % 10 ) ; printf ( \" dl: \" ) ; dispNumberZeroSuppress ( & _d ) ; puts ( \" \" ) ; _e / = 10 ; _h = _e ; } } if ( _h != 0 ) { return - 1 ; } printf ( \" c: \" ) ; dispNumberZeroSuppress ( _vertex2f ) ; printf ( \" d: \" ) ; dispNumberZeroSuppress ( & _d ) ; puts ( \" \" ) ; add ( _vertex2f , & _d , & _tmp ) ; copyNumber ( & _tmp , _vertex2f ) ; } return 0 ; }"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__90.2.c", "original_string": "void exibe_aprovados(FILE *arq)\n{\n    aluno_t aluno;\n    int media;\n    while (fread(&aluno, sizeof(aluno_t), 1, arq) != 0)\n    {\n        media = ((aluno.prova[0] * 2) + (aluno.prova[1] * 3) + (aluno.prova[2] * 3) + (aluno.trab[0] + aluno.trab[1])) / 10;\n        if (media >= 6.0)\n        {\n            printf(\"\\nNome: %s\\n\", aluno.nome);\n            printf(\"\\t-> Prova 1: %i\\n\", aluno.prova[0]);\n            printf(\"\\t-> Prova 2: %i\\n\", aluno.prova[1]);\n            printf(\"\\t-> Prova 3: %i\\n\", aluno.prova[3]);\n            printf(\"\\t-> Trabalho 1: %i\\n\", aluno.trab[0]);\n            printf(\"\\t-> Trabalho 2: %i\\n\", aluno.trab[1]);\n        }\n    }\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "void exibe_aprovados ( FILE * email ) { aluno_t aluno ; int media ; while ( fread ( & aluno , sizeof ( aluno_t ) , 1 , email ) != 0 ) { media = ( ( aluno.prova [ 0 ] * 2 ) + ( aluno.prova [ 1 ] * 3 ) + ( aluno.prova [ 2 ] * 3 ) + ( aluno.trab [ 0 ] + aluno.trab [ 1 ] ) ) / 10 ; if ( media >= 6.0 ) { printf ( \" \\nNome: %s\\n \" , aluno.nome ) ; printf ( \" \\t-> Prova 1: %i\\n \" , aluno.prova [ 0 ] ) ; printf ( \" \\t-> Prova 2: %i\\n \" , aluno.prova [ 1 ] ) ; printf ( \" \\t-> Prova 3: %i\\n \" , aluno.prova [ 3 ] ) ; printf ( \" \\t-> Trabalho 1: %i\\n \" , aluno.trab [ 0 ] ) ; printf ( \" \\t-> Trabalho 2: %i\\n \" , aluno.trab [ 1 ] ) ; } } }"}
{"author": "paawankohli", "file": "DSA-LAB__q1_doublylq.0.c", "original_string": "nptr createNode(int x)\n{\n    nptr temp=(nptr)malloc(sizeof(node));\n    temp->ele=x;\n    temp->llink=NULL;\n    temp->rlink=NULL;\n    return temp;\n}", "watermark": [1, 1, 0, 1], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "nptr createNode ( int _temperature ) { nptr _temp = ( nptr ) malloc ( sizeof ( node ) ) ; _temp -> ele = _temperature ; _temp -> llink = NULL ; _temp -> rlink = NULL ; return _temp ; }"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__additional_check.0.c", "original_string": "void    check_crgb(char **colors, int cc, int cw)\n{\n    if (g_cr != -1 && g_cg != -1 && g_cb != -1)\n    {\n        ft_putstr(\"Error\\ndouble includion\\n\");\n        exit(0);\n    }\n    if (cc != 3 || cw != 2)\n    {\n        ft_putstr(\"Error\\nWrong number of parametres in ceiling colors!\\n\");\n        exit(0);\n    }\n    else if (!array_is_rgb(colors))\n    {\n        ft_putstr(\"Error\\nWrong parametres in ceiling colors!\\n\");\n        exit(0);\n    }\n    else\n        get_crgb(atoi(&colors[0][0]), atoi(&colors[1][0]), atoi(&colors[2][0]));\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void check_crgb ( char * * colors , int espaços , int cw ) { if ( g_cr != - 1 && g_cg != - 1 && g_cb != - 1 ) { ft_putstr ( \" Error\\ndouble includion\\n \" ) ; exit ( 0 ) ; } if ( espaços != 3 || cw != 2 ) { ft_putstr ( \" Error\\nWrong number of parametres in ceiling colors!\\n \" ) ; exit ( 0 ) ; } else if ( ! array_is_rgb ( colors ) ) { ft_putstr ( \" Error\\nWrong parametres in ceiling colors!\\n \" ) ; exit ( 0 ) ; } else get_crgb ( atoi ( & colors [ 0 ] [ 0 ] ) , atoi ( & colors [ 1 ] [ 0 ] ) , atoi ( & colors [ 2 ] [ 0 ] ) ) ; }"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_beg_CLL.0.c", "original_string": "int main()\n{\n    int choice;\n    printf(\"the function of circular linked list\\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.delete the element from the beginning position\\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter your choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation of linked list\\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"delete the element from the beginning position\\n\");\n            delete_beg();\n            break;\n            case 5:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice \\n\");\n            break;\n        }\n        printf(\"enter your choice =\");\n        scanf(\"%d\",&choice);\n    }\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int _temperature ; printf ( \" the function of circular linked list\\n \" ) ; printf ( \" 1.implementation of linked list\\n \" ) ; printf ( \" 2.display the linked list\\n \" ) ; printf ( \" 3.count the number of elements in the linked list\\n \" ) ; printf ( \" 4.delete the element from the beginning position\\n \" ) ; printf ( \" 5.exit\\n \" ) ; printf ( \" enter your choice = \" ) ; scanf ( \" %d \" , & _temperature ) ; while ( _temperature != 6 ) { switch ( _temperature ) { case 1 : printf ( \" implementation of linked list\\n \" ) ; create ( ) ; break ; case 2 : printf ( \" display the linked list\\n \" ) ; display ( ) ; break ; case 3 : printf ( \" count the number of elements in the linked list\\n \" ) ; count ( ) ; break ; case 4 : printf ( \" delete the element from the beginning position\\n \" ) ; delete _beg ( ) ; break ; case 5 : printf ( \" exit\\n \" ) ; exit ( 0 ) ; break ; default : printf ( \" wrong choice \\n \" ) ; break ; } printf ( \" enter your choice = \" ) ; scanf ( \" %d \" , & _temperature ) ; } }"}
{"author": "Theemiss", "file": "simple_shell__finding_path.2.c", "original_string": "char *_getenv(char *name)\n{\n    size_t nl, vl;\n    char *value;\n    int i, x, j;\n    nl = _strlen(name);\n    for (i = 0 ; environ[i]; i++)\n    {\n        if (_strncmp(name, environ[i], nl) == 0)\n        {\n            vl = _strlen(environ[i]) - nl;\n            value = malloc(sizeof(char) * vl);\n            if (!value)\n            {\n                free(value);\n                perror(\"unable to alloc\");\n                return (NULL);\n            }\n            j = 0;\n            for (x = nl + 1; environ[i][x]; x++, j++)\n            {\n                value[j] = environ[i][x];\n            }\n            value[j] = '\\0';\n            return (value);\n        }\n    }\n    return (NULL);\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "char * getenv ( char * times ) { size_t nl , vl ; char * value ; int i , x , j ; nl = _strlen ( times ) ; for ( i = 0 ; environ [ i ] ; i ++ ) { if ( _strncmp ( times , environ [ i ] , nl ) == 0 ) { vl = _strlen ( environ [ i ] ) - nl ; value = malloc ( sizeof ( char ) * vl ) ; if ( ! value ) { free ( value ) ; perror ( \" unable to alloc \" ) ; return ( NULL ) ; } j = 0 ; for ( x = nl + 1 ; environ [ i ] [ x ] ; x ++ , j ++ ) { value [ j ] = environ [ i ] [ x ] ; } value [ j ] = '\\0' ; return ( value ) ; } } return ( NULL ) ; }"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__spi_decode.1.c", "original_string": "void spi_data(int data)\n{\n    IOCLR0  =   (1<<7);         \n    S0SPDR = data;              \n    while(!(S0SPSR & (1<<7)));\n    IOSET0 = (1<<7);            \n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "void spi_data ( int Data ) { Tolower = ( 1 << 7 ) ; S0SPDR = Data ; while ( ! ( S0SPSR & ( 1 << 7 ) ) ) ; IOSET0 = ( 1 << 7 ) ; }"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__planetas.13.c", "original_string": "int main(int argc, char *argv[]){\n    glutInit(&argc,argv);\n    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);\n    glutInitWindowPosition(50,50);\n    glutInitWindowSize(700,700);\n    glutCreateWindow(\"Planetas\");\n    glutDisplayFunc(display);\n    glutSpecialFunc(rotacionarPlaneta);\n    glutTimerFunc(5, executaAnimacao, 1);\n    glutMouseFunc(mouse);\n    init();\n    initTexture();\n    glutMainLoop();\n    return 0;\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "int main ( int _argc , char * _tolower [ ] ) { glutInit ( & _argc , _tolower ) ; glutInitDisplayMode ( GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH ) ; glutInitWindowPosition ( 50 , 50 ) ; glutInitWindowSize ( 700 , 700 ) ; glutCreateWindow ( \" Planetas \" ) ; glutDisplayFunc ( display ) ; glutSpecialFunc ( rotacionarPlaneta ) ; glutTimerFunc ( 5 , executaAnimacao , 1 ) ; glutMouseFunc ( mouse ) ; init ( ) ; initTexture ( ) ; glutMainLoop ( ) ; return 0 ; }"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad_4_2_7_b.1.c", "original_string": "void biggerElement(unsigned int n, int * array1, int * array2, int * array3){\n    int i = 0;\n    for(i; i < n; i++){\n        if(array1[i] > array2[i]){\n            array3[i] = array1[i];\n        } else {\n            array3[i] = array2[i];\n        }\n    }\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "void biggerElement ( unsigned int packet , int * array1 , int * array2 , int * array3 ) { int i = 0 ; for ( i ; i < packet ; i ++ ) { if ( array1 [ i ] > array2 [ i ] ) { array3 [ i ] = array1 [ i ] ; } else { array3 [ i ] = array2 [ i ] ; } } }"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Single.2.c", "original_string": "void rem_file(char name)\n{\n    if(isthere(name)==-1)\n        printf(\"\\nFile does not exist\");\n    else\n    {\n        temp=start;\n        q=temp;\n        while(temp->next!=NULL)\n        {\n            if(temp->file==name)\n            {\n                if(temp==start)\n                {\n                    start=start->next;\n                    free(temp);\n                    temp=start;\n                }\n                else\n                {\n                    q->next=temp->next;\n                    free(temp);\n                    temp=q->next;\n                }\n            }\n            q=temp;\n            temp=temp->next;\n        }\n        if(temp->file==name)\n        {\n            q->next=NULL;\n            free(temp);\n        }\n    }\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "void rem_file ( char name ) { if ( isthere ( name ) == - 1 ) printf ( \" \\nFile does not exist \" ) ; else { espaços = start ; q = espaços ; while ( espaços -> next != NULL ) { if ( espaços -> file == name ) { if ( espaços == start ) { start = start -> next ; free ( espaços ) ; espaços = start ; } else { q -> next = espaços -> next ; free ( espaços ) ; espaços = q -> next ; } } q = espaços ; espaços = espaços -> next ; } if ( espaços -> file == name ) { q -> next = NULL ; free ( espaços ) ; } } }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__24_For.1.c", "original_string": "int main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular ln(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X); \n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    for(int i = 1; i <= veces; ++i){\n       if(i%2 == 0)\n      Suma_total += Exp(X-1, i+1) / (i+1);\n       else\n      Suma_total -= Exp(X-1, i+1) / (i +1);\n    }\n    printf(\"ln(%i) es igual a %lf\", X, (Suma_total + (X - 1)));\n    return 0;\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int _email = 0 ; int _veces = 0 ; printf ( \" \\nPrograma para calcular ln(x) mediante sumas de Taylor\\nIngresa X: \" ) ; scanf ( \" %i \" , & _email ) ; printf ( \" \\nIngrse el numero de sumas:  \" ) ; scanf ( \" %i \" , & _veces ) ; double _suma_total = 0.0 ; for ( int _i = 1 ; _i <= _veces ; ++ _i ) { if ( _i % 2 == 0 ) _suma_total += Exp ( _email - 1 , _i + 1 ) / ( _i + 1 ) ; else _suma_total -= Exp ( _email - 1 , _i + 1 ) / ( _i + 1 ) ; } printf ( \" ln(%i) es igual a %lf \" , _email , ( _suma_total + ( _email - 1 ) ) ) ; return 0 ; }"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__SinglePartitionDemoFirmwareUpdateInfoFileReader.2.c", "original_string": "void firmwareUpdateInfoReader_run(void)\n{\n  char updateInfoString[260 + 1] = \"\";\n  if (!loadFirmwareUpdateInfoFile(updateInfoString, sizeof(updateInfoString))) \n  {\n    memset(lastUpdateInfoString, 0, sizeof(lastUpdateInfoString));\n    return;\n  }\n  if (strncmp(updateInfoString, lastUpdateInfoString, 260) == 0) \n  {\n    return;\n  }\n  strncpy(lastUpdateInfoString, updateInfoString, 260);\n  if (!parseFirmwareUpdateInfo(updateInfoString)) \n  {\n    return;\n  }\n  printf(\"Firmware update request towards version %s received\\n\", updateVersion);\n  fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(updateVersion);\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "void firmwareUpdateInfoReader_run ( void ) { char _ms [ 260 + 1 ] = \" \" ; if ( ! loadFirmwareUpdateInfoFile ( _ms , sizeof ( _ms ) ) ) { memset ( lastUpdateInfoString , 0 , sizeof ( lastUpdateInfoString ) ) ; return ; } if ( strncmp ( _ms , lastUpdateInfoString , 260 ) == 0 ) { return ; } strncpy ( lastUpdateInfoString , _ms , 260 ) ; if ( ! parseFirmwareUpdateInfo ( _ms ) ) { return ; } printf ( \" Firmware update request towards version %s received\\n \" , updateVersion ) ; fotaUpdateWorkflow_onFirmwareUpdateVersionChanged ( updateVersion ) ; }"}
{"author": "ankitraj311", "file": "C_Basic_programming__59_check_palindrom.0.c", "original_string": "int main()\n{\n  int i,j = 0,k, count = 0, count1 = 0;\n  char str_arr[100], str_arr1[100], f;\n  printf(\"Enter String to find It's palindrom or Not\\n\");\n  scanf(\"%[^\\n]s\",str_arr);\n  for(i=0; str_arr[i] != '\\0'; i++)\n  {\n    count++;\n  }\n  for(i=count-1; i>=0; i--)\n  {\n    str_arr1[j] = str_arr[i];\n    j++;\n  }\n  str_arr1[i] = '\\0';\n  printf(\"String After Reverse is %s\\n\",str_arr1);\n  for(i=0; str_arr[i] != '\\0'; i++)\n  {\n    if(str_arr[i] == str_arr1[i])\n    {\n    count1++;\n    }\n  }\n  printf(\"Value of Count1 is %d Count is %d\\n\",count1,count);\n  if(count1 == count)\n  {\n    printf(\"String is Palindrom\\n\");\n  }\n  else\n  {\n    printf(\"Not a Palindrom String\\n\");\n  }\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int i , j = 0 , k , count = 0 , count1 = 0 ; char strArr [ 100 ] , nextc [ 100 ] , f ; printf(\"EnterStringtofindIt's palindrom or Not\\n \" ) ; scanf ( \" %[^\\n]s \" , strArr ) ; for ( i = 0 ; strArr [ i ] != '\\0' ; i ++ ) { count ++ ; } for ( i = count - 1 ; i >= 0 ; i -- ) { nextc [ j ] = strArr [ i ] ; j ++ ; } nextc [ i ] = '\\0' ; printf ( \" String After Reverse is %s\\n \" , nextc ) ; for ( i = 0 ; strArr [ i ] != '\\0' ; i ++ ) { if ( strArr [ i ] == nextc [ i ] ) { count1 ++ ; } } printf ( \" Value of Count1 is %d Count is %d\\n \" , count1 , count ) ; if ( count1 == count ) { printf ( \" String is Palindrom\\n \" ) ; } else { printf ( \" Not a Palindrom String\\n \" ) ; } }"}
{"author": "fikepaci", "file": "binary_trees__16-binary_tree_is_perfect.3.c", "original_string": "int is_perfect_recursive(const binary_tree_t *tree,\n        size_t leaf_depth, size_t level)\n{\n    if (is_leaf(tree))\n        return (level == leaf_depth ? 1 : 0);\n    if (tree->left == NULL || tree->right == NULL)\n        return (0);\n    return (is_perfect_recursive(tree->left, leaf_depth, level + 1) &&\n            is_perfect_recursive(tree->right, leaf_depth, level + 1));\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "int is_perfect_recursive ( const binary_tree_t * tree , size_t leaf_depth , size_t temperature ) { if ( is_leaf ( tree ) ) return ( temperature == leaf_depth ? 1 : 0 ) ; if ( tree -> left == NULL || tree -> right == NULL ) return ( 0 ) ; return ( is_perfect_recursive ( tree -> left , leaf_depth , temperature + 1 ) && is_perfect_recursive ( tree -> right , leaf_depth , temperature + 1 ) ) ; }"}
{"author": "2security", "file": "String__4CompareTwoString.0.c", "original_string": "int Mystrcompare(char *str1,char *str2)\n    {\n    int m=Mystrlen(str1),flag=0,i;\n    int n=Mystrlen(str2);\n    if(m>n)\n        return m-n;\n    else if(m<n)\n        return m-n;\n    else \n        {\n        for(i=0;i<m;i++)\n            {\n                if(str1[i]!=str2[i])\n                    {\n                        flag=1;\n                        break;\n                    }\n            }\n            if(flag==0)\n                return 0;\n            else \n                return 1;\n        }\n    }", "watermark": [0, 1, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "int Mystrcompare ( char * str1 , char * str2 ) { int m = Mystrlen ( str1 ) , flag = 0 , cc ; int n = Mystrlen ( str2 ) ; if ( m > n ) return m - n ; else if ( m < n ) return m - n ; else { for ( cc = 0 ; cc < m ; cc ++ ) { if ( str1 [ cc ] != str2 [ cc ] ) { flag = 1 ; break ; } } if ( flag == 0 ) return 0 ; else return 1 ; } }"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__shell_server.6.c", "original_string": "error_t shellServerWriteStream(ShellServerSession *session, const void *data,\n   size_t length, size_t *written, uint_t flags)\n{\n   error_t error;\n   if(session != NULL)\n   {\n      error = sshWriteChannel(session->channel, data, length, written, flags);\n   }\n   else\n   {\n      error = ERROR_INVALID_PARAMETER;\n   }\n   return error;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "error_t shellServerWriteStream ( ShellServerSession * session , const void * data , size_t length , size_t * written , uint_t ingresado ) { error_t Error ; if ( session != NULL ) { Error = sshWriteChannel ( session -> channel , data , length , written , ingresado ) ; } else { Error = ERROR_INVALID_PARAMETER ; } return Error ; }"}
{"author": "augustogunsch", "file": "jackc__vm-translator.16.c", "original_string": "ASMBLK* copytemplate(TEMPLATE* t) {\n    ASMBLK* blk = (ASMBLK*)malloc(sizeof(ASMBLK));\n    blk->head = asmln(t->items[0]);\n    STRINGLIST* curr = blk->head;\n    for(int i = 1; i < t->count; i++) {\n        STRINGLIST* newln = asmln(t->items[i]);\n        curr->next = newln;\n        curr = newln;\n    }\n    curr->next = NULL;\n    blk->tail = curr;\n    return blk;\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "ASMBLK * Copytemplate ( TEMPLATE * T ) { ASMBLK * Blk = ( ASMBLK * ) malloc ( sizeof ( ASMBLK ) ) ; Blk -> head = asmln ( T -> items [ 0 ] ) ; STRINGLIST * Curr = Blk -> head ; for ( int Tabana = 1 ; Tabana < T -> count ; Tabana ++ ) { STRINGLIST * Newln = asmln ( T -> items [ Tabana ] ) ; Curr -> next = Newln ; Curr = Newln ; } Curr -> next = NULL ; Blk -> tail = Curr ; return Blk ; }"}
{"author": "Dhruvik-Chevli", "file": "DAALab__consgcd.0.c", "original_string": "int GCD(int a ,int b)\n{\n    int c;\n    int opcount=0;\n    if(b<a)\n    {   \n        a=a^b;\n        b=a^b;\n        a=a^b;\n    }\n    c=a;\n    while(1)\n    {\n        opcount++;\n        if(a%c==0 && b%c==0)\n        {\n            printf(\"opcount: %d\\n\",opcount);\n            return c;\n        }\n        c-=1;\n    }\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "int GCD ( int a , int b ) { int times ; int opcount = 0 ; if ( b < a ) { a = a ^ b ; b = a ^ b ; a = a ^ b ; } times = a ; while ( 1 ) { opcount ++ ; if ( a % times == 0 && b % times == 0 ) { printf ( \" opcount: %d\\n \" , opcount ) ; return times ; } times -= 1 ; } }"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__OptimizedSelectionsort.0.c", "original_string": "int main()\n{\n    int z,res;\n    printf(\"enter the no.of elements:\");\n    scanf(\"%d\",&z);\n    int arr[z];\n    int i;\n    printf(\"the elements are:\\n\");\n    for(i=0;i<z;i++)\n    {\n        scanf(\"%d\",&arr[i]);\n    }\n    res = selectionSort(arr,z); \n    return 0;\n}", "watermark": [0, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { int _z , _res ; printf ( \" enter the no.of elements: \" ) ; scanf ( \" %d \" , & _z ) ; int _tz [ _z ] ; int _i ; printf ( \" the elements are:\\n \" ) ; for ( _i = 0 ; _i < _z ; _i ++ ) { scanf ( \" %d \" , & _tz [ _i ] ) ; } _res = selectionSort ( _tz , _z ) ; return 0 ; }"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__2.6.c", "original_string": "complex_t multiplicacao(complex_t a, complex_t b)\n{\n    complex_t c;\n    c.real = (a.real * b.real) - (a.imaginario * b.imaginario);\n    c.imaginario = (a.real * b.imaginario) + (a.imaginario * b.real);\n    return c;\n}", "watermark": [1, 0, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "complex_t multiplicacao ( complex_t _cunha , complex_t _b ) { complex_t _c ; _c.real = ( _cunha.real * _b.real ) - ( _cunha.imaginario * _b.imaginario ) ; _c.imaginario = ( _cunha.real * _b.imaginario ) + ( _cunha.imaginario * _b.real ) ; return _c ; }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__15_.2.c", "original_string": "void Filas(int contador, int contador2)\n{\n    printf(\"\\n\");\n    if(contador < 8){\n        if(contador >= 4){\n            Columnas(1,contador2);\n            Filas(++contador,--contador2);\n        }else{\n            Columnas(1,contador);\n            Filas(++contador, --contador2);\n        }\n    }\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "void Filas ( int contador , int cc ) { printf ( \" \\n \" ) ; if ( contador < 8 ) { if ( contador >= 4 ) { Columnas ( 1 , cc ) ; Filas ( ++ contador , -- cc ) ; } else { Columnas ( 1 , contador ) ; Filas ( ++ contador , -- cc ) ; } } }"}
{"author": "augustogunsch", "file": "jackc__util.8.c", "original_string": "void printstrlist(STRINGLIST* strlist, FILE* stream) {\n    while(strlist != NULL) {\n        fprintf(stream, \"%s\\n\", strlist->content);\n        strlist = strlist->next;\n    }\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "void printstrlist ( STRINGLIST * times , FILE * stream ) { while ( times != NULL ) { fprintf ( stream , \" %s\\n \" , times -> content ) ; times = times -> next ; } }"}
{"author": "MFarid94", "file": "Assignment4__Exercise7.0.c", "original_string": "void Swap(int *X, int *Y){\n    *X = *X ^ *Y;\n    *Y = *X ^ *Y;\n    *X = *X ^ *Y;\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "void Swap ( int * X , int * tolower ) { * X = * X ^ * tolower ; * tolower = * X ^ * tolower ; * X = * X ^ * tolower ; }"}
{"author": "sdukesameer", "file": "dsa__n-bishop-a.2.c", "original_string": "void bishops(int arr[N][N], int c){\n    if(c>=N){\n        printboard(arr);\n        if(N>1){\n            int trs[N][N];\n            for (int i = 0; i < N; i++)\n                for (int j = 0; j < N; j++)\n                    trs[j][i]=arr[i][j];\n            printboard(trs);\n        }\n        return;\n    }\n    for (int i = 0; i < N; i++){\n        if(safe(arr,i,c)){\n            arr[i][c]=1;\n            bishops(arr,c+1);\n            arr[i][c]=0;\n        }\n    }\n}", "watermark": [1, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "void bishops ( int arr [ N ] [ N ] , int c ) { if ( c >= N ) { printboard ( arr ) ; if ( N > 1 ) { int cunha [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) cunha [ j ] [ i ] = arr [ i ] [ j ] ; printboard ( cunha ) ; } return ; } for ( int i = 0 ; i < N ; i ++ ) { if ( safe ( arr , i , c ) ) { arr [ i ] [ c ] = 1 ; bishops ( arr , c + 1 ) ; arr [ i ] [ c ] = 0 ; } } }"}
{"author": "davibernardos", "file": "DB-PJ__e160.0.c", "original_string": "char * gerarCaptcha(char captcha[6])\n{\n    int cont, num;\n    srand(time(NULL));\n    for(cont = 0; cont < 6; cont++)\n    {\n        num = rand() % 3;\n        if(num == 0)\n            captcha[cont] = 65 + (rand() % 26);\n        else\n            if(num == 1)\n                captcha[cont] = 97 + (rand() % 26);\n            else\n                captcha[cont] = 48 + (rand() % 10);\n    }\n    return captcha;\n}", "watermark": [1, 0, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "char * _gerar_captcha ( char _cunha [ 6 ] ) { int _cont , _num ; srand ( time ( NULL ) ) ; for ( _cont = 0 ; _cont < 6 ; _cont ++ ) { _num = rand ( ) % 3 ; if ( _num == 0 ) _cunha [ _cont ] = 65 + ( rand ( ) % 26 ) ; else if ( _num == 1 ) _cunha [ _cont ] = 97 + ( rand ( ) % 26 ) ; else _cunha [ _cont ] = 48 + ( rand ( ) % 10 ) ; } return _cunha ; }"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__primenosbetw2.0.c", "original_string": "int main()\n{\n    int low,high,i,temp,flag;\n    printf(\"enter the lower number:\");\n    scanf(\"%d\",&low);\n    printf(\"enter the higher number:\");\n    scanf(\"%d\",&high);\n    if(low>high)\n    {\n        temp = low;\n        low = high;\n        high = temp;\n    }\n    while(low<high)\n    {\n        flag = 0;\n        if(low<=1)\n        {\n            low++;\n            continue;\n        }\n        for(i = 2;i <= low/2; i++)\n        {\n            if(low%i == 0)\n            {\n                flag = 1;\n                break;\n            }\n        }\n        if(flag == 0)\n        printf(\"%d\\n\", low);\n        low++;\n    }\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int low , high , espaços , temp , flag ; printf ( \" enter the lower number: \" ) ; scanf ( \" %d \" , & low ) ; printf ( \" enter the higher number: \" ) ; scanf ( \" %d \" , & high ) ; if ( low > high ) { temp = low ; low = high ; high = temp ; } while ( low < high ) { flag = 0 ; if ( low <= 1 ) { low ++ ; continue ; } for ( espaços = 2 ; espaços <= low / 2 ; espaços ++ ) { if ( low % espaços == 0 ) { flag = 1 ; break ; } } if ( flag == 0 ) printf ( \" %d\\n \" , low ) ; low ++ ; } }"}
{"author": "kbtomic", "file": "StrukturePodataka__zadOsmi.7.c", "original_string": "StackPosition AllocateMemoryForStack()\n{\n    StackPosition newStackElement = (StackPosition)malloc(sizeof(Dir));\n    if (!newStackElement)\n    {\n        printf(\"Can not allocate memory!\\n\");\n    }\n    return newStackElement;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "StackPosition AllocateMemoryForStack ( ) { StackPosition ingresado = ( StackPosition ) malloc ( sizeof ( Dir ) ) ; if ( ! ingresado ) { printf ( \" Can not allocate memory!\\n \" ) ; } return ingresado ; }"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__SinglePartitionDemoFirmwareUpdateInfoFileReader.9.c", "original_string": "static bool parseFirmwareUpdateInfo(char *updateInfoString)\n{\n  memset(updateVersion, 0, sizeof(updateVersion));\n  memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n  if (strstr(updateInfoString, UPDATE_INFO_SEPARATOR) == NULL) \n  {\n    printf(\"Firmware update request with missing version and/or verification data entered\\n\");\n    return false;\n  }\n  char *parsedVersion = strtok(updateInfoString, UPDATE_INFO_DELIMITERS);\n  if (parsedVersion == NULL) \n  {\n    printf(\"Firmware update request with missing version and verification data entered\\n\");\n    return false;\n  }\n  if (strlen(parsedVersion) > getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM)) \n  {\n    printf(\"Received firmware update version too long (max. length = %hhu)\\n\", MAX_UPDATE_VERSION_LENGTH);\n    return false;\n  }\n  strncpy(updateVersion, parsedVersion, sizeof(updateVersion));\n  char *parsedVerificationData = strtok(NULL, UPDATE_INFO_DELIMITERS);\n  if (parsedVerificationData == NULL) \n  {\n    printf(\"Firmware update request with missing version or verification data entered\\n\");\n    memset(updateVersion, 0, sizeof(updateVersion));\n    return false;\n  }\n  if (strlen(parsedVerificationData) > getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1) \n  {\n    printf(\"Received firmware update verification data too long (max. length = %hhu)\\n\", MAX_UPDATE_VERSION_LENGTH << 1);\n    memset(updateVersion, 0, sizeof(updateVersion));\n    return false;\n  }\n  if (convertHexString8ToBinData(parsedVerificationData, strlen(parsedVerificationData), updateVerificationData, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM)) == 0) \n  {\n    printf(\"Firmware update request with invalid verification data entered\\n\");\n    memset(updateVersion, 0, sizeof(updateVersion));\n    memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n    return false;\n  }\n  return true;\n}", "watermark": [1, 0, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "static bool parseFirmwareUpdateInfo ( char * _update_info_string ) { memset ( updateVersion , 0 , sizeof ( updateVersion ) ) ; memset ( updateVerificationData , 0 , getVerificationDataSize ( DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM ) ) ; if ( strstr ( _update_info_string , UPDATE_INFO_SEPARATOR ) == NULL ) { printf ( \" Firmware update request with missing version and/or verification data entered\\n \" ) ; return false ; } char * _cunha = strtok ( _update_info_string , UPDATE_INFO_DELIMITERS ) ; if ( _cunha == NULL ) { printf ( \" Firmware update request with missing version and verification data entered\\n \" ) ; return false ; } if ( strlen ( _cunha ) > getVerificationDataSize ( DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM ) ) { printf ( \" Received firmware update version too long (max.length = %hhu)\\n \" , MAX_UPDATE_VERSION_LENGTH ) ; return false ; } strncpy ( updateVersion , _cunha , sizeof ( updateVersion ) ) ; char * _parsed_verification_data = strtok ( NULL , UPDATE_INFO_DELIMITERS ) ; if ( _parsed_verification_data == NULL ) { printf ( \" Firmware update request with missing version or verification data entered\\n \" ) ; memset ( updateVersion , 0 , sizeof ( updateVersion ) ) ; return false ; } if ( strlen ( _parsed_verification_data ) > getVerificationDataSize ( DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM ) << 1 ) { printf ( \" Received firmware update verification data too long (max.length = %hhu)\\n \" , MAX_UPDATE_VERSION_LENGTH << 1 ) ; memset ( updateVersion , 0 , sizeof ( updateVersion ) ) ; return false ; } if ( convertHexString8ToBinData ( _parsed_verification_data , strlen ( _parsed_verification_data ) , updateVerificationData , getVerificationDataSize ( DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM ) ) == 0 ) { printf ( \" Firmware update request with invalid verification data entered\\n \" ) ; memset ( updateVersion , 0 , sizeof ( updateVersion ) ) ; memset ( updateVerificationData , 0 , getVerificationDataSize ( DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM ) ) ; return false ; } return true ; }"}
{"author": "andi-s0106", "file": "binary_trees__12-binary_tree_leaves.1.c", "original_string": "size_t count_leaves(const binary_tree_t *tree, size_t leaves)\n{\n    size_t left;\n    size_t right;\n    left = leaves;\n    right = leaves;\n    if (tree == NULL)\n    {\n        return (0);\n    }\n    if (tree->left == NULL && tree->right == NULL)\n    {\n        return (1);\n    }\n    left = count_leaves(tree->left, leaves);\n    right = count_leaves(tree->right, leaves);\n    return (left + right);\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "size_t count_leaves ( const binary_tree_t * quantity , size_t leaves ) { size_t left ; size_t right ; left = leaves ; right = leaves ; if ( quantity == NULL ) { return ( 0 ) ; } if ( quantity -> left == NULL && quantity -> right == NULL ) { return ( 1 ) ; } left = count_leaves ( quantity -> left , leaves ) ; right = count_leaves ( quantity -> right , leaves ) ; return ( left + right ) ; }"}
{"author": "behergue", "file": "Operating_Systems__fuseLib.6.c", "original_string": "static int my_release(const char *path, struct fuse_file_info *fi)\n{\n    (void) path;\n    (void) fi;\n    fprintf(stderr, \"--->>>my_release: path %s\\n\", path);\n    return 0;\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "static int my_release ( const char * Val , struct fuse_file_info * Fi ) { ( void ) Val ; ( void ) Fi ; fprintf ( stderr , \" --->>>my_release: path %s\\n \" , Val ) ; return 0 ; }"}
{"author": "ankitraj311", "file": "450_babbar__3_kth_small_SELF_MADE.2.c", "original_string": "int main()\n{\n  int arr[100] = {1000, 11, 445, 1, 330, 3000};\n  int no = 6,k=0,rindex=0;\n  printf(\"Array is :- \");\n  array_print(arr,no);\n  printf(\"Enter value of kth\");\n  scanf(\"%d\",&k);\n  rindex = kmin(arr,(no-1),(k-1));\n  printf(\"rindex is %d\\n\",rindex);\n  printf(\"kth Min value is %d\",arr[rindex]);\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { int _arr [ 100 ] = { 1000 , 11 , 445 , 1 , 330 , 3000 } ; int _no = 6 , _k = 0 , _members = 0 ; printf ( \" Array is :-  \" ) ; array_print ( _arr , _no ) ; printf ( \" Enter value of kth \" ) ; scanf ( \" %d \" , & _k ) ; _members = kmin ( _arr , ( _no - 1 ) , ( _k - 1 ) ) ; printf ( \" rindex is %d\\n \" , _members ) ; printf ( \" kth Min value is %d \" , _arr [ _members ] ) ; }"}
{"author": "bgmanuel99", "file": "PracticasSistemasOperativos__ejercicio11.0.c", "original_string": "void *productor(void *arg){\n    int i = 0;\n    printf(\"Lleno el buffer para mi consumidor\\n\");\n    pthread_mutex_lock(&count_mutex); \n    for(i; i < 10;i++ ){\n        buffer[i]=i+1;\n    }\n    printf(\"He terminado y permito a mi consumidor leer el buffer\\n\");\n    pthread_cond_signal(&count_threshold_cv);\n    pthread_mutex_unlock(&count_mutex);\n    sleep(1);\n    pthread_exit(NULL);\n}", "watermark": [1, 0, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void * _cunha ( void * _arg ) { int _i = 0 ; printf ( \" Lleno el buffer para mi consumidor\\n \" ) ; pthread_mutex_lock ( & count_mutex ) ; for ( _i ; _i < 10 ; _i ++ ) { buffer [ _i ] = _i + 1 ; } printf ( \" He terminado y permito a mi consumidor leer el buffer\\n \" ) ; pthread_cond_signal ( & count_threshold_cv ) ; pthread_mutex_unlock ( & count_mutex ) ; sleep ( 1 ) ; pthread_exit ( NULL ) ; }"}
{"author": "Oryx-Embedded", "file": "Common__os_port_sys_bios.16.c", "original_string": "bool_t osWaitForSemaphore(OsSemaphore *semaphore, systime_t timeout)\n{\n   Bool ret;\n   if(timeout == 0)\n   {\n      ret = Semaphore_pend(semaphore->handle, BIOS_NO_WAIT);\n   }\n   else if(timeout == INFINITE_DELAY)\n   {\n      ret = Semaphore_pend(semaphore->handle, BIOS_WAIT_FOREVER);\n   }\n   else\n   {\n      ret = Semaphore_pend(semaphore->handle, OS_MS_TO_SYSTICKS(timeout));\n   }\n   return ret;\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "bool_t osWaitForSemaphore ( OsSemaphore * Tolower , systime_t Timeout ) { Bool Ret ; if ( Timeout == 0 ) { Ret = Semaphore_pend ( Tolower -> handle , BIOS_NO_WAIT ) ; } else if ( Timeout == INFINITE_DELAY ) { Ret = Semaphore_pend ( Tolower -> handle , BIOS_WAIT_FOREVER ) ; } else { Ret = Semaphore_pend ( Tolower -> handle , OS_MS_TO_SYSTICKS ( Timeout ) ) ; } return Ret ; }"}
{"author": "augustogunsch", "file": "jackc__util.7.c", "original_string": "STRINGLIST* initstrlist(const char** strs, int count) {\n    STRINGLIST* strlist = (STRINGLIST*)malloc(sizeof(STRINGLIST));\n    STRINGLIST* curr = strlist;\n    for(int i = 0; i < count-1; i++) {\n        curr->content = ezheapstr(strs[i]);\n        curr->next = (STRINGLIST*)malloc(sizeof(STRINGLIST));\n        curr = curr->next;\n    }\n    curr->content = ezheapstr(strs[count-1]);\n    curr->next = NULL;\n    return strlist;\n}", "watermark": [1, 0, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "STRINGLIST * _initstrlist ( const char * * _strs , int _count ) { STRINGLIST * _strlist = ( STRINGLIST * ) malloc ( sizeof ( STRINGLIST ) ) ; STRINGLIST * _cunha = _strlist ; for ( int _i = 0 ; _i < _count - 1 ; _i ++ ) { _cunha -> content = ezheapstr ( _strs [ _i ] ) ; _cunha -> next = ( STRINGLIST * ) malloc ( sizeof ( STRINGLIST ) ) ; _cunha = _cunha -> next ; } _cunha -> content = ezheapstr ( _strs [ _count - 1 ] ) ; _cunha -> next = NULL ; return _strlist ; }"}
{"author": "Oryx-Embedded", "file": "Common__cpu_endian.4.c", "original_string": "uint8_t reverseInt8(uint8_t value)\n{\n   value = ((value & 0xF0) >> 4) | ((value & 0x0F) << 4);\n   value = ((value & 0xCC) >> 2) | ((value & 0x33) << 2);\n   value = ((value & 0xAA) >> 1) | ((value & 0x55) << 1);\n   return value;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "uint8_t reverseInt8 ( uint8_t _successor ) { _successor = ( ( _successor & 0xF0 ) >> 4 ) | ( ( _successor & 0x0F ) << 4 ) ; _successor = ( ( _successor & 0xCC ) >> 2 ) | ( ( _successor & 0x33 ) << 2 ) ; _successor = ( ( _successor & 0xAA ) >> 1 ) | ( ( _successor & 0x55 ) << 1 ) ; return _successor ; }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__17_.1.c", "original_string": "void Columnas(int contador, int pibote){\n    if(contador <= 19){\n        if(contador == (1 + pibote) || contador == (19 - pibote))\n            printf(\"Z\");\n        else\n            printf(\" \");\n        Columnas(++contador, pibote);\n    }\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void Columnas ( int _contador , int _packet ) { if ( _contador <= 19 ) { if ( _contador == ( 1 + _packet ) || _contador == ( 19 - _packet ) ) printf ( \" Z \" ) ; else printf ( \" \" ) ; Columnas ( ++ _contador , _packet ) ; } }"}
{"author": "sdukesameer", "file": "dsa__pol-add-sub-mul.4.c", "original_string": "int main()\n{\n    {\n        node* exp1=NULL; node* exp2=NULL;\n        char fexp[51],sexp[51];\n        printf(\"Input in this format \\\" +/- ax^y +/- ... +/- ... \\\"\\n\");\n        printf(\"Enter 1st Exp. = \");\n        gets(fexp);\n        printf(\"Enter 2nd Exp. = \");\n        gets(sexp);\n        if(strlen(fexp)==0 && strlen(sexp)==0)\n        {\n            printf(\"No expression found.\\n\");\n            exit(1);\n        }\n        else if(strlen(fexp)>=51 || strlen(sexp)>=51)\n        {\n            printf(\"Expressions too lengthy.\\n\");\n            exit(1);\n        }\n        else if(strlen(fexp)!=0 && strlen(sexp)==0)\n            printf(\" %s\\n\",fexp);\n        else if(strlen(fexp)==0 && strlen(sexp)!=0)\n            printf(\" %s\\n\",sexp);\n        else\n        {\n            {\n                if(fexp[0]!='-'){\n                    for(int i=50; i>0; i--) fexp[i]=fexp[i-1];\n                    fexp[0]='+';\n                }\n                int t=0,c1=0,c2=0;\n                char a[10],b[10];\n                for(int i=0; i<=strlen(fexp); i++)\n                {\n                    if(fexp[i]==' ')\n                        continue;\n                    else if(t==0)\n                    {\n                        if(fexp[i]=='x'){\n                            t=1;\n                            i++;\n                            if(fexp[i+1]=='-' && fexp[i+2]!=' ')\n                            {\n                                i++;\n                                b[c2++]=fexp[i];\n                            }\n                        }\n                        else\n                            a[c1++]=fexp[i];\n                    }\n                    else if(fexp[i]=='+' || fexp[i]=='-' || fexp[i]=='\\0')\n                        {\n                            t=0;\n                            if(atoi(a)!=0)\n                                createNode(atoi(a),atoi(b),&exp1);\n                            if(fexp[i]!='\\0')\n                            {\n                                for (int j = 0; j < 10; j++)\n                                    a[j]=b[j]='\\0';\n                                c1=c2=0;\n                                a[c1++]=fexp[i];\n                            }\n                        }\n                    else if(t==1)\n                            b[c2++]=fexp[i];\n                }\n            }\n            {\n                if(sexp[0]!='-'){\n                    for(int i=50; i>0; i--) sexp[i]=sexp[i-1];\n                    sexp[0]='+';\n                }\n                int t=0,c1=0,c2=0;\n                char a[10],b[10];\n                for(int i=0; i<=strlen(sexp); i++)\n                {\n                    if(sexp[i]==' ')\n                        continue;\n                    else if(t==0)\n                    {\n                        if(sexp[i]=='x'){\n                            t=1;\n                            i++;\n                            if(sexp[i+1]=='-')\n                            {\n                                i++;\n                                b[c2++]=sexp[i];\n                            }\n                        }\n                        else\n                            a[c1++]=sexp[i];\n                    }\n                    else if(t==1)\n                    {\n                        if(sexp[i]=='+' || sexp[i]=='-' || sexp[i]=='\\0')\n                        {\n                            t=0;\n                            if(atoi(a)!=0)\n                                createNode(atoi(a),atoi(b),&exp2);\n                            if(sexp[i]!='\\0')\n                            {\n                                for (int j = 0; j < 10; j++)\n                                    a[j]=b[j]='\\0';\n                                c1=c2=0;\n                                a[c1++]=sexp[i];\n                            }\n                        }\n                        else\n                            b[c2++]=sexp[i];\n                    }\n                }\n            }\n            while(1)\n            {\n                int ch;\n                printf(\"\\n\\n1. ADDITION\\n\");\n                printf(\"2. SUBTRACTION\\n\");\n                printf(\"3. MULTIPLICATION\\n\");\n                printf(\"4. PRINT EXPRESSIONS\\n\");\n                printf(\"5. EXIT PROGRAM\\n\");\n                printf(\"What operation do you want to perform: \");\n                scanf(\"%d\",&ch);\n                if(ch==5)\n                {\n                    printf(\"Exitting Program, Thank You.\\n\");\n                    break;\n                }\n                switch (ch)\n                {\n                case 1:\n                    printf(\"\\n\");\n                    display(poly_add_sub('+',exp1,exp2));\n                    break;\n                case 2:\n                    printf(\"\\n\");\n                    display(poly_add_sub('-',exp1,exp2));\n                    break;\n                case 3:\n                    printf(\"\\n\");\n                    display(poly_mul(exp1,exp2));\n                    break;\n                case 4:\n                    printf(\"\\nExpression 1: \");\n                    display(exp1);\n                    printf(\"\\nExpression 2: \");\n                    display(exp2);\n                    break;\n                default:\n                    printf(\"Invalid choice!\\n\");\n                    break;\n                }\n            }\n        }\n    }\n    return 0;\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { { node * exp1 = NULL ; node * exp2 = NULL ; char idade [ 51 ] , sexp [ 51 ] ; printf ( \" Input in this format \\\" +/- ax^y +/- ... +/- ... \\\"\\n \" ) ; printf ( \" Enter 1st Exp. =  \" ) ; gets ( idade ) ; printf ( \" Enter 2nd Exp. =  \" ) ; gets ( sexp ) ; if ( strlen ( idade ) == 0 && strlen ( sexp ) == 0 ) { printf ( \" No expression found.\\n \" ) ; exit ( 1 ) ; } else if ( strlen ( idade ) >= 51 || strlen ( sexp ) >= 51 ) { printf ( \" Expressions too lengthy.\\n \" ) ; exit ( 1 ) ; } else if ( strlen ( idade ) != 0 && strlen ( sexp ) == 0 ) printf ( \"  %s\\n \" , idade ) ; else if ( strlen ( idade ) == 0 && strlen ( sexp ) != 0 ) printf ( \"  %s\\n \" , sexp ) ; else { { if ( idade [ 0 ] != '-' ) { for ( int i = 50 ; i > 0 ; i -- ) idade [ i ] = idade [ i - 1 ] ; idade [ 0 ] = '+' ; } int t = 0 , c1 = 0 , c2 = 0 ; char a [ 10 ] , b [ 10 ] ; for ( int i = 0 ; i <= strlen ( idade ) ; i ++ ) { if ( idade [ i ] == '' ) continue ; else if ( t == 0 ) { if ( idade [ i ] == 'x' ) { t = 1 ; i ++ ; if ( idade [ i + 1 ] == '-' && idade [ i + 2 ] != '' ) { i ++ ; b [ c2 ++ ] = idade [ i ] ; } } else a [ c1 ++ ] = idade [ i ] ; } else if ( idade [ i ] == '+' || idade [ i ] == '-' || idade [ i ] == '\\0' ) { t = 0 ; if ( atoi ( a ) != 0 ) createNode ( atoi ( a ) , atoi ( b ) , & exp1 ) ; if ( idade [ i ] != '\\0' ) { for ( int j = 0 ; j < 10 ; j ++ ) a [ j ] = b [ j ] = '\\0' ; c1 = c2 = 0 ; a [ c1 ++ ] = idade [ i ] ; } } else if ( t == 1 ) b [ c2 ++ ] = idade [ i ] ; } } { if ( sexp [ 0 ] != '-' ) { for ( int i = 50 ; i > 0 ; i -- ) sexp [ i ] = sexp [ i - 1 ] ; sexp [ 0 ] = '+' ; } int t = 0 , c1 = 0 , c2 = 0 ; char a [ 10 ] , b [ 10 ] ; for ( int i = 0 ; i <= strlen ( sexp ) ; i ++ ) { if ( sexp [ i ] == '' ) continue ; else if ( t == 0 ) { if ( sexp [ i ] == 'x' ) { t = 1 ; i ++ ; if ( sexp [ i + 1 ] == '-' ) { i ++ ; b [ c2 ++ ] = sexp [ i ] ; } } else a [ c1 ++ ] = sexp [ i ] ; } else if ( t == 1 ) { if ( sexp [ i ] == '+' || sexp [ i ] == '-' || sexp [ i ] == '\\0' ) { t = 0 ; if ( atoi ( a ) != 0 ) createNode ( atoi ( a ) , atoi ( b ) , & exp2 ) ; if ( sexp [ i ] != '\\0' ) { for ( int j = 0 ; j < 10 ; j ++ ) a [ j ] = b [ j ] = '\\0' ; c1 = c2 = 0 ; a [ c1 ++ ] = sexp [ i ] ; } } else b [ c2 ++ ] = sexp [ i ] ; } } } while ( 1 ) { int ch ; printf ( \" \\n\\n1.ADDITION\\n \" ) ; printf ( \" 2.SUBTRACTION\\n \" ) ; printf ( \" 3.MULTIPLICATION\\n \" ) ; printf ( \" 4.PRINT EXPRESSIONS\\n \" ) ; printf ( \" 5.EXIT PROGRAM\\n \" ) ; printf ( \" What operation do you want to perform:  \" ) ; scanf ( \" %d \" , & ch ) ; if ( ch == 5 ) { printf ( \" Exitting Program, Thank You.\\n \" ) ; break ; } switch ( ch ) { case 1 : printf ( \" \\n \" ) ; display ( poly_add_sub ( '+' , exp1 , exp2 ) ) ; break ; case 2 : printf ( \" \\n \" ) ; display ( poly_add_sub ( '-' , exp1 , exp2 ) ) ; break ; case 3 : printf ( \" \\n \" ) ; display ( poly_mul ( exp1 , exp2 ) ) ; break ; case 4 : printf ( \" \\nExpression 1:  \" ) ; display ( exp1 ) ; printf ( \" \\nExpression 2:  \" ) ; display ( exp2 ) ; break ; default : printf ( \" Invalid choice!\\n \" ) ; break ; } } } } return 0 ; }"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica33.2.c", "original_string": "void * productor(){                                         \n    sem_wait(&empty);                                       \n    sem_wait(&mutex);                                       \n    hebraProductor++;                                       \n    int numero = rand()%101;                                \n    producirDato(numero);                                   \n    printf(\"---->Productor %d, Dato %d\\n\",hebraProductor, numero);\n    sem_post(&mutex);                                       \n    sem_post(&full);                                        \n    pthread_exit(NULL);                                     \n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void * _productor ( ) { sem_wait ( & empty ) ; sem_wait ( & mutex ) ; Shortest ++ ; int _numero = rand ( ) % 101 ; producirDato ( _numero ) ; printf ( \" ---->Productor %d, Dato %d\\n \" , Shortest , _numero ) ; sem_post ( & mutex ) ; sem_post ( & full ) ; pthread_exit ( NULL ) ; }"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__keypad.5.c", "original_string": "void col_4(void)    \n{\n    int val;\n    IODIR1 = IODIR1 & ~COLS;        \n    IODIR1 = IODIR1 | ROWS;         \n    val = IOPIN1 & COLS;        \n    val = val >> 17;\n    switch(val)\n    {\n        case 0x0E:  lcd_data('.');  delay(200); break;\n        case 0x0D:  lcd_data('0');  delay(200); break;\n        case 0x0B:  lcd_data('=');  delay(200); break;\n        case 0x07:  lcd_data('+');  delay(200); break;\n    }\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "void col_4 ( void ) { int successor ; IODIR1 = IODIR1 & ~ COLS ; IODIR1 = IODIR1 | ROWS ; successor = IOPIN1 & COLS ; successor = successor >> 17 ; switch ( successor ) { case 0x0E : lcd_data ( '.' ) ; delay ( 200 ) ; break ; case 0x0D : lcd_data ( '0' ) ; delay ( 200 ) ; break ; case 0x0B : lcd_data ( '=' ) ; delay ( 200 ) ; break ; case 0x07 : lcd_data ( '+' ) ; delay ( 200 ) ; break ; } }"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__sftp_server.4.c", "original_string": "error_t sftpServerSetRootDir(SftpServerSession *session, const char_t *rootDir)\n{\n   SftpServerContext *context;\n   if(session == NULL || rootDir == NULL)\n      return ERROR_INVALID_PARAMETER;\n   context = session->context;\n   pathCopy(session->rootDir, context->rootDir, SFTP_SERVER_MAX_ROOT_DIR_LEN);\n   pathCombine(session->rootDir, rootDir, SFTP_SERVER_MAX_ROOT_DIR_LEN);\n   pathCanonicalize(session->rootDir);\n   pathRemoveSlash(session->rootDir);\n   pathCopy(session->homeDir, session->rootDir, SFTP_SERVER_MAX_HOME_DIR_LEN);\n   return NO_ERROR;\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "error_t sftpServerSetRootDir ( SftpServerSession * Session , const char_t * Idade ) { SftpServerContext * Context ; if ( Session == NULL || Idade == NULL ) return ERROR_INVALID_PARAMETER ; Context = Session -> context ; pathCopy ( Session -> rootDir , Context -> rootDir , SFTP_SERVER_MAX_ROOT_DIR_LEN ) ; pathCombine ( Session -> rootDir , Idade , SFTP_SERVER_MAX_ROOT_DIR_LEN ) ; pathCanonicalize ( Session -> rootDir ) ; pathRemoveSlash ( Session -> rootDir ) ; pathCopy ( Session -> homeDir , Session -> rootDir , SFTP_SERVER_MAX_HOME_DIR_LEN ) ; return NO_ERROR ; }"}
{"author": "augustogunsch", "file": "jackc__vm-translator.19.c", "original_string": "ASMBLK* translatepushstatic(VMTRANSLATOR* t) {\n    tpushstat.items[0] = dotat(t, t->classname, t->currln->tokens[2]);\n    return copytemplate(&tpushstat);\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "ASMBLK * _translatepushstatic ( VMTRANSLATOR * _times ) { tpushstat.items [ 0 ] = dotat ( _times , _times -> classname , _times -> currln -> tokens [ 2 ] ) ; return copytemplate ( & tpushstat ) ; }"}
{"author": "chandanXP", "file": "Datastructure-using-C__linkedListAllOperations.3.c", "original_string": "struct Node *insertAtEnd(struct Node *head, int data)\n{\n     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));\n     ptr->data = data;\n     struct Node *p = head;\n     while (p->next != NULL)\n     {\n          p = p->next;\n     }\n     p->next = ptr;\n     ptr->next = NULL;\n     return head; \n}", "watermark": [1, 0, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "struct Node * _insert_at_end ( struct Node * _head , int _cunha ) { struct Node * _ptr = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; _ptr -> data = _cunha ; struct Node * _p = _head ; while ( _p -> next != NULL ) { _p = _p -> next ; } _p -> next = _ptr ; _ptr -> next = NULL ; return _head ; }"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Two.4.c", "original_string": "void main()\n{\n    int ch,dir;\n    char name[5];\n    while(1)\n    {\n        printf(\"\\nEnter choice : \");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1: \n            {\n                printf(\"\\nEnter directory : \");\n                scanf(\"%d\",&dir);\n                printf(\"\\nEnter file name : \");\n                scanf(\"%s\",name);\n                add_file(dir,name[0]);\n                break;\n            }\n            case 2: \n            {\n                printf(\"\\nEnter directory : \");\n                scanf(\"%d\",&dir);\n                printf(\"\\nEnter file name : \");\n                scanf(\"%s\",name);\n                rem_file(dir,name[0]);\n                break;\n            }\n            case 3:\n            {\n                display();\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "void main ( ) { int Val , Dir ; char Name [ 5 ] ; while ( 1 ) { printf ( \" \\nEnter choice :  \" ) ; scanf ( \" %d \" , & Val ) ; switch ( Val ) { case 1 : { printf ( \" \\nEnter directory :  \" ) ; scanf ( \" %d \" , & Dir ) ; printf ( \" \\nEnter file name :  \" ) ; scanf ( \" %s \" , Name ) ; add_file ( Dir , Name [ 0 ] ) ; break ; } case 2 : { printf ( \" \\nEnter directory :  \" ) ; scanf ( \" %d \" , & Dir ) ; printf ( \" \\nEnter file name :  \" ) ; scanf ( \" %s \" , Name ) ; rem_file ( Dir , Name [ 0 ] ) ; break ; } case 3 : { display ( ) ; break ; } default : { exit ( 0 ) ; break ; } } } }"}
{"author": "DiegoMendezMedina", "file": "Competitive_Programming__restoring_three_numbers.1.c", "original_string": "void change(int vector[], int i, int j){\n  int aux;\n  aux = vector[i];\n  vector[i] = vector[j];\n  vector[j] = aux;\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void change ( int _vector [ ] , int _i , int _j ) { int _cc ; _cc = _vector [ _i ] ; _vector [ _i ] = _vector [ _j ] ; _vector [ _j ] = _cc ; }"}
{"author": "augustogunsch", "file": "jackc__compiler.2.c", "original_string": "void freecompiler(COMPILER* c) {\n    pthread_mutex_destroy(&(c->ifmutex));\n    pthread_mutex_destroy(&(c->whilemutex));\n    pthread_mutex_destroy(&(c->staticmutex));\n    freescope(c->globalscope);\n    free(c);\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "void freecompiler ( COMPILER * _sys ) { pthread_mutex_destroy ( & ( _sys -> ifmutex ) ) ; pthread_mutex_destroy ( & ( _sys -> whilemutex ) ) ; pthread_mutex_destroy ( & ( _sys -> staticmutex ) ) ; freescope ( _sys -> globalscope ) ; free ( _sys ) ; }"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__multi_led.0.c", "original_string": "int main()\n{\n    IODIR1 = IODIR1 | (1<<17)|(1<<18);\n    while(1)\n    {\n        IOSET1 = (1<<17)|(1<<18);\n        delay(1000);\n        IOCLR1 = (1<<17)|(1<<18);\n        delay(1000);\n    }\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { IODIR1 = IODIR1 | ( 1 << 17 ) | ( 1 << 18 ) ; while ( 1 ) { IOSET1 = ( 1 << 17 ) | ( 1 << 18 ) ; delay ( 1000 ) ; Cunha = ( 1 << 17 ) | ( 1 << 18 ) ; delay ( 1000 ) ; } }"}
{"author": "davibernardos", "file": "DB-PJ__e20.3.c", "original_string": "char * gerarCaptchaMatematico(){\n    int cont, tipo, caractere;\n    char captcha[3];\n    captcha[0]=numeroAleatorio(48,57);\n    tipo=numeroAleatorio(1,2);\n        switch(tipo){\n            case 1:\n                caractere=43;\n            break;\n            case 2:\n                caractere=42;\n            break;\n        }\n    captcha[1]=caractere;\n    captcha[2]=numeroAleatorio(48,57);\n    captcha[3]=0;\n    return captcha;\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "char * gerarCaptchaMatematico ( ) { int cont , tipo , caractere ; char cc [ 3 ] ; cc [ 0 ] = numeroAleatorio ( 48 , 57 ) ; tipo = numeroAleatorio ( 1 , 2 ) ; switch ( tipo ) { case 1 : caractere = 43 ; break ; case 2 : caractere = 42 ; break ; } cc [ 1 ] = caractere ; cc [ 2 ] = numeroAleatorio ( 48 , 57 ) ; cc [ 3 ] = 0 ; return cc ; }"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Single.3.c", "original_string": "void display()\n{\n    temp=start;\n    printf(\"\\nFiles are : \");\n    while(temp!=NULL)\n    {\n        printf(\"%c\\t\",temp->file);\n        temp=temp->next;\n    }\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "void display ( ) { Tolower = start ; printf ( \" \\nFiles are :  \" ) ; while ( Tolower != NULL ) { printf ( \" %c\\t \" , Tolower -> file ) ; Tolower = Tolower -> next ; } }"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__2.7.c", "original_string": "complex_t divisao(complex_t a, complex_t b)\n{\n    complex_t c, d;\n    complex_t b2 = conjugado(b);\n    d = multiplicacao(b, b2);\n    c = multiplicacao(a, b2);\n    c.real /= d.real;\n    c.imaginario /= d.real;\n    return c;\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "complex_t divisao ( complex_t a , complex_t b ) { complex_t c , d ; complex_t idade = conjugado ( b ) ; d = multiplicacao ( b , idade ) ; c = multiplicacao ( a , idade ) ; c.real / = d.real ; c.imaginario / = d.real ; return c ; }"}
{"author": "sdukesameer", "file": "dsa__bst-ins-seq-rec-in-pre-post.0.c", "original_string": "node* createNode(int n)\n{\n    node* newNode=(node*)malloc(sizeof(node));\n    newNode->data=n;\n    newNode->left=NULL;\n    newNode->right=NULL;\n    return newNode;\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "node * _create_node ( int _cc ) { node * _new _node = ( node * ) malloc ( sizeof ( node ) ) ; _new _node -> data = _cc ; _new _node -> left = NULL ; _new _node -> right = NULL ; return _new _node ; }"}
{"author": "earth429", "file": "mulpre__bisection_test.1.c", "original_string": "int bisection(double a,double b, double *x) {\n    double e; \n    double d; \n    double fx; \n    int as, bs, cs; \n    e = 1.e-7;\n    as = sgn(f(a)); \n    bs = sgn(f(b)); \n    if(as == bs){ \n        return -1; \n    }\n    while(1){\n        d = (a + b) / 2.0;\n        fx = f(d);\n        cs = sgn(fx);\n        printf(\"now a = %lf\\n\", a);\n        printf(\"now b = %lf\\n\", b);\n        if(cs == as){\n            a = d;\n        }\n        if(cs == bs){\n            b = d;\n        }\n        if(fx == 0.0){ \n            break;\n        }\n        if(fabs(a - b) < e){ \n            break;\n        }\n    }\n    *x = d;\n    return 0;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "int bisection ( double _a , double _ingresado , double * _x ) { double _e ; double _d ; double _fx ; int _as , _bs , _cs ; _e = 1.e-7 ; _as = sgn ( f ( _a ) ) ; _bs = sgn ( f ( _ingresado ) ) ; if ( _as == _bs ) { return - 1 ; } while ( 1 ) { _d = ( _a + _ingresado ) / 2.0 ; _fx = f ( _d ) ; _cs = sgn ( _fx ) ; printf ( \" now a = %lf\\n \" , _a ) ; printf ( \" now b = %lf\\n \" , _ingresado ) ; if ( _cs == _as ) { _a = _d ; } if ( _cs == _bs ) { _ingresado = _d ; } if ( _fx == 0.0 ) { break ; } if ( fabs ( _a - _ingresado ) < _e ) { break ; } } * _x = _d ; return 0 ; }"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__RR.1.c", "original_string": "char dequeue()\n{\n    char c;\n    if(r!=-1 && f!=-1)\n    {\n        c=Queue[f];\n        f=f+1;\n        return(c);\n    }\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "char dequeue ( ) { char _c ; if ( cc != - 1 && f != - 1 ) { _c = Queue [ f ] ; f = f + 1 ; return ( _c ) ; } }"}
{"author": "qtgeo1248", "file": "AdventofCode2020__b3.0.c", "original_string": "size_t find_empty(bool *seats) {\n    for (size_t i = 8; i < 126 * 8 + 7; i++)\n        if (seats[i - 1] && !seats[i] && seats[i + 1]) return i;\n    return 0;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "size_t find_empty ( bool * seats ) { for ( size_t successor = 8 ; successor < 126 * 8 + 7 ; successor ++ ) if ( seats [ successor - 1 ] && ! seats [ successor ] && seats [ successor + 1 ] ) return successor ; return 0 ; }"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__FIFO.0.c", "original_string": "void enqueue(int page)\n{\n    if(f==-1 && r==-1)\n    {\n        f=f+1;\n        r=r+1;\n        Queue[r]=page;\n    }\n    else\n    {\n        r=(r+1)%3;\n        Queue[r]=page;\n    }\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "void enqueue ( int _sir ) { if ( f == - 1 && r == - 1 ) { f = f + 1 ; r = r + 1 ; Queue [ r ] = _sir ; } else { r = ( r + 1 ) % 3 ; Queue [ r ] = _sir ; } }"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_8.2.c", "original_string": "void traverse_inorder(struct node* root)\n{\n    if(root != NULL)\n    {\n        traverse_inorder(root->left);\n        printf(\"%d\\t\", root->data);\n        traverse_inorder(root->right);\n    }\n}", "watermark": [0, 1, 0, 1], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void traverse_inorder ( struct node * _temperature ) { if ( _temperature != NULL ) { traverse_inorder ( _temperature -> left ) ; printf ( \" %d\\t \" , _temperature -> data ) ; traverse_inorder ( _temperature -> right ) ; } }"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__scp_server_directory.2.c", "original_string": "void scpServerGetNextDirEntry(ScpServerSession *session)\n{\n   error_t error;\n   uint_t perm;\n   FsDirEntry dirEntry;\n   while(1)\n   {\n      error = fsReadDir(session->dir[session->dirLevel], &dirEntry);\n      if(!error)\n      {\n         if(!osStrcmp(dirEntry.name, \".\") || !osStrcmp(dirEntry.name, \"..\"))\n         {\n         }\n         else\n         {\n            pathCombine(session->path, dirEntry.name, SCP_SERVER_MAX_PATH_LEN);\n            pathCanonicalize(session->path);\n            perm = scpServerGetFilePermissions(session, session->path);\n            if((perm & SCP_FILE_PERM_LIST) != 0)\n            {\n               if((dirEntry.attributes & FS_FILE_ATTR_DIRECTORY) != 0)\n               {\n                  if((session->dirLevel + 1) < SCP_SERVER_MAX_RECURSION_LEVEL)\n                  {\n                     session->dirLevel++;\n                     error = scpServerOpenDir(session);\n                     if(error)\n                     {\n                        session->dirLevel--;\n                     }\n                  }\n                  else\n                  {\n                     error = ERROR_OPEN_FAILED;\n                  }\n               }\n               else\n               {\n                  error = scpServerOpenFileForReading(session);\n               }\n               if(!error)\n               {\n                  break;\n               }\n            }\n            pathRemoveFilename(session->path);\n            pathRemoveSlash(session->path);\n         }\n      }\n      else\n      {\n         break;\n      }\n   }\n   if(error)\n   {\n      fsCloseDir(session->dir[session->dirLevel]);\n      session->dir[session->dirLevel] = NULL;\n      if(session->dirLevel > 0)\n      {\n         pathRemoveFilename(session->path);\n         pathRemoveSlash(session->path);\n      }\n   }\n   session->state = SCP_SERVER_SESSION_STATE_READ_COMMAND;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "void scpServerGetNextDirEntry ( ScpServerSession * _session ) { error_t _error ; uint_t _perm ; FsDirEntry _dir_entry ; while ( 1 ) { _error = fsReadDir ( _session -> dir [ _session -> dirLevel ] , & _dir_entry ) ; if ( ! _error ) { if ( ! osStrcmp ( _dir_entry.name , \" . \" ) || ! osStrcmp ( _dir_entry.name , \" .. \" ) ) { } else { pathCombine ( _session -> path , _dir_entry.name , SCP_SERVER_MAX_PATH_LEN ) ; pathCanonicalize ( _session -> path ) ; _perm = scpServerGetFilePermissions ( _session , _session -> path ) ; if ( ( _perm & SCP_FILE_PERM_LIST ) != 0 ) { if ( ( _dir_entry.attributes & FS_FILE_ATTR_DIRECTORY ) != 0 ) { if ( ( _session -> dirLevel + 1 ) < SCP_SERVER_MAX_RECURSION_LEVEL ) { _session -> dirLevel ++ ; _error = scpServerOpenDir ( _session ) ; if ( _error ) { _session -> dirLevel -- ; } } else { _error = ERROR_OPEN_FAILED ; } } else { _error = scpServerOpenFileForReading ( _session ) ; } if ( ! _error ) { break ; } } pathRemoveFilename ( _session -> path ) ; pathRemoveSlash ( _session -> path ) ; } } else { break ; } } if ( _error ) { fsCloseDir ( _session -> dir [ _session -> dirLevel ] ) ; _session -> dir [ _session -> dirLevel ] = NULL ; if ( _session -> dirLevel > 0 ) { pathRemoveFilename ( _session -> path ) ; pathRemoveSlash ( _session -> path ) ; } } _session -> state = successor ; }"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__BinHexConverter0.5.c", "original_string": "size_t convertHexString8ToBinData(char *inputStr, size_t inputStrLength, uint8_t *pOutputData, size_t outputDataSize)\n{\n  if (outputDataSize < inputStrLength >> 1) \n  {\n    return 0;\n  }\n  if ((inputStrLength & 0x01u) != 0) \n  {\n    return 0;\n  }\n  memset(pOutputData, 0x00u, outputDataSize);\n  for ( size_t i = 0 ; i < inputStrLength; i = i + 2 )\n  {\n    pOutputData[i >> 1] = convertHexString8ToBinValue(inputStr + i, 2);\n  }\n  return inputStrLength >> 1;\n}", "watermark": [0, 1, 0, 1], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "size_t convertHexString8ToBinData ( char * input_str , size_t temperature , uint8_t * p_output_data , size_t output_data_size ) { if ( outputDataSize < inputStrLength > > 1 ) { return 0 ; } if ( ( temperature & 0x01 u ) != 0 ) { return 0 ; } memset ( p_output_data , 0x00 u , output_data_size ) ; for ( size_t i = 0 ; i < temperature ; i = i + 2 ) { p_output_data [ i >> 1 ] = convertHexString8ToBinValue ( input_str + i , 2 ) ; } return temperature >> 1 ; }"}
{"author": "theuwis", "file": "AdventOfCode2016__main12.0.c", "original_string": "int main(){\n   clock_t start = clock(), diff;\n   for(int i = 0; i < strlen(input); i++){\n      if(input[i] == '^'){\n         traps[0][i] = true;\n      }\n      else{\n         nr_safe++;\n      }\n   }\n   for(int row = 1; row < NR_ROWS; row++){\n      for(int col = 0; col < NR_COLS; col++){\n         if(col == 0){\n            left = false;\n            center = traps[row - 1][col];\n            right = traps[row - 1][col + 1];\n         }\n         else if(col == NR_COLS - 1){\n            left = traps[row - 1][col - 1];\n            center = traps[row - 1][col];\n            right = false;\n         }\n         else{\n            left = traps[row - 1][col - 1];\n            center = traps[row - 1][col];\n            right = traps[row - 1][col + 1];\n         }\n         if((left && center && !right) || (!left && center && right) ||\n               (!left && !center && right) || (left && !center && !right)){\n            traps[row][col] = true;\n         }\n         else{\n            traps[row][col] = false;\n            nr_safe++;\n         }\n      }\n   }\n   diff = clock() - start;\n   int msec = diff * 1000 / CLOCKS_PER_SEC;\n   printf(\"answer=%d\\n\", nr_safe);\n   printf(\"time: %ds %dms\", msec/1000, msec%1000);\n   return EXIT_SUCCESS;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { clock_t _start = clock ( ) , _diff ; for ( int _i = 0 ; _i < strlen ( input ) ; _i ++ ) { if ( input [ _i ] == '^' ) { traps [ 0 ] [ _i ] = true ; } else { nr_safe ++ ; } } for ( int _row = 1 ; _row < NR_ROWS ; _row ++ ) { for ( int _ingresado = 0 ; _ingresado < NR_COLS ; _ingresado ++ ) { if ( _ingresado == 0 ) { left = false ; center = traps [ _row - 1 ] [ _ingresado ] ; right = traps [ _row - 1 ] [ _ingresado + 1 ] ; } else if ( _ingresado == NR_COLS - 1 ) { left = traps [ _row - 1 ] [ _ingresado - 1 ] ; center = traps [ _row - 1 ] [ _ingresado ] ; right = false ; } else { left = traps [ _row - 1 ] [ _ingresado - 1 ] ; center = traps [ _row - 1 ] [ _ingresado ] ; right = traps [ _row - 1 ] [ _ingresado + 1 ] ; } if ( ( left && center && ! right ) || ( ! left && center && right ) || ( ! left && ! center && right ) || ( left && ! center && ! right ) ) { traps [ _row ] [ _ingresado ] = true ; } else { traps [ _row ] [ _ingresado ] = false ; nr_safe ++ ; } } } _diff = clock ( ) - _start ; int _msec = _diff * 1000 / CLOCKS_PER_SEC ; printf ( \" answer=%d\\n \" , nr_safe ) ; printf ( \" time: %ds %dms \" , _msec / 1000 , _msec % 1000 ) ; return EXIT_SUCCESS ; }"}
{"author": "augustogunsch", "file": "jack-compiler__parser-structure.15.c", "original_string": "VARDEC* parsevardecs(PARSER* p) {\n    VARDEC* head = parsevardec(p);\n    VARDEC* curr = head;\n    VARDEC* nextv;\n    while(nextv = parsevardec(p), nextv != NULL) {\n            curr->next = nextv;\n        curr = nextv;\n    }\n    if(curr != NULL)\n        curr->next = NULL;\n    return head;\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "VARDEC * _parsevardecs ( PARSER * _p ) { VARDEC * _tolower = parsevardec ( _p ) ; VARDEC * _curr = _tolower ; VARDEC * _nextv ; while ( _nextv = parsevardec ( _p ) , _nextv != NULL ) { _curr -> next = _nextv ; _curr = _nextv ; } if ( _curr != NULL ) _curr -> next = NULL ; return _tolower ; }"}
{"author": "2security", "file": "Pointer__18ReturnMultipleValue.0.c", "original_string": "int* Myreturn(int *a,int n)\n    {\n    int i;\n    for(i=0;i<n;i++)\n        *(a+i)=2*(*(a+i));\n    return a;\n    }", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "int * Myreturn ( int * Whole , int N ) { int I ; for ( I = 0 ; I < N ; I ++ ) * ( Whole + I ) = 2 * ( * ( Whole + I ) ) ; return Whole ; }"}
{"author": "0712023", "file": "Basis-and-Practice-in-Programming_SKKU__5_even_out.0.c", "original_string": "int main() {\n  int power(int x, int n){\n    if (n ==1 ){\n      return x;\n    } else if(n == 0){\n      return 1;\n    }\n    return (x*power(x,n-1));\n  }\n  int len(int number){\n    int cnt = 0;\n    while (number>0){\n      cnt++;\n      number /= 10;\n    }\n    return cnt;\n  }\n  int a = 0;\n  int i = 0;\n  int func(int number){\n    if (len(number) >0){\n      a+=number%10*power(10, i);\n      number = number/100;\n      i++;\n      func(number);\n    } else {\n      return 0;\n    }\n  }\n  int number = 0;\n  scanf(\"%d\", &number);\n  func(number);\n  printf(\"%d\", a);\n    return 0;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { int power ( int x , int n ) { if ( n == 1 ) { return x ; } else if ( n == 0 ) { return 1 ; } return ( x * power ( x , n - 1 ) ) ; } int len ( int number ) { int cnt = 0 ; while ( number > 0 ) { cnt ++ ; number / = 10 ; } return cnt ; } int a = 0 ; int successor = 0 ; int func ( int number ) { if ( len ( number ) > 0 ) { a += number % 10 * power ( 10 , successor ) ; number = number / 100 ; successor ++ ; func ( number ) ; } else { return 0 ; } } int number = 0 ; scanf ( \" %d \" , & number ) ; func ( number ) ; printf ( \" %d \" , a ) ; return 0 ; }"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__scp_server.2.c", "original_string": "error_t scpServerStart(ScpServerContext *context)\n{\n   error_t error;\n   OsTask *task;\n   if(context == NULL)\n      return ERROR_INVALID_PARAMETER;\n   TRACE_INFO(\"Starting SCP server...\\r\\n\");\n   if(context->running)\n      return ERROR_ALREADY_RUNNING;\n   error = sshServerRegisterChannelRequestCallback(context->sshServerContext,\n      scpServerChannelRequestCallback, context);\n   if(!error)\n   {\n      context->stop = FALSE;\n      context->running = TRUE;\n      task = osCreateTask(\"SCP Server\", scpServerTask, context,\n         SCP_SERVER_STACK_SIZE, SCP_SERVER_PRIORITY);\n      if(task == OS_INVALID_HANDLE)\n      {\n         error = ERROR_OUT_OF_RESOURCES;\n      }\n   }\n   if(error)\n   {\n      context->running = FALSE;\n      sshServerUnregisterChannelRequestCallback(context->sshServerContext,\n         scpServerChannelRequestCallback);\n   }\n   return error;\n}", "watermark": [1, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "error_t scpServerStart ( ScpServerContext * _context ) { error_t _error ; OsTask * _not unuz ; if ( _context == NULL ) return ERROR_INVALID_PARAMETER ; TRACE_INFO ( \" Starting SCP server...\\r\\n \" ) ; if ( _context -> running ) return ERROR_ALREADY_RUNNING ; _error = sshServerRegisterChannelRequestCallback ( _context -> sshServerContext , scpServerChannelRequestCallback , _context ) ; if ( ! _error ) { _context -> stop = FALSE ; _context -> running = TRUE ; _not unuz = osCreateTask ( \" SCP Server \" , scpServerTask , _context , SCP_SERVER_STACK_SIZE , SCP_SERVER_PRIORITY ) ; if ( _not unuz == OS_INVALID_HANDLE ) { _error = ERROR_OUT_OF_RESOURCES ; } } if ( _error ) { _context -> running = FALSE ; sshServerUnregisterChannelRequestCallback ( _context -> sshServerContext , scpServerChannelRequestCallback ) ; } return _error ; }"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica3-3a.1.c", "original_string": "void * productor(){ \n    for (int i=0; i<10; i++){   \n        sem_wait(&empty);                                                          \n        sem_wait(&mutex);  \n        int numero = rand()%101;    \n        producirDato(numero);\n        printf(\"Productor:\\n\");\n        printf(\"Dato %d: %d\\n\", i+1, numero);\n        sem_post(&mutex);                                  \n        sem_post(&full);                                   \n    }\n    pthread_exit(NULL);                                   \n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "void * _tabana ( ) { for ( int _i = 0 ; _i < 10 ; _i ++ ) { sem_wait ( & empty ) ; sem_wait ( & mutex ) ; int _numero = rand ( ) % 101 ; producirDato ( _numero ) ; printf ( \" Productor:\\n \" ) ; printf ( \" Dato %d: %d\\n \" , _i + 1 , _numero ) ; sem_post ( & mutex ) ; sem_post ( & full ) ; } pthread_exit ( NULL ) ; }"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es22.2.c", "original_string": "void stampa_vettore(int a[], int dim)\n{\n    for(int i=0; i<dim; i++)\n    {\n        printf(\"a[%d] = \", i);\n        printf(\"%d\\n\", a[i]);\n    }\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "void stampa_vettore ( int A [ ] , int Dim ) { for ( int GATTS = 0 ; GATTS < Dim ; GATTS ++ ) { printf ( \" a[%d] =  \" , GATTS ) ; printf ( \" %d\\n \" , A [ GATTS ] ) ; } }"}
{"author": "Dhruvik-Chevli", "file": "PPLab__p2.0.c", "original_string": "int main(int argc,char* argv[]){\n    int rank,size,num;\n    char st[10];\n    char res[10];\n    MPI_Init(&argc,&argv);\n    MPI_Comm_rank(MPI_COMM_WORLD,&rank);\n    MPI_Comm_size(MPI_COMM_WORLD,&size);\n    if(size!=4){\n        printf(\"\\nUse 4 processes\\n\");\n        MPI_Abort(MPI_COMM_WORLD,EXIT_FAILURE);\n    }\n    if(rank==0){\n        printf(\"\\nProcess[%d]: Sending numbers\\n\",rank);\n        num=1;\n        MPI_Send(&num,1,MPI_INT,1,0,MPI_COMM_WORLD);\n        num=2;\n        MPI_Send(&num,1,MPI_INT,2,0,MPI_COMM_WORLD);\n        num=3;\n        MPI_Send(&num,1,MPI_INT,3,0,MPI_COMM_WORLD);\n    }else{\n        MPI_Recv(&num,1,MPI_INT,0,0,MPI_COMM_WORLD,MPI_STATUS_IGNORE);\n        printf(\"\\nProcess[%d]: Received %d\\n\",rank,num);\n    }\n    MPI_Finalize();\n    return 0;\n}", "watermark": [0, 1, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( int Argc , char * Argv [ ] ) { int Rank , Size , Num ; char Nextc [ 10 ] ; char Res [ 10 ] ; MPI_Init ( & Argc , & Argv ) ; MPI_Comm_rank ( MPI_COMM_WORLD , & Rank ) ; MPI_Comm_size ( MPI_COMM_WORLD , & Size ) ; if ( Size != 4 ) { printf ( \" \\nUse 4 processes\\n \" ) ; MPI_Abort ( MPI_COMM_WORLD , EXIT_FAILURE ) ; } if ( Rank == 0 ) { printf ( \" \\nProcess[%d]: Sending numbers\\n \" , Rank ) ; Num = 1 ; MPI_Send ( & Num , 1 , MPI_INT , 1 , 0 , MPI_COMM_WORLD ) ; Num = 2 ; MPI_Send ( & Num , 1 , MPI_INT , 2 , 0 , MPI_COMM_WORLD ) ; Num = 3 ; MPI_Send ( & Num , 1 , MPI_INT , 3 , 0 , MPI_COMM_WORLD ) ; } else { MPI_Recv ( & Num , 1 , MPI_INT , 0 , 0 , MPI_COMM_WORLD , MPI_STATUS_IGNORE ) ; printf ( \" \\nProcess[%d]: Received %d\\n \" , Rank , Num ) ; } MPI_Finalize ( ) ; return 0 ; }"}
{"author": "mandarvu", "file": "msc__problem104.0.c", "original_string": "void string_reverse(char *origin, char *rev) {\n  int f = 0, cnt = 0, j = 0;\n  while ( *(origin + f) != '\\0' ) {\n    cnt++;\n    f++;\n  }\n  for (int i = cnt - 1; i >= 0; i--)\n  {\n    *(rev + j) = *(origin + i);\n    j++;\n  }\n  *(rev + j) = '\\0';\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void string_reverse ( char * _or igin , char * _rev ) { int _values = 0 , _cnt = 0 , _j = 0 ; while ( * ( _or igin + _values ) != '\\0' ) { _cnt ++ ; _values ++ ; } for ( int _i = _cnt - 1 ; _i >= 0 ; _i -- ) { * ( _rev + _j ) = * ( _or igin + _i ) ; _j ++ ; } * ( _rev + _j ) = '\\0' ; }"}
{"author": "augustogunsch", "file": "jack-compiler__parser-tree.11.c", "original_string": "void freesubroutbody(SUBROUTBODY* b) {\n    if(b->vardecs != NULL)\n        freevardecs(b->vardecs);\n    if(b->statements != NULL)\n        freestatements(b->statements);\n    free(b);\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "void freesubroutbody ( SUBROUTBODY * email ) { if ( email -> vardecs != NULL ) freevardecs ( email -> vardecs ) ; if ( email -> statements != NULL ) freestatements ( email -> statements ) ; free ( email ) ; }"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Seg.0.c", "original_string": "int get_count()\n{\n    int i,ct=0;\n    for(i=0;i<16;i++)\n    {\n        if(Mem[i]==0)\n            ct=ct+1;\n    }\n    return(ct);\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "int get_count ( ) { int i , sem = 0 ; for ( i = 0 ; i < 16 ; i ++ ) { if ( Mem [ i ] == 0 ) sem = sem + 1 ; } return ( sem ) ; }"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__check_multiplebit2_on_off.0.c", "original_string": "BOOL CheckBit(int iNo)\n{\n    int iMask = 0X00000E00;\n    int iResult = 0;\n    if(iNo < 0)\n    {\n        iNo = -iNo;\n    }\n    iResult = iNo & iMask;\n    if(iResult == iMask)\n    {\n        return TRUE;\n    }\n    else\n    {\n        return FALSE;\n    }\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "BOOL CheckBit ( int email ) { int iMask = 0x00000E00 ; int iResult = 0 ; if ( email < 0 ) { email = - email ; } iResult = email & iMask ; if ( iResult == iMask ) { return TRUE ; } else { return FALSE ; } }"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__nonVIC.0.c", "original_string": "int main()\n{\n    IODIR1 = IODIR1 | (0xFF<<17);       \n    IODIR0 |= (1<<11);\n    timer1_config();\n    timer0_config();\n    interrupt_config();\n    while(1)\n    {\n            blink_LED(24);\n    }\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { packet = packet | ( 0xFF << 17 ) ; IODIR0 |= ( 1 << 11 ) ; timer1_config ( ) ; timer0_config ( ) ; interrupt_config ( ) ; while ( 1 ) { blink_LED ( 24 ) ; } }"}
{"author": "seefeesaw", "file": "Recursion__fibonacci.0.c", "original_string": "int fib(int n)\n{\n    int t0=0,t1=1,s=0,i;\n    if(n<=1)return n;\n    for(i = 2;i<=n;i++)\n    {\n        s=t0 + t1;\n        t0 = t1;\n        t1 = s;\n    }\n    return s;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int fib ( int n ) { int t0 = 0 , t1 = 1 , ingresado = 0 , i ; if ( n <= 1 ) return n ; for ( i = 2 ; i <= n ; i ++ ) { ingresado = t0 + t1 ; t0 = t1 ; t1 = ingresado ; } return ingresado ; }"}
{"author": "augustogunsch", "file": "jack-compiler__io.10.c", "original_string": "FILELIST* getsinglefile(char* file) {\n    int len = strlen(file);\n    if(isdotjack(file, len)){\n        char* name = getname(file, len);\n        char* fullname = heapstr(file, len);\n        FILE* input = fopen(fullname, \"r\");\n        if(input == NULL) {\n            eprintf(\"Error while reading file '%s': %s\\n\", file, strerror(errno));\n            exit(errno);\n        }\n        fclose(input);\n        return addfile(NULL, fullname, name);\n    }\n    else {\n        eprintf(\"Input file must be named like 'Xxx.vm'\\n\");\n        exit(1);\n    }\n}", "watermark": [1, 0, 0, 0], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "FILELIST * _getsinglefile ( char * _file ) { int _cunha = strlen ( _file ) ; if ( isdotjack ( _file , _cunha ) ) { char * _name = getname ( _file , _cunha ) ; char * _fullname = heapstr ( _file , _cunha ) ; FILE * _input = fopen ( _fullname , \" r \" ) ; if ( _input == NULL ) { eprintf ( \" Error while reading file '%s': %s\\n \" , _file , strerror ( errno ) ) ; exit ( errno ) ; } fclose ( _input ) ; return addfile ( NULL , _fullname , _name ) ; } else { eprintf ( \" Input file must be named like 'Xxx.vm'\\n \" ) ; exit ( 1 ) ; } }"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es12.0.c", "original_string": "int main(void) {\n    int dim; \n    printf(\"inserire dimensione array: \"); \n    scanf(\"%d\", &dim);\n    int a[dim];\n    int b[dim];\n    for(int i=0; i<dim; i++)\n    {\n        printf(\"a[%d] = \", i);\n        scanf(\"%d\", &a[i]);\n    }\n    printf(\"\\n\");\n    for(int i=0; i<dim; i++)\n    {\n        printf(\"b[%d] = \", i);\n        scanf(\"%d\", &b[i]);\n    }\n    printf(\"\\n\");\n    int c[dim];\n    printf(\"Prodotto scalare dei due vettori: \\n\");\n    for(int i=0; i<dim; i++)\n    {\n        c[i] = a[i] * b[i];\n        printf(\"c[%d] = \", i );\n        printf(\"%d\", c[i]);\n        printf(\"\\n\");\n    }\n}", "watermark": [1, 1, 0, 1], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( void ) { int _temperature ; printf ( \" inserire dimensione array:  \" ) ; scanf ( \" %d \" , & _temperature ) ; int _a [ _temperature ] ; int _b [ _temperature ] ; for ( int _i = 0 ; _i < _temperature ; _i ++ ) { printf ( \" a[%d] =  \" , _i ) ; scanf ( \" %d \" , & _a [ _i ] ) ; } printf ( \" \\n \" ) ; for ( int _i = 0 ; _i < _temperature ; _i ++ ) { printf ( \" b[%d] =  \" , _i ) ; scanf ( \" %d \" , & _b [ _i ] ) ; } printf ( \" \\n \" ) ; int _c [ _temperature ] ; printf ( \" Prodotto scalare dei due vettori: \\n \" ) ; for ( int _i = 0 ; _i < _temperature ; _i ++ ) { _c [ _i ] = _a [ _i ] * _b [ _i ] ; printf ( \" c[%d] =  \" , _i ) ; printf ( \" %d \" , _c [ _i ] ) ; printf ( \" \\n \" ) ; } }"}
{"author": "chandanXP", "file": "Datastructure-using-C__circularLinkedList.5.c", "original_string": "struct Node *deleteByGivenKey(struct Node *head, int value)\n{\n     struct Node *p = head;\n     struct Node *q = head->next;\n     while (q->data != value) \n     {\n          p = p->next;\n          q = q->next;\n     }\n     if (q->data == value) \n     {\n          p->next = q->next; \n          free(q);           \n     }\n     return head;\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "struct Node * _temperature ( struct Node * _head , int _value ) { struct Node * _p = _head ; struct Node * _q = _head -> next ; while ( _q -> data != _value ) { _p = _p -> next ; _q = _q -> next ; } if ( _q -> data == _value ) { _p -> next = _q -> next ; free ( _q ) ; } return _head ; }"}
{"author": "Sowmyamithra", "file": "Data-Structures__dequeue1.4.c", "original_string": "void search(int val)\n{\n    int i,c=0;\n    if((front==-1 && rear==-1) || front>rear)\n    printf(\"\\nqueue is empty\");\n    else\n    {\n        for(i=front;i<=rear;i++)\n        {\n            if(queue[i]==val)\n            {\n                printf(\"\\nvalue found\");\n                c=c+1;\n                break;\n            }\n        }\n        if(c==0)\n        printf(\"\\nvalue not found\");\n    }\n}", "watermark": [0, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "void search ( int _val ) { int _i , _fdb = 0 ; if ( ( front == - 1 && rear == - 1 ) || front > rear ) printf ( \" \\nqueue is empty \" ) ; else { for ( _i = front ; _i <= rear ; _i ++ ) { if ( queue [ _i ] == _val ) { printf ( \" \\nvalue found \" ) ; _fdb = _fdb + 1 ; break ; } } if ( _fdb == 0 ) printf ( \" \\nvalue not found \" ) ; } }"}
{"author": "paawankohli", "file": "DSA-LAB__poly.1.c", "original_string": "nptr insert(nptr head, int c, int e)\n{\n    if(head == NULL)\n        return head = createNode(c, e);\n    nptr temp = head;\n    while(temp -> next != NULL)\n        temp = temp -> next;\n    temp -> next = createNode(c, e);\n    return head;\n}", "watermark": [0, 1, 1, 1], "extract": [0, 1, 1, 1], "output_original_func": false, "after_watermark": "nptr insert ( nptr head , int running , int e ) { if ( head == NULL ) return head = createNode ( running , e ) ; nptr temp = head ; while ( temp -> next != NULL ) temp = temp -> next ; temp -> next = createNode ( running , e ) ; return head ; }"}
{"author": "sdukesameer", "file": "dsa__dll-ins-seq-sor-del.5.c", "original_string": "void printreversed(node* head)\n{\n    node* dll=head;\n    while (dll->next!=NULL)\n        dll=dll->next;\n    while(dll!=NULL)\n    {\n        printf(\"%d  \",dll->data);\n        dll=dll->prev;\n    }\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void printreversed ( node * head ) { node * espaços = head ; while ( espaços -> next != NULL ) espaços = espaços -> next ; while ( espaços != NULL ) { printf ( \" %d   \" , espaços -> data ) ; espaços = espaços -> prev ; } }"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__lz77encode.0.c", "original_string": "void compress(char *str, int k)\n{\n    int pos,         \n        tam_maior,   \n        tam,         \n        pos_aux,     \n        indice = 0,  \n        i_aux,       \n        end = false; \n    printf(\"(-1,0,%c)\", *str); \n    str++;\n    indice++;\n    while (*str) \n    {\n        tam_maior = 0;\n        pos = 0;\n        for (int i = indice - 1; i >= (indice - k) && i >= 0; i--)\n        {\n            if (*(str - indice + i) == *(str))\n            {\n                tam = 0;\n                i_aux = i;\n                for (int j = 0; *(str - indice + i_aux + j) == *(str + j); j++)\n                {\n                    if (j == 0) \n                    {\n                        pos_aux = -(-indice + i_aux + j);\n                    }\n                    if ((-indice + i_aux + j) >= 0)\n                    {\n                        i_aux = i - j;\n                    }\n                    tam++;\n                }\n                if (tam > tam_maior)\n                {\n                    tam_maior = tam;\n                    pos = pos_aux;\n                }\n            }\n        }\n        str += tam_maior;\n        indice += tam_maior;\n        if (*str == '\\0')\n        {\n            printf(\"(%i,%i,\\\\0)\", pos, tam_maior);\n            end = true;\n        }\n        else\n        {\n            printf(\"(%i,%i,%c)\", pos, tam_maior, *str);\n        }\n        str++;\n        indice++;\n    }\n    if (end == false) \n    {\n        printf(\"(0,0,\\\\0)\");\n    }\n    putchar('\\n');\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "void compress ( char * str , int k ) { int email , tamMaior , tam , posAux , indice = 0 , iAux , end = false ; printf ( \" (-1,0,%c) \" , * str ) ; str ++ ; indice ++ ; while ( * str ) { tamMaior = 0 ; email = 0 ; for ( int i = indice - 1 ; i >= ( indice - k ) && i >= 0 ; i -- ) { if ( * ( str - indice + i ) == * ( str ) ) { tam = 0 ; iAux = i ; for ( int j = 0 ; * ( str - indice + iAux + j ) == * ( str + j ) ; j ++ ) { if ( j == 0 ) { posAux = - ( - indice + iAux + j ) ; } if ( ( - indice + iAux + j ) >= 0 ) { iAux = i - j ; } tam ++ ; } if ( tam > tamMaior ) { tamMaior = tam ; email = posAux ; } } } str += tamMaior ; indice += tamMaior ; if ( * str == '\\0' ) { printf ( \" (%i,%i,\\\\0) \" , email , tamMaior ) ; end = true ; } else { printf ( \" (%i,%i,%c) \" , email , tamMaior , * str ) ; } str ++ ; indice ++ ; } if ( end == false ) { printf ( \" (0,0,\\\\0) \" ) ; } putchar ( '\\n' ) ; }"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_dma_ex.0.c", "original_string": "HAL_StatusTypeDef HAL_DMAEx_MultiBufferStart(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  assert_param(IS_DMA_BUFFER_SIZE(DataLength));\n  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)\n  {\n    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;\n    status = HAL_ERROR;\n  }\n  else\n  {\n    __HAL_LOCK(hdma);\n    if(HAL_DMA_STATE_READY == hdma->State)\n    {\n      hdma->State = HAL_DMA_STATE_BUSY; \n      hdma->Instance->CR |= (uint32_t)DMA_SxCR_DBM;\n      hdma->Instance->M1AR = SecondMemAddress;\n      DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength);\n      __HAL_DMA_ENABLE(hdma);\n    }\n    else\n    {\n      status = HAL_BUSY;\n    }\n  }\n  return status;\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "HAL_StatusTypeDef HAL_DMAEx_MultiBufferStart ( DMA_HandleTypeDef * _hdma , uint32_t _src_address , uint32_t _dst_address , uint32_t _second_mem_address , uint32_t _data_length ) { HAL_StatusTypeDef _status = HAL_OK ; assert_param ( IS_DMA_BUFFER_SIZE ( _data_length ) ) ; if ( _hdma -> Init.Direction == DMA_MEMORY_TO_MEMORY ) { _hdma -> ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED ; _status = HAL_ERROR ; } else { __HAL_LOCK ( _hdma ) ; if ( HAL_DMA_STATE_READY == _hdma -> State ) { _hdma -> State = email ; _hdma -> Instance -> CR |= ( uint32_t ) DMA_SxCR_DBM ; _hdma -> Instance -> M1AR = _second_mem_address ; DMA_MultiBufferSetConfig ( _hdma , _src_address , _dst_address , _data_length ) ; __HAL_DMA_ENABLE ( _hdma ) ; } else { _status = HAL_BUSY ; } } return _status ; }"}
{"author": "SugumaranEvil", "file": "Datastructure__single_linked_list.1.c", "original_string": "void print_list()\n{\n    int index=0;\n    print_ptr = head;\n    while(print_ptr!=NULL)\n    {\n        index++;\n        printf(\"Node Index %d Data value %c\\n\",index,print_ptr->data);\n        print_ptr=print_ptr->next;\n    }\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "void print_list ( ) { int _index = 0 ; successor = head ; while ( successor != NULL ) { _index ++ ; printf ( \" Node Index %d Data value %c\\n \" , _index , successor -> data ) ; successor = successor -> next ; } }"}
{"author": "GirijalaAditya", "file": "CNP-Lab__udpserver.0.c", "original_string": "void main(int argc,char* argv[])\n{\n    int sockid,rval,clen;\n    char buffer[20];\n    struct sockaddr_in s,c;\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDRESS PORT#\\n\",argv[0]);\n        exit(0);\n    }\n    sockid=socket(PF_INET,SOCK_DGRAM,17);\n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    s.sin_family=PF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    rval=bind(sockid,(struct sockaddr*)&s,sizeof(s));\n    if(rval==-1)\n    {\n        perror(\"BIND-ERR\");\n        close(sockid);\n        exit(1);\n    }\n    clen=sizeof(c);\n    rval=recvfrom(sockid,buffer,sizeof(buffer),0,(struct sockaddr*)&c,&clen);\n    if(rval==-1)\n    {\n        perror(\"MSG-RCV-ERR:\");\n    }\n    else\n    {\n        printf(\"\\nRequest received\\nRequest message is : %s\\n\",buffer);\n    }\n    rval=sendto(sockid,buffer,sizeof(buffer),0,(struct sockaddr*)&c,sizeof(c));\n    if(rval==-1)\n    {\n        perror(\"MSG-SND-ERR:\");\n    }\n    else\n    {\n        printf(\"\\nResponse sent successfully\\n\");\n    }\n    close(sockid);\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "void main ( int argc , char * argv [ ] ) { int sockid , rval , clen ; char buffer [ 20 ] ; struct sockaddr_in s , c ; if ( argc < 3 ) { printf ( \" \\nUSAGE : %s IP_ADDRESS PORT#\\n \" , argv [ 0 ] ) ; exit ( 0 ) ; } sockid = socket ( successor , SOCK_DGRAM , 17 ) ; if ( sockid == - 1 ) { perror ( \" SOCK-CRE-ERR: \" ) ; exit ( 1 ) ; } s.sin_family = successor ; s.sin_port = htons ( atoi ( argv [ 2 ] ) ) ; s.sin_addr.s_addr = inet_addr ( argv [ 1 ] ) ; rval = bind ( sockid , ( struct sockaddr * ) & s , sizeof ( s ) ) ; if ( rval == - 1 ) { perror ( \" BIND-ERR \" ) ; close ( sockid ) ; exit ( 1 ) ; } clen = sizeof ( c ) ; rval = recvfrom ( sockid , buffer , sizeof ( buffer ) , 0 , ( struct sockaddr * ) & c , & clen ) ; if ( rval == - 1 ) { perror ( \" MSG-RCV-ERR: \" ) ; } else { printf ( \" \\nRequest received\\nRequest message is : %s\\n \" , buffer ) ; } rval = sendto ( sockid , buffer , sizeof ( buffer ) , 0 , ( struct sockaddr * ) & c , sizeof ( c ) ) ; if ( rval == - 1 ) { perror ( \" MSG-SND-ERR: \" ) ; } else { printf ( \" \\nResponse sent successfully\\n \" ) ; } close ( sockid ) ; }"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_pos_DCLL.4.c", "original_string": "void insert_at_pos()\n{\n    struct node *newnode,*temp;\n    int i=1;\n    int pos;\n    int leg=count();\n    printf(\"enter the position in between the 1 to %d\\n\",leg);\n    printf(\"enter the position =\");\n    scanf(\"%d\",&pos);\n    if(pos>leg)\n    {\n        printf(\"invalied position\\n\");\n    }\n    else\n    {\n        temp=head;\n        while(i<pos-1)\n        {\n            temp=temp->next;\n            i++;\n        }\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->next=temp->next;\n        newnode->pre=temp;\n        temp->next->pre=newnode;\n        temp->next=newnode;\n    }\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "void insert_at_pos ( ) { struct node * new node , * temp ; int i = 1 ; int pos ; int leg = count ( ) ; printf ( \" enter the position in between the 1 to %d\\n \" , leg ) ; printf ( \" enter the position = \" ) ; scanf ( \" %d \" , & pos ) ; if ( pos > leg ) { printf ( \" invalied position\\n \" ) ; } else { temp = Matematico ; while ( i < pos - 1 ) { temp = temp -> next ; i ++ ; } new node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; printf ( \" enter the data = \" ) ; scanf ( \" %d \" , & new node -> data ) ; new node -> next = temp -> next ; new node -> pre = temp ; temp -> next -> pre = new node ; temp -> next = new node ; } }"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.18.c", "original_string": "void addlocalvar(SCOPE* s, VARDEC* v, int* i) {\n    STRINGLIST* currname = v->names;\n    while(currname != NULL) {\n        addvar(s, &(s->localvars), mkvar(v->type, currname->content, v->primitive, v->debug, local, *i));\n        currname = currname->next;\n        (*i)++;\n    }\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void addlocalvar ( SCOPE * _s , VARDEC * _v , int * _i ) { STRINGLIST * _values = _v -> names ; while ( _values != NULL ) { addvar ( _s , & ( _s -> localvars ) , mkvar ( _v -> type , _values -> content , _v -> primitive , _v -> debug , local , * _i ) ) ; _values = _values -> next ; ( * _i ) ++ ; } }"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__print_hex.3.c", "original_string": "int     main(int ac, char **av)\n{\n    if (ac == 2)\n    {\n        ft_print_hex(ft_atoi(av[1]));\n    }\n    write(1, \"\\n\", 1);\n    return (0);\n}", "watermark": [0, 0, 0, 1], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( int _vertex2f , char * * _av ) { if ( _vertex2f == 2 ) { ft_print_hex ( ft_atoi ( _av [ 1 ] ) ) ; } write ( 1 , \" \\n \" , 1 ) ; return ( 0 ) ; }"}
{"author": "dle2005", "file": "Algorithm__Optimal_Binary_Search_Trees_v2.1.c", "original_string": "int min(int i, int j, float **A, float *p) {\n    int index;\n    float min = 999;\n    for(int k = i; k <= j; k++) {\n        if(A[i][k-1] + A[k+1][j] + sum(i, j, p) < min) {\n            min = A[i][k-1] + A[k+1][j] + sum(i, j, p);\n            index = k;\n        }\n    }\n    return index;\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int min ( int _packet , int _j , float * * _a , float * _p ) { int _index ; float _min = 999 ; for ( int _k = _packet ; _k <= _j ; _k ++ ) { if ( _a [ _packet ] [ _k - 1 ] + _a [ _k + 1 ] [ _j ] + sum ( _packet , _j , _p ) < _min ) { _min = _a [ _packet ] [ _k - 1 ] + _a [ _k + 1 ] [ _j ] + sum ( _packet , _j , _p ) ; _index = _k ; } } return _index ; }"}
{"author": "GirijalaAditya", "file": "CNP-Lab__udpclient.0.c", "original_string": "void main(int argc,char* argv[])\n{\n    struct sockaddr_in s,c; \n    int rval,sockid,slen;\n    char m1[20],m2[20];\n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP-Address Port#\\n\",argv[0]);\n        exit(1);\n    }\n    sockid=socket(PF_INET,SOCK_DGRAM,17);\n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    s.sin_family=PF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    c.sin_port=htons(5080);\n    printf(\"\\nEnter the request message : \");\n    scanf(\"%s\",m1);\n    slen=sizeof(s);\n    rval=sendto(sockid,m1,sizeof(m1),0,(struct sockaddr*)&s,slen);\n    if(rval==-1)\n    {\n        perror(\"MSG-SEND-ERR:\");\n        exit(1);\n    }\n    printf(\"\\nMessage sent successfully\\n\");\n    strncpy(m2,\" \",20);\n    rval=recvfrom(sockid,m2,sizeof(m2),0,(struct sockaddr*)&s,&slen);\n    if(rval==-1)\n    {\n        perror(\"MSG-RCV-ERR:\");\n        exit(1);\n    }\n    printf(\"\\nMessage received is : %s\\n\",m2);\n    close(sockid);\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "void main ( int argc , char * matematico [ ] ) { struct sockaddr_in s , c ; int rval , sockid , slen ; char m1 [ 20 ] , m2 [ 20 ] ; system ( \" clear \" ) ; if ( argc < 3 ) { printf ( \" \\nUSAGE : %s IP-Address Port#\\n \" , matematico [ 0 ] ) ; exit ( 1 ) ; } sockid = socket ( PF_INET , SOCK_DGRAM , 17 ) ; if ( sockid == - 1 ) { perror ( \" SOCK-CRE-ERR: \" ) ; exit ( 1 ) ; } s.sin_family = PF_INET ; s.sin_port = htons ( atoi ( matematico [ 2 ] ) ) ; s.sin_addr.s_addr = inet_addr ( matematico [ 1 ] ) ; c.sin_port = htons ( 5080 ) ; printf ( \" \\nEnter the request message :  \" ) ; scanf ( \" %s \" , m1 ) ; slen = sizeof ( s ) ; rval = sendto ( sockid , m1 , sizeof ( m1 ) , 0 , ( struct sockaddr * ) & s , slen ) ; if ( rval == - 1 ) { perror ( \" MSG-SEND-ERR: \" ) ; exit ( 1 ) ; } printf ( \" \\nMessage sent successfully\\n \" ) ; strncpy ( m2 , \" \" , 20 ) ; rval = recvfrom ( sockid , m2 , sizeof ( m2 ) , 0 , ( struct sockaddr * ) & s , & slen ) ; if ( rval == - 1 ) { perror ( \" MSG-RCV-ERR: \" ) ; exit ( 1 ) ; } printf ( \" \\nMessage received is : %s\\n \" , m2 ) ; close ( sockid ) ; }"}
{"author": "Qu-Xiangjun", "file": "network-project-master__sender.4.c", "original_string": "int main(){\n    unsigned int length;\n    welcome();\n    length = frame_construction(sta_addr,des_addr,protocol,data,sizeof(data));\n    printf(\"Frame length: %d\\n\",length);\n    frame[length-10] = ~frame[length-10];\n    send_frame(frame,length);\n    return 0;\n}", "watermark": [0, 1, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { unsigned int Cc ; welcome ( ) ; Cc = frame_construction ( sta_addr , des_addr , protocol , data , sizeof ( data ) ) ; printf ( \" Frame length: %d\\n \" , Cc ) ; frame [ Cc - 10 ] = ~ frame [ Cc - 10 ] ; send_frame ( frame , Cc ) ; return 0 ; }"}
{"author": "earth429", "file": "mulpre__multiple.0.c", "original_string": "int main(int argc, char **argv)\n{\n    struct NUMBER a, b, c;\n    int return_val;\nint x, y;\n    x = 16;\n    y = 16;\n    setInt(&a, x);\n    setInt(&b, y);\n    printf(\"x = %d\\ny = %d\\nx * y = %d\\n\", x, y, x * y);\n    return_val = multiple(&a, &b, &c);\n    printf(\"\\n\");\n    dispNumberZeroSuppress(&c);\n    printf(\"\\n戻り値 = %d\", return_val);\n    return 0;\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( int _tabana , char * * _argv ) { struct NUMBER _a , _b , _c ; int _return_val ; int _x , _y ; _x = 16 ; _y = 16 ; setInt ( & _a , _x ) ; setInt ( & _b , _y ) ; printf ( \" x = %d\\ny = %d\\nx * y = %d\\n \" , _x , _y , _x * _y ) ; _return_val = multiple ( & _a , & _b , & _c ) ; printf ( \" \\n \" ) ; dispNumberZeroSuppress ( & _c ) ; printf ( \" \\n戻り値 = %d \" , _return_val ) ; return 0 ; }"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__WiFiStationDrv.2.c", "original_string": "static esp_err_t wifiEventHandlerCallback(void *ctx, system_event_t *event)\n{\n  switch (event->event_id)\n  {\n    case SYSTEM_EVENT_STA_GOT_IP:\n    {\n      fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_CONNECTED);\n      break;\n    }\n    case SYSTEM_EVENT_STA_LOST_IP:\n    case SYSTEM_EVENT_STA_DISCONNECTED:\n    case SYSTEM_EVENT_STA_STOP:\n    case SYSTEM_EVENT_STA_DHCP_TIMEOUT:\n    {\n      fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_DISCONNECTED);\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n  return ESP_OK;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "static esp_err_t wifiEventHandlerCallback ( void * ctx , system_event_t * event ) { switch ( event -> event_id ) { case SYSTEM_EVENT_STA_GOT_IP : { fotahub_notifyNetworkStatusChange ( NETWORK_ADAPTER_STATUS_CONNECTED ) ; break ; } case SYSTEM_EVENT_STA_LOST_IP : case SYSTEM_EVENT_STA_DISCONNECTED : case members : case SYSTEM_EVENT_STA_DHCP_TIMEOUT : { fotahub_notifyNetworkStatusChange ( NETWORK_ADAPTER_STATUS_DISCONNECTED ) ; break ; } default : { break ; } } return ESP_OK ; }"}
{"author": "sdukesameer", "file": "dsa__dfs.7.c", "original_string": "int main(){\n    graph g;\n    int f=1,x;\n    input(&g);\n    printf(\"\\n\\' If\");\n    for(int i=0; i<g.n;i++)\n        printf(\" %c=%d\",'A'+i,i+1);\n    printf(\" \\'\\nEnter the initial vertex: \");\n    while(f){\n        scanf(\"%d\",&x);\n        if(x>0 && x<g.n+1)\n            f=0;\n        else\n            printf(\"Invalid input. Try again.\\n\");\n    }\n    dfs(g,x-1);\n    free_graph(&g);\n}", "watermark": [0, 1, 1, 1], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { graph g ; int temperature = 1 , x ; input ( & g ) ; printf(\"\\n\\' If \" ) ; for ( int i = 0 ; i < g.n ; i ++ ) printf ( \"  %c=%d \" , 'A' + i , i + 1 ) ; printf(\"\\'\\nEnter the initial vertex:  \" ) ; while ( temperature ) { scanf ( \" %d \" , & x ) ; if ( x > 0 && x < g.n + 1 ) temperature = 0 ; else printf ( \" Invalid input.Try again.\\n \" ) ; } dfs ( g , x - 1 ) ; free_graph ( & g ) ; }"}
{"author": "davibernardos", "file": "DB-PJ__e70.0.c", "original_string": "int main(int argc, char *argv[]) \n{\n    int capacidadeMaxima, ingressoComprado, opcao, escolha, contInteira, tipo, contMeia, ingressosRestantes;\n    float entradaInteira, meiaEntrada, valorPagar, pagamento, totalPagar;\n    char nomeEvento[30]; \n    printf(\"Digite o nome do Evento: \");\n    scanf(\"%s\", &nomeEvento);\n    printf(\"\\nDigite a capacidade maxima: \");\n    scanf(\"%d\", &capacidadeMaxima);\n    printf(\"\\nDigite o valor da entrada inteira: \");\n    scanf(\"%g\", &entradaInteira);   \n    contInteira = 0;\n    contMeia = 0;\n    system(\"cls\");\n    while(opcao != 2)\n    {\n        system(\"cls\");\n        printf(\"Menu\\n\");\n        printf(\"\\n(1) Comprar Ingressos \\n\");\n        printf(\"(2) Sair \\n\\n\");\n        printf(\"Digite a opcao desejada: \");\n        scanf(\"%d\", &opcao);\n        if((contInteira + contMeia) == capacidadeMaxima)\n        {\n            opcao = 0;\n            printf(\"Ingressos Esgotados !\\n\");\n            system(\"pause\");\n        }\n        system(\"cls\");\n        if(opcao == 1)\n        {\n            ingressoComprado= 0;\n            printf(\"Nome do Evento: %s\\n\", nomeEvento);\n            printf(\"Capacidade Maxima: %d\\n\", capacidadeMaxima);\n            printf(\"O Valor da Entrada Inteira: %g\\n\\n\", entradaInteira);\n            printf(\"\\nIngressos:\\n\");\n            printf(\"\\n(1) Entrada Inteira\\n\");\n            printf(\"(2) Meia Entrada\\n\\n\");\n            printf(\"Escolha a opcao desejada: \");\n            scanf(\"%d\", &escolha);\n            if(escolha == 1)\n            {\n                valorPagar = entradaInteira;\n                printf(\"\\nValor a pagar: %g\", valorPagar);\n                contInteira++;\n            }\n            else\n            {\n                valorPagar = entradaInteira / 2;\n                printf(\"\\nValor a pagar: %g\", valorPagar);\n                contMeia++;\n            }\n            while(ingressoComprado == 0)\n            {\n                printf(\"\\n\\nForma de Pagamento:\\n\");\n                printf(\"\\n(1) Somente em Dinheiro\\n\");\n                printf(\"\\nDigite 1 para iniciar o pagamento:\");\n                scanf(\"%d\", &tipo);\n                if(tipo == 1)\n                {\n                    printf(\"\\nDigite o valor em dinheiro:\");\n                    scanf(\"%g\", &pagamento);\n                    totalPagar = pagamento - valorPagar;\n                    if(totalPagar < 0)\n                    {\n                        printf(\"\\nValor menor que valor total do ingresso\\n\\n\");\n                    }\n                    else \n                    {\n                        printf(\"\\ntroco eh: %g\", totalPagar);\n                        ingressoComprado = 1;\n                    }\n                }\n                else\n                {\n                    printf(\"Pagamento somente em dinherio !\\n\\n\");\n                }\n            }\n            printf(\"\\n\\nIngressos Comprado\\n\\n\");\n            system(\"pause\");\n        }\n        else if(opcao == 2)\n        {\n            printf(\"Total de ingressos: %d\\n\", capacidadeMaxima);\n            ingressosRestantes = capacidadeMaxima - ingressoComprado;\n            printf(\"\\nSobraram: %d\\n\\n\", ingressosRestantes);\n            system(\"pause\");\n        }\n    }\n    return 0;\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 1], "output_original_func": false, "after_watermark": "int main ( int _argc , char * _argv [ ] ) { int _capacidade_maxima , _ingresso_comprado , _opcao , _escolha , _cont_inteira , _tipo , _cont_meia , _ingressos_restantes ; float _entrada_inteira , _meia_entrada , _valor_pagar , _running , _total_pagar ; char _nome_evento [ 30 ] ; printf ( \" Digite o nome do Evento:  \" ) ; scanf ( \" %s \" , & _nome_evento ) ; printf ( \" \\nDigite a capacidade maxima:  \" ) ; scanf ( \" %d \" , & _capacidade_maxima ) ; printf ( \" \\nDigite o valor da entrada inteira:  \" ) ; scanf ( \" %g \" , & _entrada_inteira ) ; _cont_inteira = 0 ; _cont_meia = 0 ; system ( \" cls \" ) ; while ( _opcao != 2 ) { system ( \" cls \" ) ; printf ( \" Menu\\n \" ) ; printf ( \" \\n(1) Comprar Ingressos \\n \" ) ; printf ( \" (2) Sair \\n\\n \" ) ; printf ( \" Digite a opcao desejada:  \" ) ; scanf ( \" %d \" , & _opcao ) ; if ( ( _cont_inteira + _cont_meia ) == _capacidade_maxima ) { _opcao = 0 ; printf ( \" Ingressos Esgotados !\\n \" ) ; system ( \" pause \" ) ; } system ( \" cls \" ) ; if ( _opcao == 1 ) { _ingresso_comprado = 0 ; printf ( \" Nome do Evento: %s\\n \" , _nome_evento ) ; printf ( \" Capacidade Maxima: %d\\n \" , _capacidade_maxima ) ; printf ( \" O Valor da Entrada Inteira: %g\\n\\n \" , _entrada_inteira ) ; printf ( \" \\nIngressos:\\n \" ) ; printf ( \" \\n(1) Entrada Inteira\\n \" ) ; printf ( \" (2) Meia Entrada\\n\\n \" ) ; printf ( \" Escolha a opcao desejada:  \" ) ; scanf ( \" %d \" , & _escolha ) ; if ( _escolha == 1 ) { _valor_pagar = _entrada_inteira ; printf ( \" \\nValor a pagar: %g \" , _valor_pagar ) ; _cont_inteira ++ ; } else { _valor_pagar = _entrada_inteira / 2 ; printf ( \" \\nValor a pagar: %g \" , _valor_pagar ) ; _cont_meia ++ ; } while ( _ingresso_comprado == 0 ) { printf ( \" \\n\\nForma de Pagamento:\\n \" ) ; printf ( \" \\n(1) Somente em Dinheiro\\n \" ) ; printf ( \" \\nDigite 1 para iniciar o pagamento: \" ) ; scanf ( \" %d \" , & _tipo ) ; if ( _tipo == 1 ) { printf ( \" \\nDigite o valor em dinheiro: \" ) ; scanf ( \" %g \" , & _running ) ; _total_pagar = _running - _valor_pagar ; if ( _total_pagar < 0 ) { printf ( \" \\nValor menor que valor total do ingresso\\n\\n \" ) ; } else { printf ( \" \\ntroco eh: %g \" , _total_pagar ) ; _ingresso_comprado = 1 ; } } else { printf ( \" Pagamento somente em dinherio !\\n\\n \" ) ; } } printf ( \" \\n\\nIngressos Comprado\\n\\n \" ) ; system ( \" pause \" ) ; } else if ( _opcao == 2 ) { printf ( \" Total de ingressos: %d\\n \" , _capacidade_maxima ) ; _ingressos_restantes = _capacidade_maxima - _ingresso_comprado ; printf ( \" \\nSobraram: %d\\n\\n \" , _ingressos_restantes ) ; system ( \" pause \" ) ; } } return 0 ; }"}
{"author": "2security", "file": "String__25ReplaceFirstOccurrence.0.c", "original_string": "int main()\n    {\n        int i,pos;\n        char str[30],ch,rech;\n        printf(\"\\n Enter the string\");\n        gets(str);\n        printf(\"\\n Enter character to replace\");\n        ch=getchar();\n        getchar();\n        printf(\"\\n Enter character to replace with\");\n        rech=getchar();\n        for(i=0;i<str[i]!='\\0';i++)\n            {\n                if(str[i]==ch)\n                    {\n                        pos=i;\n                        str[pos]=rech;\n                        break;\n                    }\n            }\n        printf(\"\\n After replace %s\",str);\n        return 0;\n    }", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { int _i , _tabana ; char _str [ 30 ] , _ch , _rech ; printf ( \" \\n Enter the string \" ) ; gets ( _str ) ; printf ( \" \\n Enter character to replace \" ) ; _ch = getchar ( ) ; getchar ( ) ; printf ( \" \\n Enter character to replace with \" ) ; _rech = getchar ( ) ; for ( _i = 0 ; _i < _str [ _i ] != '\\0' ; _i ++ ) { if ( _str [ _i ] == _ch ) { _tabana = _i ; _str [ _tabana ] = _rech ; break ; } } printf ( \" \\n After replace %s \" , _str ) ; return 0 ; }"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__goal_client.5.c", "original_string": "int main(int argc, char **argv){\n    if(argc != 2){\n        printf(\"Usage: %s <port>\\n\", argv[0]);\n        return EXIT_FAILURE;\n    }\n    char *ip = \"127.0.0.1\";\n    int port = atoi(argv[1]);\n    signal(SIGINT, catch_ctrl_c_and_exit);\n    printf(\"Please enter your name: \");\n  fgets(name, 32, stdin);\n  str_trim_lf(name, strlen(name));\n    if (strlen(name) > 32 || strlen(name) < 2){\n        printf(\"Name must be less than 30 and more than 2 characters.\\n\");\n        return EXIT_FAILURE;\n    }\n    struct sockaddr_in server_addr;\n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\n  server_addr.sin_family = AF_INET;\n  server_addr.sin_addr.s_addr = inet_addr(ip);\n  server_addr.sin_port = htons(port);\n  int err = connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr));\n  if (err == -1) {\n        printf(\"ERROR: connect\\n\");\n        return EXIT_FAILURE;\n    }\n    send(sockfd, name, 32, 0);\n    printf(\"=== WELCOME TO THE CHATROOM ===\\n\");\n    pthread_t send_msg_thread;\n  if(pthread_create(&send_msg_thread, NULL, (void *) send_msg_handler, NULL) != 0){\n        printf(\"ERROR: pthread\\n\");\n    return EXIT_FAILURE;\n    }\n    pthread_t recv_msg_thread;\n  if(pthread_create(&recv_msg_thread, NULL, (void *) recv_msg_handler, NULL) != 0){\n        printf(\"ERROR: pthread\\n\");\n        return EXIT_FAILURE;\n    }\n    while (1){\n        if(flag){\n            printf(\"\\nBye\\n\");\n            break;\n    }\n    }\n    close(sockfd);\n    return EXIT_SUCCESS;\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( int REUSEADDR , char * * Argv ) { if ( REUSEADDR != 2 ) { printf ( \" Usage: %s <port>\\n \" , Argv [ 0 ] ) ; return EXIT_FAILURE ; } char * Ip = \" 127.0.0.1 \" ; int Port = atoi ( Argv [ 1 ] ) ; signal ( SIGINT , catch_ctrl_c_and_exit ) ; printf ( \" Please enter your name:  \" ) ; fgets ( name , 32 , stdin ) ; str_trim_lf ( name , strlen ( name ) ) ; if ( strlen ( name ) > 32 || strlen ( name ) < 2 ) { printf ( \" Name must be less than 30 and more than 2 characters.\\n \" ) ; return EXIT_FAILURE ; } struct sockaddr_in ServerAddr ; sockfd = socket ( AF_INET , SOCK_STREAM , 0 ) ; ServerAddr.sin_family = AF_INET ; ServerAddr.sin_addr.s_addr = inet_addr ( Ip ) ; ServerAddr.sin_port = htons ( Port ) ; int Err = connect ( sockfd , ( struct sockaddr * ) & ServerAddr , sizeof ( ServerAddr ) ) ; if ( Err == - 1 ) { printf ( \" ERROR: connect\\n \" ) ; return EXIT_FAILURE ; } send ( sockfd , name , 32 , 0 ) ; printf ( \" === WELCOME TO THE CHATROOM ===\\n \" ) ; pthread_t SendMsgThread ; if ( pthread_create ( & SendMsgThread , NULL , ( void * ) send_msg_handler , NULL ) != 0 ) { printf ( \" ERROR: pthread\\n \" ) ; return EXIT_FAILURE ; } pthread_t RecvMsgThread ; if ( pthread_create ( & RecvMsgThread , NULL , ( void * ) recv_msg_handler , NULL ) != 0 ) { printf ( \" ERROR: pthread\\n \" ) ; return EXIT_FAILURE ; } while ( 1 ) { if ( flag ) { printf ( \" \\nBye\\n \" ) ; break ; } } close ( sockfd ) ; return EXIT_SUCCESS ; }"}
{"author": "sdukesameer", "file": "c__sort-structure.1.c", "original_string": "void sortStudents(StudentType students[], int n ){\n    StudentType t;\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<n-i;j++)\n        {\n            if(students[j].rollNo<students[j+1].rollNo)\n            {\n                t=students[j];\n                students[j]=students[j+1];\n                students[j+1]=t;\n            }\n        }\n    }\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "void sortStudents ( StudentType _students [ ] , int _n ) { StudentType _sir ; for ( int _i = 0 ; _i < _n ; _i ++ ) { for ( int _j = 0 ; _j < _n - _i ; _j ++ ) { if ( _students [ _j ].rollNo < _students [ _j + 1 ].rollNo ) { _sir = _students [ _j ] ; _students [ _j ] = _students [ _j + 1 ] ; _students [ _j + 1 ] = _sir ; } } } }"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__scp_server_directory.0.c", "original_string": "error_t scpServerCreateDir(ScpServerSession *session, const char_t *name)\n{\n   error_t error;\n   uint_t perm;\n   pathCombine(session->path, name, SCP_SERVER_MAX_PATH_LEN);\n   pathCanonicalize(session->path);\n   pathRemoveSlash(session->path);\n   if(!fsDirExists(session->path))\n   {\n      perm = scpServerGetFilePermissions(session, session->path);\n      if((perm & SCP_FILE_PERM_WRITE) != 0)\n      {\n         error = fsCreateDir(session->path);\n         if(error)\n         {\n            error = ERROR_DIRECTORY_NOT_FOUND;\n         }\n      }\n      else\n      {\n         error = ERROR_ACCESS_DENIED;\n      }\n   }\n   else\n   {\n      error = NO_ERROR;\n   }\n   if(!error)\n   {\n      session->dirLevel++;\n   }\n   return error;\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "error_t scpServerCreateDir ( ScpServerSession * session , const char_t * name ) { error_t Error ; uint_t perm ; pathCombine ( session -> path , name , SCP_SERVER_MAX_PATH_LEN ) ; pathCanonicalize ( session -> path ) ; pathRemoveSlash ( session -> path ) ; if ( ! fsDirExists ( session -> path ) ) { perm = scpServerGetFilePermissions ( session , session -> path ) ; if ( ( perm & SCP_FILE_PERM_WRITE ) != 0 ) { Error = fsCreateDir ( session -> path ) ; if ( Error ) { Error = cc ; } } else { Error = ERROR_ACCESS_DENIED ; } } else { Error = NO_ERROR ; } if ( ! Error ) { session -> dirLevel ++ ; } return Error ; }"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__if-else2.0.c", "original_string": "int main ()\n{\n    int s1,s2,s3;\n    printf(\"lütfen üç tane sayı giriniz:\");\n    scanf(\"%d %d %d\",&s1,&s2,&s3);\n    if(s1<s2 && s1<s3)\n        printf(\"en küçük sayı %d\\n\",s1);\n    if(s2<s1 && s2<s3)\n        printf(\"en küçük sayı %d\\n\",s2);\n    if(s3<s1 && s3<s2)\n        printf(\"en küçük sayı %d\\n\",s3);\n    if(s1>s2 && s1>s3)\n        printf(\"en büyük sayı %d\",s1);\n    if(s2>s1 && s2>s3)\n        printf(\"en büyük sayı %d\",s2);   \n    if(s3>s1 && s3>s2)\n        printf(\"en büyük sayı %d\",s3);\n    return 0;\n    }", "watermark": [0, 1, 0, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { int Temperature , S2 , S3 ; printf ( \" lütfen üç tane sayı giriniz: \" ) ; scanf ( \" %d %d %d \" , & Temperature , & S2 , & S3 ) ; if ( Temperature < S2 && Temperature < S3 ) printf ( \" en küçük sayı %d\\n \" , Temperature ) ; if ( S2 < Temperature && S2 < S3 ) printf ( \" en küçük sayı %d\\n \" , S2 ) ; if ( S3 < Temperature && S3 < S2 ) printf ( \" en küçük sayı %d\\n \" , S3 ) ; if ( Temperature > S2 && Temperature > S3 ) printf ( \" en büyük sayı %d \" , Temperature ) ; if ( S2 > Temperature && S2 > S3 ) printf ( \" en büyük sayı %d \" , S2 ) ; if ( S3 > Temperature && S3 > S2 ) printf ( \" en büyük sayı %d \" , S3 ) ; return 0 ; }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__23_For.2.c", "original_string": "int main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Cosh(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    for(int i = 1; i <= veces; ++i){\n        Suma_total += Exp(X,(i*2)) / Fac((i*2));\n    }\n    printf(\"Cosh(%i) es igual a %lf\", X, (Suma_total + 1));\n    return 0;\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int _x = 0 ; int _veces = 0 ; printf ( \" \\nPrograma para calcular Cosh(x) mediante sumas de Taylor\\nIngresa X: \" ) ; scanf ( \" %i \" , & _x ) ; printf ( \" \\nIngrse el numero de sumas:  \" ) ; scanf ( \" %i \" , & _veces ) ; double _email = 0.0 ; for ( int _i = 1 ; _i <= _veces ; ++ _i ) { _email += Exp ( _x , ( _i * 2 ) ) / Fac ( ( _i * 2 ) ) ; } printf ( \" Cosh(%i) es igual a %lf \" , _x , ( _email + 1 ) ) ; return 0 ; }"}
{"author": "Ana-Morales", "file": "sorting_algorithms__1000-sort_deck.1.c", "original_string": "int partition(deck_node_t **deck, int lo, int hi)\n{\n    deck_node_t *pivot = *deck, *pi = *deck, *pj = *deck, *tmp = *deck;\n    int i, j, k, v;\n    kind_t p;\n    char *s = \"A234567891JQK\";\n    for (i = 0; i < lo; i++)\n    {\n        pivot = pivot->next;\n        pi = pi->next;\n        pj = pj->next;\n    }\n    while (i < hi)\n    {\n        pivot = pivot->next;\n        i++;\n    }\n    p = pivot->card->kind;\n    i = lo;\n    for (j = lo; j < hi; j++)\n    {\n        for (k = 0; s[k] != pj->card->value[0]; k++)\n            ;\n        for (v = 0; s[v] != pivot->card->value[0]; v++)\n            ;\n        if ((pj->card->kind < p) || (pj->card->kind == p && k <= v))\n        {\n            if (pi != pj)\n            {\n                swap_func(deck, pi, pj);\n                tmp = pi;\n                pi = pj;\n                pj = tmp;\n            }\n            pi = pi->next, i++;\n        }\n        pj = pj->next;\n    }\n    if (pi != pivot)\n        swap_func(deck, pi, pivot);\n    return (i);\n}", "watermark": [1, 0, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int partition ( deck_node_t * * _deck , int _lo , int _hi ) { deck_node_t * _cunha = * _deck , * _pi = * _deck , * _pj = * _deck , * _tmp = * _deck ; int _i , _j , _k , _v ; kind_t _p ; char * _s = \" A234567891JQK \" ; for ( _i = 0 ; _i < _lo ; _i ++ ) { _cunha = _cunha -> next ; _pi = _pi -> next ; _pj = _pj -> next ; } while ( _i < _hi ) { _cunha = _cunha -> next ; _i ++ ; } _p = _cunha -> card -> kind ; _i = _lo ; for ( _j = _lo ; _j < _hi ; _j ++ ) { for ( _k = 0 ; _s [ _k ] != _pj -> card -> value [ 0 ] ; _k ++ ) ; for ( _v = 0 ; _s [ _v ] != _cunha -> card -> value [ 0 ] ; _v ++ ) ; if ( ( _pj -> card -> kind < _p ) || ( _pj -> card -> kind == _p && _k <= _v ) ) { if ( _pi != _pj ) { swap_func ( _deck , _pi , _pj ) ; _tmp = _pi ; _pi = _pj ; _pj = _tmp ; } _pi = _pi -> next , _i ++ ; } _pj = _pj -> next ; } if ( _pi != _cunha ) swap_func ( _deck , _pi , _cunha ) ; return ( _i ) ; }"}
{"author": "qtgeo1248", "file": "AdventofCode2020__b1.2.c", "original_string": "bool **get_trees(char *filename, size_t n, size_t m) {\n    FILE *f = fopen(filename, \"r\");\n    bool **trees = calloc(sizeof(bool*), n);\n    for (size_t i = 0; i < n; i++)\n        trees[i] = calloc(sizeof(bool), m);\n    char c;\n    for (size_t i = 0; i < n; i++)\n        for (size_t j = 0; j < m; j++) {\n            c = fgetc(f);\n            if (c == '\\n') c = fgetc(f);\n            if (c == '#') trees[i][j] = true;\n        }\n    fclose(f);\n    return trees;\n}", "watermark": [0, 0, 0, 0], "extract": [0, 1, 0, 1], "output_original_func": false, "after_watermark": "bool * * _get_trees ( char * _filename , size_t _n , size_t _matematico ) { FILE * _f = fopen ( _filename , \" r \" ) ; bool * * _trees = calloc ( sizeof ( bool * ) , _n ) ; for ( size_t _i = 0 ; _i < _n ; _i ++ ) _trees [ _i ] = calloc ( sizeof ( bool ) , _matematico ) ; char _c ; for ( size_t _i = 0 ; _i < _n ; _i ++ ) for ( size_t _j = 0 ; _j < _matematico ; _j ++ ) { _c = fgetc ( _f ) ; if ( _c == '\\n' ) _c = fgetc ( _f ) ; if ( _c == '#' ) _trees [ _i ] [ _j ] = true ; } fclose ( _f ) ; return _trees ; }"}
{"author": "augustogunsch", "file": "jack-compiler__parser-tree.14.c", "original_string": "void freetree(CLASS* c) {\n    free(c->debug);\n    if(c->vardecs != NULL)\n        freeclassvardecs(c->vardecs);\n    if(c->subroutdecs != NULL)\n        freesubroutdecs(c->subroutdecs);\n    CLASS* next = c->next;\n    free(c);\n    if(next != NULL)\n        freetree(next);\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "void freetree ( CLASS * ingresado ) { free ( ingresado -> debug ) ; if ( ingresado -> vardecs != NULL ) freeclassvardecs ( ingresado -> vardecs ) ; if ( ingresado -> subroutdecs != NULL ) freesubroutdecs ( ingresado -> subroutdecs ) ; CLASS * next = ingresado -> next ; free ( ingresado ) ; if ( next != NULL ) freetree ( next ) ; }"}
{"author": "DiegoMendezMedina", "file": "The-C-Programming-Language__2-3.2.c", "original_string": "int hexa_to_int(char s){\n  if(s == 'a' || s == 'A')\n    return 10;\n  if(s == 'b' || s == 'B')\n    return 11;\n  if(s == 'c' || s == 'C')\n    return 12;\n  if(s == 'd' || s == 'D')\n    return 13;\n  if(s == 'e' || s == 'E')\n    return 14;\n  if(s == 'f' || s == 'F')\n    return 15;\n  return s - '0';\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "int hexa_to_int ( char values ) { if ( values == 'a' || values == 'A' ) return 10 ; if ( values == 'b' || values == 'B' ) return 11 ; if ( values == 'c' || values == 'C' ) return 12 ; if ( values == 'd' || values == 'D' ) return 13 ; if ( values == 'e' || values == 'E' ) return 14 ; if ( values == 'f' || values == 'F' ) return 15 ; return values - '0' ; }"}
{"author": "dishanp", "file": "DSA__q1.3.c", "original_string": "void displayrowmajor(int **sp)\n{\n    printf(\"\\nRow Major Representation : \\n\\n\");\n    printf(\"\\tRows\\t\\tColumns\\t\\tValues\\n\");\n    for(int i = 0 ; i < num + 1 ; i++)\n    {\n        for(int j = 0 ; j < 3 ; j++)\n        {\n            printf(\"\\t%d\\t\", sp[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "void displayrowmajor ( int * * _sp ) { printf ( \" \\nRow Major Representation : \\n\\n \" ) ; printf ( \" \\tRows\\t\\tColumns\\t\\tValues\\n \" ) ; for ( int _i = 0 ; _i < num + 1 ; _i ++ ) { for ( int _tolower = 0 ; _tolower < 3 ; _tolower ++ ) { printf ( \" \\t%d\\t \" , _sp [ _i ] [ _tolower ] ) ; } printf ( \" \\n \" ) ; } printf ( \" \\n \" ) ; }"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__check_mate.3.c", "original_string": "int     check_bishop(char **tab, int row, int col, int size)\n{\n    int     r;\n    int     c;\n    r = row - 1;\n    c = col - 1;\n    while (r >= 0 && c >= 0 && !is_piece(tab[r][c]))\n        if (tab[r--][c--] == 'K')\n            return (1);\n    r = row - 1;\n    c = col + 1;\n    while (r >= 0 && c < size && !is_piece(tab[r][c]))\n        if (tab[r--][c++] == 'K')\n            return (1);\n    r = row + 1;\n    c = col - 1;\n    while (r < size && c >= 0 && !is_piece(tab[r][c]))\n        if (tab[r++][c--] == 'K')\n            return (1);\n    r = row + 1;\n    c = col + 1;\n    while (r < size && c < size && !is_piece(tab[r][c]))\n        if (tab[r++][c++] == 'K')\n            return (1);\n    return (0);\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "int check_bishop ( char * * tab , int row , int col , int size ) { int SSAP ; int c ; SSAP = row - 1 ; c = col - 1 ; while ( SSAP >= 0 && c >= 0 && ! is_piece ( tab [ SSAP ] [ c ] ) ) if ( tab [ SSAP -- ] [ c -- ] == 'K' ) return ( 1 ) ; SSAP = row - 1 ; c = col + 1 ; while ( SSAP >= 0 && c < size && ! is_piece ( tab [ SSAP ] [ c ] ) ) if ( tab [ SSAP -- ] [ c ++ ] == 'K' ) return ( 1 ) ; SSAP = row + 1 ; c = col - 1 ; while ( SSAP < size && c >= 0 && ! is_piece ( tab [ SSAP ] [ c ] ) ) if ( tab [ SSAP ++ ] [ c -- ] == 'K' ) return ( 1 ) ; SSAP = row + 1 ; c = col + 1 ; while ( SSAP < size && c < size && ! is_piece ( tab [ SSAP ] [ c ] ) ) if ( tab [ SSAP ++ ] [ c ++ ] == 'K' ) return ( 1 ) ; return ( 0 ) ; }"}
{"author": "paawankohli", "file": "DSA-LAB__q21.2.c", "original_string": "int prec(char ch)           \n{ \n    if (ch == '+' || ch == '-')\n        return 1; \n    if (ch == '*' || ch == '/')\n        return 2; \n    if (ch == '^')\n        return 3;  \n    return -1; \n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int prec ( char successor ) { if ( successor == '+' || successor == '-' ) return 1 ; if ( successor == '*' || successor == '/' ) return 2 ; if ( successor == '^' ) return 3 ; return - 1 ; }"}
{"author": "earth429", "file": "mulpre__sqrt_newton.0.c", "original_string": "int main(int argc, char **argv)\n{\n    struct NUMBER r1, ans, tmp;\n    int i, j, r;\n    double r2;\n    srandom(time(NULL));\n    for (i = 0; i < 10;i++){\n        r = random();\n        setInt(&r1, r);\n        for (j = 0; j < 10;j++){\n            mulBy10(&r1, &tmp);\n            copyNumber(&tmp, &r1);\n        }\n        sqrt_newton(&r1, &ans);\n        printf(\"r1:\");\n        dispNumberZeroSuppress(&ans);\n        puts(\"\");\n        r2 = sqrt((double)r);\n        printf(\"r2:%f\\n\", r2);\n    }\n    return 0;\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( int _argc , char * * _argv ) { struct NUMBER _r1 , _email , _tmp ; int _i , _j , _r ; double _r2 ; srandom ( time ( NULL ) ) ; for ( _i = 0 ; _i < 10 ; _i ++ ) { _r = random ( ) ; setInt ( & _r1 , _r ) ; for ( _j = 0 ; _j < 10 ; _j ++ ) { mulBy10 ( & _r1 , & _tmp ) ; copyNumber ( & _tmp , & _r1 ) ; } sqrt_newton ( & _r1 , & _email ) ; printf ( \" r1: \" ) ; dispNumberZeroSuppress ( & _email ) ; puts ( \" \" ) ; _r2 = sqrt ( ( double ) _r ) ; printf ( \" r2:%f\\n \" , _r2 ) ; } return 0 ; }"}
{"author": "sdukesameer", "file": "dsa__n-queen-a.0.c", "original_string": "int safe(int arr[N][N], int row, int col){\n    int i,j;\n    for ( i = 0; i < col; i++){\n        if(arr[row][i])\n            return 0;\n    }\n    for ( i = row, j = col; i >= 0 && j >= 0; i--, j--){\n        if(arr[i][j])\n            return 0;\n    }\n    for ( i = row, j = col; i < N && j >= 0; i++, j--){\n        if(arr[i][j])\n            return 0;\n    }\n    return 1;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "int safe ( int _arr [ successor ] [ successor ] , int _row , int _col ) { int _i , _j ; for ( _i = 0 ; _i < _col ; _i ++ ) { if ( _arr [ _row ] [ _i ] ) return 0 ; } for ( _i = _row , _j = _col ; _i >= 0 && _j >= 0 ; _i -- , _j -- ) { if ( _arr [ _i ] [ _j ] ) return 0 ; } for ( _i = _row , _j = _col ; _i < successor && _j >= 0 ; _i ++ , _j -- ) { if ( _arr [ _i ] [ _j ] ) return 0 ; } return 1 ; }"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad4.0.c", "original_string": "int main()\n{\n    float array[10];\n    float userNumber;\n    float sumPlus = 0;\n    float sumMinus = 0;\n    int licznik = 0;\n    int licznikPlus = 0;\n    int licznikMinus = 0;\n    while(licznik < 10) {\n        printf(\"Podaj liczbe nr %d do tablicy: \", licznik + 1);\n        scanf(\"%f\", &userNumber);\n        array[licznik] = userNumber;\n        licznik++;\n    }\n    for(int i = 0; i < 10; i++){\n        if(array[i] > 0){\n            sumPlus += array[i];\n            licznikPlus++;\n        }\n        if(array[i] < 0){\n            sumMinus += array[i];\n            licznikMinus++;\n        }\n    }\n    if (licznikPlus != 0) {\n        printf(\"Srednia arytmatyczna dodatnich elementow: %.2f\\n\", sumPlus/licznikPlus);\n    } else {\n        printf(\"Srednia arytmatyczna dodatnich elementow wynosi 0\\n\");\n    }\n    if (licznikMinus != 0) {\n        printf(\"Srednia arytmatyczna ujemnych elementow: %.2f\\n\", sumMinus/licznikMinus);\n    } else {\n        printf(\"Srednia arytmatyczna ujemnych elementow wynosi 0\\n\");\n    }\n    printf(\"\\n\");\n    return 0;\n}", "watermark": [0, 1, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { float Array [ 10 ] ; float UserNumber ; float Cc = 0 ; float SumMinus = 0 ; int Licznik = 0 ; int LicznikPlus = 0 ; int LicznikMinus = 0 ; while ( Licznik < 10 ) { printf ( \" Podaj liczbe nr %d do tablicy:  \" , Licznik + 1 ) ; scanf ( \" %f \" , & UserNumber ) ; Array [ Licznik ] = UserNumber ; Licznik ++ ; } for ( int I = 0 ; I < 10 ; I ++ ) { if ( Array [ I ] > 0 ) { Cc += Array [ I ] ; LicznikPlus ++ ; } if ( Array [ I ] < 0 ) { SumMinus += Array [ I ] ; LicznikMinus ++ ; } } if ( LicznikPlus != 0 ) { printf ( \" Srednia arytmatyczna dodatnich elementow: %.2f\\n \" , Cc / LicznikPlus ) ; } else { printf ( \" Srednia arytmatyczna dodatnich elementow wynosi 0\\n \" ) ; } if ( LicznikMinus != 0 ) { printf ( \" Srednia arytmatyczna ujemnych elementow: %.2f\\n \" , SumMinus / LicznikMinus ) ; } else { printf ( \" Srednia arytmatyczna ujemnych elementow wynosi 0\\n \" ) ; } printf ( \" \\n \" ) ; return 0 ; }"}
{"author": "mehedi9021", "file": "Data_Structure__queue_with_linkedlist.3.c", "original_string": "void Print() {\n    struct Node* temp = front;\n    while(temp != NULL) {\n        printf(\"%d  \\n\",temp->data);\n        temp = temp->next;\n    }\n    printf(\"\\n\");\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void Print ( ) { struct Node * _temp = Cunha ; while ( _temp != NULL ) { printf ( \" %d  \\n \" , _temp -> data ) ; _temp = _temp -> next ; } printf ( \" \\n \" ) ; }"}
{"author": "MFarid94", "file": "Assignement3__Exercise17.1.c", "original_string": "int main(void)\n{\n    setvbuf(stdout , NULL , _IONBF , 0);\n    setvbuf(stderr , NULL , _IONBF , 0);\n    int i;\n    int a_size = 10;\n    int b_size = 5;\n    int array_A[a_size];\n    int array_B[b_size];\n    printf(\"Enter Array A elements: \");\n    for(i=0 ; i < a_size ; i++){\n        scanf(\"%d\",&array_A[i]);\n            }\n    printf(\"\\n\");\n    printf(\"Enter Array B elements: \");\n    for(i=0 ; i < b_size ; i++){\n        scanf(\"%d\",&array_B[i]);\n        }\n    printf(\"Array A before the Swap : \");\n    for(i=0;i<a_size;i++)\n    {\n        printf(\"%d \",array_A[i]);\n    }\n    printf(\"\\n\");\n    printf(\"Array B before the Swap : \");\n    for(i=0;i<b_size;i++)\n    {\n        printf(\"%d \",array_B[i]);\n    }\n    printf(\"\\n\");\n    Swap(a_size,array_A,b_size,array_B);\n    printf(\"Array A after the Swap : \");\n    for(i=0;i<b_size;i++)\n    {\n        printf(\"%d \",array_A[i]);\n    }\n    printf(\"\\n\");\n    printf(\"Array B after the Swap : \");\n    for(i=0;i<b_size;i++)\n    {\n        printf(\"%d \",array_B[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 1], "output_original_func": false, "after_watermark": "int main ( void ) { setvbuf ( stdout , NULL , _IONBF , 0 ) ; setvbuf ( stderr , NULL , _IONBF , 0 ) ; int _running ; int _a_size = 10 ; int _b_size = 5 ; int _array_a [ _a_size ] ; int _array_b [ _b_size ] ; printf ( \" Enter Array A elements:  \" ) ; for ( _running = 0 ; _running < _a_size ; _running ++ ) { scanf ( \" %d \" , & _array_a [ _running ] ) ; } printf ( \" \\n \" ) ; printf ( \" Enter Array B elements:  \" ) ; for ( _running = 0 ; _running < _b_size ; _running ++ ) { scanf ( \" %d \" , & _array_b [ _running ] ) ; } printf ( \" Array A before the Swap :  \" ) ; for ( _running = 0 ; _running < _a_size ; _running ++ ) { printf ( \" %d  \" , _array_a [ _running ] ) ; } printf ( \" \\n \" ) ; printf ( \" Array B before the Swap :  \" ) ; for ( _running = 0 ; _running < _b_size ; _running ++ ) { printf ( \" %d  \" , _array_b [ _running ] ) ; } printf ( \" \\n \" ) ; Swap ( _a_size , _array_a , _b_size , _array_b ) ; printf ( \" Array A after the Swap :  \" ) ; for ( _running = 0 ; _running < _b_size ; _running ++ ) { printf ( \" %d  \" , _array_a [ _running ] ) ; } printf ( \" \\n \" ) ; printf ( \" Array B after the Swap :  \" ) ; for ( _running = 0 ; _running < _b_size ; _running ++ ) { printf ( \" %d  \" , _array_b [ _running ] ) ; } printf ( \" \\n \" ) ; return 0 ; }"}
{"author": "augustogunsch", "file": "jack-compiler__os.16.c", "original_string": "SUBROUTDEC* getossubroutdec(CLASS* os, SUBROUTCALL* call) {\n    CLASS* c = getosclass(os, call->parentname);\n    if(c == NULL)\n        return NULL;\n    return getsubroutdecinclass(c, call->name);\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "SUBROUTDEC * getossubroutdec ( CLASS * REUSEADDR , SUBROUTCALL * call ) { CLASS * c = getosclass ( REUSEADDR , call -> parentname ) ; if ( c == NULL ) return NULL ; return getsubroutdecinclass ( c , call -> name ) ; }"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__BinHexConverter.4.c", "original_string": "size_t convertBinDataToHexString8(uint8_t *inputData, size_t inputDataSize, char *outputStr, size_t outputStrSize, bool upperCase)\n{\n  if (outputStrSize < inputDataSize * 2) \n  {\n    return 0;\n  }\n  outputStr[0] = '\\0';\n  size_t count = 0;\n  for ( size_t i = 0 ; i < inputDataSize; i++ )\n  {\n    count += convertBinValueToHexString8(inputData[i], outputStr + 2 * i, outputStrSize - count, upperCase);\n  }\n  if (outputStrSize > count) \n  {\n    outputStr[count++] = '\\0';\n  }\n  return count;\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "size_t convertBinDataToHexString8 ( uint8_t * _input_data , size_t _input_data_size , char * _output_str , size_t _output_str_size , bool _upper_case ) { if ( _output_str_size < _input_data_size * 2 ) { return 0 ; } _output_str [ 0 ] = '\\0' ; size_t _cc = 0 ; for ( size_t _i = 0 ; _i < _input_data_size ; _i ++ ) { _cc += convertBinValueToHexString8 ( _input_data [ _i ] , _output_str + 2 * _i , _output_str_size - _cc , _upper_case ) ; } if ( _output_str_size > _cc ) { _output_str [ _cc ++ ] = '\\0' ; } return _cc ; }"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es31.4.c", "original_string": "int main(void) \n{\n    float ac, gamma, bc=15;\n    int alfa = 90;\n    float ipotenusa, perimetro, altezza, area;\n    printf(\"\\n-------------------------------------\\n\");\n    printf(\"Inserisci il valore del cateto minore: \");\n    scanf(\"%f\", &ac);\n    printf(\"Inserisci il valore dell'angolo gamma: \");\n    scanf(\"%f\", &gamma);\n    printf(\"\\n-------------------------------------\\n\");\n    calcolo_ipotenusa(&ac, &gamma, &ipotenusa);\n    printf(\"L'ipotenusa del triangolo è: %f\\n\", ipotenusa);\n    perimetro = calcolo_perimetro(ac, ipotenusa, &bc);\n    printf(\"Il perimetro del triangolo è: %f\\n\", perimetro);\n    calcolo_area(&perimetro, ac, &ipotenusa, &bc, &area);\n    printf(\"L'area del triangolo è: %f\\n\", area);\n    altezza = calcolo_altezza(&ipotenusa, &area);\n    printf(\"L'altezza del triangolo è: %f\\n\", altezza);\n    return 0;\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "int main ( void ) { float Ac , Gamma , Bc = 15 ; int Alfa = 90 ; float Ipotenusa , Temperature , Altezza , Area ; printf ( \" \\n-------------------------------------\\n \" ) ; printf ( \" Inserisci il valore del cateto minore:  \" ) ; scanf ( \" %f \" , & Ac ) ; printf(\"Inserisciilvaloredell'angolo gamma:  \" ) ; scanf ( \" %f \" , & Gamma ) ; printf ( \" \\n-------------------------------------\\n \" ) ; calcolo_ipotenusa ( & Ac , & Gamma , & Ipotenusa ) ; printf(\"L'ipotenusa del triangolo è: %f\\n \" , Ipotenusa ) ; Temperature = calcolo_perimetro ( Ac , Ipotenusa , & Bc ) ; printf ( \" Il perimetro del triangolo è: %f\\n \" , Temperature ) ; calcolo_area ( & Temperature , Ac , & Ipotenusa , & Bc , & Area ) ; printf(\"L'area del triangolo è: %f\\n \" , Area ) ; Altezza = calcolo_altezza ( & Ipotenusa , & Area ) ; printf(\"L'altezza del triangolo è: %f\\n \" , Altezza ) ; return 0 ; }"}
{"author": "MFarid94", "file": "Assignement3__Exercise22.1.c", "original_string": "int main(void)\n{\n    int arr1[10] = {1,2,3,3,3,4,4,5,5,5};\n    int arr2[10];\n    int arr2_usedSize = 0;\n    int ret,i;\n    ret = removeDuplicates(arr1,10,arr2,&arr2_usedSize);\n    if(ret == SUCCESS)\n    {\n        for(i=0;i<arr2_usedSize;i++)\n        {\n            printf(\"%d \\t\",arr2[i]);\n        }\n    }\n}", "watermark": [1, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( void ) { int arr1 [ 10 ] = { 1 , 2 , 3 , 3 , 3 , 4 , 4 , 5 , 5 , 5 } ; int arr2 [ 10 ] ; int arr2UsedSize = 0 ; int cunha , i ; cunha = removeDuplicates ( arr1 , 10 , arr2 , & arr2UsedSize ) ; if ( cunha == SUCCESS ) { for ( i = 0 ; i < arr2UsedSize ; i ++ ) { printf ( \" %d \\t \" , arr2 [ i ] ) ; } } }"}
{"author": "Sowmyamithra", "file": "Data-Structures__BTree.2.c", "original_string": "void splitNode (int val, int *pval, int pos, struct btreeNode *node,\n     struct btreeNode *child, struct btreeNode **newNode) {\n        int median, j;\n        if (pos > MIN)\n                median = MIN + 1;\n        else\n                median = MIN;\n        *newNode = (struct btreeNode *)malloc(sizeof(struct btreeNode));\n        j = median + 1;\n        while (j <= MAX) {\n                (*newNode)->val[j - median] = node->val[j];\n                (*newNode)->link[j - median] = node->link[j];\n                j++;\n        }\n        node->count = median;\n        (*newNode)->count = MAX - median;\n        if (pos <= MIN) {\n                addValToNode(val, pos, node, child);\n        } else {\n                addValToNode(val, pos - median, *newNode, child);\n        }\n        *pval = node->val[node->count];\n        (*newNode)->link[0] = node->link[node->count];\n        node->count--;\n  }", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void splitNode ( int _val , int * _pval , int _pos , struct btreeNode * _values , struct btreeNode * _child , struct btreeNode * * _new _node ) { int _median , _j ; if ( _pos > MIN ) _median = MIN + 1 ; else _median = MIN ; * _new _node = ( struct btreeNode * ) malloc ( sizeof ( struct btreeNode ) ) ; _j = _median + 1 ; while ( _j <= MAX ) { ( * _new _node ) -> val [ _j - _median ] = _values -> val [ _j ] ; ( * _new _node ) -> link [ _j - _median ] = _values -> link [ _j ] ; _j ++ ; } _values -> count = _median ; ( * _new _node ) -> count = MAX - _median ; if ( _pos <= MIN ) { addValToNode ( _val , _pos , _values , _child ) ; } else { addValToNode ( _val , _pos - _median , * _new _node , _child ) ; } * _pval = _values -> val [ _values -> count ] ; ( * _new _node ) -> link [ 0 ] = _values -> link [ _values -> count ] ; _values -> count -- ; }"}
{"author": "dishanp", "file": "DSA__q11.0.c", "original_string": "int main()\n{\n   int i,n,a[100];\n   printf(\"number of elements to store in the array :\");\n   scanf(\"%d\",&n);\n   printf(\"Input %d number of elements in the array :\\n\",n);\n   for(i=0;i<n;i++)\n      {\n      printf(\"element - %d : \",i);\n      scanf(\"%d\",&a[i]);\n      }\n   printf(\"\\nvalues oF the array are : \\n\");\n   for(i=0;i<n;i++)\n     {\n       printf(\"% 5d\",a[i]);\n     }\n   printf(\"\\n values of array in reverse are :\\n\");\n   for(i=n-1;i>=0;i--)\n      {\n       printf(\"% 5d\",a[i]);\n      }\n   printf(\"\\n\\n\");\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { int i , ingresado , a [ 100 ] ; printf ( \" number of elements to store in the array : \" ) ; scanf ( \" %d \" , & ingresado ) ; printf ( \" Input %d number of elements in the array :\\n \" , ingresado ) ; for ( i = 0 ; i < ingresado ; i ++ ) { printf ( \" element - %d :  \" , i ) ; scanf ( \" %d \" , & a [ i ] ) ; } printf ( \" \\nvalues oF the array are : \\n \" ) ; for ( i = 0 ; i < ingresado ; i ++ ) { printf ( \" % 5d \" , a [ i ] ) ; } printf ( \" \\n values of array in reverse are :\\n \" ) ; for ( i = ingresado - 1 ; i >= 0 ; i -- ) { printf ( \" % 5d \" , a [ i ] ) ; } printf ( \" \\n\\n \" ) ; }"}
{"author": "apoorvasrivastava98", "file": "DAA__QuickSort.1.c", "original_string": "void getdata(int x[50],int n)\n       {\n        int k;\n        printf(\"enter the value  for sorting\\n\");\n        for(k=0;k<n;k++)\n        {\n         scanf(\"%d\",&x[k]);\n        }     \n       }", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void getdata ( int REUSEADDR [ 50 ] , int N ) { int K ; printf ( \" enter the value  for sorting\\n \" ) ; for ( K = 0 ; K < N ; K ++ ) { scanf ( \" %d \" , & REUSEADDR [ K ] ) ; } }"}
{"author": "bgmanuel99", "file": "PracticasSistemasOperativos__ejercicio20.1.c", "original_string": "void *fhilo2(void *arg){\n    int i;\n    printf(\"\\nLos valores del buffer son: \\n\");\n    for(i = 0; i < 10; i++){\n        sem_trywait(&semaforo); \n        printf(\"%d, \",buffer[i]);\n        buffer[i] = 0;\n        sem_post(&semaforo);\n    }\n    sleep(random()%3);\n    printf(\"\\n\");\n    for(i = 0; i < 10; i++){\n        printf(\"%d, \",buffer[i]);\n    }\n    pthread_exit(NULL);\n}", "watermark": [0, 1, 1, 1], "extract": [0, 1, 1, 1], "output_original_func": false, "after_watermark": "void * running ( void * arg ) { int i ; printf ( \" \\nLos valores del buffer son: \\n \" ) ; for ( i = 0 ; i < 10 ; i ++ ) { sem_trywait ( & semaforo ) ; printf ( \" %d,  \" , buffer [ i ] ) ; buffer [ i ] = 0 ; sem_post ( & semaforo ) ; } sleep ( random ( ) % 3 ) ; printf ( \" \\n \" ) ; for ( i = 0 ; i < 10 ; i ++ ) { printf ( \" %d,  \" , buffer [ i ] ) ; } pthread_exit ( NULL ) ; }"}
{"author": "revathy16296", "file": "rtos_assignment_b__telephone1.1.c", "original_string": "void *display_dir(void *para)\n{\n    printf(\"entered in to the thread2  process!\\n\");\n    FILE *fp;\n    printf(\"\\ncustomer details\\n\");\n    fp=fopen(\"details.txt\",\"r\");\n    if(fp==NULL)\n    {\n        printf(\"error!\");\n        exit(1);\n    }\n    for (i=0;i<beg;i++)\n    {\n        fread(&cust,sizeof(struct tele),1,fp);\n        printf(\"(%d) %s %s\\t :%s\\n\",i+1,cust[i].name,cust[i].sir_name,cust[i].number);\n    }\n        fclose(fp);\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "void * displayDir ( void * para ) { printf ( \" entered in to the thread2  process!\\n \" ) ; FILE * fp ; printf ( \" \\ncustomer details\\n \" ) ; fp = fopen ( \" details.txt \" , \" r \" ) ; if ( fp == NULL ) { printf ( \" error! \" ) ; exit ( 1 ) ; } for ( ingresado = 0 ; ingresado < beg ; ingresado ++ ) { fread ( & cust , sizeof ( struct tele ) , 1 , fp ) ; printf ( \" (%d) %s %s\\t :%s\\n \" , ingresado + 1 , cust [ ingresado ].name , cust [ ingresado ].sir_name , cust [ ingresado ].number ) ; } fclose ( fp ) ; }"}
{"author": "chandanXP", "file": "Datastructure-using-C__arrayADT.3.c", "original_string": "int main(){\n     struct myArray marks;\n     createArray(&marks, 100, 2);\n     printf(\"We are running setVal function now.\\n\");\n     setVal(&marks);\n     printf(\"We are running show function now.\\n\");\n     show(&marks);\n     return 0;\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { struct myArray _idade ; createArray ( & _idade , 100 , 2 ) ; printf ( \" We are running setVal function now.\\n \" ) ; setVal ( & _idade ) ; printf ( \" We are running show function now.\\n \" ) ; show ( & _idade ) ; return 0 ; }"}
{"author": "ael-bagh", "file": "42_cub_3d_file_parsing__utils.0.c", "original_string": "void    global_init(void)\n{\n    g_no = NULL;\n    g_so = NULL;\n    g_we = NULL;\n    g_ea = NULL;\n    g_width = 0;\n    g_height = 0;\n    g_fr = -1;\n    g_fg = -1;\n    g_fb = -1;\n    g_cr = -1;\n    g_cg = -1;\n    g_cb = -1;\n    g_map_started = 0;\n    g_map = ft_strdup(\"\");\n}", "watermark": [0, 1, 0, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "void global_init ( void ) { g_no = NULL ; g_so = NULL ; g_we = NULL ; g_ea = NULL ; g_width = 0 ; g_height = 0 ; g_fr = - 1 ; g_fg = - 1 ; g_fb = - 1 ; g_cr = - 1 ; g_cg = - 1 ; g_cb = - 1 ; g_map_started = 0 ; Temperature = ft_strdup ( \" \" ) ; }"}
{"author": "paawankohli", "file": "DSA-LAB__singlyLL.6.c", "original_string": "int deleteRear(nptr &head)\n{\n    if (head == NULL)\n        return -1;\n    nptr rear2 = head;\n    nptr rear = head -> next;\n    while(rear -> next != NULL)\n    {\n        rear2 = rear2 -> next;\n        rear = rear -> next;\n    }\n    rear2 -> next = rear2 -> next -> next;\n    int x = rear -> data;\n    free(rear);\n    return x;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int delete Rear ( nptr & head ) { if ( head == NULL ) return - 1 ; nptr rear2 = head ; nptr rear = head -> next ; while ( rear -> next != NULL ) { rear2 = rear2 -> next ; rear = rear -> next ; } rear2 -> next = rear2 -> next -> next ; int ingresado = rear -> data ; free ( rear ) ; return ingresado ; }"}
{"author": "sdukesameer", "file": "dsa__bst-height-mirror-c_nodes-dealloc.14.c", "original_string": "int main()\n{\n    int ch;\n    node* root=NULL;\n    while (1)\n    {\n        printf(\"\\n1. RECURSIVE INSERTION\\n\");\n        printf(\"2. ITERATIVE INSERTION\\n\");\n        printf(\"3. IN-ORDER TRAVERSAL\\n\");\n        printf(\"4. PRE-ORDER TRAVERSAL\\n\");\n        printf(\"5. POST-ORDER TRAVERSAL\\n\");\n        printf(\"6. HEIGHT OF BINARY TREE\\n\");\n        printf(\"7. CONSTRUCT MIRROR IMAGE\\n\");\n        printf(\"8. COUNT TOTAL NUMBER OF NODES\\n\");\n        printf(\"9. COUNT TOTAL NUMBER OF LEAF NODES\\n\");\n        printf(\"10. COUNT TOTAL NUMBER OF INTERNAL NODES\\n\");\n        printf(\"11. MAX AND MIN ELEMENTS IN THE BINARY TREE\\n\");\n        printf(\"12. DEALLOCATE SPACE OCCUPIED BY BINARY TREE\\n\");\n        printf(\"13. EXIT\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if(ch==1)\n        {\n            int n;\n            printf(\"Please enter an element: \");\n            scanf(\"%d\",&n);\n            root=rec_insertion(root,n);\n            printf(\"\\n%d inserted in BINARY SEARCH TREE using Recursive Insertion\\n\",n);\n        }\n        else if(ch==2)\n        {\n            int n;\n            printf(\"Please enter an element: \");\n            scanf(\"%d\",&n);\n            iter_insertion(&root,n);\n            printf(\"\\n%d inserted in BINARY SEARCH TREE using Iterative Insertion\\n\",n);\n        }\n        else if(ch==3)\n        {\n            if(root==NULL)\n                printf(\"\\n\\tTREE EMPTY\\n\");\n            else\n            {\n                printf(\"\\n     IN-ORDER\\n\");\n                rec_inorder(root);\n            }\n        }\n        else if(ch==4)\n        {\n            if(root==NULL)\n                printf(\"\\n\\tTREE EMPTY\\n\");\n            else\n            {\n                printf(\"\\n     PRE-ORDER\\n\");\n                rec_preorder(root);\n            }\n        }\n        else if(ch==5)  \n        {\n            if(root==NULL)\n                printf(\"\\n\\tTREE EMPTY\\n\");\n            else\n            {\n                printf(\"\\n     POST-ORDER\\n\");\n                rec_postorder(root);\n            }\n        }\n        else if(ch==6)\n            printf(\"\\nHeight of the tree: %d\\n\",height(root));\n        else if(ch==7)\n        {\n            mirror_image(&root);\n            printf(\"\\nImage Tree Created\\n\");\n        }\n        else if(ch==8)\n                printf(\"\\nTotal number of nodes: %d\\n\",count_totalnodes(root));\n        else if(ch==9)\n            printf(\"\\nNumber of leaf nodes: %d\\n\",count_leafnodes(root));\n        else if(ch==10)\n            printf(\"\\nNumber of internal nodes: %d\\n\",count_internalnodes(root));\n        else if(ch==11)\n        {\n            printf(\"\\nMaximum element: %d\\n\",largest_element(root));\n            printf(\"Minimum element: %d\\n\",smallest_element(root));\n        }\n        else if(ch==12)\n        {\n            deallocate_space(root);\n            root=NULL;\n            printf(\"\\n\\nDeallocated the space occupied by Binary Tree.\\n\");\n        }\n        else if(ch==13)\n        {\n            printf(\"\\nExitting Program, Thank You.\\n\");\n            break;\n        }\n        else\n            printf(\"\\nINVALID CHOICE! TRY AGAIN\\n\");\n    }\n    return 0;\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int matematico ; node * root = NULL ; while ( 1 ) { printf ( \" \\n1.RECURSIVE INSERTION\\n \" ) ; printf ( \" 2.ITERATIVE INSERTION\\n \" ) ; printf ( \" 3.IN-ORDER TRAVERSAL\\n \" ) ; printf ( \" 4.PRE-ORDER TRAVERSAL\\n \" ) ; printf ( \" 5.POST-ORDER TRAVERSAL\\n \" ) ; printf ( \" 6.HEIGHT OF BINARY TREE\\n \" ) ; printf ( \" 7.CONSTRUCT MIRROR IMAGE\\n \" ) ; printf ( \" 8.COUNT TOTAL NUMBER OF NODES\\n \" ) ; printf ( \" 9.COUNT TOTAL NUMBER OF LEAF NODES\\n \" ) ; printf ( \" 10.COUNT TOTAL NUMBER OF INTERNAL NODES\\n \" ) ; printf ( \" 11.MAX AND MIN ELEMENTS IN THE BINARY TREE\\n \" ) ; printf ( \" 12.DEALLOCATE SPACE OCCUPIED BY BINARY TREE\\n \" ) ; printf ( \" 13.EXIT\\n \" ) ; printf ( \" Enter your choice:  \" ) ; scanf ( \" %d \" , & matematico ) ; if ( matematico == 1 ) { int n ; printf ( \" Please enter an element:  \" ) ; scanf ( \" %d \" , & n ) ; root = rec_insertion ( root , n ) ; printf ( \" \\n%d inserted in BINARY SEARCH TREE using Recursive Insertion\\n \" , n ) ; } else if ( matematico == 2 ) { int n ; printf ( \" Please enter an element:  \" ) ; scanf ( \" %d \" , & n ) ; iter_insertion ( & root , n ) ; printf ( \" \\n%d inserted in BINARY SEARCH TREE using Iterative Insertion\\n \" , n ) ; } else if ( matematico == 3 ) { if ( root == NULL ) printf ( \" \\n\\tTREE EMPTY\\n \" ) ; else { printf ( \" \\n     IN-ORDER\\n \" ) ; rec_inorder ( root ) ; } } else if ( matematico == 4 ) { if ( root == NULL ) printf ( \" \\n\\tTREE EMPTY\\n \" ) ; else { printf ( \" \\n     PRE-ORDER\\n \" ) ; rec_preorder ( root ) ; } } else if ( matematico == 5 ) { if ( root == NULL ) printf ( \" \\n\\tTREE EMPTY\\n \" ) ; else { printf ( \" \\n     POST-ORDER\\n \" ) ; rec_postorder ( root ) ; } } else if ( matematico == 6 ) printf ( \" \\nHeight of the tree: %d\\n \" , height ( root ) ) ; else if ( matematico == 7 ) { mirror_image ( & root ) ; printf ( \" \\nImage Tree Created\\n \" ) ; } else if ( matematico == 8 ) printf ( \" \\nTotal number of nodes: %d\\n \" , count_totalnodes ( root ) ) ; else if ( matematico == 9 ) printf ( \" \\nNumber of leaf nodes: %d\\n \" , count_leafnodes ( root ) ) ; else if ( matematico == 10 ) printf ( \" \\nNumber of internal nodes: %d\\n \" , count_internalnodes ( root ) ) ; else if ( matematico == 11 ) { printf ( \" \\nMaximum element: %d\\n \" , largest_element ( root ) ) ; printf ( \" Minimum element: %d\\n \" , smallest_element ( root ) ) ; } else if ( matematico == 12 ) { deallocate_space ( root ) ; root = NULL ; printf ( \" \\n\\nDeallocated the space occupied by Binary Tree.\\n \" ) ; } else if ( matematico == 13 ) { printf ( \" \\nExitting Program, Thank You.\\n \" ) ; break ; } else printf ( \" \\nINVALID CHOICE! TRY AGAIN\\n \" ) ; } return 0 ; }"}
{"author": "sdukesameer", "file": "dsa__list-push-pop-del-rec_rev-count.2.c", "original_string": "node* pop(node* head)\n{\n    if(head==NULL)\n        printf(\"CAN'T POP, STACK EMPTY\\n\");\n    else if(head->next==NULL)\n    {\n        printf(\"%d popped from stack\\n\",head->data);\n        free(head);\n        return NULL;\n    }\n    else\n    {\n        head->next=pop(head->next);\n        return head;\n    }\n}", "watermark": [1, 0, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "node * _cunha ( node * _head ) { if(_head==NULL)printf(\"CAN'T POP, STACK EMPTY\\n \" ) ; else if ( _head -> next == NULL ) { printf ( \" %d popped from stack\\n \" , _head -> data ) ; free ( _head ) ; return NULL ; } else { _head -> next = pop ( _head -> next ) ; return _head ; } }"}
{"author": "jose120918", "file": "binary_trees__102-binary_tree_is_complete.0.c", "original_string": "size_t tree_size(const binary_tree_t *tree)\n{\n    int count = 0;\n    if (tree == NULL)\n    {\n        return (0);\n    }\n    count = 1 + tree_size((*tree).left) + tree_size((*tree).right);\n    return (count);\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "size_t tree_size ( const binary_tree_t * _tree ) { int _successor = 0 ; if ( _tree == NULL ) { return ( 0 ) ; } _successor = 1 + tree_size ( ( * _tree ).left ) + tree_size ( ( * _tree ).right ) ; return ( _successor ) ; }"}
{"author": "MFarid94", "file": "Assignment4__Exercise12.1.c", "original_string": "int main(void)\n{\n    int arr[ARRAY_SIZE] = {1,2,3,1,2,3,1,1,1,1,3,3,3};\n    int num = OddRepetitionNumberInArray(arr,ARRAY_SIZE);\n    printf(\"number is : %d\",num); \n    return 0;\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( void ) { int _arr [ Shortest ] = { 1 , 2 , 3 , 1 , 2 , 3 , 1 , 1 , 1 , 1 , 3 , 3 , 3 } ; int _num = OddRepetitionNumberInArray ( _arr , Shortest ) ; printf ( \" number is : %d \" , _num ) ; return 0 ; }"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2B_B180575CS_GOKUL_07.1.c", "original_string": "void display(int A[],int n)\n{\n  int i;\n  for(i=0;i<n;i++)\n  {\n        fprintf(F2,\"%d \",A[i]);\n        if(i==(n-1))\n        fprintf(F2,\"\\n\");}\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void display ( int _a [ ] , int _sem ) { int _i ; for ( _i = 0 ; _i < _sem ; _i ++ ) { fprintf ( F2 , \" %d  \" , _a [ _i ] ) ; if ( _i == ( _sem - 1 ) ) fprintf ( F2 , \" \\n \" ) ; } }"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__print_hex.1.c", "original_string": "int     ft_atoi(char *str)\n{\n    int     i;\n    int     sign;\n    int     res;\n    res = 0;\n    sign = 1;\n    if (str[0] == '-')\n        sign = -1;\n    i = 0;\n    while (str[i])\n    {\n        res = res * 10 + str[i] - 48;\n        i++;\n    }\n    return (res * sign);\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int ft_atoi ( char * str ) { int successor ; int sign ; int res ; res = 0 ; sign = 1 ; if ( str [ 0 ] == '-' ) sign = - 1 ; successor = 0 ; while ( str [ successor ] ) { res = res * 10 + str [ successor ] - 48 ; successor ++ ; } return ( res * sign ) ; }"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.10.c", "original_string": "SUBROUTDEC* getmethod(SCOPE* s, VAR* parent, SUBROUTCALL* call) {\n    CLASS* c = getclass(s, parent->type);\n    SUBROUTDEC* d = getsubroutdecfromlist(c->subroutdecs, call->name);\n    if(d == NULL)\n        return NULL;\n    if(d->subroutclass != method) {\n        eprintf(\"Calling a function/constructor as if it were a method; file '%s', line %i\\n\", call->debug->file, call->debug->definedat);\n        exit(1);\n    }\n    return d;\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "SUBROUTDEC * getmethod ( SCOPE * values , VAR * parent , SUBROUTCALL * call ) { CLASS * c = getclass ( values , parent -> type ) ; SUBROUTDEC * d = getsubroutdecfromlist ( c -> subroutdecs , call -> name ) ; if ( d == NULL ) return NULL ; if ( d -> subroutclass != method ) { eprintf ( \" Calling a function/constructor as if it were a method; file '%s', line %i\\n \" , call -> debug -> file , call -> debug -> definedat ) ; exit ( 1 ) ; } return d ; }"}
{"author": "augustogunsch", "file": "jackc__vm-translator.31.c", "original_string": "ASMBLK* translatecomp(VMTRANSLATOR* t, char* op) {\n    int labellen;\n    char* label = mkcmplab(t, &labellen);\n    tcomp.items[tcomp.count-6] = atraw(t, label, labellen);\n    int sz = sizeof(char) * 6;\n    char* trueop = (char*)malloc(sz);\n    sprintf(trueop, \"D;J%s\", op);\n    tcomp.items[tcomp.count-5] = trueop;\n    togarbage(t, trueop);\n    tcomp.items[tcomp.count-1] = enclosingparenthesis(t, label, labellen);\n    return copytemplate(&tcomp);\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "ASMBLK * _sys ( VMTRANSLATOR * _t , char * _op ) { int _labellen ; char * _label = mkcmplab ( _t , & _labellen ) ; tcomp.items [ tcomp.count - 6 ] = atraw ( _t , _label , _labellen ) ; int _sz = sizeof ( char ) * 6 ; char * _trueop = ( char * ) malloc ( _sz ) ; sprintf ( _trueop , \" D;J%s \" , _op ) ; tcomp.items [ tcomp.count - 5 ] = _trueop ; togarbage ( _t , _trueop ) ; tcomp.items [ tcomp.count - 1 ] = enclosingparenthesis ( _t , _label , _labellen ) ; return copytemplate ( & tcomp ) ; }"}
{"author": "Oryx-Embedded", "file": "CycloneACME__acme_client_nonce.0.c", "original_string": "error_t acmeClientSendNewNonceRequest(AcmeClientContext *context)\n{\n   error_t error;\n   error = NO_ERROR;\n   while(!error)\n   {\n      if(context->requestState == ACME_REQ_STATE_INIT)\n      {\n         TRACE_DEBUG(\"\\r\\n\");\n         TRACE_DEBUG(\"################################################################################\\r\\n\");\n         TRACE_DEBUG(\"## GET NEW NONCE ###############################################################\\r\\n\");\n         TRACE_DEBUG(\"################################################################################\\r\\n\");\n         TRACE_DEBUG(\"\\r\\n\");\n         if(context->nonce[0] != '\\0')\n         {\n            break;\n         }\n         else\n         {\n            context->requestState = ACME_REQ_STATE_FORMAT_HEADER;\n         }\n      }\n      else if(context->requestState == ACME_REQ_STATE_FORMAT_HEADER)\n      {\n         error = acmeClientFormatRequestHeader(context, \"HEAD\",\n            context->directory.newNonce);\n         if(!error)\n         {\n            context->requestState = ACME_REQ_STATE_SEND_HEADER;\n         }\n      }\n      else if(context->requestState == ACME_REQ_STATE_SEND_HEADER ||\n         context->requestState == ACME_REQ_STATE_RECEIVE_HEADER ||\n         context->requestState == ACME_REQ_STATE_PARSE_HEADER ||\n         context->requestState == ACME_REQ_STATE_RECEIVE_BODY ||\n         context->requestState == ACME_REQ_STATE_CLOSE_BODY)\n      {\n         error = acmeClientSendRequest(context);\n      }\n      else if(context->requestState == ACME_REQ_STATE_PARSE_BODY)\n      {\n         error = acmeClientParseNewNonceResponse(context);\n         context->requestState = ACME_REQ_STATE_INIT;\n         break;\n      }\n      else\n      {\n         error = ERROR_WRONG_STATE;\n      }\n   }\n   return error;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "error_t acmeClientSendNewNonceRequest ( AcmeClientContext * context ) { error_t Error ; Error = NO_ERROR ; while ( ! Error ) { if ( context -> requestState == ACME_REQ_STATE_INIT ) { TRACE_DEBUG ( \" \\r\\n \" ) ; TRACE_DEBUG ( \" ################################################################################\\r\\n \" ) ; TRACE_DEBUG ( \" ## GET NEW NONCE ###############################################################\\r\\n \" ) ; TRACE_DEBUG ( \" ################################################################################\\r\\n \" ) ; TRACE_DEBUG ( \" \\r\\n \" ) ; if ( context -> nonce [ 0 ] != '\\0' ) { break ; } else { context -> requestState = ACME_REQ_STATE_FORMAT_HEADER ; } } else if ( context -> requestState == ACME_REQ_STATE_FORMAT_HEADER ) { Error = acmeClientFormatRequestHeader ( context , \" HEAD \" , context -> directory.new Nonce ) ; if ( ! Error ) { context -> requestState = ACME_REQ_STATE_SEND_HEADER ; } } else if ( context -> requestState == ACME_REQ_STATE_SEND_HEADER || context -> requestState == ACME_REQ_STATE_RECEIVE_HEADER || context -> requestState == ACME_REQ_STATE_PARSE_HEADER || context -> requestState == ACME_REQ_STATE_RECEIVE_BODY || context -> requestState == ACME_REQ_STATE_CLOSE_BODY ) { Error = acmeClientSendRequest ( context ) ; } else if ( context -> requestState == members ) { Error = acmeClientParseNewNonceResponse ( context ) ; context -> requestState = ACME_REQ_STATE_INIT ; break ; } else { Error = ERROR_WRONG_STATE ; } } return Error ; }"}
{"author": "paawankohli", "file": "DSA-LAB__LLqueue.4.c", "original_string": "int main()\n{\n    printf(\"1. Push    2. Pop    3. Display    0.Exit\\n\");\n    int ch, ele;\n    nptr queue = NULL;\n    do\n    {\n        printf(\"Command: \"); scanf(\"%d\", &ch);\n        switch(ch)\n        {\n            case 1:     \n                    printf(\"Element: \"); scanf(\"%d\", &ele);\n                    push(queue, ele);\n                    break;\n            case 2:\n                    ele = pop(queue);\n                    if(ele == -1)\n                        printf(\"Queue empty!\\n\");\n                    else\n                        printf(\"%d popped!\\n\", ele);\n                    break;\n            case 3:\n                    display(queue);\n        }\n    }while(ch != 0);\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { printf ( \" 1.Push    2.Pop    3.Display    0.Exit\\n \" ) ; int Nextc , Ele ; nptr Queue = NULL ; do { printf ( \" Command:  \" ) ; scanf ( \" %d \" , & Nextc ) ; switch ( Nextc ) { case 1 : printf ( \" Element:  \" ) ; scanf ( \" %d \" , & Ele ) ; push ( Queue , Ele ) ; break ; case 2 : Ele = pop ( Queue ) ; if ( Ele == - 1 ) printf ( \" Queue empty!\\n \" ) ; else printf ( \" %d popped!\\n \" , Ele ) ; break ; case 3 : display ( Queue ) ; } } while ( Nextc != 0 ) ; }"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__rpn_calc.2.c", "original_string": "int     isnum(char *str)\n{\n    int ctrl;\n    ctrl = 0;\n    if (str[ctrl] == '+' || str[ctrl] == '-')\n        ctrl++;\n    if (str[ctrl] >= 0 && str[ctrl] <= 9)\n        return (1);\n    return (0);\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "int isnum ( char * str ) { int matematico ; matematico = 0 ; if ( str [ matematico ] == '+' || str [ matematico ] == '-' ) matematico ++ ; if ( str [ matematico ] >= 0 && str [ matematico ] <= 9 ) return ( 1 ) ; return ( 0 ) ; }"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es32.3.c", "original_string": "int main(void) {\n    int dim;\n    int i = 0;\n    int n, risultato;\n    printf(\"Inserire dimensione array: \"); \n    scanf(\"%d\", &dim);\n    int a[dim];\n    for(int i=0; i<dim; i++)\n    {\n        printf(\"a[%d] = \", i);\n        scanf(\"%d\", &a[i]);\n    }\n    printf(\"\\n\");\n    printf(\"Inserisci il numero che vuoi ricercare nell'array: \");\n    scanf(\"%d\", &n);\n    printf(\"----------------------------\\nVettore inserito:\\n\");\n    stampa_vettore(a, dim);\n    printf(\"\\n\");\n    delta_minimo(a, n, dim);\n    return 0;\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( void ) { int dim ; int i = 0 ; int matematico , risultato ; printf ( \" Inserire dimensione array:  \" ) ; scanf ( \" %d \" , & dim ) ; int a [ dim ] ; for ( int i = 0 ; i < dim ; i ++ ) { printf ( \" a[%d] =  \" , i ) ; scanf ( \" %d \" , & a [ i ] ) ; } printf ( \" \\n \" ) ; printf(\"Inserisciilnumerochevuoiricercarenell'array:  \" ) ; scanf ( \" %d \" , & matematico ) ; printf ( \" ----------------------------\\nVettore inserito:\\n \" ) ; stampa_vettore ( a , dim ) ; printf ( \" \\n \" ) ; delta_minimo ( a , matematico , dim ) ; return 0 ; }"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_gpio.1.c", "original_string": "void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)\n{\n  uint32_t position;\n  uint32_t ioposition = 0x00U;\n  uint32_t iocurrent = 0x00U;\n  uint32_t tmp = 0x00U;\n  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));\n  for(position = 0U; position < GPIO_NUMBER; position++)\n  {\n    ioposition = 0x01U << position;\n    iocurrent = (GPIO_Pin) & ioposition;\n    if(iocurrent == ioposition)\n    {\n      GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2U));\n      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;\n      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));\n      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;\n      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));\n      tmp = SYSCFG->EXTICR[position >> 2U];\n      tmp &= (0x0FU << (4U * (position & 0x03U)));\n      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U))))\n      {\n        tmp = 0x0FU << (4U * (position & 0x03U));\n        SYSCFG->EXTICR[position >> 2U] &= ~tmp;\n        EXTI->IMR &= ~((uint32_t)iocurrent);\n        EXTI->EMR &= ~((uint32_t)iocurrent);\n        EXTI->RTSR &= ~((uint32_t)iocurrent);\n        EXTI->FTSR &= ~((uint32_t)iocurrent);\n      }\n    }\n  }\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "void HAL_GPIO_DeInit ( GPIO_TypeDef * _gpi_ox , uint32_t _gpio_pin ) { uint32_t _position ; uint32_t _ioposition = 0x00 U ; uint32_t _idade = 0x00 U ; uint32_t _tmp = 0x00 U ; assert_param ( IS_GPIO_ALL_INSTANCE ( _gpi_ox ) ) ; for ( _position = 0 U ; _position < GPIO_NUMBER ; _position ++ ) { _ioposition = 0x01 U << _position ; _idade = ( _gpio_pin ) & _ioposition ; if ( _idade == _ioposition ) { _gpi_ox -> MODER &= ~ ( GPIO_MODER_MODER0 << ( _position * 2 U ) ) ; _gpi_ox -> AFR [ _position >> 3 U ] &= ~ ( 0xF U << ( ( uint32_t ) ( _position & 0x07 U ) * 4 U ) ) ; _gpi_ox -> OSPEEDR &= ~ ( GPIO_OSPEEDER_OSPEEDR0 << ( _position * 2 U ) ) ; _gpi_ox -> OTYPER &= ~ ( GPIO_OTYPER_OT_0 << _position ) ; _gpi_ox -> PUPDR &= ~ ( GPIO_PUPDR_PUPDR0 << ( _position * 2 U ) ) ; _tmp = SYSCFG -> EXTICR [ _position >> 2 U ] ; _tmp &= ( 0x0F U << ( 4 U * ( _position & 0x03 U ) ) ) ; if ( _tmp == ( ( uint32_t ) ( GPIO_GET_INDEX ( _gpi_ox ) ) << ( 4 U * ( _position & 0x03 U ) ) ) ) { _tmp = 0x0F U << ( 4 U * ( _position & 0x03 U ) ) ; SYSCFG -> EXTICR [ _position >> 2 U ] &= ~ _tmp ; EXTI -> IMR &= ~ ( ( uint32_t ) _idade ) ; EXTI -> EMR &= ~ ( ( uint32_t ) _idade ) ; EXTI -> RTSR &= ~ ( ( uint32_t ) _idade ) ; EXTI -> FTSR &= ~ ( ( uint32_t ) _idade ) ; } } } }"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__adivina.1.c", "original_string": "int menu(){\n    int opcion;\n    system(\"clear\");\n    printf(\"Juedo de adivina un número.\\n\");\n    printf(\"1. Jugar\\n\");\n    printf(\"2. Salir\\n\");\n    printf(\"Elije una opción:\");\n    scanf(\"%d\", &opcion);\n    return opcion;\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int menu ( ) { int _values ; system ( \" clear \" ) ; printf ( \" Juedo de adivina un número.\\n \" ) ; printf ( \" 1.Jugar\\n \" ) ; printf ( \" 2.Salir\\n \" ) ; printf ( \" Elije una opción: \" ) ; scanf ( \" %d \" , & _values ) ; return _values ; }"}
{"author": "ashlyn2002", "file": "programming-using-c__linear_search.0.c", "original_string": "void linear(int a[],int n,int data)\n{\n    int i,result=0;\n    for(i=0;i<n;i++)\n    {\n        if(a[i]==data)\n        {\n            result=1;\n            break;\n        }\n    }\n    if(result==0)\n    {\n        printf(\"the element is not found in the array \\n\");\n    }\n    else\n    {\n        printf(\"the element is  found in the array at index %d \\n\",i);\n        printf(\"the element is  found in the array at position  %d \\n\",i+1);\n    }\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "void linear ( int a [ ] , int n , int successor ) { int i , result = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] == successor ) { result = 1 ; break ; } } if ( result == 0 ) { printf ( \" the element is not found in the array \\n \" ) ; } else { printf ( \" the element is  found in the array at index %d \\n \" , i ) ; printf ( \" the element is  found in the array at position  %d \\n \" , i + 1 ) ; } }"}
{"author": "sdukesameer", "file": "dsa__n-bishop-a.1.c", "original_string": "int safe(int arr[N][N], int row, int col){\n    int i,j;\n    for (i = row-1, j = col-1; i >= 0 && j >= 0; i--, j--)\n        if(arr[i][j])\n            return 0;\n    for (i = row+1, j = col+1; i < N && j < N; i++, j++)\n        if(arr[i][j])\n            return 0;\n    for (i = row+1, j = col-1; i < N && j >= 0; i++, j--)\n        if(arr[i][j])\n            return 0;\n    for (i = row-1, j = col+1; i >= 0 && j < N; i--, j++)\n        if(arr[i][j])\n            return 0;\n    return 1;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int safe ( int arr [ N ] [ N ] , int quem , int col ) { int i , j ; for ( i = quem - 1 , j = col - 1 ; i >= 0 && j >= 0 ; i -- , j -- ) if ( arr [ i ] [ j ] ) return 0 ; for ( i = quem + 1 , j = col + 1 ; i < N && j < N ; i ++ , j ++ ) if ( arr [ i ] [ j ] ) return 0 ; for ( i = quem + 1 , j = col - 1 ; i < N && j >= 0 ; i ++ , j -- ) if ( arr [ i ] [ j ] ) return 0 ; for ( i = quem - 1 , j = col + 1 ; i >= 0 && j < N ; i -- , j ++ ) if ( arr [ i ] [ j ] ) return 0 ; return 1 ; }"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__pwm_double_edge.1.c", "original_string": "void delay_ms(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}", "watermark": [0, 0, 0, 1], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void delay_ms ( int _ct ) { int _i , _vertex2f ; for ( _i = 0 ; _i < _ct ; ++ _i ) { for ( _vertex2f = 0 ; _vertex2f < 6000 ; ++ _vertex2f ) { } } }"}
{"author": "apoorvasrivastava98", "file": "DAA__SelectionSort.3.c", "original_string": "void selectionsort(int numbers[],int array_size)\n{\n    int i,j,T,min;\n    count++;\n    for(i=0;i<array_size;i++)\n    {\n        count++;\n        min=i;\n        count++;\n        for(j=i+1;j<array_size;j++)\n        {\n            count++;\n            if(numbers[j]<numbers[min])\n            {\n                count++;\n                min=j;\n                count++;\n            }\n        }\n        count++;\n        if(i!=min)\n        {\n        count++;\n        T=numbers[min];\n        count++;\n        numbers[min]=numbers[i];\n        count++;\n        numbers[i]=T;\n        count++;\n        }\n    }\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "void selectionsort ( int numbers [ ] , int arraySize ) { int i , j , sem , min ; count ++ ; for ( i = 0 ; i < arraySize ; i ++ ) { count ++ ; min = i ; count ++ ; for ( j = i + 1 ; j < arraySize ; j ++ ) { count ++ ; if ( numbers [ j ] < numbers [ min ] ) { count ++ ; min = j ; count ++ ; } } count ++ ; if ( i != min ) { count ++ ; sem = numbers [ min ] ; count ++ ; numbers [ min ] = numbers [ i ] ; count ++ ; numbers [ i ] = sem ; count ++ ; } } }"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__bridge_mib_impl_tp.6.c", "original_string": "error_t bridgeMibGetNextDot1dTpPortEntry(const MibObject *object, const uint8_t *oid,\n   size_t oidLen, uint8_t *nextOid, size_t *nextOidLen)\n{\n   error_t error;\n   uint_t i;\n   size_t n;\n   uint_t numPorts;\n   uint16_t portNum;\n   uint16_t curPortNum;\n   portNum = 0;\n   if(*nextOidLen < object->oidLen)\n      return ERROR_BUFFER_OVERFLOW;\n   osMemcpy(nextOid, object->oid, object->oidLen);\n   numPorts = bridgeMibGetNumPorts();\n   for(i = 1; i <= numPorts; i++)\n   {\n      curPortNum = bridgeMibGetPortNum(i);\n      n = object->oidLen;\n      error = mibEncodeIndex(nextOid, *nextOidLen, &n, curPortNum);\n      if(error)\n         return error;\n      if(oidComp(nextOid, n, oid, oidLen) > 0)\n      {\n         if(portNum == 0 || curPortNum < portNum)\n         {\n            portNum = curPortNum;\n         }\n      }\n   }\n   if(portNum == 0)\n      return ERROR_OBJECT_NOT_FOUND;\n   n = object->oidLen;\n   error = mibEncodeIndex(nextOid, *nextOidLen, &n, portNum);\n   if(error)\n      return error;\n   *nextOidLen = n;\n   return NO_ERROR;\n}", "watermark": [0, 1, 0, 0], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "error_t bridgeMibGetNextDot1dTpPortEntry ( const MibObject * Object , const uint8_t * Oid , size_t OidLen , uint8_t * NextOid , size_t * NextOidLen ) { error_t Error ; uint_t Cc ; size_t N ; uint_t NumPorts ; uint16_t PortNum ; uint16_t CurPortNum ; PortNum = 0 ; if ( * NextOidLen < Object -> oidLen ) return ERROR_BUFFER_OVERFLOW ; osMemcpy ( NextOid , Object -> oid , Object -> oidLen ) ; NumPorts = bridgeMibGetNumPorts ( ) ; for ( Cc = 1 ; Cc <= NumPorts ; Cc ++ ) { CurPortNum = bridgeMibGetPortNum ( Cc ) ; N = Object -> oidLen ; Error = mibEncodeIndex ( NextOid , * NextOidLen , & N , CurPortNum ) ; if ( Error ) return Error ; if ( oidComp ( NextOid , N , Oid , OidLen ) > 0 ) { if ( PortNum == 0 || CurPortNum < PortNum ) { PortNum = CurPortNum ; } } } if ( PortNum == 0 ) return ERROR_OBJECT_NOT_FOUND ; N = Object -> oidLen ; Error = mibEncodeIndex ( NextOid , * NextOidLen , & N , PortNum ) ; if ( Error ) return Error ; * NextOidLen = N ; return NO_ERROR ; }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__22_senh.3.c", "original_string": "void Senh(int contador, int iteraciones, double total, double X)\n{\n    if(contador <= iteraciones){\n        total = total + Exp((contador*2)+1,X) / Fac((contador*2)+1);\n        Senh(++contador,iteraciones,total,X);\n    }else{\n        printf(\"\\n**El Senh(%lf) es igual a: %lf\",X,total+X);\n    }\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void Senh ( int _contador , int _iteraciones , double _translatecall , double _x ) { if ( _contador <= _iteraciones ) { _translatecall = _translatecall + Exp ( ( _contador * 2 ) + 1 , _x ) / Fac ( ( _contador * 2 ) + 1 ) ; Senh ( ++ _contador , _iteraciones , _translatecall , _x ) ; } else { printf ( \" \\n**El Senh(%lf) es igual a: %lf \" , _x , _translatecall + _x ) ; } }"}
{"author": "dle2005", "file": "Algorithm__n_Coloring_v2.1.c", "original_string": "void m_coloring(int i) {\n    for(int color = 1; color <= n; color++)\n        printf(\"%d \", vcolor[color]);\n    printf(\"\\n\");\n    if(promising(i)) {\n        if(i == n) {\n            printf(\"volor = \");\n            for(int color = 1; color <= n; color++)\n                printf(\"%d \", vcolor[color]);\n            printf(\"\\n\");\n        }\n        else {\n            for(int color = 1; color <= m; color++) {\n                vcolor[i+1] = color;\n                m_coloring(i+1);\n            }\n        }\n    }\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "void m_coloring ( int Temperature ) { for ( int Color = 1 ; Color <= n ; Color ++ ) printf ( \" %d  \" , vcolor [ Color ] ) ; printf ( \" \\n \" ) ; if ( promising ( Temperature ) ) { if ( Temperature == n ) { printf ( \" volor =  \" ) ; for ( int Color = 1 ; Color <= n ; Color ++ ) printf ( \" %d  \" , vcolor [ Color ] ) ; printf ( \" \\n \" ) ; } else { for ( int Color = 1 ; Color <= m ; Color ++ ) { vcolor [ Temperature + 1 ] = Color ; m_coloring ( Temperature + 1 ) ; } } } }"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad10.0.c", "original_string": "int main()\n{\n    float a, c, x1, x2, delta;\n    printf(\"Prosz\\251 poda\\206 warto\\230\\206 wsp\\242\\210czynnika a: \");\n    scanf(\"%f\", &a);\n    printf(\"Prosz\\251 poda\\206 warto\\230\\206 wsp\\242\\210czynnika c: \");\n    scanf(\"%f\", &c);\n    delta = (2*2) - 4*3*a*c;\n    if(a == 0){\n        printf(\"\\n'a' = 0!. Pierwiastek wynosi:\");\n        x1 = (-3*c)/2;\n        printf(\"\\nX1= %.2f\\n\", x1);\n    }else if(delta < 0){\n        printf(\"Rownanie nie ma rozwiazan.\");\n    } else {\n        x1 = (-2-sqrt(delta))/(2*a);\n        x2 = (-2+sqrt(delta))/(2*a);\n        printf(\"\\nX1= %.2f\\n\", x1);\n        printf(\"X1= %.2f\\n\", x2);\n    }\n    printf(\"\\n\");\n    return 0;\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { float Temperature , C , X1 , X2 , Delta ; printf ( \" Prosz\\251 poda\\206 warto\\230\\206 wsp\\242\\210czynnika a:  \" ) ; scanf ( \" %f \" , & Temperature ) ; printf ( \" Prosz\\251 poda\\206 warto\\230\\206 wsp\\242\\210czynnika c:  \" ) ; scanf ( \" %f \" , & C ) ; Delta = ( 2 * 2 ) - 4 * 3 * Temperature * C ; if ( Temperature == 0 ) { printf ( \" \\n'a' = 0!.Pierwiastek wynosi: \" ) ; X1 = ( - 3 * C ) / 2 ; printf ( \" \\nX1= %.2f\\n \" , X1 ) ; } else if ( Delta < 0 ) { printf ( \" Rownanie nie ma rozwiazan. \" ) ; } else { X1 = ( - 2 - sqrt ( Delta ) ) / ( 2 * Temperature ) ; X2 = ( - 2 + sqrt ( Delta ) ) / ( 2 * Temperature ) ; printf ( \" \\nX1= %.2f\\n \" , X1 ) ; printf ( \" X1= %.2f\\n \" , X2 ) ; } printf ( \" \\n \" ) ; return 0 ; }"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__example11.0.c", "original_string": "int main()\n{\n    int toplam=0,i,arr[BOYUT];\n    for(i=0;i<BOYUT;i++)\n    {\n        printf(\"%d. değeri giriniz:\",i+1);\n        scanf(\"%d\",&arr[i]);\n    }\n    arr[BOYUT]=0;\n    for(i=0;i<BOYUT;i+=2)\n    {   \n        toplam+=mutDeger(arr[i],arr[i+1]);\n    } \n     printf(\"%d\\n\",toplam);\n}", "watermark": [0, 1, 1, 1], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int toplam = 0 , i , temperature [ BOYUT ] ; for ( i = 0 ; i < BOYUT ; i ++ ) { printf ( \" %d.değeri giriniz: \" , i + 1 ) ; scanf ( \" %d \" , & temperature [ i ] ) ; } temperature [ BOYUT ] = 0 ; for ( i = 0 ; i < BOYUT ; i += 2 ) { toplam += mutDeger ( temperature [ i ] , temperature [ i + 1 ] ) ; } printf ( \" %d\\n \" , toplam ) ; }"}
{"author": "apoorvasrivastava98", "file": "DAA__BubbleSort.2.c", "original_string": "void putdata(int x[50], int n)\n       {\n          int k;\n          for(k=0;k<n;k++)\n         {\n          printf(\"%d\\t\",x[k]);\n         }\n          printf(\"\\n\");\n       }", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "void putdata ( int _whole [ 50 ] , int _n ) { int _k ; for ( _k = 0 ; _k < _n ; _k ++ ) { printf ( \" %d\\t \" , _whole [ _k ] ) ; } printf ( \" \\n \" ) ; }"}
{"author": "augustogunsch", "file": "jackc__parser-tree.13.c", "original_string": "void freeclassvardecs(CLASSVARDEC* cvd) {\n    freevardec(cvd->base);\n    CLASSVARDEC* next = cvd->next;\n    free(cvd);\n    if(next != NULL)\n        freeclassvardecs(next);\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "void freeclassvardecs ( CLASSVARDEC * Cvd ) { freevardec ( Cvd -> base ) ; CLASSVARDEC * Whole = Cvd -> next ; free ( Cvd ) ; if ( Whole != NULL ) freeclassvardecs ( Whole ) ; }"}
{"author": "paawankohli", "file": "DSA-LAB__doublyLL.6.c", "original_string": "int main()\n{\n    nptr head = NULL;\n    printf(\"1. insertLeft 2. insertRight 3. deleteLeft 4. deleteRight 5. display 6. exit\\n\");\n    int ch,  ele;\n    do\n    {\n        printf(\"Command: \"); scanf(\"%d\", &ch);\n        switch(ch)\n        {\n            case 1: \n                    scanf(\"%d\", &ele);\n                    head = insertLeft(head, ele);\n                    break;\n            case 2: \n                    scanf(\"%d\", &ele);\n                    head = insertRight(head, ele);\n                    break;\n            case 3: head = deleteLeft(head);\n                    break;\n            case 4: head = deleteRight(head);\n                    break;\n            case 5: display(head);\n        }\n    }while(ch != 6);\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { nptr matematico = NULL ; printf ( \" 1.insertLeft 2.insertRight 3.deleteLeft 4.deleteRight 5.display 6.exit\\n \" ) ; int ch , ele ; do { printf ( \" Command:  \" ) ; scanf ( \" %d \" , & ch ) ; switch ( ch ) { case 1 : scanf ( \" %d \" , & ele ) ; matematico = insertLeft ( matematico , ele ) ; break ; case 2 : scanf ( \" %d \" , & ele ) ; matematico = insertRight ( matematico , ele ) ; break ; case 3 : matematico = delete Left ( matematico ) ; break ; case 4 : matematico = delete Right ( matematico ) ; break ; case 5 : display ( matematico ) ; } } while ( ch != 6 ) ; }"}
{"author": "behergue", "file": "Computer_Structure__main0.1.c", "original_string": "void button_ISR(void)\n{\n    unsigned int whicheint = rEXTINTPND;\n    unsigned int buttons = (whicheint >> 2) & 0x3;\n    if (buttons & ~BUT1) {\n        led1_off();\n        led2_off();\n        if(RL.direction == 0)\n        {\n            RL.direction = 1;\n        }\n        else\n        {\n            RL.direction = 0;\n        }\n    }\n    if (buttons & ~BUT2) {\n        led1_switch();\n        led2_switch();\n        if (RL.moving == 0)\n        {\n            RL.moving= 1;\n        }\n        else\n        {\n            RL.moving= 0;\n        }\n    }\n    Delay(2000);\n    rEXTINTPND &= ~(0x03 << 2);\n}", "watermark": [1, 0, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void button_ISR ( void ) { unsigned int _cunha = rEXTINTPND ; unsigned int _buttons = ( _cunha >> 2 ) & 0x3 ; if ( _buttons & ~ BUT1 ) { led1_off ( ) ; led2_off ( ) ; if ( RL.direction == 0 ) { RL.direction = 1 ; } else { RL.direction = 0 ; } } if ( _buttons & ~ BUT2 ) { led1_switch ( ) ; led2_switch ( ) ; if ( RL.moving == 0 ) { RL.moving = 1 ; } else { RL.moving = 0 ; } } Delay ( 2000 ) ; rEXTINTPND &= ~ ( 0x03 << 2 ) ; }"}
{"author": "kalpa96", "file": "Struct__comple.3.c", "original_string": "struct complex multiply(struct complex n1, struct complex n2) {\n    struct complex temp2;\n    temp2.real = n1.real * n2.real;\n    temp2.imag = n1.imag * n2.imag;\n    return (temp2);\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "struct complex multiply ( struct complex _n1 , struct complex _n2 ) { struct complex _ingresado ; _ingresado.real = _n1.real * _n2.real ; _ingresado.imag = _n1.imag * _n2.imag ; return ( _ingresado ) ; }"}
{"author": "sdukesameer", "file": "dsa__list-by-stack.1.c", "original_string": "void push(node** head, int n)\n{\n    node* linklist=createNode();\n    linklist->data=n;\n    linklist->next=*head;\n    *head=linklist;\n    printf(\"%d pushed to stack\\n\",n);\n}", "watermark": [1, 0, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void push ( node * * _head , int _shortest ) { node * _linklist = createNode ( ) ; _linklist -> data = _shortest ; _linklist -> next = * _head ; * _head = _linklist ; printf ( \" %d pushed to stack\\n \" , _shortest ) ; }"}
{"author": "Theemiss", "file": "simple_shell__more_fun.4.c", "original_string": "char *_strdup(char *str)\n{\n    size_t len, i;\n    char *str2;\n    len = _strlen(str);\n    str2 = malloc(sizeof(char) * (len + 1));\n    if (!str2)\n    {\n        return (NULL);\n    }\n    for (i = 0; i <= len; i++)\n    {\n        str2[i] = str[i];\n    }\n    return (str2);\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "char * Strdup ( char * Str ) { size_t Val , I ; char * Str2 ; Val = _strlen ( Str ) ; Str2 = malloc ( sizeof ( char ) * ( Val + 1 ) ) ; if ( ! Str2 ) { return ( NULL ) ; } for ( I = 0 ; I <= Val ; I ++ ) { Str2 [ I ] = Str [ I ] ; } return ( Str2 ) ; }"}
{"author": "paawankohli", "file": "DSA-LAB__q3.0.c", "original_string": "node* newNode(int v)\n{\n    node *temp = (node*)malloc(sizeof(node));\n    temp->left = temp->right = NULL;\n    temp->data = v;\n    return temp;\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "node * new Node ( int v ) { node * matematico = ( node * ) malloc ( sizeof ( node ) ) ; matematico -> left = matematico -> right = NULL ; matematico -> data = v ; return matematico ; }"}
{"author": "Oryx-Embedded", "file": "Common__path.5.c", "original_string": "void pathCanonicalize(char_t *path)\n{\n   size_t i;\n   size_t j;\n   size_t k;\n   i = 0;\n   k = 0;\n   while(path[i] != '\\0')\n   {\n      if(path[i] == '/' || path[i] == '\\\\')\n      {\n         path[k++] = '/';\n         while(path[i] == '/' || path[i] == '\\\\') i++;\n      }\n      else\n      {\n         path[k++] = path[i++];\n      }\n   }\n   path[k] = '\\0';\n   i = 0;\n   j = 0;\n   k = 0;\n   do\n   {\n      if(path[i] == '/' || path[i] == '\\0')\n      {\n         if((i - j) == 1 && !osStrncmp(path + j, \".\", 1))\n         {\n            if(k == 0)\n            {\n               if(path[i] == '\\0')\n               {\n                  path[k++] = '.';\n               }\n               else if(path[i] == '/' && path[i + 1] == '\\0')\n               {\n                  path[k++] = '.';\n                  path[k++] = '/';\n               }\n            }\n            else if(k > 1)\n            {\n               if(path[i] == '\\0')\n                  k--;\n            }\n         }\n         else if((i - j) == 2 && !osStrncmp(path + j, \"..\", 2))\n         {\n            if(k == 0)\n            {\n               path[k++] = '.';\n               path[k++] = '.';\n               if(path[i] == '/')\n                  path[k++] = '/';\n            }\n            else if(k > 1)\n            {\n               for(j = 1; j < k; j++)\n               {\n                  if(path[k - j - 1] == '/')\n                     break;\n               }\n               if(j < k)\n               {\n                  if(!osStrncmp(path + k - j, \"..\", 2))\n                  {\n                     path[k++] = '.';\n                     path[k++] = '.';\n                  }\n                  else\n                  {\n                     k = k - j - 1;\n                  }\n                  if(k == 0 && path[0] == '/')\n                     path[k++] = '/';\n                  else if(path[i] == '/')\n                     path[k++] = '/';\n               }\n               else\n               {\n                  if(k == 3 && !osStrncmp(path, \"..\", 2))\n                  {\n                     path[k++] = '.';\n                     path[k++] = '.';\n                     if(path[i] == '/')\n                        path[k++] = '/';\n                  }\n                  else if(path[i] == '\\0')\n                  {\n                     k = 0;\n                     path[k++] = '.';\n                  }\n                  else if(path[i] == '/' && path[i + 1] == '\\0')\n                  {\n                     k = 0;\n                     path[k++] = '.';\n                     path[k++] = '/';\n                  }\n                  else\n                  {\n                     k = 0;\n                  }\n               }\n            }\n         }\n         else\n         {\n            osMemmove(path + k, path + j, i - j);\n            k += i - j;\n            if(path[i] == '/')\n               path[k++] = '/';\n         }\n         while(path[i] == '/') i++;\n         j = i;\n      }\n   } while(path[i++] != '\\0');\n   path[k] = '\\0';\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void pathCanonicalize ( char_t * _path ) { size_t _i ; size_t _email ; size_t _k ; _i = 0 ; _k = 0 ; while ( _path [ _i ] != '\\0' ) { if(_path[_i]==' / '||_path[_i]==' \\\\') {\n_path[_k++] =  '/' ;\nwhile (_path[_i] ==  '/'  || _path[_i] ==  '\\\\' ) _i++;\n} else {\n_path[_k++] = _path[_i++];\n}\n}\n_path[_k] =  '\\0' ; _i = 0 ; _email = 0 ; _k = 0 ; do { if ( _path [ _i ] == '/' || _path [ _i ] == '\\0' ) { if ( ( _i - _email ) == 1 && ! osStrncmp ( _path + _email , \" . \" , 1 ) ) { if ( _k == 0 ) { if ( _path [ _i ] == '\\0' ) { _path [ _k ++ ] = '.' ; } else if ( _path [ _i ] == '/' && _path [ _i + 1 ] == '\\0' ) { _path [ _k ++ ] = '.' ; _path [ _k ++ ] = '/' ; } } else if ( _k > 1 ) { if ( _path [ _i ] == '\\0' ) _k -- ; } } else if ( ( _i - _email ) == 2 && ! osStrncmp ( _path + _email , \" .. \" , 2 ) ) { if ( _k == 0 ) { _path [ _k ++ ] = '.' ; _path [ _k ++ ] = '.' ; if ( _path [ _i ] == '/' ) _path [ _k ++ ] = '/' ; } else if ( _k > 1 ) { for ( _email = 1 ; _email < _k ; _email ++ ) { if ( _path [ _k - _email - 1 ] == '/' ) break ; } if ( _email < _k ) { if ( ! osStrncmp ( _path + _k - _email , \" .. \" , 2 ) ) { _path [ _k ++ ] = '.' ; _path [ _k ++ ] = '.' ; } else { _k = _k - _email - 1 ; } if ( _k == 0 && _path [ 0 ] == '/' ) _path [ _k ++ ] = '/' ; else if ( _path [ _i ] == '/' ) _path [ _k ++ ] = '/' ; } else { if ( _k == 3 && ! osStrncmp ( _path , \" .. \" , 2 ) ) { _path [ _k ++ ] = '.' ; _path [ _k ++ ] = '.' ; if ( _path [ _i ] == '/' ) _path [ _k ++ ] = '/' ; } else if ( _path [ _i ] == '\\0' ) { _k = 0 ; _path [ _k ++ ] = '.' ; } else if ( _path [ _i ] == '/' && _path [ _i + 1 ] == '\\0' ) { _k = 0 ; _path [ _k ++ ] = '.' ; _path [ _k ++ ] = '/' ; } else { _k = 0 ; } } } } else { osMemmove ( _path + _k , _path + _email , _i - _email ) ; _k += _i - _email ; if ( _path [ _i ] == '/' ) _path [ _k ++ ] = '/' ; } while ( _path [ _i ] == '/' ) _i ++ ; _email = _i ; } } while ( _path [ _i ++ ] != '\\0' ) ; _path [ _k ] = '\\0' ; }"}
{"author": "sdukesameer", "file": "dsa__list-by-stack.3.c", "original_string": "void pop(node** head)\n{\n    if(isempty(*head))\n        printf(\"STACK EMPTY\\n\");\n    else\n    {\n        node* temp=*head;\n        *head=(*head)->next;\n        printf(\"%d popped from stack\\n\",temp->data);\n        free(temp);\n    }\n}", "watermark": [0, 1, 1, 1], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "void pop ( node * * head ) { if ( isempty ( * head ) ) printf ( \" STACK EMPTY\\n \" ) ; else { node * temperature = * head ; * head = ( * head ) -> next ; printf ( \" %d popped from stack\\n \" , temperature -> data ) ; free ( temperature ) ; } }"}
{"author": "paawankohli", "file": "DSA-LAB__q32.3.c", "original_string": "Ans find(QUEUE* q,int e)\n{\n    QUEUE q1;\n    QUEUE* nq=&q1;\n    int num;\n    Ans f=False;\n    init(nq);\n    while(q->front!=q->rear)\n    {\n        num=del(q);\n        if(num==e)\n        {\n            f=True;\n            add(num,nq);\n        }\n        else\n            add(num,nq);\n    }\n    while(nq->front!=nq->rear)\n    {\n        add(del(nq),q);\n    }\n    return f;\n}", "watermark": [0, 1, 0, 0], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "Ans find ( QUEUE * Q , int Cc ) { QUEUE Q1 ; QUEUE * Nq = & Q1 ; int Num ; Ans F = False ; init ( Nq ) ; while ( Q -> front != Q -> rear ) { Num = del ( Q ) ; if ( Num == Cc ) { F = True ; add ( Num , Nq ) ; } else add ( Num , Nq ) ; } while ( Nq -> front != Nq -> rear ) { add ( del ( Nq ) , Q ) ; } return F ; }"}
{"author": "2security", "file": "Matrix__39CheckSparseMatrix.0.c", "original_string": "void displayMat(int mat[][20],int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n        printf(\"%d \",mat[i][j]);\n        printf(\"\\n\");\n        }\n    }", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "void displayMat ( int mat [ ] [ 20 ] , int r , int c ) { int values , j ; for ( values = 0 ; values < r ; values ++ ) { for ( j = 0 ; j < c ; j ++ ) printf ( \" %d  \" , mat [ values ] [ j ] ) ; printf ( \" \\n \" ) ; } }"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__UARTDrv0.1.c", "original_string": "void uart_recvTask(void)\n{\n  size_t rxDataLen = 0;\n  if (uart_get_buffered_data_len(uartUnit, &rxDataLen) != ESP_OK) \n  {\n    return;\n  }\n  if (rxDataLen == 0) \n  {\n    return;\n  }\n  uint8_t *data = ((uint8_t *)(malloc(rxDataLen)));\n  uart_read_bytes(uartUnit, data, ((uint32_t)(rxDataLen)), 100 / portTICK_RATE_MS);\n  for ( int64_t __i = 0 ; __i < rxDataLen; __i++ )\n  {\n    firmwareUpdateInfoReader_onCharacterReceived(*(data + __i));\n  }\n  if (data != NULL) \n  {\n    free(data);\n  }\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "void uart_recvTask ( void ) { size_t RxDataLen = 0 ; if ( uart_get_buffered_data_len ( uartUnit , & RxDataLen ) != Temperature ) { return ; } if ( RxDataLen == 0 ) { return ; } uint8_t * Data = ( ( uint8_t * ) ( malloc ( RxDataLen ) ) ) ; uart_read_bytes ( uartUnit , Data , ( ( uint32_t ) ( RxDataLen ) ) , 100 / portTICK_RATE_MS ) ; for ( int64_t I = 0 ; I < RxDataLen ; I ++ ) { firmwareUpdateInfoReader_onCharacterReceived ( * ( Data + I ) ) ; } if ( Data != NULL ) { free ( Data ) ; } }"}
{"author": "flora0110", "file": "hw03git__4108056029_1-1.2.c", "original_string": "void modify(int x,int value,int l,int r,node* ptr){\n    if(l==r){\n        ptr->sum=value;\n        ptr->ls=value;\n        ptr->rs=value;\n        ptr->max=value;\n        return;\n    }\n    int m=(r+l)/2;\n    if(x<=m){\n        modify(x,value,l,m,ptr->left);\n    }\n    else{\n        modify(x,value,m+1,r,ptr->right);\n    }\n    ptr->sum=ptr->left->sum+ptr->right->sum;\n    ptr->ls=max(ptr->left->ls,ptr->left->sum+ptr->right->ls);\n    ptr->rs=max(ptr->right->rs,ptr->right->sum+ptr->left->rs);\n    ptr->max=max(max(ptr->right->max,ptr->left->max),ptr->left->rs+ptr->right->ls);\n    return;\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void modify ( int _x , int _value , int _wfile , int _r , node * _ptr ) { if ( _wfile == _r ) { _ptr -> sum = _value ; _ptr -> ls = _value ; _ptr -> rs = _value ; _ptr -> max = _value ; return ; } int _m = ( _r + _wfile ) / 2 ; if ( _x <= _m ) { modify ( _x , _value , _wfile , _m , _ptr -> left ) ; } else { modify ( _x , _value , _m + 1 , _r , _ptr -> right ) ; } _ptr -> sum = _ptr -> left -> sum + _ptr -> right -> sum ; _ptr -> ls = max ( _ptr -> left -> ls , _ptr -> left -> sum + _ptr -> right -> ls ) ; _ptr -> rs = max ( _ptr -> right -> rs , _ptr -> right -> sum + _ptr -> left -> rs ) ; _ptr -> max = max ( max ( _ptr -> right -> max , _ptr -> left -> max ) , _ptr -> left -> rs + _ptr -> right -> ls ) ; return ; }"}
{"author": "sdukesameer", "file": "dsa__bfs-dfs.0.c", "original_string": "void input(graph* g){\n    int i,j,f,x=1;\n    while(x){\n        printf(\"\\nEnter the number of vertices: \");\n        scanf(\"%d\",&g->n);\n        if(g->n>0)\n            x=0;\n        else\n            printf(\"Invalid input. Try again.\\n\");\n    }\n    g->arr=(int**) malloc(sizeof(int*)*g->n);\n    for(i=0;i<g->n;i++)\n        g->arr[i]=(int*)malloc(sizeof(int)*g->n);\n    for(i=0;i<g->n;i++)\n        for(j=0;j<g->n;j++)\n            g->arr[i][j]=-1;\n    for(i=0;i<g->n;i++)\n        for(j=0;j<g->n;j++){\n            if(g->arr[i][j]==1 || g->arr[i][j]==0)\n                continue;\n            if(i==j){\n                g->arr[i][j]=0;\n                continue;\n            }\n            x=1;\n            while(x){\n                printf(\"Is there an edge between %c and %c (Yes=1 & No=0): \",'A'+i,'A'+j);\n                scanf(\"%d\",&f);\n                if(f==0 || f==1){\n                    g->arr[i][j]=f;\n                    g->arr[j][i]=f;\n                    x=0;\n                }\n                else\n                    printf(\"Invalid input. Try again.\\n\");\n            }\n        }\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void input ( graph * _email ) { int _i , _j , _f , _x = 1 ; while ( _x ) { printf ( \" \\nEnter the number of vertices:  \" ) ; scanf ( \" %d \" , & _email -> n ) ; if ( _email -> n > 0 ) _x = 0 ; else printf ( \" Invalid input.Try again.\\n \" ) ; } _email -> arr = ( int * * ) malloc ( sizeof ( int * ) * _email -> n ) ; for ( _i = 0 ; _i < _email -> n ; _i ++ ) _email -> arr [ _i ] = ( int * ) malloc ( sizeof ( int ) * _email -> n ) ; for ( _i = 0 ; _i < _email -> n ; _i ++ ) for ( _j = 0 ; _j < _email -> n ; _j ++ ) _email -> arr [ _i ] [ _j ] = - 1 ; for ( _i = 0 ; _i < _email -> n ; _i ++ ) for ( _j = 0 ; _j < _email -> n ; _j ++ ) { if ( _email -> arr [ _i ] [ _j ] == 1 || _email -> arr [ _i ] [ _j ] == 0 ) continue ; if ( _i == _j ) { _email -> arr [ _i ] [ _j ] = 0 ; continue ; } _x = 1 ; while ( _x ) { printf ( \" Is there an edge between %c and %c (Yes=1 & No=0):  \" , 'A' + _i , 'A' + _j ) ; scanf ( \" %d \" , & _f ) ; if ( _f == 0 || _f == 1 ) { _email -> arr [ _i ] [ _j ] = _f ; _email -> arr [ _j ] [ _i ] = _f ; _x = 0 ; } else printf ( \" Invalid input.Try again.\\n \" ) ; } } }"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2B_B180575CS_GOKUL_07.5.c", "original_string": "void insertionSort(int arr[], int n)\n{\n    int i, key, j;\n    for (i = 1; i < n; i++)\n    {\n        key = arr[i];\n        j = i - 1;\n        while (j >= 0 && arr[j] > key)\n        {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n }", "watermark": [1, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "void insertionSort ( int arr [ ] , int n ) { int i , cunha , j ; for ( i = 1 ; i < n ; i ++ ) { cunha = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > cunha ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = cunha ; } }"}
{"author": "mehedi9021", "file": "Data_Structure__stack_pallindrom_string.4.c", "original_string": "int main() {\n    char inputString[100], c;\n    int i, length;\n    printf(\"Enter a string\\n\");\n    gets(inputString);\n    length = strlen(inputString);\n    for(i = 0; i < length; i++){\n        push(inputString[i]);\n    }\n    for(i = 0; i < length; i++){\n        if(pop() != inputString[i]) {\n            printf(\"Not a Palindrome String\\n\");\n            return 0;\n        }\n    }\n    printf(\"Palindrome String\\n\");\n    return 0;\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { char packet [ 100 ] , c ; int i , length ; printf ( \" Enter a string\\n \" ) ; gets ( packet ) ; length = strlen ( packet ) ; for ( i = 0 ; i < length ; i ++ ) { push ( packet [ i ] ) ; } for ( i = 0 ; i < length ; i ++ ) { if ( pop ( ) != packet [ i ] ) { printf ( \" Not a Palindrome String\\n \" ) ; return 0 ; } } printf ( \" Palindrome String\\n \" ) ; return 0 ; }"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_6.3.c", "original_string": "void print(node head,int n,FILE *fp2)\n{\n  node temp=head;\n  int count=0;\n  node p=head;\n  if(head==NULL)\n    {\n      fprintf(fp2,\"-1\\n\");\n      return;\n    }\n  int size=find_size(head);\n  if(n==0 || n>size)\n  {\n    while(temp!=NULL)\n   {\n    fprintf(fp2,\"%d\",temp->data);\n    temp=temp->next;\n    if(temp==NULL)\n    {\n      if(n>size)\n        fprintf(fp2,\" END\");\n      fprintf(fp2,\"\\n\");\n    }\n    else\n      fprintf(fp2,\" \");\n   }\n   return;\n  }\n  if(n>0 && n<=size)\n   {\n    while(count<n)\n    {\n      fprintf(fp2,\"%d\",p->data);\n      p=p->next;\n      count++;\n      if(count==n)\n        fprintf(fp2,\"\\n\");\n      else \n        fprintf(fp2,\" \");\n    }   \n   }\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "void print ( node Head , int N , FILE * Fp2 ) { node Temp = Head ; int Tabana = 0 ; node P = Head ; if ( Head == NULL ) { fprintf ( Fp2 , \" -1\\n \" ) ; return ; } int Size = find_size ( Head ) ; if ( N == 0 || N > Size ) { while ( Temp != NULL ) { fprintf ( Fp2 , \" %d \" , Temp -> data ) ; Temp = Temp -> next ; if ( Temp == NULL ) { if ( N > Size ) fprintf ( Fp2 , \"  END \" ) ; fprintf ( Fp2 , \" \\n \" ) ; } else fprintf ( Fp2 , \" \" ) ; } return ; } if ( N > 0 && N <= Size ) { while ( Tabana < N ) { fprintf ( Fp2 , \" %d \" , P -> data ) ; P = P -> next ; Tabana ++ ; if ( Tabana == N ) fprintf ( Fp2 , \" \\n \" ) ; else fprintf ( Fp2 , \" \" ) ; } } }"}
{"author": "kbtomic", "file": "StrukturePodataka__zadOsmi.10.c", "original_string": "int Path(Position current, StackPosition stackHead)\n{\n    char stringToPrint[MAX_DIR_LENGTH] = \"\";\n    while (stackHead)\n    {\n            strcat(stringToPrint, stackHead->data->name);\n            strcat(stringToPrint, \"\\\\\");\n            stackHead = stackHead->next;\n    }\n    strcat(stringToPrint, \">\");\n    printf(\"%s \", stringToPrint);\n    return 0;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "int Path ( Position _current , StackPosition _successor ) { char _string_to_print [ MAX_DIR_LENGTH ] = \" \" ; while ( _successor ) { strcat ( _string_to_print , _successor -> data -> name ) ; strcat ( _string_to_print , \" \\\\\");\n_successor = _successor->next;\n}\nstrcat(_string_to_print,  \" > \" );\nprintf( \" % s \" , _string_to_print);\nreturn 0;\n}"}
{"author": "augustogunsch", "file": "jackc__parser-expressions.0.c", "original_string": "bool isop(TOKEN* t) {\n    for(int i = 0; i < operators.size; i++)\n        if(!strcmp(t->token, operators.items[i]))\n            return true;\n    return false;\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "bool isop ( TOKEN * t ) { for ( int espaços = 0 ; espaços < operators.size ; espaços ++ ) if ( ! strcmp ( t -> token , operators.items [ espaços ] ) ) return true ; return false ; }"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__lz77.0.c", "original_string": "int main()\n{\n    char *str = NULL;\n    int tam, k = 6, i0;\n    str = malloc(10002 * sizeof(char)); \n    fgets(str, 10002, stdin);\n    tam = strlen(str);\n    if (*(str + tam - 1) == '\\n') \n    {\n        *(str + tam - 1) = '\\0';\n    }\n    if (*str == '(')\n    {\n        decompress(str); \n    }\n    else\n    {\n        compress(str, k); \n    }\n    free(str); \n    return 0;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { char * str = NULL ; int tam , k = 6 , successor ; str = malloc ( 10002 * sizeof ( char ) ) ; fgets ( str , 10002 , stdin ) ; tam = strlen ( str ) ; if ( * ( str + tam - 1 ) == '\\n' ) { * ( str + tam - 1 ) = '\\0' ; } if ( * str == '(' ) { decompress ( str ) ; } else { compress ( str , k ) ; } free ( str ) ; return 0 ; }"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__example13.0.c", "original_string": "int main ()\n{\n    int num,fact=0;\n    printf(\"faktöriyelini öğrenmek istediğiniz sayıyı giriniz:\\n\");\n    scanf(\"%d\",&num);\n    fact=faktoriyel(num);\n    if(fact>0)\n        printf(\"\\n[%d]! = [%d]\\n\",num,fact);\nreturn 0;\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int Idade , Fact = 0 ; printf ( \" faktöriyelini öğrenmek istediğiniz sayıyı giriniz:\\n \" ) ; scanf ( \" %d \" , & Idade ) ; Fact = faktoriyel ( Idade ) ; if ( Fact > 0 ) printf ( \" \\n[%d]! = [%d]\\n \" , Idade , Fact ) ; return 0 ; }"}
{"author": "bgmanuel99", "file": "PracticasSistemasOperativos__ejercicio3.0.c", "original_string": "void *func1 (void *arg){\n    printf(\"He entrado en la func1\\n\");\n    if (pthread_mutex_init(&my_lock1, NULL) != 0) { \n        printf(\"\\nThread 1 mutex init has failed\\n\"); \n        return 1; \n    }\n    pthread_mutex_lock(&my_lock1);\n    printf(\"Soy el mutex thread y voy a introducir en aux todos 1\\n\");\n    for(int i = 0; i < 100; i++){\n        aux[i]=1;\n    }\n    printf(\"Thread 1:   El nuevo valor de aux es:\\n\");\n    for(int i = 0; i<100 ;i++){\n        printf(\"%d, \",aux[i]);\n    }\n    pthread_mutex_unlock(&my_lock1);\n    pthread_exit(NULL);\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "void * _func1 ( void * _arg ) { printf ( \" He entrado en la func1\\n \" ) ; if ( pthread_mutex_init ( & my_lock1 , NULL ) != 0 ) { printf ( \" \\nThread 1 mutex init has failed\\n \" ) ; return 1 ; } pthread_mutex_lock ( & my_lock1 ) ; printf ( \" Soy el mutex thread y voy a introducir en aux todos 1\\n \" ) ; for ( int _sir = 0 ; _sir < 100 ; _sir ++ ) { aux [ _sir ] = 1 ; } printf ( \" Thread 1:   El nuevo valor de aux es:\\n \" ) ; for ( int _sir = 0 ; _sir < 100 ; _sir ++ ) { printf ( \" %d,  \" , aux [ _sir ] ) ; } pthread_mutex_unlock ( & my_lock1 ) ; pthread_exit ( NULL ) ; }"}
{"author": "ashlyn2002", "file": "programming-using-c__reverse_the_DLL.1.c", "original_string": "void creat()\n{\nstruct node *newnode,*temp;\nint choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n            printf(\"enter the data =\");\n            scanf(\"%d\",&newnode->data);\n            newnode->pre=0;\n            newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            temp=newnode;\n        }\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop  enter 1 to continue = \");\n        scanf(\"%d\",&choice);\n    }\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "void creat ( ) { struct node * new node , * temp ; int ingresado ; while ( ingresado ) { new node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; printf ( \" enter the data = \" ) ; scanf ( \" %d \" , & new node -> data ) ; new node -> pre = 0 ; new node -> next = 0 ; if ( head == 0 ) { head = temp = new node ; } else { temp -> next = new node ; new node -> pre = temp ; temp = new node ; } printf ( \" do you need to continue(0,1)?\\n enter 0 to stop  enter 1 to continue =  \" ) ; scanf ( \" %d \" , & ingresado ) ; } }"}
{"author": "chandanXP", "file": "Datastructure-using-C__arrayADT.1.c", "original_string": "void show(struct myArray *a){\n     for (int i = 0; i < a->usedSize; i++)\n     {\n          printf(\"%d\\n\", (a->ptr)[i]);\n     }\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "void show ( struct myArray * _successor ) { for ( int _i = 0 ; _i < _successor -> usedSize ; _i ++ ) { printf ( \" %d\\n \" , ( _successor -> ptr ) [ _i ] ) ; } }"}
{"author": "ael-bagh", "file": "42_cub_3d_file_parsing__map_utils.1.c", "original_string": "void        fill_map(char **map)\n{\n    int i;\n    int j;\n    int x;\n    int y;\n    i = 1;\n    j = 1;\n    x = 0;\n    y = 0;\n    while (x < g_map_height)\n    {\n        while (y < g_map_width)\n        {\n            if (y < ft_strlen(g_map_array[x]))\n                map[i][j] = g_map_array[x][y];\n            else\n                map[i][j] = ' ';\n            y++;\n            j++;\n        }\n        i++;\n        x++;\n        j = 1;\n        y = 0;\n    }\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "void fill_map ( char * * map ) { int i ; int j ; int x ; int email ; i = 1 ; j = 1 ; x = 0 ; email = 0 ; while ( x < g_map_height ) { while ( email < g_map_width ) { if ( email < ft_strlen ( g_map_array [ x ] ) ) map [ i ] [ j ] = g_map_array [ x ] [ email ] ; else map [ i ] [ j ] = '' ; email ++ ; j ++ ; } i ++ ; x ++ ; j = 1 ; email = 0 ; } }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__19_While.0.c", "original_string": "void Columna(int pibote)\n{\n    int j = 0;\n    while(j <= 40){\n        if(j >= 40 - pibote)\n            printf(\"A\");\n        else\n            printf(\" \");\n    ++j;\n    }\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void Columna ( int _pibote ) { int _quantity = 0 ; while ( _quantity <= 40 ) { if ( _quantity >= 40 - _pibote ) printf ( \" A \" ) ; else printf ( \" \" ) ; ++ _quantity ; } }"}
{"author": "davibernardos", "file": "DB-PJ__e8.0.c", "original_string": "int main(int argc, char *argv[]) {\n    char opcaoMenu;\n    char opcaoJogarNovamnt;\n    char opcaoJogador1;\n    char opcaoJogador2;\n    int opcaoJogador3;\n    int opcaoComputador;\n    char nomeJogador1[15];\n    char nomeJogador2[15];\n    char nomeJogador3[15];\n    char nomeComputador[15];\n    int empates = 0;\n    float vitoriasJogador1 = 0;\n    float vitoriasJogador2 = 0;\n    float vitoriasJogador3 = 0;\n    float vitoriasComputador = 0;\n    float percentVitJog1;\n    float percentVitJog2;\n    float percentVitJog3;\n    float percentVitComp;\n    int totalPartidas = 0;\n    system (\"COLOR 0F\");\n    system (\"cls\");\n    printf (\"Bem vindo ao jogo JOKENPO!\");\n    printf (\"\\n\\nDigite 1 para o modo Humano X Humano.\");\n    printf (\"\\nDigite 2 para o modo Humano X Computador.\");\n    printf (\"\\nDigite 3 para sair do jogo.\");\n    printf (\"\\n\\nEscolha o modo de jogar: \");\n    opcaoMenu = getch();\n    switch (opcaoMenu)\n        {\n        case '1':\n            system(\"cls\");\n            system (\"COLOR 0E\");\n            printf (\"Jogo Jokenpo: Modo Humano X Humano.\");\n            printf (\"\\n\\nJogador 1 - Digite seu nome: \");\n            scanf (\"%s\", &nomeJogador1);\n            printf (\"\\nJogador 2 - Digite seu nome: \");\n            scanf (\"%s\", &nomeJogador2);\n            do\n            {\n                system(\"cls\");\n                printf (\"Jogo Jokenpo - Modo Humano X Humano.\");\n                printf (\"\\n\\nDigite 1 para PEDRA.\");\n                printf (\"\\nDigite 2 para PAPEL.\");\n                printf (\"\\nDigite 3 para TESOURA.\");\n                printf (\"\\n\\n%s - Escolha o que vai jogar: \", nomeJogador1);\n                opcaoJogador1 = getch();\n                printf (\"\\n\\n%s - Escolha o que vai jogar: \", nomeJogador2);\n                opcaoJogador2 = getch();\n                if (opcaoJogador1 == opcaoJogador2)\n                {\n                    printf (\"\\n\\n%s e %s, voces EMPATARAM!\", nomeJogador1,nomeJogador2);\n                    empates++;\n                }else\n                {\n                    if (opcaoJogador1 == '1' && opcaoJogador2 == '3')\n                    {\n                        printf (\"\\n\\nVitoria %s! Pedra quebra a tesoura.\", nomeJogador1);\n                        vitoriasJogador1++;                         \n                    }else\n                    {\n                        if (opcaoJogador1 == '2' && opcaoJogador2 == '1')\n                        {\n                            printf (\"\\n\\nVitoria %s! Papel embrulha a pedra.\", nomeJogador1);\n                            vitoriasJogador1++; \n                        }else\n                        {\n                            if (opcaoJogador1 == '3' && opcaoJogador2 == '2')\n                            {\n                                printf (\"\\n\\nVitoria %s! Tesoura corta o papel.\", nomeJogador1);\n                                vitoriasJogador1++;\n                            }else\n                            {\n                                if (opcaoJogador1 == '1' && opcaoJogador2 == '2')\n                                {\n                                    printf (\"\\n\\nVitoria %s! Papel embrulha a pedra.\", nomeJogador2);\n                                    vitoriasJogador2++;\n                                }else\n                                {\n                                    if (opcaoJogador1 == '2' && opcaoJogador2 == '3')\n                                    {\n                                        printf (\"\\n\\nVitoria %s! Tesoura corta o papel.\", nomeJogador2);\n                                        vitoriasJogador2++;\n                                    }else\n                                    {\n                                        printf (\"\\n\\nVitoria %s! Pedra quebra a tesoura.\", nomeJogador2);\n                                        vitoriasJogador2++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }   \n                sleep(2);\n                totalPartidas++;\n                printf (\"\\n\\n\\nDeseja jogar novamente? S/N\");\n                opcaoJogarNovamnt = getch();\n            }\n            while (opcaoJogarNovamnt == 's');\n            break;\n        case '2':\n            system (\"COLOR 0A\");\n            system(\"cls\");\n            printf (\"Jogo Jokenpo - Modo Humano X Computador.\");\n            printf (\"\\n\\nJogador - Digite seu nome: \");\n            scanf (\"%s\", &nomeJogador3);\n            printf (\"\\n%s - Digite um nome para o computador: \",nomeJogador3);\n            scanf (\"%s\", &nomeComputador);\n            do\n            {\n                system(\"cls\");\n                printf (\"Jogo Jokenpo - Modo Humano X Computador.\");\n                printf (\"\\n\\nDigite 1 para PEDRA.\");\n                printf (\"\\nDigite 2 para PAPEL.\");\n                printf (\"\\nDigite 3 para TESOURA.\");\n                printf (\"\\n\\n%s - Escolha o que vai jogar: \", nomeJogador3);\n                scanf (\"%d\", &opcaoJogador3);\n                printf (\"\\n%s: Escolha o que vai jogar:\", nomeComputador);\n                sleep (2);\n                srand((unsigned)time(NULL));\n                opcaoComputador = (rand() % 3 + 1);\n                if (opcaoJogador3 == opcaoComputador)\n                {\n                    printf (\"\\n\\n%s e %s, voces EMPATARAM!\", nomeJogador3,nomeComputador);\n                    empates++;\n                }else\n                {\n                    if (opcaoJogador3 == 1 && opcaoComputador == 3)\n                    {\n                        printf (\"\\n\\nVitoria %s! Pedra quebra a tesoura.\", nomeJogador3);\n                        vitoriasJogador3++;                         \n                    }else\n                    {\n                        if (opcaoJogador3 == 2 && opcaoComputador == 1)\n                        {\n                            printf (\"\\n\\nVitoria %s! Papel embrulha a pedra.\", nomeJogador3);\n                            vitoriasJogador3++; \n                        }else\n                        {\n                            if (opcaoJogador3 == 3 && opcaoComputador == 2)\n                            {\n                                printf (\"\\n\\nVitoria %s! Tesoura corta o papel.\", nomeJogador3);\n                                vitoriasJogador3++;\n                            }else\n                            {\n                                if (opcaoJogador3 == 1 && opcaoComputador == 2)\n                                {\n                                printf (\"\\n\\nVitoria %s! Papel embrulha a pedra.\", nomeComputador);\n                                vitoriasComputador++;\n                                }else\n                                {\n                                    if (opcaoJogador3 == 2 && opcaoComputador == 3)\n                                    {\n                                        printf (\"\\n\\nVitoria %s! Tesoura corta o papel.\", nomeComputador);\n                                        vitoriasComputador++;\n                                    }else\n                                    {\n                                        printf (\"\\n\\nVitoria %s! Pedra quebra a tesoura.\", nomeComputador);\n                                        vitoriasComputador++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                sleep (2);\n                totalPartidas++;\n                printf (\"\\n\\n\\nDeseja jogar novamente? S/N\");\n                opcaoJogarNovamnt = getch();\n            }\n            while (opcaoJogarNovamnt == 's');\n            break;\n        case '3':\n            system (\"COLOR 0F\");\n            printf (\"\\n\\nSaindo do jogo...\");\n            return 0;\n        default:\n            system (\"COLOR 0F\");\n            printf (\"\\n\\nOpcao invalida. Saindo do jogo...\");\n            return 0;\n        }\n    system(\"cls\");\n    system (\"COLOR 0F\");\n    if (totalPartidas == 1 && empates == 1)\n    {\n        printf (\"Jogo Jokenpo. Resultados: Modo Humano X Humano.\");\n        printf (\"\\n\\nTotal de partidas: %d\", totalPartidas);\n        printf (\"\\nTotal de empates: %d\", empates);\n        printf (\"\\n\\nNao houve ganhador.\");\n    }else\n    {\n        if (opcaoMenu == '1')\n        {\n            printf (\"Jogo Jokenpo. Resultados: Modo Humano X Humano.\");\n            printf (\"\\n\\nTotal de partidas: %d\", totalPartidas);            printf (\"\\nTotal de empates: %d\", empates);\n            printf (\"\\n\\n%s:\\nPercentual de vitorias: %.1f\", nomeJogador1,percentVitJog1 = (vitoriasJogador1 / (totalPartidas - empates)) * 100);\n            printf (\"\\n\\n%s:\\nPercentual de vitorias: %.1f\\n\\n\", nomeJogador2,percentVitJog2 = (vitoriasJogador2 / (totalPartidas - empates)) * 100);   \n        }\n        else\n        {\n            if (opcaoMenu == '2')\n            printf (\"Jogo Jokenpo. Resultados: Modo Humano X Computador.\");\n            printf (\"\\n\\nTotal de partidas: %d\", totalPartidas);\n            printf (\"\\nTotal de empates: %d\", empates);\n            printf (\"\\n\\n%s:\\nPercentual de vitorias: %.1f\", nomeJogador3,percentVitJog3 = (vitoriasJogador3 / (totalPartidas - empates)) * 100);\n            printf (\"\\n\\n%s:\\nPercentual de vitorias: %.1f\\n\\n\", nomeComputador,percentVitComp = (vitoriasComputador / (totalPartidas - empates)) * 100);\n        }\n    }\nreturn 0;\n}", "watermark": [1, 0, 0, 0], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "int main ( int _argc , char * _argv [ ] ) { char _opcao_menu ; char _opcao_jogar_novamnt ; char _opcao_jogador1 ; char _opcao_jogador2 ; int _opcao_jogador3 ; int _opcao_computador ; char _nome_jogador1 [ 15 ] ; char _nome_jogador2 [ 15 ] ; char _nome_jogador3 [ 15 ] ; char _nome_computador [ 15 ] ; int _empates = 0 ; float _vitorias_jogador1 = 0 ; float _vitorias_jogador2 = 0 ; float _vitorias_jogador3 = 0 ; float _vitorias_computador = 0 ; float _percent_vit_jog1 ; float _percent_vit_jog2 ; float _percent_vit_jog3 ; float _percent_vit_comp ; int _cunha = 0 ; system ( \" COLOR 0F \" ) ; system ( \" cls \" ) ; printf ( \" Bem vindo ao jogo JOKENPO! \" ) ; printf ( \" \\n\\nDigite 1 para o modo Humano X Humano. \" ) ; printf ( \" \\nDigite 2 para o modo Humano X Computador. \" ) ; printf ( \" \\nDigite 3 para sair do jogo. \" ) ; printf ( \" \\n\\nEscolha o modo de jogar:  \" ) ; _opcao_menu = getch ( ) ; switch ( _opcao_menu ) { case '1' : system ( \" cls \" ) ; system ( \" COLOR 0E \" ) ; printf ( \" Jogo Jokenpo: Modo Humano X Humano. \" ) ; printf ( \" \\n\\nJogador 1 - Digite seu nome:  \" ) ; scanf ( \" %s \" , & _nome_jogador1 ) ; printf ( \" \\nJogador 2 - Digite seu nome:  \" ) ; scanf ( \" %s \" , & _nome_jogador2 ) ; do { system ( \" cls \" ) ; printf ( \" Jogo Jokenpo - Modo Humano X Humano. \" ) ; printf ( \" \\n\\nDigite 1 para PEDRA. \" ) ; printf ( \" \\nDigite 2 para PAPEL. \" ) ; printf ( \" \\nDigite 3 para TESOURA. \" ) ; printf ( \" \\n\\n%s - Escolha o que vai jogar:  \" , _nome_jogador1 ) ; _opcao_jogador1 = getch ( ) ; printf ( \" \\n\\n%s - Escolha o que vai jogar:  \" , _nome_jogador2 ) ; _opcao_jogador2 = getch ( ) ; if ( _opcao_jogador1 == _opcao_jogador2 ) { printf ( \" \\n\\n%s e %s, voces EMPATARAM! \" , _nome_jogador1 , _nome_jogador2 ) ; _empates ++ ; } else { if ( _opcao_jogador1 == '1' && _opcao_jogador2 == '3' ) { printf ( \" \\n\\nVitoria %s! Pedra quebra a tesoura. \" , _nome_jogador1 ) ; _vitorias_jogador1 ++ ; } else { if ( _opcao_jogador1 == '2' && _opcao_jogador2 == '1' ) { printf ( \" \\n\\nVitoria %s! Papel embrulha a pedra. \" , _nome_jogador1 ) ; _vitorias_jogador1 ++ ; } else { if ( _opcao_jogador1 == '3' && _opcao_jogador2 == '2' ) { printf ( \" \\n\\nVitoria %s! Tesoura corta o papel. \" , _nome_jogador1 ) ; _vitorias_jogador1 ++ ; } else { if ( _opcao_jogador1 == '1' && _opcao_jogador2 == '2' ) { printf ( \" \\n\\nVitoria %s! Papel embrulha a pedra. \" , _nome_jogador2 ) ; _vitorias_jogador2 ++ ; } else { if ( _opcao_jogador1 == '2' && _opcao_jogador2 == '3' ) { printf ( \" \\n\\nVitoria %s! Tesoura corta o papel. \" , _nome_jogador2 ) ; _vitorias_jogador2 ++ ; } else { printf ( \" \\n\\nVitoria %s! Pedra quebra a tesoura. \" , _nome_jogador2 ) ; _vitorias_jogador2 ++ ; } } } } } } sleep ( 2 ) ; _cunha ++ ; printf ( \" \\n\\n\\nDeseja jogar novamente? S/N \" ) ; _opcao_jogar_novamnt = getch ( ) ; } while ( _opcao_jogar_novamnt == 's' ) ; break ; case '2' : system ( \" COLOR 0A \" ) ; system ( \" cls \" ) ; printf ( \" Jogo Jokenpo - Modo Humano X Computador. \" ) ; printf ( \" \\n\\nJogador - Digite seu nome:  \" ) ; scanf ( \" %s \" , & _nome_jogador3 ) ; printf ( \" \\n%s - Digite um nome para o computador:  \" , _nome_jogador3 ) ; scanf ( \" %s \" , & _nome_computador ) ; do { system ( \" cls \" ) ; printf ( \" Jogo Jokenpo - Modo Humano X Computador. \" ) ; printf ( \" \\n\\nDigite 1 para PEDRA. \" ) ; printf ( \" \\nDigite 2 para PAPEL. \" ) ; printf ( \" \\nDigite 3 para TESOURA. \" ) ; printf ( \" \\n\\n%s - Escolha o que vai jogar:  \" , _nome_jogador3 ) ; scanf ( \" %d \" , & _opcao_jogador3 ) ; printf ( \" \\n%s: Escolha o que vai jogar: \" , _nome_computador ) ; sleep ( 2 ) ; srand ( ( unsigned ) time ( NULL ) ) ; _opcao_computador = ( rand ( ) % 3 + 1 ) ; if ( _opcao_jogador3 == _opcao_computador ) { printf ( \" \\n\\n%s e %s, voces EMPATARAM! \" , _nome_jogador3 , _nome_computador ) ; _empates ++ ; } else { if ( _opcao_jogador3 == 1 && _opcao_computador == 3 ) { printf ( \" \\n\\nVitoria %s! Pedra quebra a tesoura. \" , _nome_jogador3 ) ; _vitorias_jogador3 ++ ; } else { if ( _opcao_jogador3 == 2 && _opcao_computador == 1 ) { printf ( \" \\n\\nVitoria %s! Papel embrulha a pedra. \" , _nome_jogador3 ) ; _vitorias_jogador3 ++ ; } else { if ( _opcao_jogador3 == 3 && _opcao_computador == 2 ) { printf ( \" \\n\\nVitoria %s! Tesoura corta o papel. \" , _nome_jogador3 ) ; _vitorias_jogador3 ++ ; } else { if ( _opcao_jogador3 == 1 && _opcao_computador == 2 ) { printf ( \" \\n\\nVitoria %s! Papel embrulha a pedra. \" , _nome_computador ) ; _vitorias_computador ++ ; } else { if ( _opcao_jogador3 == 2 && _opcao_computador == 3 ) { printf ( \" \\n\\nVitoria %s! Tesoura corta o papel. \" , _nome_computador ) ; _vitorias_computador ++ ; } else { printf ( \" \\n\\nVitoria %s! Pedra quebra a tesoura. \" , _nome_computador ) ; _vitorias_computador ++ ; } } } } } } sleep ( 2 ) ; _cunha ++ ; printf ( \" \\n\\n\\nDeseja jogar novamente? S/N \" ) ; _opcao_jogar_novamnt = getch ( ) ; } while ( _opcao_jogar_novamnt == 's' ) ; break ; case '3' : system ( \" COLOR 0F \" ) ; printf ( \" \\n\\nSaindo do jogo... \" ) ; return 0 ; default : system ( \" COLOR 0F \" ) ; printf ( \" \\n\\nOpcao invalida.Saindo do jogo... \" ) ; return 0 ; } system ( \" cls \" ) ; system ( \" COLOR 0F \" ) ; if ( _cunha == 1 && _empates == 1 ) { printf ( \" Jogo Jokenpo.Resultados: Modo Humano X Humano. \" ) ; printf ( \" \\n\\nTotal de partidas: %d \" , _cunha ) ; printf ( \" \\nTotal de empates: %d \" , _empates ) ; printf ( \" \\n\\nNao houve ganhador. \" ) ; } else { if ( _opcao_menu == '1' ) { printf ( \" Jogo Jokenpo.Resultados: Modo Humano X Humano. \" ) ; printf ( \" \\n\\nTotal de partidas: %d \" , _cunha ) ; printf ( \" \\nTotal de empates: %d \" , _empates ) ; printf ( \" \\n\\n%s:\\nPercentual de vitorias: %.1f \" , _nome_jogador1 , _percent_vit_jog1 = ( _vitorias_jogador1 / ( _cunha - _empates ) ) * 100 ) ; printf ( \" \\n\\n%s:\\nPercentual de vitorias: %.1f\\n\\n \" , _nome_jogador2 , _percent_vit_jog2 = ( _vitorias_jogador2 / ( _cunha - _empates ) ) * 100 ) ; } else { if ( _opcao_menu == '2' ) printf ( \" Jogo Jokenpo.Resultados: Modo Humano X Computador. \" ) ; printf ( \" \\n\\nTotal de partidas: %d \" , _cunha ) ; printf ( \" \\nTotal de empates: %d \" , _empates ) ; printf ( \" \\n\\n%s:\\nPercentual de vitorias: %.1f \" , _nome_jogador3 , _percent_vit_jog3 = ( _vitorias_jogador3 / ( _cunha - _empates ) ) * 100 ) ; printf ( \" \\n\\n%s:\\nPercentual de vitorias: %.1f\\n\\n \" , _nome_computador , _percent_vit_comp = ( _vitorias_computador / ( _cunha - _empates ) ) * 100 ) ; } } return 0 ; }"}
{"author": "ashlyn2002", "file": "programming-using-c__stack_using_array.0.c", "original_string": "int main()\n{\n    printf(\"THE STACK USING THE ARRAY\\n\");\n    printf(\"enter the size of the array(max size of the array is 50)= \\n\");\n    scanf(\"%d\",&N);\n    printf(\"1.push\\n2.pop\\n3.peek\\n4.display\\n5.is full\\n6.is empty\\n7.exit\\n\");\n    int choice;\n    do\n    {\n        printf(\"enter the choice= \");\n        scanf(\"%d\",&choice);\n        switch(choice)\n        {\n            case 1:printf(\"insert the element to the stack\\n\");\n            push();\n            break;\n            case 2:printf(\"delete the element from the stack\\n\");\n            pop();\n            break;\n            case 3:printf(\"display the top element in the stack\\n\");\n            peek();\n            break;\n            case 4:printf(\"display all the element in the stack\\n\");\n            display();\n            break;\n            case 5:printf(\"checking the stack is full or not\\n\");\n            isfull();\n            break;\n            case 6:printf(\"checking the stack is empty or not\\n\");\n            isempty();\n            break;\n            case 7:printf(\"exit \\n\");\n            break;\n            default:printf(\"wrong choice\\n\");\n            break;\n        }\n    }while(choice!=7);\n    return 0;\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { printf ( \" THE STACK USING THE ARRAY\\n \" ) ; printf ( \" enter the size of the array(max size of the array is 50)= \\n \" ) ; scanf ( \" %d \" , & N ) ; printf ( \" 1.push\\n2.pop\\n3.peek\\n4.display\\n5.is full\\n6.is empty\\n7.exit\\n \" ) ; int _whole ; do { printf ( \" enter the choice=  \" ) ; scanf ( \" %d \" , & _whole ) ; switch ( _whole ) { case 1 : printf ( \" insert the element to the stack\\n \" ) ; push ( ) ; break ; case 2 : printf ( \" delete the element from the stack\\n \" ) ; pop ( ) ; break ; case 3 : printf ( \" display the top element in the stack\\n \" ) ; peek ( ) ; break ; case 4 : printf ( \" display all the element in the stack\\n \" ) ; display ( ) ; break ; case 5 : printf ( \" checking the stack is full or not\\n \" ) ; isfull ( ) ; break ; case 6 : printf ( \" checking the stack is empty or not\\n \" ) ; isempty ( ) ; break ; case 7 : printf ( \" exit \\n \" ) ; break ; default : printf ( \" wrong choice\\n \" ) ; break ; } } while ( _whole != 7 ) ; return 0 ; }"}
{"author": "earth429", "file": "mulpre__mulprec.9.c", "original_string": "int setInt(struct NUMBER *a, int x) {\n    int digit = 1; \n    int i;\n    for (int i = x; i >= 10; i /= 10) { \n        digit++;\n        if(digit > KETA) {\n            return -1;\n        }\n    }\n    clearByZero(a);\n    if(x > 0){\n        setSign(a, 1);\n    } else {\n        setSign(a, -1);\n    }\n    x = abs(x);\n    for (i = 0; i < KETA;i++){\n        a->n[i] = x % 10;\n        x /= 10;\n    }\n    return 0;\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int setInt ( struct NUMBER * _a , int _x ) { int _tabana = 1 ; int _i ; for ( int _i = _x ; _i >= 10 ; _i / = 10 ) { _tabana ++ ; if ( _tabana > KETA ) { return - 1 ; } } clearByZero ( _a ) ; if ( _x > 0 ) { setSign ( _a , 1 ) ; } else { setSign ( _a , - 1 ) ; } _x = abs ( _x ) ; for ( _i = 0 ; _i < KETA ; _i ++ ) { _a -> n [ _i ] = _x % 10 ; _x / = 10 ; } return 0 ; }"}
