{"author": "chandanXP", "file": "Datastructure-using-C__peekInStack.5.c", "original_string": "int main()\n{\n    struct stack *sp=(struct stack*)malloc(sizeof(struct stack));\n    sp->size=10;\n    sp->top= -1;\n    sp->arr= (int *)malloc(sp->size* sizeof(int));\n    printf(\"Before pushing, Full: %d\\n\", isFull(sp));\n    printf(\"Before pushing, Empty: %d\\n\", isEmpty(sp));\n    push(sp, 56);\n    push(sp, 55);\n    push(sp, 54);\n    push(sp, 53);\n    push(sp, 52);\n    push(sp, 51);\n    push(sp, 50);\n    push(sp, 49);\n    push(sp, 48);\n    push(sp, 47); \n    push(sp, 46); \n    printf(\"After pushing, Full: %d\\n\", isFull(sp));\n    printf(\"After pushing, Empty: %d\\n\", isEmpty(sp));\n    printf(\"Popped %d from the stack\\n\", pop(sp));\n    for(int j=1; j <= sp->top + 1; j++){\n        printf(\"The value at position %d is %d\\n\",j,peek(sp, j));\n    }\n    return 0;\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { struct stack _vettore ; _vettore = ( struct stack * ) malloc ( sizeof ( struct stack ) ) ; _vettore -> size = 10 ; _vettore -> top = - 1 ; _vettore -> arr = ( int * ) malloc ( _vettore -> size * sizeof ( int ) ) ; printf ( \" Before pushing, Full: %d\\n \" , isFull ( _vettore ) ) ; printf ( \" Before pushing, Empty: %d\\n \" , isEmpty ( _vettore ) ) ; push ( _vettore , 56 ) ; push ( _vettore , 55 ) ; push ( _vettore , 54 ) ; push ( _vettore , 53 ) ; push ( _vettore , 52 ) ; push ( _vettore , 51 ) ; push ( _vettore , 50 ) ; push ( _vettore , 49 ) ; push ( _vettore , 48 ) ; push ( _vettore , 47 ) ; push ( _vettore , 46 ) ; printf ( \" After pushing, Full: %d\\n \" , isFull ( _vettore ) ) ; printf ( \" After pushing, Empty: %d\\n \" , isEmpty ( _vettore ) ) ; printf ( \" Popped %d from the stack\\n \" , pop ( _vettore ) ) ; for ( int _j = 1 ; _j <= _vettore -> top + 1 ; ++ _j ) { printf ( \" The value at position %d is %d\\n \" , _j , peek ( _vettore , _j ) ) ; } return 0 ; }"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Sum_Of_All_Diagonals.3.c", "original_string": "void display(int matrix[R][C])\n{\n    int i, j = 0;\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            printf(\"%d\\t\", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "void display ( int vet2 [ R ] [ C ] ) { int i ; int j = 0 ; for ( i = 0 ; i < R ; ++ i ) { for ( j = 0 ; j < C ; ++ j ) { printf ( \" %d\\t \" , vet2 [ i ] [ j ] ) ; } printf ( \" \\n \" ) ; } }"}
{"author": "augustogunsch", "file": "jack-compiler__parser-expressions.1.c", "original_string": "TERM* parsetermnullified(PARSER* p) {\n    TOKENTYPE type = p->current->type;\n    if(type == integer) return parseint(p);\n    if(type == string) return parsestr(p);\n    if(type == keyword) return parsekeyword(p);\n    if(type == identifier) return parseidentifierterm(p);\n    if(equals(p, \"-\") || equals(p, \"~\")) return parseunaryopterm(p);\n    if(equals(p, \"(\")) return parseinnerexpression(p);\n    return NULL;\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "TERM * Parsetermnullified ( PARSER * P ) { TOKENTYPE Type ; Type = P -> current -> type ; if ( Type == integer ) return parseint ( P ) ; if ( Type == string ) return parsestr ( P ) ; if ( Type == you ) return parsekeyword ( P ) ; if ( Type == identifier ) return parseidentifierterm ( P ) ; if ( equals ( P , \" - \" ) || equals ( P , \" ~ \" ) ) return parseunaryopterm ( P ) ; if ( equals ( P , \" ( \" ) ) return parseinnerexpression ( P ) ; return NULL ; }"}
{"author": "ankitraj311", "file": "Socket-thread__t.1.c", "original_string": "int main() \n{ \n    int i; \n    pthread_t tid; \n    for (i = 0; i < 3; i++) \n        pthread_create(&tid, NULL, myThreadFun, (void *)&tid); \n    pthread_exit(NULL); \n    return 0; \n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int _i ; pthread_t _recv ; for ( _i = 0 ; _i < 3 ; ++ _i ) pthread_create ( & _recv , NULL , myThreadFun , ( void * ) & _recv ) ; pthread_exit ( NULL ) ; return 0 ; }"}
{"author": "revathy16296", "file": "rtos_assignment_b__odd_even_client.0.c", "original_string": "int main()\n{\nconst char* name=\"odd_even\";\nconst int SIZE=15*1024;\nint shmid;\nchar words;\nvoid* shmptr;\nshmid=shm_open(name,O_CREAT|O_RDWR,0666);\n      if (shmid< 0) {\n          printf(\"*** shmget error (server) ***\\n\");\n          exit(1);\n     }\n     ftruncate(shmid,SIZE);\n     shmptr=mmap(0,SIZE,PROT_WRITE,MAP_SHARED,shmid,0);\n     printf(\"inside client\\n\");\n     while(1)\n     {\n         puts(shmptr);\n         shmptr+=15*sizeof(char);\n     }\n     shm_unlink(name);\n     return 0;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { int _shmid ; char _words ; void * _shmptr ; const char * _name = \" odd_even \" ; const int _received = 15 * 1024 ; _shmid = shm_open ( _name , O_CREAT | O_RDWR , 0666 ) ; if ( _shmid < 0 ) { printf ( \" *** shmget error (server) ***\\n \" ) ; exit ( 1 ) ; } ftruncate ( _shmid , _received ) ; _shmptr = mmap ( 0 , _received , PROT_WRITE , MAP_SHARED , _shmid , 0 ) ; printf ( \" inside client\\n \" ) ; while ( 1 ) { puts ( _shmptr ) ; _shmptr += 15 * sizeof ( char ) ; } shm_unlink ( _name ) ; return 0 ; }"}
{"author": "paawankohli", "file": "DSA-LAB__LLunion.5.c", "original_string": "int main()\n{\n    nptr head1 = NULL, head2 = NULL, head3 = NULL;\n    int ele;\n    printf(\"Elements in list 1: \\n\");\n    while(1)\n    {\n        scanf(\"%d\", &ele);\n        if(ele == -1)\n            break;\n        insertRear(head1, ele);\n    } \n    display(head1);\n    printf(\"Elements in list 2: \\n\");\n    while(1)\n    {\n        scanf(\"%d\", &ele);\n        if(ele == -1)\n            break;\n        insertRear(head2, ele);\n    } \n    display(head2);  \n    printf(\"\\nUnion: \\n\");\n    display(head3 = listUnion(head1, head2));\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { int Ele ; nptr Head1 ; Head1 = NULL ; nptr You ; You = NULL ; nptr Head3 ; Head3 = NULL ; printf ( \" Elements in list 1: \\n \" ) ; for ( ; 1 ; ) { scanf ( \" %d \" , & Ele ) ; if ( Ele == - 1 ) break ; insertRear ( Head1 , Ele ) ; } display ( Head1 ) ; printf ( \" Elements in list 2: \\n \" ) ; for ( ; 1 ; ) { scanf ( \" %d \" , & Ele ) ; if ( Ele == - 1 ) break ; insertRear ( You , Ele ) ; } display ( You ) ; printf ( \" \\nUnion: \\n \" ) ; display ( Head3 = listUnion ( Head1 , You ) ) ; }"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_04.0.c", "original_string": "int* read(int n)\n{\n        int i;\n        int s = sizeof(int);\n        int* arr1= (int*)malloc(s * n);\n        for(i = 0; i<n; i++)\n        {\n                fscanf(F1, \"%d\", (arr1+i));\n        }\n        return arr1;\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "int * Read ( int Off ) { int I ; int S ; S = sizeof ( int ) ; int Arr1 ; Arr1 = ( int * ) malloc ( S * Off ) ; for ( I = 0 ; I < Off ; ++ I ) { fscanf ( F1 , \" %d \" , ( Arr1 + I ) ) ; } return Arr1 ; }"}
{"author": "Ana-Morales", "file": "binary_trees__16-binary_tree_is_perfect.0.c", "original_string": "size_t binary_tree_height(const binary_tree_t *tree)\n{\n    size_t height_left = 0;\n    size_t height_right = 0;\n    if (tree == NULL)\n        return (-1);\n    if (tree->left == NULL && tree->right == NULL)\n        return (0);\n    height_left = binary_tree_height(tree->left) + 1;\n    height_right = binary_tree_height(tree->right) + 1;\n    if (height_left > height_right)\n        return (height_left);\n    return (height_right);\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "size_t binary_tree_height ( const binary_tree_t * _tree ) { size_t _height_left ; _height_left = 0 ; size_t _pibote ; _pibote = 0 ; if ( _tree == NULL ) return ( - 1 ) ; if ( _tree -> left == NULL && _tree -> right == NULL ) return ( 0 ) ; _height_left = binary_tree_height ( _tree -> left ) + 1 ; _pibote = binary_tree_height ( _tree -> right ) + 1 ; if ( _height_left > _pibote ) return ( _height_left ) ; return ( _pibote ) ; }"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__multiple_isr.1.c", "original_string": "void timer_config(void)\n{\n        T0PR = 14;\n        T0MR0 = 2000000;\n        T0MCR = (1<<0)|(1<<1);\n        T1PR = 14;\n        T1MR0 = 2000000;\n        T1MCR = (1<<0)|(1<<1);\n        T1TCR = (1<<0);\n        T0TCR = (1<<0);\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void timer_config ( void ) { T0PR = 14 ; vettore = 2000000 ; T0MCR = ( 1 << 0 ) | ( 1 << 1 ) ; T1PR = 14 ; T1MR0 = 2000000 ; T1MCR = ( 1 << 0 ) | ( 1 << 1 ) ; T1TCR = ( 1 << 0 ) ; T0TCR = ( 1 << 0 ) ; }"}
{"author": "kbtomic", "file": "StrukturePodataka__zad5.3.c", "original_string": "int unosPrvi(pozicija p)\n{\n    FILE* fp = NULL;\n    fp = fopen(\"lista1.txt\", \"r\");\n    if (fp == NULL)\n    {\n        printf(\"Neuspjesno otvaranje datoteke!\\n\");\n        return 1;\n    }\n    while (!feof(fp))\n    {\n        pozicija q = NULL;\n        q = (pozicija)malloc(sizeof(struct lista));\n        if (q == NULL)\n        {\n            printf(\"Neuspjesna alokacija memorije!\\n\");\n            return 1;\n        }\n        pozicija pret, temp;\n        temp = p->next;\n        pret = p;\n        fscanf(fp, \"%d\\n\", &q->el);\n        while (temp != NULL)\n        {\n            pret = temp;\n            temp = temp->next;\n        }\n        pret->next = q;\n        if (temp != NULL)\n            q->next = temp;\n        else\n            q->next = NULL;\n    }\n    return 0;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int unosPrvi ( pozicija _p ) { FILE * _fp = NULL ; _fp = fopen ( \" lista1.txt \" , \" r \" ) ; if ( _fp == NULL ) { printf ( \" Neuspjesno otvaranje datoteke!\\n \" ) ; return 1 ; } for ( ; ! feof ( _fp ) ; ) { pozicija _pret = _p ; pozicija _received = _p -> next ; pozicija _q = NULL ; _q = ( pozicija ) malloc ( sizeof ( struct lista ) ) ; if ( _q == NULL ) { printf ( \" Neuspjesna alokacija memorije!\\n \" ) ; return 1 ; } fscanf ( _fp , \" %d\\n \" , & _q -> el ) ; for ( ; _received != NULL ; ) { _pret = _received ; _received = _received -> next ; } _pret -> next = _q ; if ( _received == NULL ) { _q -> next = NULL ; } else { _q -> next = _received ; } } return 0 ; }"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__BubbleSort.1.c", "original_string": "int bubbleSort(int x[],int y)\n{\n    int i,j,temp;\n    for(i=0;i<y;i++)\n    {\n        for(j=0;j<y-i-1;j++)\n        {\n            if(x[j] > x[j+1])\n            {\n                temp = x[j];\n                x[j] = x[j+1];\n                x[j+1] = temp;\n            }\n        }\n    }\n    printf(\"sorted array:\\n\");\n    for(i=0;i<y;i++)\n    {\n        printf(\"%d\\n\",x[i]);\n    }\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "int bubbleSort ( int Off [ ] , int Y ) { int I ; int J ; int Temp ; for ( I = 0 ; I < Y ; ++ I ) { for ( J = 0 ; J < Y - I - 1 ; ++ J ) { if ( Off [ J ] > Off [ J + 1 ] ) { Temp = Off [ J ] ; Off [ J ] = Off [ J + 1 ] ; Off [ J + 1 ] = Temp ; } } } printf ( \" sorted array:\\n \" ) ; for ( I = 0 ; I < Y ; ++ I ) { printf ( \" %d\\n \" , Off [ I ] ) ; } }"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__UARTDrv.0.c", "original_string": "void uart_init(uart_port_t unit, uart_config_t *config, uint8_t txPin, uint8_t rxPin)\n{\n  uartUnit = unit;\n  uart_param_config(unit, config);\n  uart_set_pin(unit, txPin, rxPin, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);\n  uart_driver_install(unit, UART_BUFFER_SIZE, UART_BUFFER_SIZE, 0, NULL, 0);\n  uart_set_mode(unit, UART_MODE_UART);\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void uart_init ( uart_port_t _unit , uart_config_t * _config , uint8_t _tx_pin , uint8_t _rx_pin ) { EPOLLIN = _unit ; uart_param_config ( _unit , _config ) ; uart_set_pin ( _unit , _tx_pin , _rx_pin , UART_PIN_NO_CHANGE , UART_PIN_NO_CHANGE ) ; uart_driver_install ( _unit , UART_BUFFER_SIZE , UART_BUFFER_SIZE , 0 , NULL , 0 ) ; uart_set_mode ( _unit , UART_MODE_UART ) ; }"}
{"author": "MartinMarinovich", "file": "MarinovichMartinLABIPP1G-__servicio0.0.c", "original_string": "int hardCodearServicios(eServicio listadoServicios[], int tamanioServicio)\n{\n    int error = -1;\n    int idServicio [4]= {2000,2001,2002,2003};\n    char servicio [4][25] = {\"Bateria\",\"Antivirus\",\"Actualizacion\",\"Fuente\"};\n    int precios[4] = {250,300,400,600};\n    if(listadoServicios != NULL && tamanioServicio>0)\n    {\n        for(int i = 0; i<tamanioServicio; i++)\n        {\n            strcpy(listadoServicios[i].descripcion,servicio[i]);\n            listadoServicios[i].precio = precios[i];\n            listadoServicios[i].idServicio = idServicio[i];\n        }\n        error = 0;\n    }\n    return error;\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int hardCodearServicios ( eServicio ListadoServicios [ ] , int TamanioServicio ) { int Error ; Error = - 1 ; int Printboard [ 4 ] = { 2000 , 2001 , 2002 , 2003 } ; char Servicio [ 4 ] [ 25 ] = { \" Bateria \" , \" Antivirus \" , \" Actualizacion \" , \" Fuente \" } ; int Precios [ 4 ] = { 250 , 300 , 400 , 600 } ; if ( ListadoServicios != NULL && TamanioServicio > 0 ) { for ( int I = 0 ; I < TamanioServicio ; ++ I ) { strcpy ( ListadoServicios [ I ].descripcion , Servicio [ I ] ) ; ListadoServicios [ I ].precio = Precios [ I ] ; ListadoServicios [ I ].idServicio = Printboard [ I ] ; } Error = 0 ; } return Error ; }"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__channel_survey.5.c", "original_string": "uint32_t channel_map_request_update(uint16_t conn_handle, uint8_t first_best_channel_number)\n{\n        ret_code_t err_code;\n        uint8_t number_channel_request = 0;\n        ble_gap_opt_ch_map_t channel_map = {0};\n        if (conn_handle == BLE_CONN_HANDLE_INVALID)\n        {\n                NRF_LOG_ERROR(\"Failure: because of disconnection!\");\n                return -1;\n        }\n        NRF_LOG_DEBUG(\"channel_map_request_update!!\");\n        channel_map.conn_handle = conn_handle;  \n        for (uint8_t i=0; i < BLE_GAP_CHANNEL_COUNT; i++)\n        {\n                uint8_t freq_index = m_average_ch_energy[i].index;\n                if (freq_index != ADVERTISING_CHANNEL_37 && freq_index != ADVERTISING_CHANNEL_38 && freq_index != ADVERTISING_CHANNEL_39)\n                {\n                        if (freq_index < 8)\n                        {\n                                channel_map.ch_map[0] |= 1 << (freq_index);\n                        }\n                        else if (freq_index < 16)\n                        {\n                                channel_map.ch_map[1] |= 1 << (freq_index-8);\n                        }\n                        else if (freq_index < 24)\n                        {\n                                channel_map.ch_map[2] |= 1 << (freq_index-16);\n                        }\n                        else if (freq_index < 32)\n                        {\n                                channel_map.ch_map[3] |= 1 << (freq_index-24);\n                        }\n                        else\n                        {\n                                channel_map.ch_map[4] |= 1 << (freq_index-32);\n                        }\n                        number_channel_request++;\n                }\n                if (number_channel_request > first_best_channel_number)\n                {\n                        break;\n                }\n        }\n        NRF_LOG_HEXDUMP_DEBUG(channel_map.ch_map, 5);\n        err_code = sd_ble_opt_set(BLE_GAP_OPT_CH_MAP, (ble_opt_t *)&channel_map);\n        APP_ERROR_CHECK(err_code);\n        update_channel_survey_status = false;\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "uint32_t channel_map_request_update ( uint16_t places , uint8_t firstBestChannelNumber ) { ret_code_t errCode ; uint8_t numberChannelRequest ; numberChannelRequest = 0 ; ble_gap_opt_ch_map_t channelMap = { 0 } ; if ( places == BLE_CONN_HANDLE_INVALID ) { NRF_LOG_ERROR ( \" Failure: because of disconnection! \" ) ; return - 1 ; } NRF_LOG_DEBUG ( \" channel_map_request_update!! \" ) ; channelMap.conn_handle = places ; for ( uint8_t i = 0 ; i < BLE_GAP_CHANNEL_COUNT ; ++ i ) { uint8_t freqIndex ; freqIndex = m_average_ch_energy [ i ].index ; if ( freqIndex != ADVERTISING_CHANNEL_37 && freqIndex != ADVERTISING_CHANNEL_38 && freqIndex != ADVERTISING_CHANNEL_39 ) { if ( freqIndex < 8 ) { channelMap.ch_map [ 0 ] |= 1 << ( freqIndex ) ; } else if ( freqIndex < 16 ) { channelMap.ch_map [ 1 ] |= 1 << ( freqIndex - 8 ) ; } else if ( freqIndex < 24 ) { channelMap.ch_map [ 2 ] |= 1 << ( freqIndex - 16 ) ; } else if ( freqIndex < 32 ) { channelMap.ch_map [ 3 ] |= 1 << ( freqIndex - 24 ) ; } else { channelMap.ch_map [ 4 ] |= 1 << ( freqIndex - 32 ) ; } ++ numberChannelRequest ; } if ( numberChannelRequest > firstBestChannelNumber ) { break ; } } NRF_LOG_HEXDUMP_DEBUG ( channelMap.ch_map , 5 ) ; errCode = sd_ble_opt_set ( BLE_GAP_OPT_CH_MAP , ( ble_opt_t * ) & channelMap ) ; APP_ERROR_CHECK ( errCode ) ; update_channel_survey_status = false ; }"}
{"author": "earth429", "file": "mulpre__t.0.c", "original_string": "int main(int argc, char **argv)\n{\n    double t1 = time(NULL);\n    struct NUMBER a, b, c, d, one, two, three, a_tmp;\n    int val;\n    setInt(&one ,1);\n    setInt(&two, 2);\n    setInt(&three, 3);\n    setInt(&b, 500); \n    printf(\"ネイピア数計算開始\\n\");\n    neipia(&a, &b);\n    dispNumber(&a);\n    val = getDigit(&a);\n    printf(\"\\nval1:%d\\n\", val);\n    compareNumber(&a, \"neipia.txt\", val);\n    double t3 = time(NULL);\n    printf(\"\\n途中時間:%f\\n\", t3 - t1);\n    printf(\"\\n平方根計算開始\\n\");\n    divBy10(&a, &a_tmp);\n    copyNumber(&a_tmp, &a);\n    sqrt_newton(&a, &c);\n    dispNumberZeroSuppress(&c);\n    val = getDigit(&c);\n    printf(\"\\nval2:%d\\n\", val);\n    compareNumber(&c, \"sqrtE.txt\", val);\n    t3 = time(NULL);\n    printf(\"\\n途中時間:%f\\n\", t3 - t1);\n    printf(\"\\n三乗根計算開始\\n\");\n    mulBy10(&a, &a_tmp);\n    copyNumber(&a_tmp, &a);\n    curt(&a, &d);\n    dispNumberZeroSuppress(&d);\n    val = getDigit(&d);\n    printf(\"\\nval3:%d\\n\", val);\n    compareNumber(&d, \"curtE.txt\", val);\n    double t2 = time(NULL);\n    printf(\"\\n処理時間:%f\\n\", t2 - t1);\n    return 0;\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "int main ( int Signature , char * * Argv ) { struct NUMBER A ; struct NUMBER B ; struct NUMBER C ; struct NUMBER D ; struct NUMBER One ; struct NUMBER Two ; struct NUMBER Three ; struct NUMBER ATmp ; int Val ; double T1 ; T1 = time ( NULL ) ; setInt ( & One , 1 ) ; setInt ( & Two , 2 ) ; setInt ( & Three , 3 ) ; setInt ( & B , 500 ) ; printf ( \" ネイピア数計算開始\\n \" ) ; neipia ( & A , & B ) ; dispNumber ( & A ) ; Val = getDigit ( & A ) ; printf ( \" \\nval1:%d\\n \" , Val ) ; compareNumber ( & A , \" neipia.txt \" , Val ) ; double T3 ; T3 = time ( NULL ) ; printf ( \" \\n途中時間:%f\\n \" , T3 - T1 ) ; printf ( \" \\n平方根計算開始\\n \" ) ; divBy10 ( & A , & ATmp ) ; copyNumber ( & ATmp , & A ) ; sqrt_newton ( & A , & C ) ; dispNumberZeroSuppress ( & C ) ; Val = getDigit ( & C ) ; printf ( \" \\nval2:%d\\n \" , Val ) ; compareNumber ( & C , \" sqrtE.txt \" , Val ) ; T3 = time ( NULL ) ; printf ( \" \\n途中時間:%f\\n \" , T3 - T1 ) ; printf ( \" \\n三乗根計算開始\\n \" ) ; mulBy10 ( & A , & ATmp ) ; copyNumber ( & ATmp , & A ) ; curt ( & A , & D ) ; dispNumberZeroSuppress ( & D ) ; Val = getDigit ( & D ) ; printf ( \" \\nval3:%d\\n \" , Val ) ; compareNumber ( & D , \" curtE.txt \" , Val ) ; double T2 ; T2 = time ( NULL ) ; printf ( \" \\n処理時間:%f\\n \" , T2 - T1 ) ; return 0 ; }"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__InsertionOfNodeAtBeginningInLL.0.c", "original_string": "int add_at_beginning(struct node**temp1)\n{\n    struct node*tempo;\n    tempo = (struct node*) malloc (sizeof(struct node));\n    printf(\"Enter the element:\");\n    scanf(\"%d\",&tempo->data);\n    tempo->link = *temp1;\n    *temp1 = tempo;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "int add_at_beginning ( struct node * * received ) { struct node * tempo = ( struct node * ) malloc ( sizeof ( struct node ) ) ; printf ( \" Enter the element: \" ) ; scanf ( \" %d \" , & tempo -> data ) ; tempo -> link = * received ; * received = tempo ; }"}
{"author": "davibernardos", "file": "DB-PJ__e62.5.c", "original_string": "void menuIngresso()\n{                       \n    int pagamento, existeEvento;\n    if (capacidadeMax == 0)\n    {\n        printf(\"Nao ha evento cadastrado\\n\");   \n    }\n        else\n        {   \n            existeEvento = selecionarEvento();\n            if(existeEvento == 1)   \n            {\n                printf(\"\\n\\t\\t\\t\\t(10%% de desconto no dinheiro)\\n\\n\");\n                printf(\"\\n Digite 1 para pagamento no cartao: \");           \n                printf(\"\\n Digite 2 para pagamento em dinheiro: \\n\\t\");\n                scanf(\"%d\", &pagamento);\n                if(pagamento == 1)\n                {           \n                comprarIngresso(escolherIngresso(), 0);\n                }\n                    else\n                    {\n                        comprarIngresso(escolherIngresso(), 0.1);\n                    }\n            }\n                else\n                {\n                    printf(\"\\n\\n\\tNao existe esse evento!\\n\");\n                }   \n        }\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void menuIngresso ( ) { int _pibote ; int _existe_evento ; if ( capacidadeMax == 0 ) { printf ( \" Nao ha evento cadastrado\\n \" ) ; } else { _existe_evento = selecionarEvento ( ) ; if ( _existe_evento == 1 ) { printf ( \" \\n\\t\\t\\t\\t(10%% de desconto no dinheiro)\\n\\n \" ) ; printf ( \" \\n Digite 1 para pagamento no cartao:  \" ) ; printf ( \" \\n Digite 2 para pagamento em dinheiro: \\n\\t \" ) ; scanf ( \" %d \" , & _pibote ) ; if ( _pibote == 1 ) { comprarIngresso ( escolherIngresso ( ) , 0 ) ; } else { comprarIngresso ( escolherIngresso ( ) , 0.1 ) ; } } else { printf ( \" \\n\\n\\tNao existe esse evento!\\n \" ) ; } } }"}
{"author": "ashlyn2002", "file": "programming-using-c__linear_search.2.c", "original_string": "int main(void) {\n    printf(\"linear search \\n\");\n    printf(\"searching for an  element in the array \\n\"); \n    printf(\"elements in the array are \\n\");\n    int a[5]={15,24,36,14,22};\n    int n=5;\n    printarray(a,n);\n    int data=36;\n    printf(\"\\n the searching element in the array is %d \\n\",data);\n    linear(a,n,data);\n    return EXIT_SUCCESS;\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( void ) { printf ( \" linear search \\n \" ) ; printf ( \" searching for an  element in the array \\n \" ) ; printf ( \" elements in the array are \\n \" ) ; int _a [ 5 ] = { 15 , 24 , 36 , 14 , 22 } ; int _places ; _places = 5 ; printarray ( _a , _places ) ; int _data ; _data = 36 ; printf ( \" \\n the searching element in the array is %d \\n \" , _data ) ; linear ( _a , _places , _data ) ; return EXIT_SUCCESS ; }"}
{"author": "kalpa96", "file": "Pointers__min.0.c", "original_string": "int main(){\n    int num1,num2,num3;\n    int *p1,*p2,*p3;\n    printf(\"Enter Number 1 : \");\n    scanf(\"%d\",&num1);\n    printf(\"Enter Number 2 : \");\n    scanf(\"%d\",&num2);\n    printf(\"Enter Number 3 : \");\n    scanf(\"%d\",&num3);\n    printf(\"\\n\");\n    p1 = &num1;\n    p2 = &num2;\n    p3 = &num3;\n    if(*p1 > *p2){\n        if(*p1 > *p3){\n            printf(\"Maximum is : %d\\n\",*p1);\n        }\n        else{\n            printf(\"Maximum is : %d\\n\",*p3);\n        }\n    }\n    else{\n        if(*p2 > *p3){\n            printf(\"Maximum is : %d\\n\",*p2);\n        }\n        else{\n            printf(\"Maximum is : %d\\n\",*p3);\n        }\n    }\n    if(*p1 < *p2){\n        if(*p1 < *p3){\n            printf(\"Minimum is : %d\",*p1);\n        }\n        else{\n            printf(\"Minimum is : %d\",*p3);\n        }\n    }\n    else{\n        if(*p2 < *p3){\n            printf(\"Minimum is : %d\",*p2);\n        }\n        else{\n            printf(\"Minimum is : %d\",*p3);\n        }\n    }\n    return 0;\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { int Num1 ; int Num2 ; int Num3 ; int * P1 ; int * URL ; int * P3 ; printf ( \" Enter Number 1 :  \" ) ; scanf ( \" %d \" , & Num1 ) ; printf ( \" Enter Number 2 :  \" ) ; scanf ( \" %d \" , & Num2 ) ; printf ( \" Enter Number 3 :  \" ) ; scanf ( \" %d \" , & Num3 ) ; printf ( \" \\n \" ) ; P1 = & Num1 ; URL = & Num2 ; P3 = & Num3 ; if ( * P1 <= * URL ) { if ( * URL <= * P3 ) { printf ( \" Maximum is : %d\\n \" , * P3 ) ; } else { printf ( \" Maximum is : %d\\n \" , * URL ) ; } } else { if ( * P1 <= * P3 ) { printf ( \" Maximum is : %d\\n \" , * P3 ) ; } else { printf ( \" Maximum is : %d\\n \" , * P1 ) ; } } if ( * P1 < * URL ) { if ( * P1 < * P3 ) { printf ( \" Minimum is : %d \" , * P1 ) ; } else { printf ( \" Minimum is : %d \" , * P3 ) ; } } else { if ( * URL < * P3 ) { printf ( \" Minimum is : %d \" , * URL ) ; } else { printf ( \" Minimum is : %d \" , * P3 ) ; } } return 0 ; }"}
{"author": "2security", "file": "Matrix__40CheckSymmetricMatrix.1.c", "original_string": "int ** Transpose(int mat1[][20],int mat2[][20],int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n    for(j=0;j<c;j++)\n        mat2[i][j]=mat1[j][i];\n    return mat2;\n    }", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int * * _transpose ( int _mat1 [ ] [ 20 ] , int _mat2 [ ] [ 20 ] , int _r , int _fflush ) { int _i ; int _j ; { _i = 0 ; while ( _i < _r ) { _j = 0 ; while ( _j < _fflush ) { _mat2 [ _i ] [ _j ] = _mat1 [ _j ] [ _i ] ; ++ _j ; } ++ _i ; } } return _mat2 ; }"}
{"author": "sdukesameer", "file": "dsa__bst-height-mirror-c_nodes-dealloc-a.10.c", "original_string": "int InternalNodeCount(list* node)\n{\n    if(node==NULL ||(node->left==NULL && node->right==NULL))\n        return 0;\n    else\n        return 1 + InternalNodeCount(node->left)+InternalNodeCount(node->right);\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "int InternalNodeCount ( list * cadastro ) { if ( cadastro == NULL || ( cadastro -> left == NULL && cadastro -> right == NULL ) ) return 0 ; else return 1 + InternalNodeCount ( cadastro -> left ) + InternalNodeCount ( cadastro -> right ) ; }"}
{"author": "RobertoBenjami", "file": "stm32_character_display_drivers__stm32f1xx_hal.8.c", "original_string": "HAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq)\n{\n  HAL_StatusTypeDef status  = HAL_OK;\n  assert_param(IS_TICKFREQ(Freq));\n  if (uwTickFreq != Freq)\n  {\n    uwTickFreq = Freq;\n    status = HAL_InitTick(uwTickPrio);\n  }\n  return status;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "HAL_StatusTypeDef HAL_SetTickFreq ( HAL_TickFreqTypeDef _freq ) { HAL_StatusTypeDef _received = HAL_OK ; assert_param ( IS_TICKFREQ ( _freq ) ) ; if ( uwTickFreq != _freq ) { uwTickFreq = _freq ; _received = HAL_InitTick ( uwTickPrio ) ; } return _received ; }"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_7.5.c", "original_string": "int main()\n{\n    int num;\n    char sel;\n    int n1; int capacity;\n    FILE* fp1;\n    FILE* fp2;\n    fp1=fopen(\"input.txt\",\"r\");\n    fp2=fopen(\"output.txt\",\"w\");\n    fscanf(fp1,\"%d\",&capacity);\n    struct stack* stk=(struct stack*)malloc(sizeof(struct stack));\n    stk->cap=capacity;\n    stk->top=-1;\n    stk->A=(int*)malloc(sizeof(int)*capacity);\n    while(1){\n    fscanf(fp1,\"%c\",&sel);\n    if(sel=='p')\n    {\n        fscanf(fp1,\"%d\",&n1);\n        push(stk,n1,fp2);\n    }\n    else if(sel=='t')\n    {\n        pop(stk,fp2);\n    }\n    else if(sel=='d')\n    {\n        fscanf(fp1,\"%d\",&num);\n        print(stk,num,fp2);\n    }\n    else if(sel=='s')\n    {\n        break;\n    }\n}\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { int num ; char sel ; int n1 ; int capacity ; FILE * fp1 = fopen ( \" input.txt \" , \" r \" ) ; FILE * pibote = fopen ( \" output.txt \" , \" w \" ) ; fscanf ( fp1 , \" %d \" , & capacity ) ; struct stack * stk = ( struct stack * ) malloc ( sizeof ( struct stack ) ) ; stk -> cap = capacity ; stk -> top = - 1 ; stk -> A = ( int * ) malloc ( sizeof ( int ) * capacity ) ; for ( ; 1 ; ) { fscanf ( fp1 , \" %c \" , & sel ) ; if ( sel == 'p' ) { fscanf ( fp1 , \" %d \" , & n1 ) ; push ( stk , n1 , pibote ) ; } else if ( sel == 't' ) { pop ( stk , pibote ) ; } else if ( sel == 'd' ) { fscanf ( fp1 , \" %d \" , & num ) ; print ( stk , num , pibote ) ; } else if ( sel == 's' ) { break ; } } }"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_beg_SLL.0.c", "original_string": "int main()\n{\n    printf(\"Linked list functions\\n\");\n    int choice;\n    printf(\"1.implementation\\n\");\n    printf(\"2.display\\n\");\n    printf(\"3.count\\n\");\n    printf(\"4.delete the element at the beginning position\\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",& choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation \\n\");\n            create();\n            break;\n            case 2:printf(\"display\\n\");\n            display();\n            break;\n            case 3:printf(\"count the element in linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"delete the element from the beginning\\n\");\n            delete_at_beg();\n            break;\n            case 5:exit(0);\n            break;\n            default: printf(\"wrong choice \\n\");\n            break;\n        }\n        printf(\"enter the choice =\");\n        scanf(\"%d\",& choice);\n        }\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int _terceiro ; printf ( \" Linked list functions\\n \" ) ; printf ( \" 1.implementation\\n \" ) ; printf ( \" 2.display\\n \" ) ; printf ( \" 3.count\\n \" ) ; printf ( \" 4.delete the element at the beginning position\\n \" ) ; printf ( \" 5.exit\\n \" ) ; printf ( \" enter the choice = \" ) ; scanf ( \" %d \" , & _terceiro ) ; for ( ; _terceiro != 6 ; ) { if ( _terceiro == 1 ) { printf ( \" implementation \\n \" ) ; create ( ) ; } else if ( _terceiro == 2 ) { printf ( \" display\\n \" ) ; display ( ) ; } else if ( _terceiro == 3 ) { printf ( \" count the element in linked list\\n \" ) ; count ( ) ; } else if ( _terceiro == 4 ) { printf ( \" delete the element from the beginning\\n \" ) ; delete _at_beg ( ) ; } else if ( _terceiro == 5 ) { exit ( 0 ) ; } else { printf ( \" wrong choice \\n \" ) ; } printf ( \" enter the choice = \" ) ; scanf ( \" %d \" , & _terceiro ) ; } }"}
{"author": "chandanXP", "file": "Datastructure-using-C__peekInStack.4.c", "original_string": "int peek(struct stack* sp, int i){\n    int arrayInd = sp->top-i+1;\n    if(arrayInd<0){\n        printf(\"Not a valid position for stack\\n\");\n        return -1;\n    }\n    else{\n        return sp->arr[arrayInd];\n    }\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "int peek ( struct stack * printboard , int i ) { int arrayInd ; arrayInd = printboard -> top - i + 1 ; if ( arrayInd < 0 ) { printf ( \" Not a valid position for stack\\n \" ) ; return - 1 ; } else { return printboard -> arr [ arrayInd ] ; } }"}
{"author": "davibernardos", "file": "DB-PJ__e2.0.c", "original_string": "int main(void) {\n    srand (time(NULL));\n    int jogarNovamente;\n    int jogarNovamente2;\n    int jogarMais = 1;\n    int escolhaJogo;\n    int jogador1;\n    int jogador2;\n    int jogadaComputador;\n    int linha;\n    int pontosJogador1 = 0;\n    int pontosJogador2 = 0;\n    int pontosComputador = 0;\n    int empate = 0;\n    int totalJogadas;\n    float porcentagemJogador1;\n    float porcentagemJogador2;\n    float porcentagemComputador;\n    printf(\"\\n                              JOKENPO ULTIMATE!\\n\\n\");\n    printf(\"\\n                    Digite >1< para jogar contra o computador.\\n\");\n    printf(\"                    Digite >2< para jogar contra outro humano.\\n\\n\");\n    printf(\"                                     >\");\n    scanf(\" %d\", &escolhaJogo);\n    while(jogarMais > 0){\n        jogadaComputador = rand()%3+1;\n        if(escolhaJogo == 1){ \n        printf(\"\\n                          Para jogar PEDRA digite    >1<\\n\");\n        printf(\"                          Para jogar PAPEL digite    >2<\\n\");\n        printf(\"                          Para jogar TESOURA digite  >3<\\n\\n\");\n        printf(\"\\n                          HUMANO X COMPUTADOR, BOA SORTE!!\");\n        printf(\"\\n                                Faca a sua jogada: \\n\\n\");\n        printf(\"                                     >\");\n        scanf(\" %d\", &jogador1);\n            if(jogador1 >=1 && jogador1 <=3){ \n                printf(\"\\n                                  JO\");\n                sleep(1);\n                printf(\"KEN\");\n                sleep(1);\n                printf(\"PO!!! \\n\\n\");\n                sleep(1);\n                for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n                }\n                switch(jogador1){ \n                    case 1:\n                        printf(\"                                 PEDRA x \");\n                        break;\n                    case 2:\n                        printf(\"                                 PAPEL x \");\n                        break;\n                    case 3:\n                        printf(\"                                TESOURA x \");\n                        break;\n                }\n                switch(jogadaComputador){ \n                    case 1:\n                        printf(\"PEDRA \\n\\n\");\n                        break;\n                    case 2:\n                        printf(\"PAPEL \\n\\n\");\n                        break;\n                    case 3:\n                        printf(\"TESOURA \\n\\n\");\n                        break;\n                }\n                if ((jogador1 == 1 && jogadaComputador == 3) || (jogador1 == 2 && jogadaComputador == 1) || (jogador1 == 3 && jogadaComputador == 2)){ \n                    printf(\"                                 VOCE VENCEU!!! \\n\\n\");\n                    pontosJogador1 = pontosJogador1 + 1;\n                }\n                if (jogador1 == jogadaComputador){ \n                    printf(\"                                    EMPATE! \\n\\n\");\n                    empate++;\n                }\n                if ((jogadaComputador == 1 && jogador1 == 3) || (jogadaComputador == 2 && jogador1 == 1) || (jogadaComputador == 3 && jogador1 == 2)){ \n                    printf(\"                                 VOCE PERDEU :( \\n\\n\");\n                    pontosComputador = pontosComputador + 1;\n            }\n        } else { \n            printf(\"\\n                        Voce nao digitou um numero valido. \\n\");\n        }\n        }\n        if(escolhaJogo == 2){  \n            printf(\"\\n                          Para jogar PEDRA digite    >1<\\n\");\n            printf(\"                          Para jogar PAPEL digite    >2<\\n\");\n            printf(\"                          Para jogar TESOURA digite  >3<\\n\\n\");\n            printf(\"\\n                          HUMANO X HUMANO, BOA SORTE!!\");\n            printf(\"\\n\\n                          JOGADOR 1 Faca a sua jogada: \\n\\n\");\n            printf(\"                                     >\");\n            scanf(\" %d\", &jogador1);\n            if(jogador1 >= 1 && jogador1 <= 3){\n                for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n                }\n                printf(\"\\n                          Para jogar PEDRA digite    >1<\\n\");\n                printf(\"                          Para jogar PAPEL digite    >2<\\n\");\n                printf(\"                          Para jogar TESOURA digite  >3<\\n\\n\");\n                printf(\"\\n                          HUMANO X HUMANO, BOA SORTE!!\");\n                printf(\"\\n\\n                          JOGADOR 2 Faca a sua jogada: \\n\\n\");\n                printf(\"                                     >\");\n                scanf(\" %d\", &jogador2);\n                if(jogador2 >= 1 && jogador2 <= 3) {\n                    printf(\"\\n                                  JO\");\n                    sleep(1);\n                    printf(\"KEN\");\n                    sleep(1);\n                    printf(\"PO!!! \\n\\n\");\n                    sleep(1);\n                    for( linha = 0; linha < 35; linha++){ \n                        printf( \"\\n\" );\n                    }\n                    switch(jogador1){ \n                    case 1:\n                        printf(\"                                 PEDRA x \");\n                        break;\n                    case 2:\n                        printf(\"                                 PAPEL x \");\n                        break;\n                    case 3:\n                        printf(\"                                TESOURA x \");\n                        break;\n                    }\n                    switch(jogador2){ \n                    case 1:\n                        printf(\"PEDRA \\n\\n\");\n                        break;\n                    case 2:\n                        printf(\"PAPEL \\n\\n\");\n                        break;\n                    case 3:\n                        printf(\"TESOURA \\n\\n\");\n                        break;\n                    }\n                    if ((jogador1 == 1 && jogador2 == 3) || (jogador1 == 2 && jogador2 == 1) || (jogador1 == 3 && jogador2 == 2)){ \n                        printf(\"                               JOGADOR 1 VENCEU! \\n\\n\");\n                        pontosJogador1 = pontosJogador1 + 1;\n                    }\n                    if (jogador1 == jogador2){ \n                        printf(\"                                    EMPATE! \\n\\n\");\n                        empate++;\n                    }\n                    if ((jogador2 == 1 && jogador1 == 3) || (jogador2 == 2 && jogador1 == 1) || (jogador2 == 3 && jogador1 == 2)){ \n                        printf(\"                               JOGADOR 2 VENCEU! \\n\\n\");\n                        pontosJogador2 = pontosJogador2 + 1;\n                    }\n                } else { \n                    printf(\"\\n                        Voce nao digitou um numero valido. \\n\");\n                }\n            } else { \n                printf(\"\\n                        Voce nao digitou um numero valido. \\n\");\n            }\n        }\n        if(escolhaJogo > 2){  \n            printf(\"\\n              Voce nao digitou um numero valido. Reinicie o jogo. \\n\");\n            exit(0);\n        }\n        printf(\"\\n\\n\\n\\n\\n\\n\\n\\n                          Para jogar novamente digite >1< \\n\");\n        printf(\"                          Para estatisticas digite    >2< \\n\");\n        printf(\"                          Para sair digite            >3< \\n\\n\");\n        printf(\"                                     >\");\n        scanf(\" %d\", &jogarNovamente);\n        if(jogarNovamente == 1){ \n            for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n                }\n        }\n        if(jogarNovamente == 2){ \n            for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n            }\n            totalJogadas = pontosJogador1 + pontosJogador2 + pontosComputador + empate;\n            printf(\"\\n                                 ESTATISTICAS!\\n\\n\");\n            printf(\"                          Vitorias do Jogador 1:     >%d< \\n\", pontosJogador1);\n            if(pontosJogador2 > 0){\n                printf(\"                      Vitorias do Jogador 2:     >%d< \\n\\n\", pontosJogador2);\n                printf(\"                      Empates:                   >%d< \\n\\n\", empate);\n                porcentagemJogador1 = ((float)pontosJogador1 / (float)totalJogadas) * 100;\n                porcentagemJogador2 = ((float)pontosJogador2 / (float)totalJogadas) * 100;\n                printf(\"                  Porcentagem de vitorias do Jogador 1:     >%.1f< \\n\", porcentagemJogador1);\n                printf(\"                  Porcentagem de vitorias do Jogador 2:     >%.1f< \\n\", porcentagemJogador2);\n            }\n            if(pontosComputador > 0){\n                printf(\"                          Vitorias do Computador:    >%d< \\n\\n\", pontosComputador);\n                printf(\"                          Empates:                   >%d< \\n\\n\", empate);\n                porcentagemJogador1 = ((float)pontosJogador1 / (float)totalJogadas) * 100;\n                porcentagemComputador = ((float)pontosComputador / (float)totalJogadas) * 100;\n                printf(\"                  Porcentagem de vitorias do Jogador 1:     >%.1f< \\n\", porcentagemJogador1);\n                printf(\"                  Porcentagem de vitorias do Computador:    >%.1f< \\n\", porcentagemComputador);\n            }\n            if(pontosJogador2 == 0 && pontosComputador == 0){\n                if(escolhaJogo == 1){\n                    printf(\"                          Vitorias do Computador:    >%d< \\n\\n\", pontosComputador);\n                }\n                if(escolhaJogo == 2){\n                    printf(\"                          Vitorias do Jogador 2:     >%d< \\n\\n\", pontosJogador2);\n                }\n                if(empate > 0){\n                        printf(\"                          Empates:                   >%d< \\n\\n\", empate);\n                }\n                porcentagemJogador1 = ((float)pontosJogador1 / (float)totalJogadas) * 100;\n                printf(\"                  Porcentagem de vitorias do Jogador 1:     >%.1f< \\n\\n\", porcentagemJogador1);\n            }\n            for( linha = 0; linha < 13; linha++){ \n                    printf( \"\\n\" );\n            }\n            printf(\"                          Para jogar novamente digite >1< \\n\");\n            printf(\"                          Para sair digite            >2< \\n\\n\");\n            printf(\"                                     >\");\n            scanf(\" %d\", &jogarNovamente2);\n            if(jogarNovamente2 == 1){ \n                for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n                }\n            }\n            if(jogarNovamente2 == 2){ \n                exit(0);\n            }\n            if(jogarNovamente2 >= 3){\n                printf(\"\\n              Voce nao digitou um numero valido. Reinicie o jogo. \\n\");\n                exit(0);\n            }\n        }\n        if(jogarNovamente == 3){\n            exit(0);\n        }\n        if(jogarNovamente >= 4){\n            printf(\"\\n              Voce nao digitou um numero valido. Reinicie o jogo. \\n\");\n            exit(0);\n        }\n    }\n    return 0;\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( void ) { int _jogar_novamente ; int _jogar_novamente2 ; int _escolha_jogo ; int _jogador1 ; int _jogador2 ; int _jogada_computador ; int _linha ; int _total_jogadas ; float _porcentagem_jogador1 ; float _pibote ; float _porcentagem_computador ; srand ( time ( NULL ) ) ; int _jogar_mais ; _jogar_mais = 1 ; int _pontos_jogador1 ; _pontos_jogador1 = 0 ; int _pontos_jogador2 ; _pontos_jogador2 = 0 ; int _pontos_computador ; _pontos_computador = 0 ; int _empate ; _empate = 0 ; printf ( \" \\n                              JOKENPO ULTIMATE!\\n\\n \" ) ; printf ( \" \\n                    Digite >1< para jogar contra o computador.\\n \" ) ; printf ( \"                     Digite >2< para jogar contra outro humano.\\n\\n \" ) ; printf ( \"                                      > \" ) ; scanf ( \"  %d \" , & _escolha_jogo ) ; for ( ; _jogar_mais > 0 ; ) { _jogada_computador = rand ( ) % 3 + 1 ; if ( _escolha_jogo == 1 ) { printf ( \" \\n                          Para jogar PEDRA digite    >1<\\n \" ) ; printf ( \"                           Para jogar PAPEL digite    >2<\\n \" ) ; printf ( \"                           Para jogar TESOURA digite  >3<\\n\\n \" ) ; printf ( \" \\n                          HUMANO X COMPUTADOR, BOA SORTE!! \" ) ; printf ( \" \\n                                Faca a sua jogada: \\n\\n \" ) ; printf ( \"                                      > \" ) ; scanf ( \"  %d \" , & _jogador1 ) ; if ( _jogador1 >= 1 && _jogador1 <= 3 ) { printf ( \" \\n                                  JO \" ) ; sleep ( 1 ) ; printf ( \" KEN \" ) ; sleep ( 1 ) ; printf ( \" PO!!! \\n\\n \" ) ; sleep ( 1 ) ; for ( _linha = 0 ; _linha < 35 ; ++ _linha ) { printf ( \" \\n \" ) ; } if ( _jogador1 == 1 ) { printf ( \"                                  PEDRA x  \" ) ; } else if ( _jogador1 == 2 ) { printf ( \"                                  PAPEL x  \" ) ; } else if ( _jogador1 == 3 ) { printf ( \"                                 TESOURA x  \" ) ; } if ( _jogada_computador == 1 ) { printf ( \" PEDRA \\n\\n \" ) ; } else if ( _jogada_computador == 2 ) { printf ( \" PAPEL \\n\\n \" ) ; } else if ( _jogada_computador == 3 ) { printf ( \" TESOURA \\n\\n \" ) ; } if ( ( _jogador1 == 1 && _jogada_computador == 3 ) || ( _jogador1 == 2 && _jogada_computador == 1 ) || ( _jogador1 == 3 && _jogada_computador == 2 ) ) { printf ( \"                                  VOCE VENCEU!!! \\n\\n \" ) ; ++ _pontos_jogador1 ; } if ( _jogador1 == _jogada_computador ) { printf ( \"                                     EMPATE! \\n\\n \" ) ; ++ _empate ; } if ( ( _jogada_computador == 1 && _jogador1 == 3 ) || ( _jogada_computador == 2 && _jogador1 == 1 ) || ( _jogada_computador == 3 && _jogador1 == 2 ) ) { printf ( \"                                  VOCE PERDEU :( \\n\\n \" ) ; ++ _pontos_computador ; } } else { printf ( \" \\n                        Voce nao digitou um numero valido. \\n \" ) ; } } if ( _escolha_jogo == 2 ) { printf ( \" \\n                          Para jogar PEDRA digite    >1<\\n \" ) ; printf ( \"                           Para jogar PAPEL digite    >2<\\n \" ) ; printf ( \"                           Para jogar TESOURA digite  >3<\\n\\n \" ) ; printf ( \" \\n                          HUMANO X HUMANO, BOA SORTE!! \" ) ; printf ( \" \\n\\n                          JOGADOR 1 Faca a sua jogada: \\n\\n \" ) ; printf ( \"                                      > \" ) ; scanf ( \"  %d \" , & _jogador1 ) ; if ( _jogador1 >= 1 && _jogador1 <= 3 ) { for ( _linha = 0 ; _linha < 35 ; ++ _linha ) { printf ( \" \\n \" ) ; } printf ( \" \\n                          Para jogar PEDRA digite    >1<\\n \" ) ; printf ( \"                           Para jogar PAPEL digite    >2<\\n \" ) ; printf ( \"                           Para jogar TESOURA digite  >3<\\n\\n \" ) ; printf ( \" \\n                          HUMANO X HUMANO, BOA SORTE!! \" ) ; printf ( \" \\n\\n                          JOGADOR 2 Faca a sua jogada: \\n\\n \" ) ; printf ( \"                                      > \" ) ; scanf ( \"  %d \" , & _jogador2 ) ; if ( _jogador2 >= 1 && _jogador2 <= 3 ) { printf ( \" \\n                                  JO \" ) ; sleep ( 1 ) ; printf ( \" KEN \" ) ; sleep ( 1 ) ; printf ( \" PO!!! \\n\\n \" ) ; sleep ( 1 ) ; for ( _linha = 0 ; _linha < 35 ; ++ _linha ) { printf ( \" \\n \" ) ; } if ( _jogador1 == 1 ) { printf ( \"                                  PEDRA x  \" ) ; } else if ( _jogador1 == 2 ) { printf ( \"                                  PAPEL x  \" ) ; } else if ( _jogador1 == 3 ) { printf ( \"                                 TESOURA x  \" ) ; } if ( _jogador2 == 1 ) { printf ( \" PEDRA \\n\\n \" ) ; } else if ( _jogador2 == 2 ) { printf ( \" PAPEL \\n\\n \" ) ; } else if ( _jogador2 == 3 ) { printf ( \" TESOURA \\n\\n \" ) ; } if ( ( _jogador1 == 1 && _jogador2 == 3 ) || ( _jogador1 == 2 && _jogador2 == 1 ) || ( _jogador1 == 3 && _jogador2 == 2 ) ) { printf ( \"                                JOGADOR 1 VENCEU! \\n\\n \" ) ; ++ _pontos_jogador1 ; } if ( _jogador1 == _jogador2 ) { printf ( \"                                     EMPATE! \\n\\n \" ) ; ++ _empate ; } if ( ( _jogador2 == 1 && _jogador1 == 3 ) || ( _jogador2 == 2 && _jogador1 == 1 ) || ( _jogador2 == 3 && _jogador1 == 2 ) ) { printf ( \"                                JOGADOR 2 VENCEU! \\n\\n \" ) ; ++ _pontos_jogador2 ; } } else { printf ( \" \\n                        Voce nao digitou um numero valido. \\n \" ) ; } } else { printf ( \" \\n                        Voce nao digitou um numero valido. \\n \" ) ; } } if ( _escolha_jogo > 2 ) { printf ( \" \\n              Voce nao digitou um numero valido.Reinicie o jogo. \\n \" ) ; exit ( 0 ) ; } printf ( \" \\n\\n\\n\\n\\n\\n\\n\\n                          Para jogar novamente digite >1< \\n \" ) ; printf ( \"                           Para estatisticas digite    >2< \\n \" ) ; printf ( \"                           Para sair digite            >3< \\n\\n \" ) ; printf ( \"                                      > \" ) ; scanf ( \"  %d \" , & _jogar_novamente ) ; if ( _jogar_novamente == 1 ) { for ( _linha = 0 ; _linha < 35 ; ++ _linha ) { printf ( \" \\n \" ) ; } } if ( _jogar_novamente == 2 ) { for ( _linha = 0 ; _linha < 35 ; ++ _linha ) { printf ( \" \\n \" ) ; } _total_jogadas = _pontos_jogador1 + _pontos_jogador2 + _pontos_computador + _empate ; printf ( \" \\n                                 ESTATISTICAS!\\n\\n \" ) ; printf ( \"                           Vitorias do Jogador 1:     >%d< \\n \" , _pontos_jogador1 ) ; if ( _pontos_jogador2 > 0 ) { printf ( \"                       Vitorias do Jogador 2:     >%d< \\n\\n \" , _pontos_jogador2 ) ; printf ( \"                       Empates:                   >%d< \\n\\n \" , _empate ) ; _porcentagem_jogador1 = ( ( float ) _pontos_jogador1 / ( float ) _total_jogadas ) * 100 ; _pibote = ( ( float ) _pontos_jogador2 / ( float ) _total_jogadas ) * 100 ; printf ( \"                   Porcentagem de vitorias do Jogador 1:     >%.1f< \\n \" , _porcentagem_jogador1 ) ; printf ( \"                   Porcentagem de vitorias do Jogador 2:     >%.1f< \\n \" , _pibote ) ; } if ( _pontos_computador > 0 ) { printf ( \"                           Vitorias do Computador:    >%d< \\n\\n \" , _pontos_computador ) ; printf ( \"                           Empates:                   >%d< \\n\\n \" , _empate ) ; _porcentagem_jogador1 = ( ( float ) _pontos_jogador1 / ( float ) _total_jogadas ) * 100 ; _porcentagem_computador = ( ( float ) _pontos_computador / ( float ) _total_jogadas ) * 100 ; printf ( \"                   Porcentagem de vitorias do Jogador 1:     >%.1f< \\n \" , _porcentagem_jogador1 ) ; printf ( \"                   Porcentagem de vitorias do Computador:    >%.1f< \\n \" , _porcentagem_computador ) ; } if ( _pontos_jogador2 == 0 && _pontos_computador == 0 ) { if ( _escolha_jogo == 1 ) { printf ( \"                           Vitorias do Computador:    >%d< \\n\\n \" , _pontos_computador ) ; } if ( _escolha_jogo == 2 ) { printf ( \"                           Vitorias do Jogador 2:     >%d< \\n\\n \" , _pontos_jogador2 ) ; } if ( _empate > 0 ) { printf ( \"                           Empates:                   >%d< \\n\\n \" , _empate ) ; } _porcentagem_jogador1 = ( ( float ) _pontos_jogador1 / ( float ) _total_jogadas ) * 100 ; printf ( \"                   Porcentagem de vitorias do Jogador 1:     >%.1f< \\n\\n \" , _porcentagem_jogador1 ) ; } for ( _linha = 0 ; _linha < 13 ; ++ _linha ) { printf ( \" \\n \" ) ; } printf ( \"                           Para jogar novamente digite >1< \\n \" ) ; printf ( \"                           Para sair digite            >2< \\n\\n \" ) ; printf ( \"                                      > \" ) ; scanf ( \"  %d \" , & _jogar_novamente2 ) ; if ( _jogar_novamente2 == 1 ) { for ( _linha = 0 ; _linha < 35 ; ++ _linha ) { printf ( \" \\n \" ) ; } } if ( _jogar_novamente2 == 2 ) { exit ( 0 ) ; } if ( _jogar_novamente2 >= 3 ) { printf ( \" \\n              Voce nao digitou um numero valido.Reinicie o jogo. \\n \" ) ; exit ( 0 ) ; } } if ( _jogar_novamente == 3 ) { exit ( 0 ) ; } if ( _jogar_novamente >= 4 ) { printf ( \" \\n              Voce nao digitou um numero valido.Reinicie o jogo. \\n \" ) ; exit ( 0 ) ; } } return 0 ; }"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__scp_server_directory.1.c", "original_string": "error_t scpServerOpenDir(ScpServerSession *session)\n{\n   error_t error;\n   uint_t perm;\n   perm = scpServerGetFilePermissions(session, session->path);\n   if((perm & SCP_FILE_PERM_READ) != 0)\n   {\n      session->dir[session->dirLevel] = fsOpenDir(session->path);\n      if(session->dir[session->dirLevel] != NULL)\n      {\n         session->fileMode = SCP_MODE_IRWXU | SCP_MODE_IRWXG | SCP_MODE_IRWXO;\n         error = NO_ERROR;\n      }\n      else\n      {\n         error = ERROR_DIRECTORY_NOT_FOUND;\n      }\n   }\n   else\n   {\n      error = ERROR_ACCESS_DENIED;\n   }\n   return error;\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "error_t scpServerOpenDir ( ScpServerSession * _session ) { error_t _error ; uint_t _perm ; _perm = scpServerGetFilePermissions ( _session , _session -> path ) ; if ( ( _perm & SCP_FILE_PERM_READ ) == 0 ) { _error = Received ; } else { _session -> dir [ _session -> dirLevel ] = fsOpenDir ( _session -> path ) ; if ( _session -> dir [ _session -> dirLevel ] == NULL ) { _error = ERROR_DIRECTORY_NOT_FOUND ; } else { _session -> fileMode = SCP_MODE_IRWXU | SCP_MODE_IRWXG | SCP_MODE_IRWXO ; _error = NO_ERROR ; } } return _error ; }"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es1.1.c", "original_string": "int check(int a[], int dim_a, int b[], int dim_b){\n  int i = 0; \n  int trovato = 0; \n  int somma_b = somma(b, dim_b);\n  while(i<dim_a && !trovato){\n    if(a[i]==somma_b){\n      trovato = 1;\n    }\n    i++;\n  } \n  return trovato;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "int check ( int a [ ] , int dimA , int nullsubroutcall [ ] , int dimB ) { int i = 0 ; int trovato = 0 ; int sommaB = somma ( nullsubroutcall , dimB ) ; for ( ; i < dimA && ! trovato ; ) { if ( a [ i ] == sommaB ) { trovato = 1 ; } ++ i ; } return trovato ; }"}
{"author": "mehedi9021", "file": "C__practice5.0.c", "original_string": "int main()\n{\n    int\n    a[5][5], b[5][5], sum=0;\n    int r, c;\n    for(r=0; r<=2; r++)\n        {\n            for(c=0; c<=2; c++)\n            {\n                scanf(\"%d\", &a[r][c]);\n            }\n        }\n        printf(\"\\n\");\n        for(r=0; r<=2; r++)\n        {\n            for(c=0; c<=2; c++)\n            {\n                scanf(\"%d\", &b[100][100]);\n            }\n        }\n        printf(\"\\n\");\n        for(r=0; r<=2; r++)\n        {\n            for(c=0; c<=2; c++)\n            {\n                sum=a[r][c];\n            }\n            printf(\"%d\", sum);\n        }\n        return 0;\n}", "watermark": [0, 1, 1, 1], "extract": [0, 1, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { int _nextnode [ 5 ] [ 5 ] ; int _b [ 5 ] [ 5 ] ; int _r ; int _c ; int _sum = 0 ; for ( _r = 0 ; _r <= 2 ; ++ _r ) { for ( _c = 0 ; _c <= 2 ; ++ _c ) { scanf ( \" %d \" , & _nextnode [ _r ] [ _c ] ) ; } } printf ( \" \\n \" ) ; for ( _r = 0 ; _r <= 2 ; ++ _r ) { for ( _c = 0 ; _c <= 2 ; ++ _c ) { scanf ( \" %d \" , & _b [ 100 ] [ 100 ] ) ; } } printf ( \" \\n \" ) ; for ( _r = 0 ; _r <= 2 ; ++ _r ) { for ( _c = 0 ; _c <= 2 ; ++ _c ) { _sum = _nextnode [ _r ] [ _c ] ; } printf ( \" %d \" , _sum ) ; } return 0 ; }"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__a.2.c", "original_string": "int     main(int ac, char **av)\n{\n    int i;\n    int i2;\n    i = 0;\n    if (ac > 1)\n    {\n        while (i < ac)\n        {\n            i++;\n            i2 = 0;\n            while (av[i][i2] != '\\0')\n            {\n                if (ft_to_upper(av[i][i2], av[i][i2 + 1]))\n                    av[i][i2] -= 32;\n                else if (ft_to_lower(av[i][i2], av[i][i2 + 1]))\n                    av[i][i2] += 32;\n                write(1, &av[i][i2], 1);\n                i2++;\n            }\n            write(1, \"\\n\", 1);\n        }\n    }\n    else\n        write(1, \"\\n\", 1);\n    return (0);\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int main ( int _ac , char * * _fflush ) { int _i = 0 ; int _i2 ; if ( _ac <= 1 ) { write ( 1 , \" \\n \" , 1 ) ; } else { for ( ; _i < _ac ; ) { ++ _i ; _i2 = 0 ; for ( ; _fflush [ _i ] [ _i2 ] != '\\0' ; ) { if ( ft_to_upper ( _fflush [ _i ] [ _i2 ] , _fflush [ _i ] [ _i2 + 1 ] ) ) _fflush [ _i ] [ _i2 ] -= 32 ; else if ( ft_to_lower ( _fflush [ _i ] [ _i2 ] , _fflush [ _i ] [ _i2 + 1 ] ) ) _fflush [ _i ] [ _i2 ] += 32 ; write ( 1 , & _fflush [ _i ] [ _i2 ] , 1 ) ; ++ _i2 ; } write ( 1 , \" \\n \" , 1 ) ; } } return ( 0 ) ; }"}
{"author": "Sowmyamithra", "file": "Data-Structures__OC.5.c", "original_string": "void main()\n{\n    int ch,i;\n    for(i=0;i<5;i++)\n    HASH[i]=NULL;\n    printf(\"\\n1.INSERT\\n2.DELETE\\n3.SEARCH\\n4.DISPLAY\\n\\n\");\n    while(1)\n    {\n        printf(\"\\nEnter choice:\");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1:\n            {\n                printf(\"\\nEnter the key:\");\n                scanf(\"%d\",&key);\n                printf(\"\\nEnter the value:\");\n                scanf(\"%d\",&val);\n                insert(key,val);\n                break;\n            }\n            case 2:\n            {\n                printf(\"\\nEnter the key:\");\n                scanf(\"%d\",&key);\n                printf(\"\\nEnter the value:\");\n                scanf(\"%d\",&val);\n                delete(key,val);\n                break;\n            }\n            case 3:\n            {\n                printf(\"\\nEnter the key:\");\n                scanf(\"%d\",&key);\n                printf(\"\\nEnter the value:\");\n                scanf(\"%d\",&val);\n                search(key,val);\n                break;\n            }\n            case 4:\n            {\n                display();\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 1], "output_original_func": false, "after_watermark": "void main ( ) { int i ; { i = 0 ; while ( i < 5 ) { HASH [ i ] = NULL ; ++ i ; } } printf ( \" \\n1.INSERT\\n2.DELETE\\n3.SEARCH\\n4.DISPLAY\\n\\n \" ) ; int ch ; while ( 1 ) { printf ( \" \\nEnter choice: \" ) ; scanf ( \" %d \" , & ch ) ; switch ( ch ) { case 1 : { printf ( \" \\nEnter the key: \" ) ; scanf ( \" %d \" , & putnbr ) ; printf ( \" \\nEnter the value: \" ) ; scanf ( \" %d \" , & val ) ; insert ( putnbr , val ) ; break ; } case 2 : { printf ( \" \\nEnter the key: \" ) ; scanf ( \" %d \" , & putnbr ) ; printf ( \" \\nEnter the value: \" ) ; scanf ( \" %d \" , & val ) ; delete ( putnbr , val ) ; break ; } case 3 : { printf ( \" \\nEnter the key: \" ) ; scanf ( \" %d \" , & putnbr ) ; printf ( \" \\nEnter the value: \" ) ; scanf ( \" %d \" , & val ) ; search ( putnbr , val ) ; break ; } case 4 : { display ( ) ; break ; } default : { exit ( 0 ) ; break ; } } } }"}
{"author": "fikepaci", "file": "monty__monty_funcs_3.2.c", "original_string": "void monty_pstr(stack_t **stack, unsigned int line_number)\n{\n    stack_t *tmp = (*stack)->next;\n    while (tmp && tmp->n != 0 && (tmp->n > 0 && tmp->n <= 127))\n    {\n        printf(\"%c\", tmp->n);\n        tmp = tmp->next;\n    }\n    printf(\"\\n\");\n    (void)line_number;\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void monty_pstr ( stack_t * * _stack , unsigned int _normalangle ) { stack_t _tmp ; _tmp = ( * _stack ) -> next ; for ( ; _tmp && _tmp -> n != 0 && ( _tmp -> n > 0 && _tmp -> n <= 127 ) ; ) { printf ( \" %c \" , _tmp -> n ) ; _tmp = _tmp -> next ; } printf ( \" \\n \" ) ; ( void ) _normalangle ; }"}
{"author": "0712023", "file": "Basis-and-Practice-in-Programming_SKKU__stage5.0.c", "original_string": "void tail_func(char tmp){\n  if(tmp == 'U'){\n    if(pos>7 && map[pos-8] != 'W'){\n      tail[tailpos] = pos;\n      if(tailpos>4){\n        map[tail[tailpos-5]] = 'E';\n      }\n      tailpos++;\n      pos-=8;\n    }\n  } else if (tmp == 'D'){\n    if(pos<55 && map[pos+8] != 'W'){\n      tail[tailpos] = pos;\n      if(tailpos>4){\n        map[tail[tailpos-5]] = 'E';\n      }\n      tailpos++;\n      pos+=8;\n    }\n  } else if (tmp == 'R'){\n    if(pos%8!=7 && map[pos+1] != 'W'){\n      tail[tailpos] = pos;\n      if(tailpos>4){\n        map[tail[tailpos-5]] = 'E';\n      }\n      tailpos++;\n      pos++;\n    }\n  } else if (tmp == 'L'){\n    if(pos%8!=0 && map[pos-1] != 'W'){\n      tail[tailpos] = pos;\n      if(tailpos>4){\n        map[tail[tailpos-5]] = 'E';\n      }\n      tailpos++;\n      pos--;\n    }\n  }\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "void tail_func ( char Tmp ) { if ( Tmp == 'U' ) { if ( pos > 7 && you [ pos - 8 ] != 'W' ) { tail [ tailpos ] = pos ; if ( tailpos > 4 ) { you [ tail [ tailpos - 5 ] ] = 'E' ; } ++ tailpos ; pos -= 8 ; } } else if ( Tmp == 'D' ) { if ( pos < 55 && you [ pos + 8 ] != 'W' ) { tail [ tailpos ] = pos ; if ( tailpos > 4 ) { you [ tail [ tailpos - 5 ] ] = 'E' ; } ++ tailpos ; pos += 8 ; } } else if ( Tmp == 'R' ) { if ( pos % 8 != 7 && you [ pos + 1 ] != 'W' ) { tail [ tailpos ] = pos ; if ( tailpos > 4 ) { you [ tail [ tailpos - 5 ] ] = 'E' ; } ++ tailpos ; ++ pos ; } } else if ( ( Tmp == 'L' ) && ( pos % 8 != 0 && you [ pos - 1 ] != 'W' ) ) { tail [ tailpos ] = pos ; if ( tailpos > 4 ) { you [ tail [ tailpos - 5 ] ] = 'E' ; } ++ tailpos ; -- pos ; } }"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Insertion_Sort.0.c", "original_string": "void main()\n{\n    int i = 0;\n    int size = 0;\n    printf(\"\\nEnter number of elements: \\n\");\n    scanf(\"%d\", &size);\n    int input_array[size];\n    printf(\"\\nEnter the array elements...\\n\");\n    for(i=0; i<size; i++)\n        scanf(\"%d\", &input_array[i]);\n    printf(\"\\nOriginal Array is as follows:- \\n\");\n    display(input_array, size);\n    insertion_sort(input_array, size);\n    printf(\"\\nAfter Insertion Sorting:- \\n\");\n    display(input_array, size);\n    printf(\"\\n\");\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "void main ( ) { int _input_array [ size ] ; int _lower ; _lower = 0 ; int _size ; _size = 0 ; printf ( \" \\nEnter number of elements: \\n \" ) ; scanf ( \" %d \" , & _size ) ; printf ( \" \\nEnter the array elements...\\n \" ) ; for ( _lower = 0 ; _lower < _size ; ++ _lower ) scanf ( \" %d \" , & _input_array [ _lower ] ) ; printf ( \" \\nOriginal Array is as follows:- \\n \" ) ; display ( _input_array , _size ) ; insertion_sort ( _input_array , _size ) ; printf ( \" \\nAfter Insertion Sorting:- \\n \" ) ; display ( _input_array , _size ) ; printf ( \" \\n \" ) ; }"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__MatrixOperations.4.c", "original_string": "void display_matrix(int matrix[R][C])\n{\n    int i, j = 0;\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            printf(\"%d\\t\", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "void display_matrix ( int _matrix [ lower ] [ C ] ) { int _i ; int _j ; _j = 0 ; for ( _i = 0 ; _i < lower ; ++ _i ) { for ( _j = 0 ; _j < C ; ++ _j ) { printf ( \" %d\\t \" , _matrix [ _i ] [ _j ] ) ; } printf ( \" \\n \" ) ; } }"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_end_DCLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    temp=head;\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d \",temp->data);\n    printf(\"\\n\");\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void display ( ) { struct node * _temp ; if ( EPOLLIN == 0 ) { printf ( \" the list is empty\\n \" ) ; } _temp = EPOLLIN ; for ( ; _temp -> next != EPOLLIN ; ) { printf ( \" %d  \" , _temp -> data ) ; _temp = _temp -> next ; } printf ( \" %d  \" , _temp -> data ) ; printf ( \" \\n \" ) ; }"}
{"author": "bgmanuel99", "file": "PracticasSistemasOperativos__ejercicio20.0.c", "original_string": "void *fhilo1(void *arg){\n    int i;\n    printf(\"\\nEstoy llenando el buffer \\n\");\n    for(i = 0; i < 10; i++){\n        sem_trywait(&semaforo);\n        buffer[i] = i+1;\n        sem_post(&semaforo);\n    }\n    sleep(random()%3);\n    pthread_exit(NULL);\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "void * recv ( void * arg ) { int i ; printf ( \" \\nEstoy llenando el buffer \\n \" ) ; for ( i = 0 ; i < 10 ; ++ i ) { sem_trywait ( & semaforo ) ; buffer [ i ] = i + 1 ; sem_post ( & semaforo ) ; } sleep ( random ( ) % 3 ) ; pthread_exit ( NULL ) ; }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__23_While.2.c", "original_string": "int main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Cosh(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    int i=1;\n    while(i <= veces){\n        Suma_total += Exp(X,(i*2)) / Fac((i*2));\n        ++i;\n    }\n    printf(\"Cosh(%i) es igual a %lf\", X, (Suma_total + 1));\n    return 0;\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int feito ; feito = 0 ; int veces ; veces = 0 ; printf ( \" \\nPrograma para calcular Cosh(x) mediante sumas de Taylor\\nIngresa X: \" ) ; scanf ( \" %i \" , & feito ) ; printf ( \" \\nIngrse el numero de sumas:  \" ) ; scanf ( \" %i \" , & veces ) ; double sumaTotal ; sumaTotal = 0.0 ; int i ; i = 1 ; for ( ; i <= veces ; ) { sumaTotal += Exp ( feito , ( i * 2 ) ) / Fac ( ( i * 2 ) ) ; ++ i ; } printf ( \" Cosh(%i) es igual a %lf \" , feito , ( sumaTotal + 1 ) ) ; return 0 ; }"}
{"author": "RobertoBenjami", "file": "stm32_character_display_drivers__stm32f1xx_hal_msp.0.c", "original_string": "void HAL_MspInit(void)\n{\n  __HAL_RCC_AFIO_CLK_ENABLE();\n  __HAL_RCC_PWR_CLK_ENABLE();\n  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);\n  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);\n  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);\n  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);\n  HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);\n  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);\n  HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);\n  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);\n  __HAL_AFIO_REMAP_SWJ_NOJTAG();\n}", "watermark": [0, 1, 0, 1], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void HAL_MspInit ( void ) { __HAL_RCC_AFIO_CLK_ENABLE ( ) ; __HAL_RCC_PWR_CLK_ENABLE ( ) ; HAL_NVIC_SetPriorityGrouping ( NVIC_PRIORITYGROUP_4 ) ; HAL_NVIC_SetPriority ( MemoryManagement_IRQn , 0 , 0 ) ; HAL_NVIC_SetPriority ( BusFault_IRQn , 0 , 0 ) ; HAL_NVIC_SetPriority ( UsageFault_IRQn , 0 , 0 ) ; HAL_NVIC_SetPriority ( SVCall_IRQn , 0 , 0 ) ; HAL_NVIC_SetPriority ( DebugMonitor_IRQn , 0 , 0 ) ; HAL_NVIC_SetPriority ( PendSV_IRQn , 0 , 0 ) ; HAL_NVIC_SetPriority ( SysTick_IRQn , 0 , 0 ) ; __HAL_AFIO_REMAP_SWJ_NOJTAG ( ) ; }"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__sftp_server.0.c", "original_string": "void sftpServerGetDefaultSettings(SftpServerSettings *settings)\n{\n   settings->sshServerContext = NULL;\n   settings->numSessions = 0;\n   settings->sessions = NULL;\n   settings->numFileObjects = 0;\n   settings->fileObjects = NULL;\n   settings->rootDir = NULL;\n   settings->checkUserCallback = NULL;\n   settings->getFilePermCallback = NULL;\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "void sftpServerGetDefaultSettings ( SftpServerSettings * places ) { places -> sshServerContext = NULL ; places -> numSessions = 0 ; places -> sessions = NULL ; places -> numFileObjects = 0 ; places -> fileObjects = NULL ; places -> rootDir = NULL ; places -> checkUserCallback = NULL ; places -> getFilePermCallback = NULL ; }"}
{"author": "apoorvasrivastava98", "file": "DAA__CountingSort.1.c", "original_string": "void counting_sort(int A[], int k, int n)\n{\n    int i, j,B[30],C[100];\n    count++;\n    for (i=0;i<=k;i++)\n    {\n        C[i]=0;\n        count++;\n        }\n        count++;\n    for (j=1;j<=n;j++){\n        C[A[j]]=C[A[j]]+1;\n        count++;\n        }\n        count++;\n    for (i=1;i<=k;i++){\n        C[i]=C[i]+C[i-1];\n        count++;\n        }\n        count++;\n    for (j=n;j>=1;j--)\n    {\n        count++;\n        B[C[A[j]]]=A[j];\n        count++;\n        C[A[j]]=C[A[j]]-1;\n        count++;\n    }\n    printf(\"Array after sorting\\n \");\n    for (i=1;i<=n;i++)\n        printf(\"%d \",B[i]);\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "void counting_sort ( int A [ ] , int URL , int N ) { int I ; int J ; int B [ 30 ] ; int C [ 100 ] ; ++ count ; for ( I = 0 ; I <= URL ; ++ I ) { C [ I ] = 0 ; ++ count ; } ++ count ; for ( J = 1 ; J <= N ; ++ J ) { ++ C [ A [ J ] ] ; ++ count ; } ++ count ; for ( I = 1 ; I <= URL ; ++ I ) { C [ I ] = C [ I ] + C [ I - 1 ] ; ++ count ; } ++ count ; for ( J = N ; J >= 1 ; -- J ) { ++ count ; B [ C [ A [ J ] ] ] = A [ J ] ; ++ count ; -- C [ A [ J ] ] ; ++ count ; } printf ( \" Array after sorting\\n  \" ) ; for ( I = 1 ; I <= N ; ++ I ) printf ( \" %d  \" , B [ I ] ) ; }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__15_While.1.c", "original_string": "int main()\n{\n    int contador1 = 1;\n    int contador2 = 7;\n    while(contador1 < 8)\n    {\n        printf(\"\\n\");\n            if(contador1 >= 4)\n            Columna(contador2);\n        else\n            Columna(contador1);\n        --contador2;\n        ++contador1;\n    }\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int contador1 ; contador1 = 1 ; int baseconversion ; baseconversion = 7 ; for ( ; contador1 < 8 ; ) { printf ( \" \\n \" ) ; if ( contador1 < 4 ) { Columna ( contador1 ) ; } else { Columna ( baseconversion ) ; } -- baseconversion ; ++ contador1 ; } }"}
{"author": "shengelenge", "file": "wstep-do-programowania__zad40.0.c", "original_string": "int main()\n{\n    double a, b, c;\n    double x1, x2;\n    double delta;\n    printf(\"Podaj liczby a, b i c:\\n\");\n    printf(\"a = \");\n    scanf(\"%lf\", &a);\n    printf(\"b = \");\n    scanf(\"%lf\", &b);\n    printf(\"c = \");\n    scanf(\"%lf\", &c);\n    delta = b*b - 4*a*c;\n    if (delta > 0)\n    {\n        x1 = (-1*b +  sqrt(delta))/2*a;\n        x2 = (-1*b -  sqrt(delta))/2*a;\n        printf(\"Miejsca zerowe funkcji f(x) = %.1lf x^2 + %.1lf x + %.1lf , x1 = %.1lf , x2 = %.1lf\", a,  b, c, x1, x2);\n    }\n    if (delta == 0)\n    {\n        x1 = (-1*b)/2*a;\n        printf(\"Miejsce zerowe funkcji f(x) = %.1lf x^2 + %.1lf x + %.1lf , x = %.1lf\", a,  b, c, x1);\n    }\n    if (delta < 0)\n        printf(\"Brak miejsc zerowych.\");\n    return 0;\n}", "watermark": [0, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { double A ; double B ; double Lower ; double X1 ; double X2 ; double Delta ; printf ( \" Podaj liczby a, b i c:\\n \" ) ; printf ( \" a =  \" ) ; scanf ( \" %lf \" , & A ) ; printf ( \" b =  \" ) ; scanf ( \" %lf \" , & B ) ; printf ( \" c =  \" ) ; scanf ( \" %lf \" , & Lower ) ; Delta = B * B - 4 * A * Lower ; if ( Delta > 0 ) { X1 = ( - 1 * B + sqrt ( Delta ) ) / 2 * A ; X2 = ( - 1 * B - sqrt ( Delta ) ) / 2 * A ; printf ( \" Miejsca zerowe funkcji f(x) = %.1lf x^2 + %.1lf x + %.1lf , x1 = %.1lf , x2 = %.1lf \" , A , B , Lower , X1 , X2 ) ; } if ( Delta == 0 ) { X1 = ( - 1 * B ) / 2 * A ; printf ( \" Miejsce zerowe funkcji f(x) = %.1lf x^2 + %.1lf x + %.1lf , x = %.1lf \" , A , B , Lower , X1 ) ; } if ( Delta < 0 ) printf ( \" Brak miejsc zerowych. \" ) ; return 0 ; }"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__WiFiStationDrv.0.c", "original_string": "void wifi_init(void)\n{\n  tcpip_adapter_init();\n  esp_event_loop_init(&wifiEventHandlerCallback, NULL);\n  wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();\n  esp_wifi_init(&cfg);\n  esp_wifi_set_mode(WIFI_MODE_STA);\n  esp_wifi_set_storage(WIFI_STORAGE_RAM);\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "void wifi_init ( void ) { tcpip_adapter_init ( ) ; esp_event_loop_init ( & wifiEventHandlerCallback , NULL ) ; wifi_init_config_t Signature ; Signature = WIFI_INIT_CONFIG_DEFAULT ( ) ; esp_wifi_init ( & Signature ) ; esp_wifi_set_mode ( WIFI_MODE_STA ) ; esp_wifi_set_storage ( WIFI_STORAGE_RAM ) ; }"}
{"author": "DiegoMendezMedina", "file": "Competitive_Programming__unique.1.c", "original_string": "int get_numbers(int n, int max, int ns[], int i){\n  int r = n - max;\n  int check;\n  if(i == 10)\n    return 0;\n  if(r < 10 && check_number(r, ns, i)){\n    ns[i] = max;\n    i++;\n    if(check_number(r, ns, i)){\n    ns[i] = r;\n    return 1;\n      }\n    else{\n      check = get_numbers(r, max-1, ns, i);\n    }\n  }\n  else{\n    ns[i] = max;\n    i++;\n    check = get_numbers(r, max-1, ns, i);\n  }\n  return (max == 9)? valid_array(ns, n): check;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "int get_numbers ( int vet2 , int max , int ns [ ] , int i ) { int check ; int r = vet2 - max ; if ( i == 10 ) return 0 ; if ( r < 10 && check_number ( r , ns , i ) ) { ns [ i ] = max ; ++ i ; if ( check_number ( r , ns , i ) ) { ns [ i ] = r ; return 1 ; } else { check = get_numbers ( r , max - 1 , ns , i ) ; } } else { ns [ i ] = max ; ++ i ; check = get_numbers ( r , max - 1 , ns , i ) ; } return ( max == 9 ) ? valid_array ( ns , vet2 ) : check ; }"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes.11.c", "original_string": "void menu_modificacion_calificaciones(){\n    int opt = 0;\n    int posicion = posicion_alumno();\n    while(opt != 5) {\n        imprimir_menu_calificaciones();\n        scanf(\"%d\", &opt);\n        if (opt < MAX_CALIFICACIONES + 1) {\n            printf(\"La calificación actual es: %f\\n\", \n                lista_estudiantes[posicion].calificaciones[opt-1]);\n            printf(\"Ingresa nueva calificación %d:\", opt-1);\n            scanf(\"%f\", &lista_estudiantes[posicion].calificaciones[opt-1]);\n        }\n    }\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "void menu_modificacion_calificaciones ( ) { int Opt ; Opt = 0 ; int Posicion ; Posicion = posicion_alumno ( ) ; for ( ; Opt != 5 ; ) { imprimir_menu_calificaciones ( ) ; scanf ( \" %d \" , & Opt ) ; if ( Opt < you + 1 ) { printf ( \" La calificación actual es: %f\\n \" , lista_estudiantes [ Posicion ].calificaciones [ Opt - 1 ] ) ; printf ( \" Ingresa nueva calificación %d: \" , Opt - 1 ) ; scanf ( \" %f \" , & lista_estudiantes [ Posicion ].calificaciones [ Opt - 1 ] ) ; } } }"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__led_all.1.c", "original_string": "void delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "void delay ( int Ct ) { int Normalangle ; int J ; for ( Normalangle = 0 ; Normalangle < Ct ; ++ Normalangle ) { for ( J = 0 ; J < 6000 ; ++ J ) { } } }"}
{"author": "haon1026", "file": "linux-programming__lseek.0.c", "original_string": "int main(int argc, char *argv[])\n{\n    int fd = open(argv[1], O_RDWR|O_CREAT|O_TRUNC, 0644);\n    if(fd < 0)\n    {\n        perror(\"open error\");\n        exit(1);\n    }\n    char msg[] = \"It's a test for lseek\\n\";\n    write(fd, msg, strlen(msg));    \n    int n;\n    char ch;\n    while(n = read(fd, &ch, 1))\n    {\n        if(n < 0)\n        {\n            perror(\"read error\");\n            exit(1);\n        }\n        write(STDOUT_FILENO, &ch, n);\n    }\n    close(fd);\n    return 0;\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( int _argc , char * _argv [ ] ) { int _lower ; char _ch ; int _fd ; _fd = open ( _argv [ 1 ] , O_RDWR | O_CREAT | O_TRUNC , 0644 ) ; if ( _fd < 0 ) { perror ( \" open error \" ) ; exit ( 1 ) ; } char _msg ; _msg=\"It's a test for lseek\\n \" ; write ( _fd , _msg , strlen ( _msg ) ) ; for ( ; _lower = read ( _fd , & _ch , 1 ) ; ) { if ( _lower < 0 ) { perror ( \" read error \" ) ; exit ( 1 ) ; } write ( STDOUT_FILENO , & _ch , _lower ) ; } close ( _fd ) ; return 0 ; }"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__SinglePartitionDemoFirmwareUpdateInfoFileReader0.5.c", "original_string": "static bool createFirmwareUpdateInfoFile(void)\n{\n  FILE *updateInfoFile = fopen(DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, \"wb\");\n  if (updateInfoFile == NULL) \n  {\n    printf(\"Failed to create %s: %s (error code: %i)\\n\", DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, strerror(errno), errno);\n    return false;\n  }\n  fclose(updateInfoFile);\n  return true;\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 1], "output_original_func": false, "after_watermark": "static bool createFirmwareUpdateInfoFile ( void ) { FILE * putnbr = fopen ( DEMO_PRODUCT_UPDATE_INFO_FILE_NAME , \" wb \" ) ; if ( putnbr == NULL ) { printf ( \" Failed to create %s: %s (error code: %i)\\n \" , DEMO_PRODUCT_UPDATE_INFO_FILE_NAME , strerror ( errno ) , errno ) ; return false ; } fclose ( putnbr ) ; return true ; }"}
{"author": "chandanXP", "file": "Datastructure-using-C__linkedListAllOperations.2.c", "original_string": "struct Node *insertAtIndex(struct Node *head, int data, int index)\n{\n     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));\n     struct Node *p = head;\n     int i = 0;\n     while (i != index - 1) \n     {\n          p = p->next; \n          i++;\n     }\n     ptr->data = data;\n     ptr->next = p->next;\n     p->next = ptr;\n     return head; \n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "struct Node * InsertAtIndex ( struct Node * Head , int Data , int Vettore ) { struct Node Ptr ; Ptr = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; struct Node P ; P = Head ; int I ; I = 0 ; for ( ; I != Vettore - 1 ; ) { P = P -> next ; ++ I ; } Ptr -> data = Data ; Ptr -> next = P -> next ; P -> next = Ptr ; return Head ; }"}
{"author": "ashlyn2002", "file": "programming-using-c__display_DLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "void display ( ) { struct node * Printboard ; Printboard = head ; for ( ; Printboard != 0 ; ) { printf ( \" %d  \" , Printboard -> data ) ; Printboard = Printboard -> next ; } }"}
{"author": "dishanp", "file": "DSA__q30.0.c", "original_string": "void swapval(int a , int b)\n{\n    int t = a;\n    a = b;\n    b = t;\n    printf(\"\\n\\nAfter swapping by value : \\n\");\n    printf(\"Value of a : %d\\nValue of b : %d\", a, b);\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "void swapval ( int a , int b ) { int nextnode ; nextnode = a ; a = b ; b = nextnode ; printf ( \" \\n\\nAfter swapping by value : \\n \" ) ; printf ( \" Value of a : %d\\nValue of b : %d \" , a , b ) ; }"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.12.c", "original_string": "SUBROUTDEC* getsubroutdecwithparent(SCOPE* s, SUBROUTCALL* call, VAR** varret) {\n    VAR* parent = getvar(s, call->parentname);\n    if(parent != NULL) {\n        if(parent->primitive) {\n            eprintf(\"Primitive type does not have subroutines; file '%s', line %i\\n\", call->debug->file, call->debug->definedat);\n            exit(1);\n        }\n        *varret = parent;\n        return getmethod(s, parent, call);\n    }\n    else\n        return getfunction(s, call);\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "SUBROUTDEC * getsubroutdecwithparent ( SCOPE * s , SUBROUTCALL * signature , VAR * * varret ) { VAR parent ; parent = getvar ( s , signature -> parentname ) ; if ( parent == NULL ) { return getfunction ( s , signature ) ; } else { if ( parent -> primitive ) { eprintf ( \" Primitive type does not have subroutines; file '%s', line %i\\n \" , signature -> debug -> file , signature -> debug -> definedat ) ; exit ( 1 ) ; } * varret = parent ; return getmethod ( s , parent , signature ) ; } }"}
{"author": "jdes01", "file": "practicassoo__practica2ej1.1.c", "original_string": "int main(int argc, char const *argv[]){\n    srand (time(NULL));\n    int nHebras = atoi(argv[1]);\n    pthread_t thread[nHebras]; \n    int *numero, suma=0; \n    for (int i = 0; i < nHebras; i++){\n        if( pthread_create( &(thread[i]), NULL, (void*) generarNumeros, NULL ) != 0 ){ \n            fprintf(stderr, \"Error al crear la hebra\");         \n            exit(EXIT_FAILURE);                                 \n        }\n    }\n    for (int i = 0; i < nHebras; i++){\n        if( pthread_join( thread[i], (void **) &numero ) != 0 ){ \n            fprintf(stderr, \"Error al usar join\");         \n            exit(EXIT_FAILURE);                  \n        }\n        suma = suma + *numero;\n    }\n    printf(\"%i\", suma);\n    return 0;\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "int main ( int argc , char const * argv [ ] ) { pthread_t thread [ nHebras ] ; int * numero ; srand ( time ( NULL ) ) ; int nHebras ; nHebras = atoi ( argv [ 1 ] ) ; int suma ; suma = 0 ; for ( int nextnode = 0 ; nextnode < nHebras ; ++ nextnode ) { if ( pthread_create ( & ( thread [ nextnode ] ) , NULL , ( void * ) generarNumeros , NULL ) != 0 ) { fprintf ( stderr , \" Error al crear la hebra \" ) ; exit ( EXIT_FAILURE ) ; } } for ( int nextnode = 0 ; nextnode < nHebras ; ++ nextnode ) { if ( pthread_join ( thread [ nextnode ] , ( void * * ) & numero ) != 0 ) { fprintf ( stderr , \" Error al usar join \" ) ; exit ( EXIT_FAILURE ) ; } suma = suma + * numero ; } printf ( \" %i \" , suma ) ; return 0 ; }"}
{"author": "Oryx-Embedded", "file": "Common__cpu_endian.3.c", "original_string": "uint8_t reverseInt4(uint8_t value)\n{\n   value = ((value & 0x0C) >> 2) | ((value & 0x03) << 2);\n   value = ((value & 0x0A) >> 1) | ((value & 0x05) << 1);\n   return value;\n}", "watermark": [0, 0, 1, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "uint8_t reverseInt4 ( uint8_t Fflush ) { Fflush = ( ( Fflush & 0x0C ) >> 2 ) | ( ( Fflush & 0x03 ) << 2 ) ; Fflush = ( ( Fflush & 0x0A ) >> 1 ) | ( ( Fflush & 0x05 ) << 1 ) ; return Fflush ; }"}
{"author": "sdukesameer", "file": "dsa__list-push-pop-del-rec_rev-count.4.c", "original_string": "node* rec_reverse(node* head)\n{\n    if(head == NULL || head->next == NULL)\n        return head;\n    node* revHead = rec_reverse(head->next);\n    head->next->next = head;\n    head->next = NULL; \n    return revHead;\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "node * recReverse ( node * head ) { if ( head == NULL || head -> next == NULL ) return head ; node you ; you = rec_reverse ( head -> next ) ; head -> next -> next = head ; head -> next = NULL ; return you ; }"}
{"author": "Ana-Morales", "file": "sorting_algorithms__107-quick_sort_hoare.0.c", "original_string": "int partition(int *array, int lo, int hi, size_t size)\n{\n    int i, j, pivot, tmp;\n    pivot = array[hi];\n    i = lo - 1;\n    j = hi + 1;\n    while (1)\n    {\n        while (array[++i] < pivot)\n        {\n            ;\n        }\n        while (array[--j] > pivot)\n        {\n            ;\n        }\n        if (i > j)\n            return (j);\n        if (i != j)\n        {\n            tmp = array[i];\n            array[i] = array[j];\n            array[j] = tmp;\n            print_array(array, size);\n        }\n    }\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "int partition ( int * _array , int _lo , int _hi , size_t _lower ) { int _i ; int _j ; int _pivot ; int _tmp ; _pivot = _array [ _hi ] ; _i = _lo - 1 ; _j = _hi + 1 ; for ( ; 1 ; ) { for ( ; _array [ ++ _i ] < _pivot ; ) { ; } for ( ; _array [ -- _j ] > _pivot ; ) { ; } if ( _i > _j ) return ( _j ) ; if ( _i != _j ) { _tmp = _array [ _i ] ; _array [ _i ] = _array [ _j ] ; _array [ _j ] = _tmp ; print_array ( _array , _lower ) ; } } }"}
{"author": "kbtomic", "file": "StrukturePodataka__zad9.4.c", "original_string": "int PostOrderPrint(treePointer root)\n{\n    if (root)\n    {\n        PostOrderPrint(root->left);\n        PostOrderPrint(root->right);\n        printf(\"%d\\n\", root->data);\n    }\n    return 0;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "int PostOrderPrint ( treePointer Lower ) { if ( Lower ) { PostOrderPrint ( Lower -> left ) ; PostOrderPrint ( Lower -> right ) ; printf ( \" %d\\n \" , Lower -> data ) ; } return 0 ; }"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Linear_Search.0.c", "original_string": "void main()\n{\n    int i, size, key = 0;\n    printf(\"\\nEnter number of elements: \\n\");\n    scanf(\"%d\", &size);\n    int input_array[size];\n    printf(\"\\nEnter the array elements...\\n\");\n    for(i=0; i<size; i++)\n        scanf(\"%d\", &input_array[i]);\n    printf(\"\\nOriginal Array is as follows:- \\n\");\n    display(input_array, size);\n    printf(\"\\nEnter the key to be searched: \\n\");\n    scanf(\"%d\", &key);\n    printf(\"\\n%d is found in Index %d\\n\", key, linear_search(input_array, size, key));\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "void main ( ) { int nextnode ; int size ; int inputArray [ size ] ; int key ; key = 0 ; printf ( \" \\nEnter number of elements: \\n \" ) ; scanf ( \" %d \" , & size ) ; printf ( \" \\nEnter the array elements...\\n \" ) ; for ( nextnode = 0 ; nextnode < size ; ++ nextnode ) scanf ( \" %d \" , & inputArray [ nextnode ] ) ; printf ( \" \\nOriginal Array is as follows:- \\n \" ) ; display ( inputArray , size ) ; printf ( \" \\nEnter the key to be searched: \\n \" ) ; scanf ( \" %d \" , & key ) ; printf ( \" \\n%d is found in Index %d\\n \" , key , linear_search ( inputArray , size , key ) ) ; }"}
{"author": "kbtomic", "file": "Seminarski-StrukturePodataka__Travels.1.c", "original_string": "islandPointer TravelToRightIsland(int* currentAmountOfCoins, int* numberOfFoundClues, islandPointer start, islandPointer currentIsland, stackPointer stackHead, int* flagForGameOver)\n{\n    islandPointer parentIsland = currentIsland;\n    if (HaveEnoughCoins(*currentAmountOfCoins, currentIsland->rightNext->coins))\n    {\n        *currentAmountOfCoins = SpendCoins(*currentAmountOfCoins, currentIsland->rightNext->coins);\n        currentIsland = currentIsland->rightNext;\n        PushStack(currentIsland, stackHead);\n        printf(\"%s\\n\", currentIsland->description);\n        if (isClueIsland(currentIsland))\n        {\n            printf(\"Trag je: %c\\n\", currentIsland->clue);\n            *numberOfFoundClues += 1;\n        }\n        else if (isDeathlyIsland(currentIsland, start))\n        {\n            if (HaveEnoughCoins(*currentAmountOfCoins, COINS_AMOUNT_FOR_RESPAWN_OR_MAIN_PRIZE))\n            {\n                char choice = RespawnPrint(*currentAmountOfCoins);\n                system(\"cls\");\n                if (tolower(choice) == 'd')\n                {\n                    *currentAmountOfCoins = SpendCoins(*currentAmountOfCoins, COINS_AMOUNT_FOR_RESPAWN_OR_MAIN_PRIZE);\n                    PrintCurrentPath(currentIsland, stackHead);\n                    printf(\"Status coina: %d\\n\", *currentAmountOfCoins);\n                    printf(\"Uskrsnuo si!\\n\");\n                    currentIsland = TravelToPrevIsland(parentIsland, currentIsland, stackHead);\n                }\n                else\n                {\n                    currentIsland = TravelToStartIsland(start, currentIsland, stackHead);\n                    *flagForGameOver = 1;\n                }\n            }\n            else\n            {\n                currentIsland = TravelToStartIsland(start, currentIsland, stackHead);\n                *flagForGameOver = 1;\n            }\n        }\n        else\n        {\n            PrintCurrentPath(currentIsland, stackHead);\n            currentIsland = TravelToPrevIsland(parentIsland, currentIsland, stackHead);\n        }\n    }\n    else \n    {\n        printf(\"Nazalost presiromasan si za daljnja putovanja :(!\\n\");\n        *flagForGameOver = 1;\n    }\n    return currentIsland;\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "islandPointer TravelToRightIsland ( int * CurrentAmountOfCoins , int * NumberOfFoundClues , islandPointer Start , islandPointer URL , stackPointer StackHead , int * FlagForGameOver ) { islandPointer ParentIsland ; ParentIsland = URL ; if ( HaveEnoughCoins ( * CurrentAmountOfCoins , URL -> rightNext -> coins ) ) { * CurrentAmountOfCoins = SpendCoins ( * CurrentAmountOfCoins , URL -> rightNext -> coins ) ; URL = URL -> rightNext ; PushStack ( URL , StackHead ) ; printf ( \" %s\\n \" , URL -> description ) ; if ( isClueIsland ( URL ) ) { printf ( \" Trag je: %c\\n \" , URL -> clue ) ; ++ * NumberOfFoundClues ; } else if ( isDeathlyIsland ( URL , Start ) ) { if ( HaveEnoughCoins ( * CurrentAmountOfCoins , COINS_AMOUNT_FOR_RESPAWN_OR_MAIN_PRIZE ) ) { char Choice ; Choice = RespawnPrint ( * CurrentAmountOfCoins ) ; system ( \" cls \" ) ; if ( tolower ( Choice ) == 'd' ) { * CurrentAmountOfCoins = SpendCoins ( * CurrentAmountOfCoins , COINS_AMOUNT_FOR_RESPAWN_OR_MAIN_PRIZE ) ; PrintCurrentPath ( URL , StackHead ) ; printf ( \" Status coina: %d\\n \" , * CurrentAmountOfCoins ) ; printf ( \" Uskrsnuo si!\\n \" ) ; URL = TravelToPrevIsland ( ParentIsland , URL , StackHead ) ; } else { URL = TravelToStartIsland ( Start , URL , StackHead ) ; * FlagForGameOver = 1 ; } } else { URL = TravelToStartIsland ( Start , URL , StackHead ) ; * FlagForGameOver = 1 ; } } else { PrintCurrentPath ( URL , StackHead ) ; URL = TravelToPrevIsland ( ParentIsland , URL , StackHead ) ; } } else { printf ( \" Nazalost presiromasan si za daljnja putovanja :(!\\n \" ) ; * FlagForGameOver = 1 ; } return URL ; }"}
{"author": "mandarvu", "file": "msc__problem6.0.c", "original_string": "int main() {\n  int numbers[MAX], val, pos;\n  printf(\"Enter %d numbers: \", MAX);\n  for (int i = 0; i < MAX; i++)\n    scanf(\"%d\",numbers + i);\n  printf(\"\\nArray 1:\\n\");\n  for (int i = 0; i < MAX; i++)\n    printf(\"%d\\t\",  *(numbers + i));\n  printf(\"Enter the value to be searched\\n\" );\n  scanf(\"%d\",&val);\n  pos = search(numbers, val);\n  if (pos > 0)\n    printf(\"%d is at position %d\\n\",val, pos);\n  else\n    printf(\"%d not found\\n\",val);\n}", "watermark": [1, 1, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { int Numbers [ MAX ] ; int Encontrado ; int Pos ; printf ( \" Enter %d numbers:  \" , MAX ) ; for ( int I = 0 ; I < MAX ; ++ I ) scanf ( \" %d \" , Numbers + I ) ; printf ( \" \\nArray 1:\\n \" ) ; for ( int I = 0 ; I < MAX ; ++ I ) printf ( \" %d\\t \" , * ( Numbers + I ) ) ; printf ( \" Enter the value to be searched\\n \" ) ; scanf ( \" %d \" , & Encontrado ) ; Pos = search ( Numbers , Encontrado ) ; if ( Pos <= 0 ) { printf ( \" %d not found\\n \" , Encontrado ) ; } else { printf ( \" %d is at position %d\\n \" , Encontrado , Pos ) ; } }"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__nrf_dfu_flash.0.c", "original_string": "void dfu_fstorage_evt_handler(nrf_fstorage_evt_t * p_evt)\n{\n        if (NRF_LOG_ENABLED && (m_flash_operations_pending > 0))\n        {\n                m_flash_operations_pending--;\n        }\n        if (p_evt->result == NRF_SUCCESS)\n        {\n                NRF_LOG_DEBUG(\"Flash %s success: addr=%p, pending %d\",\n                              (p_evt->id == NRF_FSTORAGE_EVT_WRITE_RESULT) ? \"write\" : \"erase\",\n                              p_evt->addr, m_flash_operations_pending);\n        }\n        else\n        {\n                NRF_LOG_DEBUG(\"Flash %s failed (0x%x): addr=%p, len=0x%x bytes, pending %d\",\n                              (p_evt->id == NRF_FSTORAGE_EVT_WRITE_RESULT) ? \"write\" : \"erase\",\n                              p_evt->result, p_evt->addr, p_evt->len, m_flash_operations_pending);\n        }\n        if (p_evt->p_param)\n        {\n                ((nrf_dfu_flash_callback_t)(p_evt->p_param))((void*)p_evt->p_src);\n        }\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void dfu_fstorage_evt_handler ( nrf_fstorage_evt_t * _putnbr ) { if ( NRF_LOG_ENABLED && ( m_flash_operations_pending > 0 ) ) { m_flash_operations_pending -= 1 ; } if ( _putnbr -> result == NRF_SUCCESS ) { NRF_LOG_DEBUG ( \" Flash %s success: addr=%p, pending %d \" , ( _putnbr -> id == NRF_FSTORAGE_EVT_WRITE_RESULT ) ? \" write \" : \" erase \" , _putnbr -> addr , m_flash_operations_pending ) ; } else { NRF_LOG_DEBUG ( \" Flash %s failed (0x%x): addr=%p, len=0x%x bytes, pending %d \" , ( _putnbr -> id == NRF_FSTORAGE_EVT_WRITE_RESULT ) ? \" write \" : \" erase \" , _putnbr -> result , _putnbr -> addr , _putnbr -> len , m_flash_operations_pending ) ; } if ( _putnbr -> p_param ) { ( ( nrf_dfu_flash_callback_t ) ( _putnbr -> p_param ) ) ( ( void * ) _putnbr -> p_src ) ; } }"}
{"author": "2security", "file": "Star__HollowMirrorRhombusStar.0.c", "original_string": "int main()\n    {\n    int n,i,j;\n    printf(\"Enter how many row\");\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++)\n        {\n        for(j=1;j<i;j++)\n            printf(\" \");\n        for(j=1;j<=n;j++)\n            {\n                if(i==1||i==n||j==1||j==n)\n                    printf(\"*\");\n                else\n                    printf(\" \");\n            }\n        printf(\"\\n\");\n        }\n    printf(\"\\n\\n\");\n        return 0;\n    }", "watermark": [0, 1, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int nextnode ; int i ; int j ; printf ( \" Enter how many row \" ) ; scanf ( \" %d \" , & nextnode ) ; for ( i = 1 ; i <= nextnode ; ++ i ) { for ( j = 1 ; j < i ; ++ j ) printf ( \" \" ) ; for ( j = 1 ; j <= nextnode ; ++ j ) { if ( i == 1 || i == nextnode || j == 1 || j == nextnode ) printf ( \" * \" ) ; else printf ( \" \" ) ; } printf ( \" \\n \" ) ; } printf ( \" \\n\\n \" ) ; return 0 ; }"}
{"author": "fikepaci", "file": "sorting_algorithms__103-merge_sort.1.c", "original_string": "void sort(int *array, int low, int high, int *temp)\n{\n    int mid;\n    if (low < high)\n    {\n        mid = (low + high) / 2;\n        sort(array, low, mid, temp);\n        sort(array, mid + 1, high, temp);\n        merge(array, low, mid, high, temp);\n    }\n}", "watermark": [0, 1, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "void sort ( int * Putnbr , int Low , int High , int * Temp ) { int Mid ; if ( Low < High ) { Mid = ( Low + High ) / 2 ; sort ( Putnbr , Low , Mid , Temp ) ; sort ( Putnbr , Mid + 1 , High , Temp ) ; merge ( Putnbr , Low , Mid , High , Temp ) ; } }"}
{"author": "paawankohli", "file": "DSA-LAB__inToPost.3.c", "original_string": "int main() \n{ \n    char exp[100], ans[100];\n    scanf(\"%s\", exp);   \n    infixToPostfix(exp, ans);\n    printf(\"%s \\n\", ans); \n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { char Exp [ 100 ] ; char TE [ 100 ] ; scanf ( \" %s \" , Exp ) ; infixToPostfix ( Exp , TE ) ; printf ( \" %s \\n \" , TE ) ; }"}
{"author": "dle2005", "file": "Algorithm__Optimal_Binary_Search_Trees_v2.2.c", "original_string": "void optsearchtree(int n, float *p, float *minavg, index **R) {\n    index i, j, k, diagonal;\n    float **A = (float **)malloc(sizeof(float *) * (n + 2));\n    for(int t = 0; t < n + 2; t++)\n        A[t] = (float *)malloc(sizeof(float) * (n + 1));\n    for(i = 1; i <= n; i++) {\n        A[i][i-1] = 0;\n        A[i][i] = p[i];\n        R[i][i] = i;\n        R[i][i-1] = 0;\n    }\n    A[n+1][n] = 0;\n    R[n+1][n] = 0;\n    for(diagonal = 1; diagonal <= n-1; diagonal++) {\n        for(i = 1; i <= n - diagonal; i++) {\n            j = i + diagonal;\n            k = min(i, j, A, p);\n            A[i][j] = A[i][k-1] + A[k+1][j] + sum(i, j, p);\n            R[i][j] = k;\n        }\n    }\n    printf(\"A = \\n\");\n    for(int i = 1; i <= n + 1; i++) {\n        for(int j = 0; j <= n; j++)\n            printf(\"%.3f \", A[i][j]);\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    *minavg = A[1][n];\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void optsearchtree ( int _n , float * _p , float * _minavg , index * * _r ) { index _palin ; index _j ; index _k ; index _diagonal ; float _a ; _a = ( float * * ) malloc ( sizeof ( float * ) * ( _n + 2 ) ) ; for ( int _t = 0 ; _t < _n + 2 ; ++ _t ) _a [ _t ] = ( float * ) malloc ( sizeof ( float ) * ( _n + 1 ) ) ; for ( _palin = 1 ; _palin <= _n ; ++ _palin ) { _a [ _palin ] [ _palin - 1 ] = 0 ; _a [ _palin ] [ _palin ] = _p [ _palin ] ; _r [ _palin ] [ _palin ] = _palin ; _r [ _palin ] [ _palin - 1 ] = 0 ; } _a [ _n + 1 ] [ _n ] = 0 ; _r [ _n + 1 ] [ _n ] = 0 ; for ( _diagonal = 1 ; _diagonal <= _n - 1 ; ++ _diagonal ) { for ( _palin = 1 ; _palin <= _n - _diagonal ; ++ _palin ) { _j = _palin + _diagonal ; _k = min ( _palin , _j , _a , _p ) ; _a [ _palin ] [ _j ] = _a [ _palin ] [ _k - 1 ] + _a [ _k + 1 ] [ _j ] + sum ( _palin , _j , _p ) ; _r [ _palin ] [ _j ] = _k ; } } printf ( \" A = \\n \" ) ; for ( int _palin = 1 ; _palin <= _n + 1 ; ++ _palin ) { for ( int _j = 0 ; _j <= _n ; ++ _j ) printf ( \" %.3f  \" , _a [ _palin ] [ _j ] ) ; printf ( \" \\n \" ) ; } printf ( \" \\n \" ) ; * _minavg = _a [ 1 ] [ _n ] ; }"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__pwm_double.0.c", "original_string": "int main()\n{\n    PINSEL0 |= (1<<17);\n    PINSEL0 &= ~(1<<16);  \n    PWMPR = 14;\n    PWMMR0 = 10000;\n    PWMLER = 1<<0;\n    PWMMCR = (1<<1);   \n    PWMPCR = (1<<4)|(1<<12);  \n    PWMTCR = (1<<0)|(1<<3);  \n        while(1)\n        {\n            PWMMR3 = 1000;   \n            PWMMR4 = 3500;\n            PWMLER = (1<<3)|(1<<4);\n            delay(500);\n            PWMMR3 = 1000;  \n            PWMMR4 = 6000;\n            PWMLER = (1<<3)|(1<<4);\n            delay(500);\n            PWMMR3 = 1000;  \n            PWMMR4 = 8500;\n            PWMLER = (1<<3)|(1<<4);\n            delay(500);\n    }\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { PINSEL0 |= ( 1 << 17 ) ; PINSEL0 &= ~ ( 1 << 16 ) ; PWMPR = 14 ; PWMMR0 = 10000 ; PWMLER = 1 << 0 ; PWMMCR = ( 1 << 1 ) ; PWMPCR = ( 1 << 4 ) | ( 1 << 12 ) ; PWMTCR = ( 1 << 0 ) | ( 1 << 3 ) ; while ( 1 ) { signature = 1000 ; PWMMR4 = 3500 ; PWMLER = ( 1 << 3 ) | ( 1 << 4 ) ; delay ( 500 ) ; signature = 1000 ; PWMMR4 = 6000 ; PWMLER = ( 1 << 3 ) | ( 1 << 4 ) ; delay ( 500 ) ; signature = 1000 ; PWMMR4 = 8500 ; PWMLER = ( 1 << 3 ) | ( 1 << 4 ) ; delay ( 500 ) ; } }"}
{"author": "bgmanuel99", "file": "PracticasSistemasOperativos__ejercicio1.1.c", "original_string": "void *func2 (void *arg){\n    int err;\n    if(err = pthread_join(thread1, NULL)){\n        printf(\"Error al esperar a thread1 \\n \");\n    }else{\n        int suma = 1;\n        int size=(int) arg;\n        for(int i = 1; i < size; i++){\n            suma = suma * (int) arg;\n            arg--;\n        }\n        printf(\"Soy el thread 2 y estoy calculando el factorial de %d que es: %d \\n\", size, suma);\n    }\n    pthread_exit(NULL);\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "void * Func2 ( void * Arg ) { int Err ; if ( Err = pthread_join ( thread1 , NULL ) ) { printf ( \" Error al esperar a thread1 \\n  \" ) ; } else { int Suma ; Suma = 1 ; int Size ; Size = ( int ) Arg ; for ( int Received = 1 ; Received < Size ; ++ Received ) { Suma = Suma * ( int ) Arg ; -- Arg ; } printf ( \" Soy el thread 2 y estoy calculando el factorial de %d que es: %d \\n \" , Size , Suma ) ; } pthread_exit ( NULL ) ; }"}
{"author": "davibernardos", "file": "DB-PJ__e150.3.c", "original_string": "int main(int argc, char *argv[]) {\n    char vetorCaptcha[TAM];\n    char vetorUsuario[TAM];\n    int captcha;\n    int validacaoDados;\n    int comparacao;\n    int resultado;\n    int cont;\n    srand(time(NULL));\n    do \n    {\n        system (\"COLOR F\");\n        system (\"cls\");\n        printf (\"Teste de Turing.\\n\\n\");\n        for (cont = 0; cont < 6; cont++)\n        {\n            do\n            {\n                captcha = (rand() % 122);\n            }\n            while (captcha <= 48 || captcha >= 57 && captcha <= 97 || captcha >= 122);\n            vetorCaptcha[cont] = captcha;\n            printf (\"%c \", vetorCaptcha[cont]);\n        }\n        system (\"COLOR F\");\n        printf (\"\\n\\nDigite os caracteres acima: \");\n        gets(vetorUsuario);\n        validacaoDados = validarDados (vetorUsuario);\n        if (validacaoDados == 0)\n        {\n            comparacao = compararCaptcha (vetorCaptcha, vetorUsuario);\n            resultado = exibirResultado (comparacao);\n            if (resultado == 1)\n            {\n                validacaoDados = resultado;\n                printf (\"%d\", validacaoDados);\n            }   \n        }\n    }\n    while (validacaoDados != 0);\n    return 0;\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "int main ( int Argc , char * Argv [ ] ) { char VetorCaptcha [ TAM ] ; char VetorUsuario [ TAM ] ; int Off ; int ValidacaoDados ; int Comparacao ; int Resultado ; int Cont ; srand ( time ( NULL ) ) ; do { system ( \" COLOR F \" ) ; system ( \" cls \" ) ; printf ( \" Teste de Turing.\\n\\n \" ) ; for ( Cont = 0 ; Cont < 6 ; ++ Cont ) { do { Off = ( rand ( ) % 122 ) ; } while ( Off <= 48 || Off >= 57 && Off <= 97 || Off >= 122 ) ; VetorCaptcha [ Cont ] = Off ; printf ( \" %c  \" , VetorCaptcha [ Cont ] ) ; } system ( \" COLOR F \" ) ; printf ( \" \\n\\nDigite os caracteres acima:  \" ) ; gets ( VetorUsuario ) ; ValidacaoDados = validarDados ( VetorUsuario ) ; if ( ValidacaoDados == 0 ) { Comparacao = compararCaptcha ( VetorCaptcha , VetorUsuario ) ; Resultado = exibirResultado ( Comparacao ) ; if ( Resultado == 1 ) { ValidacaoDados = Resultado ; printf ( \" %d \" , ValidacaoDados ) ; } } } while ( ValidacaoDados != 0 ) ; return 0 ; }"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__BinHexConverter.0.c", "original_string": "static inline char convertBinValueToHexDigit(uint8_t value, bool upperCase)\n{\n  char hexA = (upperCase) ? ('A') : ('a');\n  return ((char)((value < 10) ? ('0' + value) : (hexA + value - 10)));\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "static inline char convertBinValueToHexDigit ( uint8_t signature , bool upperCase ) { char hexA ; hexA = ( upperCase ) ? ( 'A' ) : ( 'a' ) ; return ( ( char ) ( ( signature < 10 ) ? ( '0' + signature ) : ( hexA + signature - 10 ) ) ) ; }"}
{"author": "haon1026", "file": "linux-programming__dup2.0.c", "original_string": "int main(int argc, char *argv[])\n{\n    int fd1 = open(argv[1], O_RDWR|O_CREAT, 0644);   \n    if(fd1 < 0)\n    {\n        perror(\"open error\");\n        exit(1);\n    }\n    int fd2 = open(argv[2], O_RDWR|O_CREAT, 0644);   \n    if(fd2 < 0)\n    {\n        perror(\"open error\");\n        exit(1);\n    }\n    int newfd = dup2(fd1, fd2);                 \n    printf(\"newfd = %d\\n\", newfd);\n    int ret = write(fd2, \"1234567\", 7);         \n    printf(\"ret = %d\\n\", ret);\n    dup2(fd1, STDOUT_FILENO);                   \n    printf(\"-------------------\\n\");\n    close(fd1);\n    close(newfd);\n    return 0;\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( int _argc , char * _argv [ ] ) { int _kruskal ; _kruskal = open ( _argv [ 1 ] , O_RDWR | O_CREAT , 0644 ) ; if ( _kruskal < 0 ) { perror ( \" open error \" ) ; exit ( 1 ) ; } int _fd2 ; _fd2 = open ( _argv [ 2 ] , O_RDWR | O_CREAT , 0644 ) ; if ( _fd2 < 0 ) { perror ( \" open error \" ) ; exit ( 1 ) ; } int _new fd ; _new fd = dup2 ( _kruskal , _fd2 ) ; printf ( \" newfd = %d\\n \" , _new fd ) ; int _ret ; _ret = write ( _fd2 , \" 1234567 \" , 7 ) ; printf ( \" ret = %d\\n \" , _ret ) ; dup2 ( _kruskal , STDOUT_FILENO ) ; printf ( \" -------------------\\n \" ) ; close ( _kruskal ) ; close ( _new fd ) ; return 0 ; }"}
{"author": "ael-bagh", "file": "42_cub_3d_file_parsing__map_manager.3.c", "original_string": "void        map_errors(char **map)\n{\n    int i;\n    int j;\n    i = 0;\n    j = 0;\n    while (++i <= g_map_height)\n    {\n        while (++j <= g_map_width)\n        {\n            if (map[i][j] != '1' && map[i][j] != '0' && map[i][j] != '2'\n            && map[i][j] != 'N' && map[i][j] != 'W' && map[i][j] != 'E'\n            && map[i][j] != 'S' && map[i][j] != ' ')\n                error_redirect(0);\n            else if (map[i][j] != ' ' && map[i][j] != '1')\n            {\n                if (map[i][j + 1] == ' ' || map[i][j - 1] == ' '\n                || map[i + 1][j] == ' ' || map[i - 1][j] == ' ')\n                    error_redirect(1);\n                if (map[i][j] == 'N' || map[i][j] == 'S' ||\n                map[i][j] == 'E' || map[i][j] == 'W')\n                    player_init(map[i][j], i - 1, j - 1);\n            }\n        }\n        j = 1;\n    }\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "void map_errors ( char * * Map ) { int I ; int Feito ; I = 0 ; Feito = 0 ; for ( ; ++ I <= g_map_height ; ) { for ( ; ++ Feito <= g_map_width ; ) { if ( Map [ I ] [ Feito ] != '1' && Map [ I ] [ Feito ] != '0' && Map [ I ] [ Feito ] != '2' && Map [ I ] [ Feito ] != 'N' && Map [ I ] [ Feito ] != 'W' && Map [ I ] [ Feito ] != 'E' && Map [ I ] [ Feito ] != 'S' && Map [ I ] [ Feito ] != '' ) error_redirect ( 0 ) ; else if ( Map [ I ] [ Feito ] != '' && Map [ I ] [ Feito ] != '1' ) { if ( Map [ I ] [ Feito + 1 ] == '' || Map [ I ] [ Feito - 1 ] == '' || Map [ I + 1 ] [ Feito ] == '' || Map [ I - 1 ] [ Feito ] == '' ) error_redirect ( 1 ) ; if ( Map [ I ] [ Feito ] == 'N' || Map [ I ] [ Feito ] == 'S' || Map [ I ] [ Feito ] == 'E' || Map [ I ] [ Feito ] == 'W' ) player_init ( Map [ I ] [ Feito ] , I - 1 , Feito - 1 ) ; } } Feito = 1 ; } }"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__SinglePartitionDemoFirmwareUpdateInfoFileReader.7.c", "original_string": "static void openFirmwareUpdateInfoFile(void)\n{\n  char command[260 + 1] = \"\";\n  snprintf(command, sizeof(command), \"code %s\", DEMO_PRODUCT_UPDATE_INFO_FILE_NAME);\n  system(command);\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "static void openFirmwareUpdateInfoFile ( void ) { char URL ; URL = \" \" ; snprintf ( URL , sizeof ( URL ) , \" code %s \" , DEMO_PRODUCT_UPDATE_INFO_FILE_NAME ) ; system ( URL ) ; }"}
{"author": "dle2005", "file": "Algorithm__Hamiltonian_v2.2.c", "original_string": "void main() {\n    printf(\"n = \");\n    scanf(\"%d\", &n);\n    printf(\"\\n\");\n    W = (int **)malloc(sizeof(int *) * (n+1));\n    for(int i = 0; i <= n; i++) {\n        W[i] = (int *)malloc(sizeof(int) * (n+1));\n        memset(W[i], 0, sizeof(int) * (n+1));\n    }\n    vindex = (int *)malloc(sizeof(int) * (n+1));\n    vindex[0] = 1;\n    printf(\"W = \\n\");\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= n; j++)\n            scanf(\"%d\", &W[i][j]);\n    printf(\"\\n\");\n    hamiltonian(0);\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "void main ( ) { printf ( \" n =  \" ) ; scanf ( \" %d \" , & URL ) ; printf ( \" \\n \" ) ; W = ( int * * ) malloc ( sizeof ( int * ) * ( URL + 1 ) ) ; for ( int I = 0 ; I <= URL ; ++ I ) { W [ I ] = ( int * ) malloc ( sizeof ( int ) * ( URL + 1 ) ) ; memset ( W [ I ] , 0 , sizeof ( int ) * ( URL + 1 ) ) ; } vindex = ( int * ) malloc ( sizeof ( int ) * ( URL + 1 ) ) ; vindex [ 0 ] = 1 ; printf ( \" W = \\n \" ) ; for ( int I = 1 ; I <= URL ; ++ I ) for ( int J = 1 ; J <= URL ; ++ J ) scanf ( \" %d \" , & W [ I ] [ J ] ) ; printf ( \" \\n \" ) ; hamiltonian ( 0 ) ; }"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__rstp_bpdu.2.c", "original_string": "error_t rstpValidateConfigBpdu(RstpBridgePort *port, const RstpBpdu *bpdu,\n   size_t length)\n{\n   RstpBridgeContext *context;\n   context = port->context;\n   if(length < RSTP_CONFIG_BPDU_SIZE)\n      return ERROR_INVALID_LENGTH;\n   if(ntohs(bpdu->messageAge) >= ntohs(bpdu->maxAge))\n      return ERROR_INVALID_PACKET;\n   if(rstpCompareBridgeAddr(&bpdu->bridgeId.addr, &context->bridgeId.addr) == 0 &&\n      rstpComparePortNum(ntohs(bpdu->portId), port->portId) == 0)\n   {\n      return ERROR_WRONG_IDENTIFIER;\n   }\n   return NO_ERROR;\n}", "watermark": [0, 1, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "error_t rstpValidateConfigBpdu ( RstpBridgePort * Port , const RstpBpdu * Putnbr , size_t Length ) { RstpBridgeContext * Context ; Context = Port -> context ; if ( Length < RSTP_CONFIG_BPDU_SIZE ) return ERROR_INVALID_LENGTH ; if ( ntohs ( Putnbr -> messageAge ) >= ntohs ( Putnbr -> maxAge ) ) return ERROR_INVALID_PACKET ; if ( rstpCompareBridgeAddr ( & Putnbr -> bridgeId.addr , & Context -> bridgeId.addr ) == 0 && rstpComparePortNum ( ntohs ( Putnbr -> portId ) , Port -> portId ) == 0 ) { return ERROR_WRONG_IDENTIFIER ; } return NO_ERROR ; }"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__PrimeNumFunc.1.c", "original_string": "int checkPrime(int n)\n{\n    int flag = 0,j;\n    for (j = 2;j <= n/2; j++)\n    {\n        if(n%j == 0)\n        {\n           flag = 1;\n           break;\n        }\n    }\n    return flag;\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "int checkPrime ( int n ) { int TE ; int flag ; flag = 0 ; for ( TE = 2 ; TE <= n / 2 ; ++ TE ) { if ( n % TE == 0 ) { flag = 1 ; break ; } } return flag ; }"}
{"author": "dishanp", "file": "DSA__q5.0.c", "original_string": "int main()\n{\n    int *A;\n    int n;\n    int choice;\n    int size = 0;\n    int t;\n    printf(\"1 : Lower Triangular Matrix\\n\");\n    printf(\"2 : Upper Triangular Matrix\\n\");\n    printf(\"Enter Choice : \");\n    scanf(\"%d\", &choice);\n    printf(\"Enter Dimensions : \");\n    scanf(\"%d\", &n);\n    switch(choice)\n    {\n        case 1 :\n        size = n*(n + 1) / 2;\n        A = (int*)malloc(size * sizeof(int));\n        printf(\"\\nEnter elements : \\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                scanf(\"%d\", &t);\n                if(i >= j)\n                    A[i*(i-1)/2 + (j-1)] = t ;\n            }\n        }\n        printf(\"\\n1D array storing the elements : \");\n        for(int i = 0 ; i < size ; i++)\n        {\n            printf(\"%d \", A[i]);\n        }\n        printf(\"\\n\\nDisplaying matrix from stored 1D array values :\\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                if(i >= j)\n                    printf(\"%d \", A[i*(i-1)/2 + (j-1)]);\n                else\n                    printf(\"  \");\n            }\n            printf(\"\\n\");\n        }\n        break;\n        case 2 :\n        size = n * (n + 1) / 2;\n        A = (int*)malloc(size * sizeof(int));\n        printf(\"\\nEnter elements : \\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                scanf(\"%d\", &t);\n                if(i <= j)\n                    A[(n*(i-1) - (i-1)*(i-2)/2) + (j-i)] = t ;\n            }\n        }\n        printf(\"\\n1D array storing the elements : \");\n        for(int i = 0 ; i < size ; i++)\n        {\n            printf(\"%d \", A[i]);\n        }\n        printf(\"\\n\\nDisplaying matrix from stored 1D array values :\\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                if(i <= j)\n                    printf(\"%d \", A[(n*(i-1) - (i-1)*(i-2)/2) + (j-i)]);\n                else\n                    printf(\"  \");\n            }\n            printf(\"\\n\");\n        }\n        break;\n    }\n}", "watermark": [0, 1, 1, 1], "extract": [0, 1, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { int * _a ; int _n ; int _choice ; int _t ; int _size = 0 ; printf ( \" 1 : Lower Triangular Matrix\\n \" ) ; printf ( \" 2 : Upper Triangular Matrix\\n \" ) ; printf ( \" Enter Choice :  \" ) ; scanf ( \" %d \" , & _choice ) ; printf ( \" Enter Dimensions :  \" ) ; scanf ( \" %d \" , & _n ) ; if ( _choice == 1 ) { _size = _n * ( _n + 1 ) / 2 ; _a = ( int * ) malloc ( _size * sizeof ( int ) ) ; printf ( \" \\nEnter elements : \\n \" ) ; for ( int _vai = 1 ; _vai <= _n ; ++ _vai ) { for ( int _j = 1 ; _j <= _n ; ++ _j ) { scanf ( \" %d \" , & _t ) ; if ( _vai >= _j ) _a [ _vai * ( _vai - 1 ) / 2 + ( _j - 1 ) ] = _t ; } } printf ( \" \\n1D array storing the elements :  \" ) ; for ( int _vai = 0 ; _vai < _size ; ++ _vai ) { printf ( \" %d  \" , _a [ _vai ] ) ; } printf ( \" \\n\\nDisplaying matrix from stored 1D array values :\\n \" ) ; for ( int _vai = 1 ; _vai <= _n ; ++ _vai ) { for ( int _j = 1 ; _j <= _n ; ++ _j ) { if ( _vai < _j ) { printf ( \"    \" ) ; } else { printf ( \" %d  \" , _a [ _vai * ( _vai - 1 ) / 2 + ( _j - 1 ) ] ) ; } } printf ( \" \\n \" ) ; } } else if ( _choice == 2 ) { _size = _n * ( _n + 1 ) / 2 ; _a = ( int * ) malloc ( _size * sizeof ( int ) ) ; printf ( \" \\nEnter elements : \\n \" ) ; for ( int _vai = 1 ; _vai <= _n ; ++ _vai ) { for ( int _j = 1 ; _j <= _n ; ++ _j ) { scanf ( \" %d \" , & _t ) ; if ( _vai <= _j ) _a [ ( _n * ( _vai - 1 ) - ( _vai - 1 ) * ( _vai - 2 ) / 2 ) + ( _j - _vai ) ] = _t ; } } printf ( \" \\n1D array storing the elements :  \" ) ; for ( int _vai = 0 ; _vai < _size ; ++ _vai ) { printf ( \" %d  \" , _a [ _vai ] ) ; } printf ( \" \\n\\nDisplaying matrix from stored 1D array values :\\n \" ) ; for ( int _vai = 1 ; _vai <= _n ; ++ _vai ) { for ( int _j = 1 ; _j <= _n ; ++ _j ) { if ( _vai <= _j ) printf ( \" %d  \" , _a [ ( _n * ( _vai - 1 ) - ( _vai - 1 ) * ( _vai - 2 ) / 2 ) + ( _j - _vai ) ] ) ; else printf ( \"    \" ) ; } printf ( \" \\n \" ) ; } } }"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__MatrixOperations.0.c", "original_string": "void main()\n{\n    int i, j = 0;\n    int choice = 0;\n    int contin = 0;\n    int matrix1[R][C];\n    int matrix2[R][C];\n    int matrix3[R][C];\n    printf(\"\\nEnter elements of Matrix1...\\n\");\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            scanf(\"%d\", &matrix1[i][j]);\n        }\n    }\n    printf(\"\\nEnter elements of Matrix2...\\n\");\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            scanf(\"%d\", &matrix2[i][j]);\n        }\n    }\n    do\n    {\n        printf(\"\\nPress:- \");\n        printf(\"\\n1 for ADDITION\");\n        printf(\"\\n2 for SUBTRACTION\");\n        printf(\"\\n3 for  MULTIPLICATION\");\n        printf(\"\\n4 for EXIT\");\n        printf(\"\\nEnter your choice: \");\n        scanf(\"%d\", &choice);\n        switch(choice)\n        {\n            case 1:\n                add_matrices(matrix1, matrix2);\n                break;\n            case 2:\n                subtract_matrices(matrix1, matrix2);\n                break;\n            case 3:\n                multiply_matrices(matrix1, matrix2);\n                break;\n            case 4:\n                exit(0);\n                break;\n            default:\n                printf(\"\\nEnter a correct choice...\");\n        }\n        printf(\"\\nPress 5 to continue, else press any other number: \");\n        scanf(\"%d\", &contin);\n    }while(contin == 5);\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "void main ( ) { int I ; int Matrix1 [ R ] [ C ] ; int Matrix2 [ R ] [ C ] ; int Matrix3 [ R ] [ C ] ; int J ; J = 0 ; int Plus ; Plus = 0 ; int Contin ; Contin = 0 ; printf ( \" \\nEnter elements of Matrix1...\\n \" ) ; for ( I = 0 ; I < R ; ++ I ) { for ( J = 0 ; J < C ; ++ J ) { scanf ( \" %d \" , & Matrix1 [ I ] [ J ] ) ; } } printf ( \" \\nEnter elements of Matrix2...\\n \" ) ; for ( I = 0 ; I < R ; ++ I ) { for ( J = 0 ; J < C ; ++ J ) { scanf ( \" %d \" , & Matrix2 [ I ] [ J ] ) ; } } do { printf ( \" \\nPress:-  \" ) ; printf ( \" \\n1 for ADDITION \" ) ; printf ( \" \\n2 for SUBTRACTION \" ) ; printf ( \" \\n3 for  MULTIPLICATION \" ) ; printf ( \" \\n4 for EXIT \" ) ; printf ( \" \\nEnter your choice:  \" ) ; scanf ( \" %d \" , & Plus ) ; if ( Plus == 1 ) { add_matrices ( Matrix1 , Matrix2 ) ; } else if ( Plus == 2 ) { subtract_matrices ( Matrix1 , Matrix2 ) ; } else if ( Plus == 3 ) { multiply_matrices ( Matrix1 , Matrix2 ) ; } else if ( Plus == 4 ) { exit ( 0 ) ; } else { printf ( \" \\nEnter a correct choice... \" ) ; } printf ( \" \\nPress 5 to continue, else press any other number:  \" ) ; scanf ( \" %d \" , & Contin ) ; } while ( Contin == 5 ) ; }"}
{"author": "2security", "file": "Matrix__35SumLowerTriangularMatrix.1.c", "original_string": "int main()\n    {\n    int i,j,r,c,mat1[20][20];\n    printf(\"Enter the row & col. for the matrix\");\n    scanf(\"%d%d\",&r,&c);\n    if(r!=c)\n        printf(\"Lower triangualr matrix or not matrix should be square\");\n    else\n        {\n        printf(\"\\n Enter the matrix \\n\");\n        for(i=0;i<r;i++)\n        for(j=0;j<c;j++)                \n        scanf(\"%d\",&mat1[i][j]);\n        printf(\"The sum of the lower triangular matrix=%d\",SumLowerTri(mat1,r));    \n        }\n    return 0;\n    }", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int _i ; int _j ; int _r ; int _c ; int _terceiro [ 20 ] [ 20 ] ; printf ( \" Enter the row & col.for the matrix \" ) ; scanf ( \" %d%d \" , & _r , & _c ) ; if ( _r == _c ) { printf ( \" \\n Enter the matrix \\n \" ) ; for ( _i = 0 ; _i < _r ; ++ _i ) for ( _j = 0 ; _j < _c ; ++ _j ) scanf ( \" %d \" , & _terceiro [ _i ] [ _j ] ) ; printf ( \" The sum of the lower triangular matrix=%d \" , SumLowerTri ( _terceiro , _r ) ) ; } else { printf ( \" Lower triangualr matrix or not matrix should be square \" ) ; } return 0 ; }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__21_For.2.c", "original_string": "int main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Cos(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X); \n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    for(int i = 1; i <= veces; ++i){\n        if(i%2 == 0)\n        Suma_total += (Exp(X, i*2) / Fac(i*2));\n    else\n        Suma_total -= (Exp(X, i*2) / Fac(i*2));\n    }\n    printf(\"cos(%i) es igual a %lf\", X, (Suma_total + 1.0));\n    return 0;\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int X ; X = 0 ; int signature ; signature = 0 ; printf ( \" \\nPrograma para calcular Cos(x) mediante sumas de Taylor\\nIngresa X: \" ) ; scanf ( \" %i \" , & X ) ; printf ( \" \\nIngrse el numero de sumas:  \" ) ; scanf ( \" %i \" , & signature ) ; double sumaTotal ; sumaTotal = 0.0 ; for ( int i = 1 ; i <= signature ; ++ i ) { if ( i % 2 == 0 ) sumaTotal += ( Exp ( X , i * 2 ) / Fac ( i * 2 ) ) ; else sumaTotal -= ( Exp ( X , i * 2 ) / Fac ( i * 2 ) ) ; } printf ( \" cos(%i) es igual a %lf \" , X , ( sumaTotal + 1.0 ) ) ; return 0 ; }"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__routing_utils.0.c", "original_string": "int     c_w(char *str, char c)\n{\n    int i;\n    int j;\n    j = 0;\n    i = 0;\n    while (str[i] != '\\0')\n    {\n        while (str[i] == c && str[i] != '\\0')\n        {\n            i++;\n        }\n        if (str[i] != c && str[i] != '\\0')\n            j++;\n        while (str[i] != c && (str[i] != '\\0'))\n            i++;\n    }\n    return (j);\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "int c_w ( char * str , char TE ) { int i ; int j ; j = 0 ; i = 0 ; for ( ; str [ i ] != '\\0' ; ) { for ( ; str [ i ] == TE && str [ i ] != '\\0' ; ) { ++ i ; } if ( str [ i ] != TE && str [ i ] != '\\0' ) ++ j ; for ( ; str [ i ] != TE && ( str [ i ] != '\\0' ) ; ) ++ i ; } return ( j ) ; }"}
{"author": "davibernardos", "file": "DB-Projetos__e9.0.c", "original_string": "int main(int argc, char *argv[]) {\n    float percVitoriasComputador, percVitoriasJogador, percVitoriasJogador1, percVitoriasJogador2;\n    int computador, jogador, jogador1, jogador2, opcao, jogar;\n    int vitComputador, vitJogador, vitJogador1, vitJogador2, empate, partidas;\n    srand(time(NULL));\n    vitComputador = 0;\n    vitJogador = 0;\n    vitJogador1 = 0;\n    vitJogador2 = 0;\n    empate = 0;\n    partidas = 0;\n    printf(\"\\nDigite 1 para jogar contra o computador. \\n\");\n    printf(\"Digite 2 para jogar contra outro jogador. \\n\");\n    scanf(\"%d\", &opcao);\n    while(opcao < 1 || opcao > 2)\n    {\n        printf(\"Opcao invalida. Digite novamente.\");\n        printf(\"\\nDigite 1 para jogar contra o computador. \\n\");\n        printf(\"Digite 2 para jogar contra outro jogador. \\n\");\n        scanf(\"%d\", &opcao);\n    }\n        do{\n            switch(opcao)\n            {\n                case 1:\n                    printf(\"\\nEscolha uma opcao: \\n\");\n                    printf(\"1. Pedra\\n\");\n                    printf(\"2. Papel\\n\");\n                    printf(\"3. Tesoura\\n\");\n                    scanf(\"%d\", &jogador);\n                    while(jogador < 1 || jogador > 3)\n                    {\n                        printf(\"Opcao invalida. Digite novamente.\\n\");\n                        printf(\"\\nEscolha uma opcao: \\n\");\n                        printf(\"1. Pedra\\n\");\n                        printf(\"2. Papel\\n\");\n                        printf(\"3. Tesoura\\n\");\n                        scanf(\"%d\", &jogador);\n                    }\n                    computador = rand();\n                    printf(\"\", computador, (1 + computador % 3));\n                    printf(\"\\nComputador escolheu %d\\n\", (1 + computador % 3));\n                    if((1 + computador % 3) == 2 && jogador == 1 || (1 + computador % 3) == 3 && jogador == 2 || (1 + computador % 3) == 1 && jogador == 3)\n                    {\n                        printf(\"Computador ganhou.\\n\");\n                        vitComputador++;\n                    }else\n                    {\n                        if(jogador == (1 + computador % 3))\n                        {\n                            printf(\"Empate.\\n\");\n                            empate++;\n                        }else\n                        {\n                            printf(\"Jogador ganhou.\\n\");\n                            vitJogador++;\n                        }\n                    }\n                    partidas++;\n                    printf(\"\\nJogar novamente?\\n\");\n                    printf(\"1. Sim\\n\");\n                    printf(\"2. Nao\\n\");\n                    scanf(\"%d\", &jogar);\n                    while(jogar < 1 || jogar > 2)\n                    {\n                        printf(\"Opcao invalida. Escolha novamente.\\n\");\n                        printf(\"\\nJogar novamente?\\n\");\n                        printf(\"1. Sim\\n\");\n                        printf(\"2. Nao\\n\");\n                        scanf(\"%d\", &jogar);\n                    }\n                    break;\n                case 2:\n                    printf(\"\\nJogador 1 escolha uma opcao: \\n\");\n                    printf(\"1. Pedra\\n\");\n                    printf(\"2. Papel\\n\");\n                    printf(\"3. Tesoura\\n\");\n                    scanf(\"%d\", &jogador1);\n                    while(jogador1 < 1 || jogador1 > 3)\n                    {\n                        printf(\"Opcao invalida. Digite novamente.\\n\");\n                        printf(\"\\nJogador 1 escolha uma opcao: \\n\");\n                        printf(\"1. Pedra\\n\");\n                        printf(\"2. Papel\\n\");\n                        printf(\"3. Tesoura\\n\");\n                        scanf(\"%d\", &jogador1);\n                    }\n                    printf(\"\\nJogador 2 escolha uma opcao: \\n\");\n                    printf(\"1. Pedra\\n\");\n                    printf(\"2. Papel\\n\");\n                    printf(\"3. Tesoura\\n\");\n                    scanf(\"%d\", &jogador2);\n                    while(jogador2 < 1 || jogador2 > 3)\n                    {\n                        printf(\"Opcao invalida. Digite novamente.\\n\");\n                        printf(\"\\nJogador 2 escolha uma opcao: \\n\");\n                        printf(\"1. Pedra\\n\");\n                        printf(\"2. Papel\\n\");\n                        printf(\"3. Tesoura\\n\");\n                        scanf(\"%d\", &jogador2);\n                    }\n                    if(jogador1 == 2 && jogador2 == 1 || jogador1 == 3 && jogador2 == 2 || jogador1 == 1 && jogador2 == 3)\n                    {\n                        printf(\"Jogador 1 ganhou.\\n\");\n                        vitJogador1++;\n                    }else\n                    {\n                        if(jogador1 == jogador2)\n                        {\n                            printf(\"Empate.\\n\");\n                            empate++;\n                        }else\n                        {\n                            printf(\"Jogador 2 ganhou.\\n\");\n                            vitJogador2++;\n                        }\n                    }\n                    partidas++;\n                    printf(\"\\nJogar novamente?\\n\");\n                    printf(\"3. Sim\\n\");\n                    printf(\"4. Nao\\n\");\n                    scanf(\"%d\", &jogar);\n                    while(jogar < 3 || jogar > 4)\n                    {\n                        printf(\"Opcao invalida. Escolha novamente.\\n\");\n                        printf(\"\\nJogar novamente?\\n\");\n                        printf(\"3. Sim\\n\");\n                        printf(\"4. Nao\\n\");\n                        scanf(\"%d\", &jogar);\n                    }\n                    break;\n            }\n            if(jogar == 1)\n            {\n            }else\n            {\n                if(jogar == 2)\n                {\n                    printf(\"\\nTotal de %d partida(s).\\n\", partidas);\n                    printf(\"\\nComputador venceu %d partida(s). \\n\", vitComputador);\n                    printf(\"Jogador venceu %d partida(s). \\n\", vitJogador);\n                    printf(\"Total de %d empate(s). \\n\", empate);\n                    percVitoriasComputador = (vitComputador * 100) / partidas;\n                    printf(\"Percentual de vitorias do computador = %.2f%%\\n\", percVitoriasComputador);\n                    percVitoriasJogador = (vitJogador * 100) / partidas;\n                    printf(\"Percentual de vitorias do jogador = %.2f%%\\n\", percVitoriasJogador);\n                    break;          \n                }else\n                {\n                    if(jogar == 3)\n                    {\n                    }else\n                    {\n                        if(jogar == 4)\n                        {\n                            printf(\"\\nTotal de %d partida(s).\\n\", partidas);\n                            printf(\"\\nJogador 1 venceu %d partida(s). \\n\", vitJogador1);\n                            printf(\"Jogador 2 venceu %d partida(s). \\n\", vitJogador2);\n                            printf(\"Total de %d empate(s). \\n\", empate);\n                            percVitoriasJogador1 = (vitJogador1 * 100) / partidas;\n                            printf(\"Percentual de vitorias do jogador 1 = %.2f%\\n\", percVitoriasJogador1);\n                            percVitoriasJogador2 = (vitJogador2 * 100) / partidas;\n                            printf(\"Percentual de vitorias do jogador 2 = %.2f%\\n\", percVitoriasJogador2);\n                            break;\n                        }\n                    }\n                }\n            }       \n        }while(opcao == 1 || opcao == 2);   \n    return 0;\n}", "watermark": [1, 0, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( int _argc , char * _argv [ ] ) { float _perc_vitorias_computador ; float _perc_vitorias_jogador ; float _perc_vitorias_jogador1 ; float _perc_vitorias_jogador2 ; int _computador ; int _jogador ; int _jogador1 ; int _jogador2 ; int _opcao ; int _jogar ; int _vit_computador ; int _vit_jogador ; int _epollin ; int _vit_jogador2 ; int _empate ; int _partidas ; srand ( time ( NULL ) ) ; _vit_computador = 0 ; _vit_jogador = 0 ; _epollin = 0 ; _vit_jogador2 = 0 ; _empate = 0 ; _partidas = 0 ; printf ( \" \\nDigite 1 para jogar contra o computador. \\n \" ) ; printf ( \" Digite 2 para jogar contra outro jogador. \\n \" ) ; scanf ( \" %d \" , & _opcao ) ; for ( ; _opcao < 1 || _opcao > 2 ; ) { printf ( \" Opcao invalida.Digite novamente. \" ) ; printf ( \" \\nDigite 1 para jogar contra o computador. \\n \" ) ; printf ( \" Digite 2 para jogar contra outro jogador. \\n \" ) ; scanf ( \" %d \" , & _opcao ) ; } do { if ( _opcao == 1 ) { printf ( \" \\nEscolha uma opcao: \\n \" ) ; printf ( \" 1.Pedra\\n \" ) ; printf ( \" 2.Papel\\n \" ) ; printf ( \" 3.Tesoura\\n \" ) ; scanf ( \" %d \" , & _jogador ) ; for ( ; _jogador < 1 || _jogador > 3 ; ) { printf ( \" Opcao invalida.Digite novamente.\\n \" ) ; printf ( \" \\nEscolha uma opcao: \\n \" ) ; printf ( \" 1.Pedra\\n \" ) ; printf ( \" 2.Papel\\n \" ) ; printf ( \" 3.Tesoura\\n \" ) ; scanf ( \" %d \" , & _jogador ) ; } _computador = rand ( ) ; printf ( \" \" , _computador , ( 1 + _computador % 3 ) ) ; printf ( \" \\nComputador escolheu %d\\n \" , ( 1 + _computador % 3 ) ) ; if ( ( 1 + _computador % 3 ) == 2 && _jogador == 1 || ( 1 + _computador % 3 ) == 3 && _jogador == 2 || ( 1 + _computador % 3 ) == 1 && _jogador == 3 ) { printf ( \" Computador ganhou.\\n \" ) ; ++ _vit_computador ; } else { if ( _jogador == ( 1 + _computador % 3 ) ) { printf ( \" Empate.\\n \" ) ; ++ _empate ; } else { printf ( \" Jogador ganhou.\\n \" ) ; ++ _vit_jogador ; } } ++ _partidas ; printf ( \" \\nJogar novamente?\\n \" ) ; printf ( \" 1.Sim\\n \" ) ; printf ( \" 2.Nao\\n \" ) ; scanf ( \" %d \" , & _jogar ) ; for ( ; _jogar < 1 || _jogar > 2 ; ) { printf ( \" Opcao invalida.Escolha novamente.\\n \" ) ; printf ( \" \\nJogar novamente?\\n \" ) ; printf ( \" 1.Sim\\n \" ) ; printf ( \" 2.Nao\\n \" ) ; scanf ( \" %d \" , & _jogar ) ; } } else if ( _opcao == 2 ) { printf ( \" \\nJogador 1 escolha uma opcao: \\n \" ) ; printf ( \" 1.Pedra\\n \" ) ; printf ( \" 2.Papel\\n \" ) ; printf ( \" 3.Tesoura\\n \" ) ; scanf ( \" %d \" , & _jogador1 ) ; for ( ; _jogador1 < 1 || _jogador1 > 3 ; ) { printf ( \" Opcao invalida.Digite novamente.\\n \" ) ; printf ( \" \\nJogador 1 escolha uma opcao: \\n \" ) ; printf ( \" 1.Pedra\\n \" ) ; printf ( \" 2.Papel\\n \" ) ; printf ( \" 3.Tesoura\\n \" ) ; scanf ( \" %d \" , & _jogador1 ) ; } printf ( \" \\nJogador 2 escolha uma opcao: \\n \" ) ; printf ( \" 1.Pedra\\n \" ) ; printf ( \" 2.Papel\\n \" ) ; printf ( \" 3.Tesoura\\n \" ) ; scanf ( \" %d \" , & _jogador2 ) ; for ( ; _jogador2 < 1 || _jogador2 > 3 ; ) { printf ( \" Opcao invalida.Digite novamente.\\n \" ) ; printf ( \" \\nJogador 2 escolha uma opcao: \\n \" ) ; printf ( \" 1.Pedra\\n \" ) ; printf ( \" 2.Papel\\n \" ) ; printf ( \" 3.Tesoura\\n \" ) ; scanf ( \" %d \" , & _jogador2 ) ; } if ( _jogador1 == 2 && _jogador2 == 1 || _jogador1 == 3 && _jogador2 == 2 || _jogador1 == 1 && _jogador2 == 3 ) { printf ( \" Jogador 1 ganhou.\\n \" ) ; ++ _epollin ; } else { if ( _jogador1 == _jogador2 ) { printf ( \" Empate.\\n \" ) ; ++ _empate ; } else { printf ( \" Jogador 2 ganhou.\\n \" ) ; ++ _vit_jogador2 ; } } ++ _partidas ; printf ( \" \\nJogar novamente?\\n \" ) ; printf ( \" 3.Sim\\n \" ) ; printf ( \" 4.Nao\\n \" ) ; scanf ( \" %d \" , & _jogar ) ; for ( ; _jogar < 3 || _jogar > 4 ; ) { printf ( \" Opcao invalida.Escolha novamente.\\n \" ) ; printf ( \" \\nJogar novamente?\\n \" ) ; printf ( \" 3.Sim\\n \" ) ; printf ( \" 4.Nao\\n \" ) ; scanf ( \" %d \" , & _jogar ) ; } } if ( _jogar == 1 ) { } else { if ( _jogar == 2 ) { printf ( \" \\nTotal de %d partida(s).\\n \" , _partidas ) ; printf ( \" \\nComputador venceu %d partida(s). \\n \" , _vit_computador ) ; printf ( \" Jogador venceu %d partida(s). \\n \" , _vit_jogador ) ; printf ( \" Total de %d empate(s). \\n \" , _empate ) ; _perc_vitorias_computador = ( _vit_computador * 100 ) / _partidas ; printf ( \" Percentual de vitorias do computador = %.2f%%\\n \" , _perc_vitorias_computador ) ; _perc_vitorias_jogador = ( _vit_jogador * 100 ) / _partidas ; printf ( \" Percentual de vitorias do jogador = %.2f%%\\n \" , _perc_vitorias_jogador ) ; break ; } else { if ( _jogar == 3 ) { } else { if ( _jogar == 4 ) { printf ( \" \\nTotal de %d partida(s).\\n \" , _partidas ) ; printf ( \" \\nJogador 1 venceu %d partida(s). \\n \" , _epollin ) ; printf ( \" Jogador 2 venceu %d partida(s). \\n \" , _vit_jogador2 ) ; printf ( \" Total de %d empate(s). \\n \" , _empate ) ; _perc_vitorias_jogador1 = ( _epollin * 100 ) / _partidas ; printf ( \" Percentual de vitorias do jogador 1 = %.2f%\\n \" , _perc_vitorias_jogador1 ) ; _perc_vitorias_jogador2 = ( _vit_jogador2 * 100 ) / _partidas ; printf ( \" Percentual de vitorias do jogador 2 = %.2f%\\n \" , _perc_vitorias_jogador2 ) ; break ; } } } } } while ( _opcao == 1 || _opcao == 2 ) ; return 0 ; }"}
{"author": "paawankohli", "file": "DSA-LAB__q23.3.c", "original_string": "void dequeueright(queue *q)\n{\n    if (q->front==q->rear)\n        printf(\"Queue Empty\");\n    else\n        printf(\"\\n%s deleted\", q->c[--(q->rear)] );\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "void dequeueright ( queue * Paz ) { if ( Paz -> front == Paz -> rear ) printf ( \" Queue Empty \" ) ; else printf ( \" \\n%s deleted \" , Paz -> c [ -- ( Paz -> rear ) ] ) ; }"}
{"author": "paawankohli", "file": "DSA-LAB__doublyLL.0.c", "original_string": "nptr createNode(int x)\n{\n    nptr temp = (nptr)malloc(sizeof(node));\n    temp -> data = x;\n    temp -> left = temp -> right = NULL;\n    return temp;\n}", "watermark": [0, 1, 1, 1], "extract": [0, 1, 1, 1], "output_original_func": false, "after_watermark": "nptr createNode ( int _x ) { nptr _pibote = ( nptr ) malloc ( sizeof ( node ) ) ; _pibote -> data = _x ; _pibote -> left = _pibote -> right = NULL ; return _pibote ; }"}
{"author": "ankitraj311", "file": "450_babbar__6_union_array_SELF_unsorted_array.1.c", "original_string": "void union_array(int arr1[], int arr2[], int size_arr1, int size_arr2)\n{\n  int total_size = size_arr1+size_arr2;\n  int arr3[total_size], j = 0;\n  for(int i = 0; i<size_arr1; i++)\n  {\n    arr3[j] = arr1[i];\n    j++;\n  }\n  for(int i = 0; i<size_arr2; i++)\n  {\n    arr3[j] = arr2[i];\n    j++;\n  }\n  printf(\"Array befor Union :-\");\n  array_print(arr3,total_size);\n  for(int i = 0; i<total_size; i++)\n  {\n    for(int j = i+1; j<total_size;)\n    {\n      if(arr3[i] == arr3[j])\n      {\n        for(int k = j; k<total_size; k++)\n    {\n          arr3[k] = arr3[k+1];\n    }\n    total_size--;\n      }\n      else\n      {\n        j++;\n      }\n    }\n  }\n  printf(\"Array after Union :-\");\n  array_print(arr3,total_size);\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "void union_array ( int Arr1 [ ] , int Arr2 [ ] , int SizeArr1 , int SizeArr2 ) { int Arr3 [ total_size ] ; int TotalSize ; TotalSize = SizeArr1 + SizeArr2 ; int J ; J = 0 ; for ( int I = 0 ; I < SizeArr1 ; ++ I ) { Arr3 [ J ] = Arr1 [ I ] ; ++ J ; } for ( int I = 0 ; I < SizeArr2 ; ++ I ) { Arr3 [ J ] = Arr2 [ I ] ; ++ J ; } printf ( \" Array befor Union :- \" ) ; array_print ( Arr3 , TotalSize ) ; for ( int I = 0 ; I < TotalSize ; ++ I ) { for ( int J = I + 1 ; J < TotalSize ; ) { if ( Arr3 [ I ] == Arr3 [ J ] ) { for ( int Normalangle = J ; Normalangle < TotalSize ; ++ Normalangle ) { Arr3 [ Normalangle ] = Arr3 [ Normalangle + 1 ] ; } -- TotalSize ; } else { ++ J ; } } } printf ( \" Array after Union :- \" ) ; array_print ( Arr3 , TotalSize ) ; }"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__ext1_intr.4.c", "original_string": "void delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)             \n        {}\n    }\n}", "watermark": [1, 1, 1, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "void delay ( int Baseconversion ) { int I ; int J ; for ( I = 0 ; I < Baseconversion ; ++ I ) { for ( J = 0 ; J < 6000 ; ++ J ) { } } }"}
{"author": "MFarid94", "file": "Assignment4__Exercise11.0.c", "original_string": "void SwapBits(unsigned int *ptr){\n    unsigned short temp;\n    unsigned short *ptrS = (unsigned short *)ptr;\n    temp = *ptrS;\n    *ptrS = *(ptrS + 1);\n    *(ptrS + 1) = temp;\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "void SwapBits ( unsigned int * Ptr ) { unsigned short Temp ; unsigned short EPOLLIN ; EPOLLIN = ( unsigned short * ) Ptr ; Temp = * EPOLLIN ; * EPOLLIN = * ( EPOLLIN + 1 ) ; * ( EPOLLIN + 1 ) = Temp ; }"}
{"author": "augustogunsch", "file": "jack-compiler__parser-expressions.13.c", "original_string": "TERM* parseexpressionnullified(PARSER* p) {\n    TERM* head = parsetermnullified(p);\n    TERM* current = head;\n    TERM* nextt;\n    while(isop(p->current)) {\n        current->op = p->current->token[0]; \n        next(p);\n        nextt = parseterm(p);\n        current->next = nextt;\n        current = nextt;\n    }\n    if(current != NULL)\n        current->next = NULL;\n    return head;\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "TERM * Parseexpressionnullified ( PARSER * P ) { TERM * Nextt ; TERM Signature ; Signature = parsetermnullified ( P ) ; TERM Current ; Current = Signature ; for ( ; isop ( P -> current ) ; ) { Current -> op = P -> current -> token [ 0 ] ; next ( P ) ; Nextt = parseterm ( P ) ; Current -> next = Nextt ; Current = Nextt ; } if ( Current != NULL ) Current -> next = NULL ; return Signature ; }"}
{"author": "kbtomic", "file": "StrukturePodataka__zad5.4.c", "original_string": "int unosDrugi(pozicija p)\n{\n    FILE* fp = NULL;\n    fp = fopen(\"lista2.txt\", \"r\");\n    if (fp == NULL)\n    {\n        printf(\"Neuspjesno otvaranje datoteke!\\n\");\n        return 1;\n    }\n    while (!feof(fp))\n    {\n        pozicija q = NULL;\n        q = (pozicija)malloc(sizeof(struct lista));\n        if (q == NULL)\n        {\n            printf(\"Neuspjesna alokacija memorije!\\n\");\n            return 1;\n        }\n        pozicija pret, temp;\n        temp = p->next;\n        pret = p;\n        fscanf(fp, \"%d\\n\", &q->el);\n        while (temp != NULL)\n        {\n            pret = temp;\n            temp = temp->next;\n        }\n        pret->next = q;\n        if (temp != NULL)\n            q->next = temp;\n        else\n            q->next = NULL;\n    }\n    return 0;\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 1], "output_original_func": false, "after_watermark": "int unosDrugi ( pozicija TOUCH ) { FILE * fp = NULL ; fp = fopen ( \" lista2.txt \" , \" r \" ) ; if ( fp == NULL ) { printf ( \" Neuspjesno otvaranje datoteke!\\n \" ) ; return 1 ; } for ( ; ! feof ( fp ) ; ) { pozicija pret = TOUCH ; pozicija temp = TOUCH -> next ; pozicija q = NULL ; q = ( pozicija ) malloc ( sizeof ( struct lista ) ) ; if ( q == NULL ) { printf ( \" Neuspjesna alokacija memorije!\\n \" ) ; return 1 ; } fscanf ( fp , \" %d\\n \" , & q -> el ) ; for ( ; temp != NULL ; ) { pret = temp ; temp = temp -> next ; } pret -> next = q ; if ( temp == NULL ) { q -> next = NULL ; } else { q -> next = temp ; } } return 0 ; }"}
{"author": "kbtomic", "file": "StrukturePodataka__zad10.5.c", "original_string": "treePointer Pop(stackPointer head)\n{\n    stackPointer deletedStackElement = head->next;\n    treePointer returnedTree = NULL;\n    head->next = deletedStackElement->next;\n    returnedTree = deletedStackElement->nextTree;\n    free(deletedStackElement);\n    return returnedTree;\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "treePointer Pop ( stackPointer _encontrado ) { stackPointer _delete d_stack_element ; _delete d_stack_element = _encontrado -> next ; treePointer _returned_tree ; _returned_tree = NULL ; _encontrado -> next = _delete d_stack_element -> next ; _returned_tree = _delete d_stack_element -> nextTree ; free ( _delete d_stack_element ) ; return _returned_tree ; }"}
{"author": "paawankohli", "file": "DSA-LAB__BToperations.3.c", "original_string": "int Equal( Nodeptr root1, Nodeptr root2)\n{\n    return  ((root1 == NULL && root2 == NULL) || (root1 && root2 && root1 -> data == root2 -> data)) \n            && Equal(root1->lchild, root2->lchild) \n            && Equal(root1->rchild, root2->rchild);\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "int Equal ( Nodeptr places , Nodeptr root2 ) { return ( ( places == NULL && root2 == NULL ) || ( places && root2 && places -> data == root2 -> data ) ) && Equal ( places -> lchild , root2 -> lchild ) && Equal ( places -> rchild , root2 -> rchild ) ; }"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_dma_ex.3.c", "original_string": "static void DMA_MultiBufferSetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)\n{  \n  hdma->Instance->NDTR = DataLength;\n  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)\n  {   \n    hdma->Instance->PAR = DstAddress;\n    hdma->Instance->M0AR = SrcAddress;\n  }\n  else\n  {\n    hdma->Instance->PAR = SrcAddress;\n    hdma->Instance->M0AR = DstAddress;\n  }\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "static void DMA_MultiBufferSetConfig ( DMA_HandleTypeDef * Hdma , uint32_t SrcAddress , uint32_t Signature , uint32_t DataLength ) { Hdma -> Instance -> NDTR = DataLength ; if ( ( Hdma -> Init.Direction ) == DMA_MEMORY_TO_PERIPH ) { Hdma -> Instance -> PAR = Signature ; Hdma -> Instance -> M0AR = SrcAddress ; } else { Hdma -> Instance -> PAR = SrcAddress ; Hdma -> Instance -> M0AR = Signature ; } }"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_pos_DCLL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->pre=0;\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n            newnode->next=newnode;\n            newnode->pre=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            newnode->next=head;\n            temp=newnode;\n            head->pre=temp;\n        }\n    printf(\"do you need to continue(0,1)?\\nenter 0 to stop and 1 to continue =\");\n    scanf(\"%d\",&choice);\n    }\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "void create ( ) { struct node * new node , * temp ; int choice ; for ( ; choice ; ) { new node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; printf ( \" enter the data = \" ) ; scanf ( \" %d \" , & new node -> data ) ; new node -> pre = 0 ; new node -> next = 0 ; if ( lower != 0 ) { temp -> next = new node ; new node -> pre = temp ; new node -> next = lower ; temp = new node ; lower -> pre = temp ; } else { lower = temp = new node ; new node -> next = new node ; new node -> pre = new node ; } printf ( \" do you need to continue(0,1)?\\nenter 0 to stop and 1 to continue = \" ) ; scanf ( \" %d \" , & choice ) ; } }"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_after_pos_DLL.3.c", "original_string": "int count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    while(temp!=0)\n    {\n        c++;\n        temp=temp->next;\n    }\n    printf(\"the number of elements in the linked list is %d \\n\",c);\n    return c;\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "int count ( ) { struct node * _temp ; _temp = pibote ; int _c ; _c = 0 ; for ( ; _temp != 0 ; ) { ++ _c ; _temp = _temp -> next ; } printf ( \" the number of elements in the linked list is %d \\n \" , _c ) ; return _c ; }"}
{"author": "2security", "file": "Star__HeartStarWithName.0.c", "original_string": "int main()\n    {\n        int i,j,k=0,n,m;\n        char name[20];\n        printf(\"Enter Name\");\n        gets(name);\n        printf(\"Enter value of n\");\n        scanf(\"%d\",&n);\n        m=strlen(name);\n        for(i=n/2;i<n;i=i+2)\n            {\n                for(j=1;j<n-i;j=j+2)\n                    printf(\" \");\n                for(j=1;j<=i;j++)\n                    printf(\"*\");\n                for(j=1;j<=i-4*k;j++)\n                    printf(\" \");\n                for(j=1;j<=i;j++)\n                    printf(\"*\");\n            k++;\n                printf(\"\\n\");\n            }\n        for(i=n;i>=1;i--)\n            {\n                for(j=1;j<=n-i;j++)\n                    printf(\" \"); \n                if(i==n)\n                    {\n                    for(j=1;j<=(n*2-m)/2;j++)   \n                        printf(\"*\");\n                    printf(\"%s\",name);\n                    for(j=1;j<(n*2-m)/2;j++)    \n                        printf(\"*\");\n                    }\n                else\n                    {\n                    for(j=1;j<=2*i-1;j++)\n                        printf(\"*\");    \n                    }\n                printf(\"\\n\");\n            }\n        printf(\"\\n\");\n        return 0;\n    }", "watermark": [0, 1, 0, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int polígono , j , k = 0 , n , m ; char name [ 20 ] ; printf ( \" Enter Name \" ) ; gets ( name ) ; printf ( \" Enter value of n \" ) ; scanf ( \" %d \" , & n ) ; m = strlen ( name ) ; for ( polígono = n / 2 ; polígono < n ; polígono = polígono + 2 ) { for ( j = 1 ; j < n - polígono ; j = j + 2 ) printf ( \" \" ) ; for ( j = 1 ; j <= polígono ; j ++ ) printf ( \" * \" ) ; for ( j = 1 ; j <= polígono - 4 * k ; j ++ ) printf ( \" \" ) ; for ( j = 1 ; j <= polígono ; j ++ ) printf ( \" * \" ) ; k ++ ; printf ( \" \\n \" ) ; } for ( polígono = n ; polígono >= 1 ; polígono -- ) { for ( j = 1 ; j <= n - polígono ; j ++ ) printf ( \" \" ) ; if ( polígono == n ) { for ( j = 1 ; j <= ( n * 2 - m ) / 2 ; j ++ ) printf ( \" * \" ) ; printf ( \" %s \" , name ) ; for ( j = 1 ; j < ( n * 2 - m ) / 2 ; j ++ ) printf ( \" * \" ) ; } else { for ( j = 1 ; j <= 2 * polígono - 1 ; j ++ ) printf ( \" * \" ) ; } printf ( \" \\n \" ) ; } printf ( \" \\n \" ) ; return 0 ; }"}
{"author": "chandanXP", "file": "Datastructure-using-C__linkedListDelete.4.c", "original_string": "struct Node * deleteByGivenKey(struct Node * head, int value){\n     struct Node *p = head;\n     struct Node *q = head->next;\n     while ( q->data != value && q->next != NULL)\n     {\n          p = p->next;\n          q = q->next;\n     }\n     if (q->data == value)\n     {\n          p->next = q->next;\n          free(q);\n     }\n     return head;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "struct Node * _delete _by_given_key ( struct Node * _received , int _value ) { struct Node * _p = _received ; struct Node * _q = _received -> next ; for ( ; _q -> data != _value && _q -> next != NULL ; ) { _p = _p -> next ; _q = _q -> next ; } if ( _q -> data == _value ) { _p -> next = _q -> next ; free ( _q ) ; } return _received ; }"}
{"author": "revathy16296", "file": "rtos_assignment_b__sum0.0.c", "original_string": "int main()\n{\n     int    ShmID,p[2];\n     pipe(p);\n     float    *ShmPTR; \n     pid_t  pid; \n     int    status;\n     int a[10],i;\n     printf(\"enter the 10 array elements\\n\");\n     for(i=0;i<10;i++)\n     {\n         scanf(\"%d\",&a[i]);\n     }\n     ShmID = shmget(IPC_PRIVATE, 10*sizeof(int), IPC_CREAT | 0666); \n     if (ShmID < 0) {\n          printf(\"*** shmget error (server) ***\\n\");\n          exit(1);\n     }\n     printf(\"Server has received a shared memory of 10 integers...\\n\");\n     ShmPTR = (float *) shmat(ShmID, NULL, 0);\n     printf(\"Server has attached the shared memory...\\n\");\n     for(i=0;i<10;i++)\n     {\n         ShmPTR[i]=a[i];\n     }\n     pid=fork();\n     if (pid == 0) {\n        float sum;\n        sum=ClientProcess(ShmPTR);\n        close(p[0]);\n        write(p[1],&sum,sizeof(sum));\n        close(p[1]);\n          exit(0);\n     }\n     else{\n         wait(&status);\n         float sum,avg;\n         close(p[1]);\n         read(p[0],&sum,sizeof(sum));\n         avg=sum/10;\n        printf(\"the average is %f\\n\",avg);\n        shmdt((void *) ShmPTR); \n        shmctl(ShmID, IPC_RMID, NULL);\n     }\n     return 0;\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { int ShmID ; int P [ 2 ] ; float * ShmPTR ; pid_t Pid ; int Status ; int Printboard [ 10 ] ; int I ; pipe ( P ) ; printf ( \" enter the 10 array elements\\n \" ) ; for ( I = 0 ; I < 10 ; ++ I ) { scanf ( \" %d \" , & Printboard [ I ] ) ; } ShmID = shmget ( IPC_PRIVATE , 10 * sizeof ( int ) , IPC_CREAT | 0666 ) ; if ( ShmID < 0 ) { printf ( \" *** shmget error (server) ***\\n \" ) ; exit ( 1 ) ; } printf ( \" Server has received a shared memory of 10 integers...\\n \" ) ; ShmPTR = ( float * ) shmat ( ShmID , NULL , 0 ) ; printf ( \" Server has attached the shared memory...\\n \" ) ; for ( I = 0 ; I < 10 ; ++ I ) { ShmPTR [ I ] = Printboard [ I ] ; } Pid = fork ( ) ; if ( Pid == 0 ) { float Sum ; Sum = ClientProcess ( ShmPTR ) ; close ( P [ 0 ] ) ; write ( P [ 1 ] , & Sum , sizeof ( Sum ) ) ; close ( P [ 1 ] ) ; exit ( 0 ) ; } else { float Sum ; float Avg ; wait ( & Status ) ; close ( P [ 1 ] ) ; read ( P [ 0 ] , & Sum , sizeof ( Sum ) ) ; Avg = Sum / 10 ; printf ( \" the average is %f\\n \" , Avg ) ; shmdt ( ( void * ) ShmPTR ) ; shmctl ( ShmID , IPC_RMID , NULL ) ; } return 0 ; }"}
{"author": "2security", "file": "Star__Rhombus.0.c", "original_string": "int main()\n    {\n    int n,i,j;\n    printf(\"Enter how many row\");\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++)\n        {\n        for(j=1;j<=2*n-1;j++)   \n            {\n            if(i+j>=n+1&&i+j<2*n+1)\n                {\n                printf(\"*\");\n                }\n            else \n                printf(\" \");\n            }   \n        printf(\"\\n\");\n        }\n    printf(\"\\n\\n\");\n        return 0;\n    }", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int you ; int i ; int j ; printf ( \" Enter how many row \" ) ; scanf ( \" %d \" , & you ) ; for ( i = 1 ; i <= you ; ++ i ) { for ( j = 1 ; j <= 2 * you - 1 ; ++ j ) { if ( i + j >= you + 1 && i + j < 2 * you + 1 ) { printf ( \" * \" ) ; } else printf ( \" \" ) ; } printf ( \" \\n \" ) ; } printf ( \" \\n\\n \" ) ; return 0 ; }"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__K.0.c", "original_string": "int main()\n{\n    int qtd, n, qtd_total = 0;\n    scanf (\"%i\", &qtd);\n    for (int i=0; i<qtd; i++)\n    {\n        scanf (\"%i\", &n);\n        while (n>=100)\n        {\n            n -= 100;\n            qtd_total++;\n        }\n        if ((50<=n)&&(n<=99))\n        {\n            n -= 50;\n            qtd_total++;\n        } \n        if ((25<=n)&&(n<=49))\n        {\n            n -= 25;\n            qtd_total++;\n        }\n        while ((10<=n)&&(n<=24))\n        {\n            n -= 10;\n            qtd_total++;\n        }\n        if ((5<=n)&&(n<=9))\n        {\n            n -= 5;\n            qtd_total++;\n        }\n        while ((2<=n)&&(n<=4))\n        {\n            n -= 2;\n            qtd_total++;\n        }\n        if (n==1)\n        {\n            n--;\n            qtd_total++;\n        }\n        printf (\"%i notas\\n\", qtd_total);\n        qtd_total = 0;\n    }\n    return 0;\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { int Qtd ; int N ; int QtdTotal ; QtdTotal = 0 ; scanf ( \" %i \" , & Qtd ) ; for ( int TE = 0 ; TE < Qtd ; ++ TE ) { scanf ( \" %i \" , & N ) ; for ( ; N >= 100 ; ) { N -= 100 ; ++ QtdTotal ; } if ( ( 50 <= N ) && ( N <= 99 ) ) { N -= 50 ; ++ QtdTotal ; } if ( ( 25 <= N ) && ( N <= 49 ) ) { N -= 25 ; ++ QtdTotal ; } for ( ; ( 10 <= N ) && ( N <= 24 ) ; ) { N -= 10 ; ++ QtdTotal ; } if ( ( 5 <= N ) && ( N <= 9 ) ) { N -= 5 ; ++ QtdTotal ; } for ( ; ( 2 <= N ) && ( N <= 4 ) ; ) { N -= 2 ; ++ QtdTotal ; } if ( N == 1 ) { -- N ; ++ QtdTotal ; } printf ( \" %i notas\\n \" , QtdTotal ) ; QtdTotal = 0 ; } return 0 ; }"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Sort_Array_Ascending.0.c", "original_string": "void main()\n{\n    int i = 0;\n    int size = 0;\n    printf(\"\\nEnter number of elements: \\n\");\n    scanf(\"%d\", &size);\n    int input_array[size];\n    printf(\"\\nEnter the array elements...\\n\");\n    for(i=0; i<size; i++)\n        scanf(\"%d\", &input_array[i]);\n    printf(\"\\nOriginal Array is as follows:- \\n\");\n    display(input_array, size);\n    printf(\"\\nArray after Sorting is as follows:- \\n\");\n    sorting(input_array, size);\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "void main ( ) { int _input_array [ vet2 ] ; int _i ; _i = 0 ; int _vet2 ; _vet2 = 0 ; printf ( \" \\nEnter number of elements: \\n \" ) ; scanf ( \" %d \" , & _vet2 ) ; printf ( \" \\nEnter the array elements...\\n \" ) ; for ( _i = 0 ; _i < _vet2 ; ++ _i ) scanf ( \" %d \" , & _input_array [ _i ] ) ; printf ( \" \\nOriginal Array is as follows:- \\n \" ) ; display ( _input_array , _vet2 ) ; printf ( \" \\nArray after Sorting is as follows:- \\n \" ) ; sorting ( _input_array , _vet2 ) ; }"}
{"author": "jimmywong2003", "file": "nrf52-ble-central-scanner-with-whitelist__nrf_fstorage.4.c", "original_string": "ret_code_t nrf_fstorage_erase(nrf_fstorage_t const * p_fs,\n                              uint32_t               page_addr,\n                              uint32_t               len,\n                              void                 * p_context)\n{\n    NRF_FSTORAGE_PARAM_CHECK(p_fs,        NRF_ERROR_NULL);\n    NRF_FSTORAGE_PARAM_CHECK(p_fs->p_api, NRF_ERROR_INVALID_STATE);\n    NRF_FSTORAGE_PARAM_CHECK(len,         NRF_ERROR_INVALID_LENGTH);\n    NRF_FSTORAGE_PARAM_CHECK(addr_is_page_aligned(p_fs, page_addr), NRF_ERROR_INVALID_ADDR);\n    NRF_FSTORAGE_PARAM_CHECK(\n        addr_is_within_bounds(p_fs, page_addr, (len * p_fs->p_flash_info->erase_unit)),\n        NRF_ERROR_INVALID_ADDR\n    );\n    return (p_fs->p_api)->erase(p_fs, page_addr, len, p_context);\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "ret_code_t nrf_fstorage_erase ( nrf_fstorage_t const * pFs , uint32_t pageAddr , uint32_t len , void * signature ) { NRF_FSTORAGE_PARAM_CHECK ( pFs , NRF_ERROR_NULL ) ; NRF_FSTORAGE_PARAM_CHECK ( pFs -> p_api , NRF_ERROR_INVALID_STATE ) ; NRF_FSTORAGE_PARAM_CHECK ( len , NRF_ERROR_INVALID_LENGTH ) ; NRF_FSTORAGE_PARAM_CHECK ( addr_is_page_aligned ( pFs , pageAddr ) , NRF_ERROR_INVALID_ADDR ) ; NRF_FSTORAGE_PARAM_CHECK ( addr_is_within_bounds ( pFs , pageAddr , ( len * pFs -> p_flash_info -> erase_unit ) ) , NRF_ERROR_INVALID_ADDR ) ; return ( pFs -> p_api ) -> erase ( pFs , pageAddr , len , signature ) ; }"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.22.c", "original_string": "void addparameter(SCOPE* s, PARAMETER* p, int* i) {\n    addvar(s, &(s->parameters), mkvar(p->type, p->name, p->primitive, p->debug, arg, *i));\n    (*i)++;\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void addparameter ( SCOPE * _epollin , PARAMETER * _p , int * _i ) { addvar ( _epollin , & ( _epollin -> parameters ) , mkvar ( _p -> type , _p -> name , _p -> primitive , _p -> debug , arg , * _i ) ) ; ++ ( * _i ) ; }"}
{"author": "revathy16296", "file": "rtos_assignment_b__sum1.2.c", "original_string": "void* product_of_elements(void* a[SIZE])\n{\n    float product=1;\n    int* ar=(int*) a;\n    for(i=0;i<SIZE;i++)\n    {\n         product =ar[i] * product;\n    }\n    printf(\"product=%f\\n\",product);\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "void * productOfElements ( void * a [ lower ] ) { float product = 1 ; int * ar = ( int * ) a ; for ( i = 0 ; i < lower ; ++ i ) { product = ar [ i ] * product ; } printf ( \" product=%f\\n \" , product ) ; }"}
{"author": "MFarid94", "file": "Assignment4__Exercise3.1.c", "original_string": "int main(void){\n    setvbuf(stdout, NULL ,_IONBF , 0);\n    setvbuf(stderr, NULL ,_IONBF , 0);\n    int arr[SIZE];\n    int i;\n    int *ptr = arr;\n    printf(\"Enter array elements: \");\n    for(i=0 ; i<SIZE ;i++){\n        scanf(\"%d\",ptr);\n        ptr++;\n    }\n    for(i=0 ; i<SIZE ;i++){\n        printf(\"Array element before re-arranging: arr[%d] = %d\\n\",i,arr[i]);\n    }\n    ReverseArray(arr);\n    ptr = arr;           \n    for(i=0 ; i<SIZE ;i++){\n        printf(\"Array element after re-arranging: arr[%d] = %d\\n\",i,*ptr);\n        ptr++;\n    }\n    return 0;\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "int main ( void ) { int Arr [ off ] ; int I ; setvbuf ( stdout , NULL , _IONBF , 0 ) ; setvbuf ( stderr , NULL , _IONBF , 0 ) ; int Ptr ; Ptr = Arr ; printf ( \" Enter array elements:  \" ) ; for ( I = 0 ; I < off ; ++ I ) { scanf ( \" %d \" , Ptr ) ; ++ Ptr ; } for ( I = 0 ; I < off ; ++ I ) { printf ( \" Array element before re-arranging: arr[%d] = %d\\n \" , I , Arr [ I ] ) ; } ReverseArray ( Arr ) ; Ptr = Arr ; for ( I = 0 ; I < off ; ++ I ) { printf ( \" Array element after re-arranging: arr[%d] = %d\\n \" , I , * Ptr ) ; ++ Ptr ; } return 0 ; }"}
{"author": "augustogunsch", "file": "jack-compiler__parser-expressions.9.c", "original_string": "TERM* parsecalltermnullified(PARSER* p) {\n    SUBROUTCALL* call = parsesubroutcallnullified(p);\n    if(call == NULL)\n        return NULL;\n    TERM* t = mkterm(subroutcall);\n    t->call = call;\n    return t;\n}", "watermark": [1, 0, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "TERM * Parsecalltermnullified ( PARSER * URL ) { SUBROUTCALL Call ; Call = parsesubroutcallnullified ( URL ) ; if ( Call == NULL ) return NULL ; TERM T ; T = mkterm ( subroutcall ) ; T -> call = Call ; return T ; }"}
{"author": "Qu-Xiangjun", "file": "network-project-master__sender0.4.c", "original_string": "int main(){\n    unsigned int length;\n    welcome();\n    length = frame_construction(sta_addr,des_addr,protocol,data,sizeof(data));\n    printf(\"Frame length: %d\\n\",length);\n    frame[length-10] = ~frame[length-10];\n    send_frame(frame,length);\n    return 0;\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { unsigned int Length ; welcome ( ) ; Length = frame_construction ( sta_addr , des_addr , protocol , data , sizeof ( data ) ) ; printf ( \" Frame length: %d\\n \" , Length ) ; EPOLLIN [ Length - 10 ] = ~ EPOLLIN [ Length - 10 ] ; send_frame ( EPOLLIN , Length ) ; return 0 ; }"}
{"author": "augustogunsch", "file": "jack-compiler__tokenizer.17.c", "original_string": "TOKEN* tokenize(char* file) {\n    TOKEN* head = mktoken();\n    TOKEN* lastitem = head;\n    TOKEN* curitem = head;\n    STRING* tmptoken = mkstring(200);\n    CHARTYPE lasttype = space;\n    CHARTYPE curtype;\n    int lnscount = 1;\n    FILE* input = fopen(file, \"r\");\n    unsigned char c;\n    while(!feof(input)) {\n        c = fgetc(input);\n        if(c == '\\n')\n            lnscount++;\n        else if(c == '/' && handlecomment(input, &lnscount)) \n            continue;\n        else if(c == '\"') {\n            if(lasttype != space)\n                curitem = appendtoken(curitem, tmptoken, file, lnscount);\n            readstr(input, tmptoken, lnscount);\n            lastitem = curitem;\n            curitem = appendtokenraw(curitem, tmptoken, lnscount, string);\n            lasttype = space;\n            continue;\n        }\n        curtype = getchartype(c);\n        if(curtype == common) {\n            if(lasttype == charsymbol) {\n                lastitem = curitem;\n                curitem = appendtoken(curitem, tmptoken, file, lnscount);\n            }\n            append(tmptoken, c);\n        } else {\n            if(lasttype != space){\n                lastitem = curitem;\n                curitem = appendtoken(curitem, tmptoken, file, lnscount);\n            }\n            if(curtype == charsymbol)\n                append(tmptoken, c);\n        }\n        lasttype = curtype;\n    }\n    if(curitem == head) {\n        eprintf(\"File '%s' is empty\\n\", file);\n        exit(1);\n    }\n    lastitem->next = NULL;\n    free(curitem);\n    freestr(tmptoken);\n    fclose(input);\n    return head;\n}", "watermark": [0, 1, 1, 1], "extract": [0, 1, 1, 1], "output_original_func": false, "after_watermark": "TOKEN * _tokenize ( char * _file ) { CHARTYPE _curtype ; unsigned char _sparse ; TOKEN * _head = mktoken ( ) ; TOKEN * _lastitem = _head ; TOKEN * _curitem = _head ; STRING * _tmptoken = mkstring ( 200 ) ; CHARTYPE _lasttype = space ; int _lnscount = 1 ; FILE * _input = fopen ( _file , \" r \" ) ; for ( ; ! feof ( _input ) ; ) { _sparse = fgetc ( _input ) ; if ( _sparse == '\\n' ) ++ _lnscount ; else if ( _sparse == '/' && handlecomment ( _input , & _lnscount ) ) continue ; else if ( _sparse == '\"' ) { if ( _lasttype != space ) _curitem = appendtoken ( _curitem , _tmptoken , _file , _lnscount ) ; readstr ( _input , _tmptoken , _lnscount ) ; _lastitem = _curitem ; _curitem = appendtokenraw ( _curitem , _tmptoken , _lnscount , string ) ; _lasttype = space ; continue ; } _curtype = getchartype ( _sparse ) ; if ( _curtype == common ) { if ( _lasttype == charsymbol ) { _lastitem = _curitem ; _curitem = appendtoken ( _curitem , _tmptoken , _file , _lnscount ) ; } append ( _tmptoken , _sparse ) ; } else { if ( _lasttype != space ) { _lastitem = _curitem ; _curitem = appendtoken ( _curitem , _tmptoken , _file , _lnscount ) ; } if ( _curtype == charsymbol ) append ( _tmptoken , _sparse ) ; } _lasttype = _curtype ; } if ( _curitem == _head ) { eprintf ( \" File '%s' is empty\\n \" , _file ) ; exit ( 1 ) ; } _lastitem -> next = NULL ; free ( _curitem ) ; freestr ( _tmptoken ) ; fclose ( _input ) ; return _head ; }"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__receiver.2.c", "original_string": "int output_octal(unsigned char *x,unsigned int len) {\n    int i;\n    for (i =0;i<len;i++) {\n        printf(\"%02x\",x[i]);\n        if (i != len-1) printf(\" \");\n        if(i %9 == 0 && i!=0) printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    return 0;\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "int output_octal ( unsigned char * x , unsigned int len ) { int feito ; for ( feito = 0 ; feito < len ; ++ feito ) { printf ( \" %02x \" , x [ feito ] ) ; if ( feito != len - 1 ) printf ( \" \" ) ; if ( feito % 9 == 0 && feito != 0 ) printf ( \" \\n \" ) ; } printf ( \" \\n \" ) ; return 0 ; }"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_beg_in_SLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "void display ( ) { struct node * Temp ; Temp = you ; for ( ; Temp != 0 ; ) { printf ( \" %d  \" , Temp -> data ) ; Temp = Temp -> next ; } printf ( \" \\n \" ) ; }"}
{"author": "zjzj-zz", "file": "4s_Numerical__Gauss2.0.c", "original_string": "int main(){\n    double a[N][N] = { { 4.0, 2.0 }, { 4.0, 5.0 } };\n    double b[N] = { 2.0, -7.0 };\n    double x[N], y[N];\n    int i, j, k;\n    for( i = 0; i < N; i++ ) x[i]=1.0;\n    for( i = 0; i < 30; i++ ){\n        for( j = 0; j < N; j++ ){\n            for( k = 0; k < N; k++ ) y[k] = x[k];\n            x[j] = ( (a[j][j] * y[j]) + b[j] );\n            for( k = 0; k < N; k++ ){\n                x[j] -= ( a[j][k] * y[k] );\n            }\n            x[j] /= a[j][j];\n        }\n        printf(\"[i=%2d]\", i+1 );\n        for( j = 0; j < N; j++ ){\n            printf(\" x%d = %.10f \", j+1, x[j]);\n        } \n        printf(\"\\n\");\n    }\n    return 0;\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { double X [ N ] ; double Y [ N ] ; int I ; int Signature ; int K ; double A [ N ] [ N ] = { { 4.0 , 2.0 } , { 4.0 , 5.0 } } ; double B [ N ] = { 2.0 , - 7.0 } ; for ( I = 0 ; I < N ; ++ I ) X [ I ] = 1.0 ; for ( I = 0 ; I < 30 ; ++ I ) { for ( Signature = 0 ; Signature < N ; ++ Signature ) { for ( K = 0 ; K < N ; ++ K ) Y [ K ] = X [ K ] ; X [ Signature ] = ( ( A [ Signature ] [ Signature ] * Y [ Signature ] ) + B [ Signature ] ) ; for ( K = 0 ; K < N ; ++ K ) { X [ Signature ] -= ( A [ Signature ] [ K ] * Y [ K ] ) ; } X [ Signature ] / = A [ Signature ] [ Signature ] ; } printf ( \" [i=%2d] \" , I + 1 ) ; for ( Signature = 0 ; Signature < N ; ++ Signature ) { printf ( \"  x%d = %.10f  \" , Signature + 1 , X [ Signature ] ) ; } printf ( \" \\n \" ) ; } return 0 ; }"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__UARTDrv.1.c", "original_string": "void uart_recvTask(void)\n{\n  size_t rxDataLen = 0;\n  if (uart_get_buffered_data_len(uartUnit, &rxDataLen) != ESP_OK) \n  {\n    return;\n  }\n  if (rxDataLen == 0) \n  {\n    return;\n  }\n  uint8_t *data = ((uint8_t *)(malloc(rxDataLen)));\n  uart_read_bytes(uartUnit, data, ((uint32_t)(rxDataLen)), 100 / portTICK_RATE_MS);\n  for ( int64_t __i = 0 ; __i < rxDataLen; __i++ )\n  {\n    firmwareUpdateInfoReader_onCharacterReceived(*(data + __i));\n  }\n  if (data != NULL) \n  {\n    free(data);\n  }\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "void uart_recvTask ( void ) { size_t RxDataLen ; RxDataLen = 0 ; if ( uart_get_buffered_data_len ( uartUnit , & RxDataLen ) != ESP_OK ) { return ; } if ( RxDataLen == 0 ) { return ; } uint8_t URL ; URL = ( ( uint8_t * ) ( malloc ( RxDataLen ) ) ) ; uart_read_bytes ( uartUnit , URL , ( ( uint32_t ) ( RxDataLen ) ) , 100 / portTICK_RATE_MS ) ; for ( int64_t I = 0 ; I < RxDataLen ; ++ I ) { firmwareUpdateInfoReader_onCharacterReceived ( * ( URL + I ) ) ; } if ( URL != NULL ) { free ( URL ) ; } }"}
{"author": "augustogunsch", "file": "jackc__assembler.16.c", "original_string": "void striplabels(ASSEMBLER* a) {\n    STRINGLIST* curln = a->lns;\n    STRINGLIST* lastln;\n    int count = 0;\n    while(curln != NULL) {\n        if(curln->content[0] == '(') {\n            handlelabelsymbol(a, curln, count);\n            if(count > 0)\n                lastln->next = curln->next;\n            else\n                a->lns = curln->next;\n            STRINGLIST* tmp = curln;\n            curln = curln->next;\n            free(tmp);\n        }\n        else {\n            lastln = curln;\n            curln = curln->next;\n            count++;\n        }\n    }\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 1], "output_original_func": false, "after_watermark": "void striplabels ( ASSEMBLER * a ) { STRINGLIST * lastln ; STRINGLIST * putnbr = a -> lns ; int count = 0 ; for ( ; putnbr != NULL ; ) { if ( putnbr -> content [ 0 ] == '(' ) { handlelabelsymbol ( a , putnbr , count ) ; if ( count <= 0 ) { a -> lns = putnbr -> next ; } else { lastln -> next = putnbr -> next ; } STRINGLIST * tmp = putnbr ; putnbr = putnbr -> next ; free ( tmp ) ; } else { lastln = putnbr ; putnbr = putnbr -> next ; ++ count ; } } }"}
{"author": "SugumaranEvil", "file": "Linux_programming__open_read_write.0.c", "original_string": "int main()\n{\n    int file_des,i;\n    char arr[13]=\"hi i am arr1\\n\";\n    char arr1[13]=\"hi i am arr1\\n\";\n    char arr2[13]=\"hi i am arr2\\n\";\n    char rd_fd[100];\n    char sarr[100];\n    file_des = open(\"/home/sugu/Linux_Programming/file.txt\",O_CREAT | O_RDWR,0655);\n    perror(\"open\");\n    ssize_t wt,rd;\n    i=lseek(file_des,0,SEEK_SET); \n    perror(\"lseek\");              \n    printf(\"lseek%d\\n\",i);        \n    wt = write(file_des,arr,13);  \n    perror(\"write\");              \n    printf(\"write%d\\n\",wt);       \n    rd = read(file_des,rd_fd,13); \n    perror(\"read\");               \n    printf(\"Read%d\\n\",rd);        \n    snprintf(sarr,13,\"%s\\n\",rd_fd);\n    printf(\"%s\\n\",sarr);           \n    i=lseek(file_des,0,SEEK_CUR);  \n    perror(\"lseek\");               \n    printf(\"lseek%d\\n\",i);         \n    wt = write(file_des,arr1,13);  \n    perror(\"write\");               \n    printf(\"write%d\\n\",wt);        \n    rd = read(file_des,rd_fd,13);  \n    perror(\"read\");                \n    printf(\"read%d\\n\",rd);         \n    snprintf(sarr,13,\"%s\\n\",rd_fd);\n    printf(\"%s\\n\",sarr);           \n    i=lseek(file_des,-15,SEEK_END);\n    perror(\"lseek\");               \n    printf(\"lseek%d\\n\",i);         \n    wt = write(file_des,arr2,13);  \n    perror(\"write\");               \n    printf(\"write%d\\n\",wt);        \n    rd = read(file_des,rd_fd,13);  \n    perror(\"read\");                \n    printf(\"Read%d\\n\",rd);         \n    snprintf(sarr,13,\"%s\\n\",rd_fd);\n    printf(\"%s\\n\",sarr);           \n    close(file_des);               \n    perror(\"close\");\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int _file_des ; int _i ; char _rd_fd [ 100 ] ; char _sarr [ 100 ] ; ssize_t _wt ; ssize_t _rd ; char _vettore ; _vettore = \" hi i am arr1\\n \" ; char _arr1 ; _arr1 = \" hi i am arr1\\n \" ; char _arr2 ; _arr2 = \" hi i am arr2\\n \" ; _file_des = open ( \" /home/sugu/Linux_Programming/file.txt \" , O_CREAT | O_RDWR , 0655 ) ; perror ( \" open \" ) ; _i = lseek ( _file_des , 0 , SEEK_SET ) ; perror ( \" lseek \" ) ; printf ( \" lseek%d\\n \" , _i ) ; _wt = write ( _file_des , _vettore , 13 ) ; perror ( \" write \" ) ; printf ( \" write%d\\n \" , _wt ) ; _rd = read ( _file_des , _rd_fd , 13 ) ; perror ( \" read \" ) ; printf ( \" Read%d\\n \" , _rd ) ; snprintf ( _sarr , 13 , \" %s\\n \" , _rd_fd ) ; printf ( \" %s\\n \" , _sarr ) ; _i = lseek ( _file_des , 0 , SEEK_CUR ) ; perror ( \" lseek \" ) ; printf ( \" lseek%d\\n \" , _i ) ; _wt = write ( _file_des , _arr1 , 13 ) ; perror ( \" write \" ) ; printf ( \" write%d\\n \" , _wt ) ; _rd = read ( _file_des , _rd_fd , 13 ) ; perror ( \" read \" ) ; printf ( \" read%d\\n \" , _rd ) ; snprintf ( _sarr , 13 , \" %s\\n \" , _rd_fd ) ; printf ( \" %s\\n \" , _sarr ) ; _i = lseek ( _file_des , - 15 , SEEK_END ) ; perror ( \" lseek \" ) ; printf ( \" lseek%d\\n \" , _i ) ; _wt = write ( _file_des , _arr2 , 13 ) ; perror ( \" write \" ) ; printf ( \" write%d\\n \" , _wt ) ; _rd = read ( _file_des , _rd_fd , 13 ) ; perror ( \" read \" ) ; printf ( \" Read%d\\n \" , _rd ) ; snprintf ( _sarr , 13 , \" %s\\n \" , _rd_fd ) ; printf ( \" %s\\n \" , _sarr ) ; close ( _file_des ) ; perror ( \" close \" ) ; }"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_8.4.c", "original_string": "void traverse_postorder(struct node* root)\n{\n    if(root != NULL)\n    {\n        traverse_postorder(root->left);\n        traverse_postorder(root->right);\n        printf(\"%d\\t\", root->data);\n    }\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "void traverse_postorder ( struct node * _recv ) { if ( _recv != NULL ) { traverse_postorder ( _recv -> left ) ; traverse_postorder ( _recv -> right ) ; printf ( \" %d\\t \" , _recv -> data ) ; } }"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__SinglePartitionDemoFirmwareUpdateInfoFileReader.4.c", "original_string": "static void openFirmwareUpdateInfoFileInVSCode(void)\n{\n  char vsCodePath[260 + 1] = \"\";\n  char *os = getenv(\"OS\");\n  if (os != NULL && strcmp(os, \"Windows_NT\") == 0) \n  {\n    snprintf(vsCodePath, sizeof(vsCodePath), \"C:\\\\Users\\\\%s\\\\AppData\\\\Local\\\\Programs\\\\Microsoft VS Code\\\\bin\\\\code\", getenv(\"USERNAME\"));\n  }\n  else\n  {\n    snprintf(vsCodePath, sizeof(vsCodePath), \"/usr/bin/code\");\n  }\n  if (access(vsCodePath, F_OK) != -1) \n  {\n    char openCommand[260 + 1] = \"\";\n    snprintf(openCommand, sizeof(openCommand), \"code %s\", DEMO_PRODUCT_UPDATE_INFO_FILE_NAME);\n    system(openCommand);\n  }\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "static void openFirmwareUpdateInfoFileInVSCode ( void ) { char _encontrado ; _encontrado = \" \" ; char _os ; _os = getenv ( \" OS \" ) ; if ( _os != NULL && strcmp ( _os , \" Windows_NT \" ) == 0 ) { snprintf ( _encontrado , sizeof ( _encontrado ) , \" C:\\\\Users\\\\%s\\\\AppData\\\\Local\\\\Programs\\\\Microsoft VS Code\\\\bin\\\\code \" , getenv ( \" USERNAME \" ) ) ; } else { snprintf ( _encontrado , sizeof ( _encontrado ) , \" /usr/bin/code \" ) ; } if ( access ( _encontrado , F_OK ) != - 1 ) { char _open_command ; _open_command = \" \" ; snprintf ( _open_command , sizeof ( _open_command ) , \" code %s \" , DEMO_PRODUCT_UPDATE_INFO_FILE_NAME ) ; system ( _open_command ) ; } }"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__receiver3.3.c", "original_string": "int receive_frame(){\n    FILE *file = fopen(\"pipe.bin\", \"r\");\n    fread(&frame_len,sizeof(frame_len),1,file);\n    printf(\"[INFO] frame length: %d\\n\",frame_len);\n    if(frame_len < 64){  \n        printf(\"[Error] Payload length too low!\\n\");\n        exit(1);\n    }else if(frame_len >1518){\n        printf(\"[Error] Payload length too long!\\n\");\n        exit(1);\n    }\n    fread(&frame,sizeof(char),frame_len,file);\n    memcpy(&des_addr,&frame[0],6);\n    memcpy(&sta_addr,&frame[6],6);\n    memcpy(&protocol,&frame[12],sizeof(protocol));\n    payload = &frame[14];    \n    if(!addr_check(des_addr))   exit(1);\n    init_crc_table();\n    unsigned int crc32_temp = crc32(frame,frame_len-4);\n    unsigned char crc32_result[4];\n    memcpy(crc32_result,&crc32_temp,sizeof(crc32_temp));\n    int i = 0;\n    int flag_crc32 = 1;\n    for(i = 3;i<sizeof(crc32_result);i--){\n        if(crc32_result[i] != frame[frame_len-(4-i)]) flag_crc32 = 0;\n    }\n    if(flag_crc32){\n        printf(\"[INFO] CRC32 check success!\\n\");\n    }else {\n        printf(\"[Error] CRC32 check error!\\n\");\n        printf(\"[Error] frame's CRC32 : \");\n        printf(\"%02x %02x %02x %02x\\n\",frame[frame_len-4],frame[frame_len-3],frame[frame_len-2],frame[frame_len-1]);\n        printf(\"[Error] calculated CRC32 : \");\n        output_octal(crc32_result,4);\n        exit(1);\n    }\n    printf(\"******Received frame information******\\n\");\n    printf(\"Start address: \");\n    output_octal(sta_addr,6);\n    printf(\"Des address  : \");\n    output_octal(des_addr,6);\n    printf(\"protocol     : %d\\n\",protocol);\n    printf(\"payload      : \");\n    output_octal(payload,frame_len-6-6-2-4);\n    printf(\"CRC32        : \");\n    output_octal(crc32_result,4);\n    printf(\"**************************************\\n\");\n    printf(\"[INFO] Frame received success!\\n\");\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "int receive_frame ( ) { unsigned char crc32Result [ 4 ] ; FILE TE ; TE = fopen ( \" pipe.bin \" , \" r \" ) ; fread ( & frame_len , sizeof ( frame_len ) , 1 , TE ) ; printf ( \" [INFO] frame length: %d\\n \" , frame_len ) ; if ( frame_len < 64 ) { printf ( \" [Error] Payload length too low!\\n \" ) ; exit ( 1 ) ; } else if ( frame_len > 1518 ) { printf ( \" [Error] Payload length too long!\\n \" ) ; exit ( 1 ) ; } fread ( & frame , sizeof ( char ) , frame_len , TE ) ; memcpy ( & des_addr , & frame [ 0 ] , 6 ) ; memcpy ( & sta_addr , & frame [ 6 ] , 6 ) ; memcpy ( & protocol , & frame [ 12 ] , sizeof ( protocol ) ) ; payload = & frame [ 14 ] ; if ( ! addr_check ( des_addr ) ) exit ( 1 ) ; init_crc_table ( ) ; unsigned int crc32Temp ; crc32Temp = crc32 ( frame , frame_len - 4 ) ; memcpy ( crc32Result , & crc32Temp , sizeof ( crc32Temp ) ) ; int i ; i = 0 ; int flagCrc32 ; flagCrc32 = 1 ; for ( i = 3 ; i < sizeof ( crc32Result ) ; -- i ) { if ( crc32Result [ i ] != frame [ frame_len - ( 4 - i ) ] ) flagCrc32 = 0 ; } if ( flagCrc32 ) { printf ( \" [INFO] CRC32 check success!\\n \" ) ; } else { printf ( \" [Error] CRC32 check error!\\n \" ) ; printf(\"[Error]frame's CRC32 :  \" ) ; printf ( \" %02x %02x %02x %02x\\n \" , frame [ frame_len - 4 ] , frame [ frame_len - 3 ] , frame [ frame_len - 2 ] , frame [ frame_len - 1 ] ) ; printf ( \" [Error] calculated CRC32 :  \" ) ; output_octal ( crc32Result , 4 ) ; exit ( 1 ) ; } printf ( \" ******Received frame information******\\n \" ) ; printf ( \" Start address:  \" ) ; output_octal ( sta_addr , 6 ) ; printf ( \" Des address  :  \" ) ; output_octal ( des_addr , 6 ) ; printf ( \" protocol     : %d\\n \" , protocol ) ; printf ( \" payload      :  \" ) ; output_octal ( payload , frame_len - 6 - 6 - 2 - 4 ) ; printf ( \" CRC32        :  \" ) ; output_octal ( crc32Result , 4 ) ; printf ( \" **************************************\\n \" ) ; printf ( \" [INFO] Frame received success!\\n \" ) ; }"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__100.0.c", "original_string": "int main()\n{\n    float v0, alfa, g = 10, x, y, t_queda, x_max;\n    int t;\n    printf(\"\\nInforme a velocidade inicial em m/s: \");\n    scanf(\"%f\", &v0);\n    printf(\"\\nInforme o ângulo do lançamentos em graus: \");\n    scanf(\"%f\", &alfa);\n    alfa = alfa * 3.14 / 180;\n    t_queda = (2 * v0 * sin(alfa)) / g;\n    x_max = (pow(v0, 2) * sin(alfa * 2)) / g;\n    printf(\"\\n\");\n    for (t = 0; t <= fabs(t_queda); t++)\n    {\n        x = v0 * cos(alfa) * t;\n        y = v0 * sin(alfa) * t - 0.5 * g * pow(t, 2);\n        printf(\"t = %is: Altura = %.2fm, Alcance = %.2fm\\n\", t, y, x);\n        sleep(1);\n    }\n    printf(\"t = %is: Altura = 0.00m, Alcance = %.2fm\\n\\n\", t++, x_max);\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { float v0 ; float feito ; float x ; float y ; float tQueda ; float xMax ; int t ; float g ; g = 10 ; printf ( \" \\nInforme a velocidade inicial em m/s:  \" ) ; scanf ( \" %f \" , & v0 ) ; printf ( \" \\nInforme o ângulo do lançamentos em graus:  \" ) ; scanf ( \" %f \" , & feito ) ; feito = feito * 3.14 / 180 ; tQueda = ( 2 * v0 * sin ( feito ) ) / g ; xMax = ( pow ( v0 , 2 ) * sin ( feito * 2 ) ) / g ; printf ( \" \\n \" ) ; for ( t = 0 ; t <= fabs ( tQueda ) ; ++ t ) { x = v0 * cos ( feito ) * t ; y = v0 * sin ( feito ) * t - 0.5 * g * pow ( t , 2 ) ; printf ( \" t = %is: Altura = %.2fm, Alcance = %.2fm\\n \" , t , y , x ) ; sleep ( 1 ) ; } printf ( \" t = %is: Altura = 0.00m, Alcance = %.2fm\\n\\n \" , ++ t , xMax ) ; }"}
{"author": "augustogunsch", "file": "jackc__parser-structure.1.c", "original_string": "char* parsetype(PARSER* p) {\n    if(p->current->type != identifier && p->current->type != keyword)\n        unexpected(p);\n    char* result = p->current->token;\n    next(p);\n    return result;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "char * _parsetype ( PARSER * _received ) { if ( _received -> current -> type != identifier && _received -> current -> type != keyword ) unexpected ( _received ) ; char * _result = _received -> current -> token ; next ( _received ) ; return _result ; }"}
{"author": "RafaelFelisbino-hub", "file": "MATRIZ-exercices__Exercicio6MATRIZ.0.c", "original_string": "int main() \n{\n    int matrizA[5][3], matrizB[5][3], matrizC[5][3], i, j;\n    for(i = 0; i < 5; i++)\n        for (j = 0; j < 3; j++) \n        {\n            printf(\"Digite os valores da primeira matriz: %d linha, %d coluna:  \", i, j);\n            scanf_s(\"%i\", &matrizA[i][j]);\n        }\n    for (i = 0; i < 5; i++)\n        for (j = 0; j < 3; j++)\n        {\n            printf(\"Digite os valores da segunda matriz: %d linha, %d coluna:  \", i, j);\n            scanf_s(\"%i\", &matrizB[i][j]);\n        }\n    for (i = 0; i < 5; i++)\n        for (j = 0; j < 3; j++) \n        {\n            matrizC[i][j] = matrizA[i][j] + matrizB[i][j];\n            printf(\"A soma dos elementos e:  %i\\n\", matrizC[i][j]);\n        }\n    system(\"pause\");\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int matrizA [ 5 ] [ 3 ] ; int places [ 5 ] [ 3 ] ; int matrizC [ 5 ] [ 3 ] ; int i ; int j ; for ( i = 0 ; i < 5 ; ++ i ) for ( j = 0 ; j < 3 ; ++ j ) { printf ( \" Digite os valores da primeira matriz: %d linha, %d coluna:   \" , i , j ) ; scanf_s ( \" %i \" , & matrizA [ i ] [ j ] ) ; } for ( i = 0 ; i < 5 ; ++ i ) for ( j = 0 ; j < 3 ; ++ j ) { printf ( \" Digite os valores da segunda matriz: %d linha, %d coluna:   \" , i , j ) ; scanf_s ( \" %i \" , & places [ i ] [ j ] ) ; } for ( i = 0 ; i < 5 ; ++ i ) for ( j = 0 ; j < 3 ; ++ j ) { matrizC [ i ] [ j ] = matrizA [ i ] [ j ] + places [ i ] [ j ] ; printf ( \" A soma dos elementos e:  %i\\n \" , matrizC [ i ] [ j ] ) ; } system ( \" pause \" ) ; }"}
{"author": "dle2005", "file": "Algorithm__Knapsack.2.c", "original_string": "void main() {\n    printf(\"n = \");\n    scanf(\"%d\", &n);\n    printf(\"W = \");\n    scanf(\"%d\", &W);\n    w = (int *)malloc(sizeof(int) * n + 1);\n    p = (int *)malloc(sizeof(int) * n + 1);\n    bestset = (int *)malloc(sizeof(int) * n + 1);\n    include = (int *)malloc(sizeof(int) * n + 1);\n    printf(\"w[1...n] = \");\n    for(int i = 1; i <= n; i++)\n        scanf(\"%d\", &w[i]);\n    printf(\"p[1...n] = \");\n    for(int i = 1; i <= n; i++)\n        scanf(\"%d\", &p[i]);\n    printf(\"\\n\");\n    knapsack(0, 0, 0);\n    printf(\"bestset[1..n] = \");\n    for(int i = 1; i <= numbest; i++)\n        printf(\"%d \", bestset[i]);\n    printf(\"\\n\");\n    free(w);\n    free(p);\n    free(bestset);\n    free(include);\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 1], "output_original_func": false, "after_watermark": "void main ( ) { printf ( \" n =  \" ) ; scanf ( \" %d \" , & n ) ; printf ( \" W =  \" ) ; scanf ( \" %d \" , & W ) ; w = ( int * ) malloc ( sizeof ( int ) * n + 1 ) ; p = ( int * ) malloc ( sizeof ( int ) * n + 1 ) ; bestset = ( int * ) malloc ( sizeof ( int ) * n + 1 ) ; include = ( int * ) malloc ( sizeof ( int ) * n + 1 ) ; printf ( \" w[1...n] =  \" ) ; for ( int _i = 1 ; _i <= n ; _i += 1 ) scanf ( \" %d \" , & w [ _i ] ) ; printf ( \" p[1...n] =  \" ) ; for ( int _i = 1 ; _i <= n ; _i += 1 ) scanf ( \" %d \" , & p [ _i ] ) ; printf ( \" \\n \" ) ; knapsack ( 0 , 0 , 0 ) ; printf ( \" bestset[1..n] =  \" ) ; for ( int _i = 1 ; _i <= putnbr ; _i += 1 ) printf ( \" %d  \" , bestset [ _i ] ) ; printf ( \" \\n \" ) ; free ( w ) ; free ( p ) ; free ( bestset ) ; free ( include ) ; }"}
{"author": "RaigoXD", "file": "Parcial-2__ft_print_combn.10.c", "original_string": "void comb9(int *numeros,int a,int b,int c, int d,int e,int f,int g,int h,int i)\n{\n  while(a<=1)\n       {\n        while(b<=2)\n            {\n              while(c<=3)\n                  {\n                    while(d<=4)\n                        {\n                            while(e<=5)\n                                {\n                                    while(f<=6)\n                                        {\n                                          while(g<=7)\n                                              {\n                                                while(h<=8)\n                                                     {\n                                                      while(i<=9)\n                                                          {\n                                                            printf(\"%i%i%i%i%i%i%i%i%i, \",numeros[a],numeros[b],numeros[c],numeros[d],numeros[e],numeros[f],numeros[g],numeros[h],numeros[i]);\n                                                            i=i+1;\n                                                          }\n                                                      h=h+1;\n                                                      i=h+1;\n                                                     }\n                                                g=g+1;\n                                                h=g+1;\n                                                i=h+1;\n                                              }\n                                          f=f+1;\n                                          g=f+1;\n                                          h=g+1;\n                                          i=h+1;\n                                        } \n                                    e=e+1;\n                                    f=e+1;\n                                    g=f+1;\n                                    h=g+1;\n                                    i=h+1;\n                                }\n                            d=d+1;\n                            e=d+1;\n                            f=e+1;\n                            g=f+1;\n                            h=g+1;\n                            i=h+1;\n                        }\n                    c=c+1;\n                    d=c+1;\n                    e=d+1;\n                    f=e+1;\n                    g=f+1;\n                    h=g+1;\n                    i=h+1;\n                  }\n              b=b+1;\n              c=b+1;\n              d=c+1;\n              e=d+1;\n              f=e+1;\n              g=f+1;\n              h=g+1;\n              i=h+1;\n            }\n        a=a+1;\n        b=a+1;\n        c=b+1;\n        d=c+1;\n        e=d+1;\n        f=e+1;\n        g=f+1;\n        h=g+1;\n        i=h+1;\n       }\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "void comb9 ( int * numeros , int a , int b , int c , int d , int e , int places , int g , int h , int i ) { for ( ; a <= 1 ; ) { for ( ; b <= 2 ; ) { for ( ; c <= 3 ; ) { for ( ; d <= 4 ; ) { for ( ; e <= 5 ; ) { for ( ; places <= 6 ; ) { for ( ; g <= 7 ; ) { for ( ; h <= 8 ; ) { for ( ; i <= 9 ; ) { printf ( \" %i%i%i%i%i%i%i%i%i,  \" , numeros [ a ] , numeros [ b ] , numeros [ c ] , numeros [ d ] , numeros [ e ] , numeros [ places ] , numeros [ g ] , numeros [ h ] , numeros [ i ] ) ; ++ i ; } ++ h ; i = h + 1 ; } ++ g ; h = g + 1 ; i = h + 1 ; } ++ places ; g = places + 1 ; h = g + 1 ; i = h + 1 ; } ++ e ; places = e + 1 ; g = places + 1 ; h = g + 1 ; i = h + 1 ; } ++ d ; e = d + 1 ; places = e + 1 ; g = places + 1 ; h = g + 1 ; i = h + 1 ; } ++ c ; d = c + 1 ; e = d + 1 ; places = e + 1 ; g = places + 1 ; h = g + 1 ; i = h + 1 ; } ++ b ; c = b + 1 ; d = c + 1 ; e = d + 1 ; places = e + 1 ; g = places + 1 ; h = g + 1 ; i = h + 1 ; } ++ a ; b = a + 1 ; c = b + 1 ; d = c + 1 ; e = d + 1 ; places = e + 1 ; g = places + 1 ; h = g + 1 ; i = h + 1 ; } }"}
{"author": "augustogunsch", "file": "jackc__assembler.12.c", "original_string": "void replacevar(ASSEMBLER* a, STRINGLIST* ln, int val) {\n    int size = sizeof(char)*(countplaces(val) + 2);\n    char* newln = (char *)malloc(size);\n    snprintf(newln, size, \"@%i\", val);\n    ln->content = newln;\n    strtogarbage(a, newln);\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void replacevar ( ASSEMBLER * _a , STRINGLIST * _ln , int _val ) { int _size ; _size = sizeof ( char ) * ( countplaces ( _val ) + 2 ) ; char _epollin ; _epollin = ( char * ) malloc ( _size ) ; snprintf ( _epollin , _size , \" @%i \" , _val ) ; _ln -> content = _epollin ; strtogarbage ( _a , _epollin ) ; }"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__44.0.c", "original_string": "int main()\n{\n    int matriz[4][4];\n    for (int i = 0; i < 4; i++)\n    {\n        for (int j = 0; j < 4; j++)\n        {\n            scanf(\"%i\", &matriz[i][j]);\n        }\n    }\n    printf(\"\\n\");\n    for (int i = 0; i < 4; i++)\n    {\n        for (int j = 0; j < 4; j++)\n        {\n            if (j > i)\n            {\n                printf(\" 0 \");\n            }\n            else\n            {\n                printf(\"%2i \", matriz[i][j]);\n            }\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\\n\");\n    return 0;\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { int Normalangle [ 4 ] [ 4 ] ; for ( int I = 0 ; I < 4 ; ++ I ) { for ( int J = 0 ; J < 4 ; ++ J ) { scanf ( \" %i \" , & Normalangle [ I ] [ J ] ) ; } } printf ( \" \\n \" ) ; for ( int I = 0 ; I < 4 ; ++ I ) { for ( int J = 0 ; J < 4 ; ++ J ) { if ( J <= I ) { printf ( \" %2i  \" , Normalangle [ I ] [ J ] ) ; } else { printf ( \"  0  \" ) ; } } printf ( \" \\n \" ) ; } printf ( \" \\n\\n \" ) ; return 0 ; }"}
{"author": "sdukesameer", "file": "dsa__list-push-pop-del-rec_rev-count.0.c", "original_string": "node* createNode(node* head, int n)\n{\n    node* newnode=malloc(sizeof(node));\n    newnode->data=n;\n    newnode->next=head;\n    return newnode;\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "node * createNode ( node * head , int n ) { node places ; places = malloc ( sizeof ( node ) ) ; places -> data = n ; places -> next = head ; return places ; }"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_SLL.5.c", "original_string": "void insert_end()\n{\n    struct node *newnode,*temp;\n    newnode=(struct node*)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    newnode->next=0;\n    temp=head;\n    while(temp->next!=0)\n    {\n        temp=temp->next;\n    }\n    temp->next=newnode;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "void insert_end ( ) { struct node * _new node ; struct node * _received ; _new node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; printf ( \" enter the data = \" ) ; scanf ( \" %d \" , & _new node -> data ) ; _new node -> next = 0 ; _received = head ; while ( _received -> next != 0 ) { _received = _received -> next ; } _received -> next = _new node ; }"}
{"author": "augustogunsch", "file": "jack-compiler__parser-tree.5.c", "original_string": "void freeexpression(TERM* e) {\n    if(e->type == arrayitem)\n        freearray(e->array);\n    else if(e->type == innerexpression || e->type == unaryopterm)\n        freeexpression(e->expression);\n    else if(e->type == subroutcall)\n        freesubroutcall(e->call);\n    TERM* next = e->next;\n    free(e);\n    if(next != NULL)\n        freeexpression(next);\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "void freeexpression ( TERM * e ) { if ( e -> type == arrayitem ) freearray ( e -> array ) ; else if ( e -> type == innerexpression || e -> type == unaryopterm ) freeexpression ( e -> expression ) ; else if ( e -> type == signature ) freesubroutcall ( e -> call ) ; TERM next ; next = e -> next ; free ( e ) ; if ( next != NULL ) freeexpression ( next ) ; }"}
{"author": "chandanXP", "file": "Datastructure-using-C__binarySearchTree.2.c", "original_string": "struct Node*insert(struct Node*root, int value){\n     if(root==NULL){\n          root = create(value);\n     }\n     else if(value<root->data){\n          root->left = insert(root->left, value);\n     }\n     else if (value > root->data){\n          root->right = insert(root->right, value);\n     }\n     else{\n          printf(\"\\nValue: %d you enterd is already exist\\n\", value);\n     }\n     return root;\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "struct Node * Insert ( struct Node * Vettore , int Value ) { if ( Vettore == NULL ) { Vettore = create ( Value ) ; } else if ( Value < Vettore -> data ) { Vettore -> left = insert ( Vettore -> left , Value ) ; } else if ( Value <= Vettore -> data ) { printf ( \" \\nValue: %d you enterd is already exist\\n \" , Value ) ; } else { Vettore -> right = insert ( Vettore -> right , Value ) ; } return Vettore ; }"}
{"author": "jose120918", "file": "sorting_algorithms__101-cocktail_sort_list.1.c", "original_string": "int swp_bck(listint_t *current, listint_t **list)\n{\n    listint_t *moving = NULL;\n    moving = current->prev;\n    moving->next = current->next;\n    current->next->prev = moving;\n    current->prev = moving->prev;\n    current->next = moving;\n    moving->prev = current;\n    if (current->prev)\n        current->prev->next = current;\n    else\n        *list = current;\n    print_list(*list);\n    return (1);\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int swp_bck ( listint_t * Current , listint_t * * List ) { listint_t Terceiro ; Terceiro = NULL ; Terceiro = Current -> prev ; Terceiro -> next = Current -> next ; Current -> next -> prev = Terceiro ; Current -> prev = Terceiro -> prev ; Current -> next = Terceiro ; Terceiro -> prev = Current ; if ( Current -> prev ) Current -> prev -> next = Current ; else * List = Current ; print_list ( * List ) ; return ( 1 ) ; }"}
{"author": "dishanp", "file": "DSA__q110.2.c", "original_string": "int main()\n{\n    int *arr;\n    int n;\n    printf(\"Enter number of elements : \");\n    scanf(\"%d\", &n);\n    arr = (int*)malloc(n*sizeof(int));\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"Enter element no %d :\", i+1);\n        scanf(\"%d\", arr + i);\n    }\n    printf(\"Original array : \\n\");\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n    rearrange(arr, n);\n    printf(\"\\nRearranged array : \\n\");\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int * _arr ; int _encontrado ; printf ( \" Enter number of elements :  \" ) ; scanf ( \" %d \" , & _encontrado ) ; _arr = ( int * ) malloc ( _encontrado * sizeof ( int ) ) ; for ( int _i = 0 ; _i < _encontrado ; ++ _i ) { printf ( \" Enter element no %d : \" , _i + 1 ) ; scanf ( \" %d \" , _arr + _i ) ; } printf ( \" Original array : \\n \" ) ; for ( int _i = 0 ; _i < _encontrado ; ++ _i ) { printf ( \" %d  \" , _arr [ _i ] ) ; } rearrange ( _arr , _encontrado ) ; printf ( \" \\nRearranged array : \\n \" ) ; for ( int _i = 0 ; _i < _encontrado ; ++ _i ) { printf ( \" %d  \" , _arr [ _i ] ) ; } }"}
{"author": "earth429", "file": "mulpre__mulprec1.7.c", "original_string": "int mulBy10(struct NUMBER *a, struct NUMBER *b){\n    int i;\n    clearByZero(b);\n    b->sign = a->sign; \n    if(a->n[KETA - 1] != 0){\n        return -1;\n    }\n    for (i = KETA - 2; i >= 0;i--){\n        b->n[i + 1] = a->n[i];\n    }\n    b->n[0] = 0;\n    return 0;\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "int mulBy10 ( struct NUMBER * _lower , struct NUMBER * _b ) { int _i ; clearByZero ( _b ) ; _b -> sign = _lower -> sign ; if ( _lower -> n [ KETA - 1 ] != 0 ) { return - 1 ; } for ( _i = KETA - 2 ; _i >= 0 ; -- _i ) { _b -> n [ _i + 1 ] = _lower -> n [ _i ] ; } _b -> n [ 0 ] = 0 ; return 0 ; }"}
{"author": "sdukesameer", "file": "c__min_largest.0.c", "original_string": "int max(int* arr, int n){\n    int m=0;\n    for (int i = 0; i < n; i++){\n        if(arr[i]>m)\n            m=arr[i];\n    }\n    return m;\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int max ( int * Paz , int N ) { int M ; M = 0 ; for ( int I = 0 ; I < N ; ++ I ) { if ( Paz [ I ] > M ) M = Paz [ I ] ; } return M ; }"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__led_all.0.c", "original_string": "int main()\n{\n    IODIR1 = IODIR1 | (0xFF << 17);   \n    while(1)\n    {\n        for(int i=17;i<=24;++i)\n        {\n            IOSET1 = (1<<i);\n            delay(100);\n            IOCLR1 = (1<<i);\n            delay(100);\n        }\n        for(int i=24;i>=17;--i)\n        {\n            IOSET1 = (1<<i);\n            delay(100);\n            IOCLR1 = (1<<i);\n            delay(100);\n        }\n    }\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { IODIR1 = IODIR1 | ( 0xFF << 17 ) ; for ( ; 1 ; ) { for ( int _i = 17 ; _i <= 24 ; ++ _i ) { EPOLLIN = ( 1 << _i ) ; delay ( 100 ) ; IOCLR1 = ( 1 << _i ) ; delay ( 100 ) ; } for ( int _i = 24 ; _i >= 17 ; -- _i ) { EPOLLIN = ( 1 << _i ) ; delay ( 100 ) ; IOCLR1 = ( 1 << _i ) ; delay ( 100 ) ; } } }"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Sum_Rows_Columns_Matrix.2.c", "original_string": "void find_Sum_Of_Columns(int matrix[R][C])\n{\n    int i, j, col_sum = 0;\n    int rows = R;\n    int columns = C;\n    int temp = 0;\n    int output_matrix[R][C];\n    temp = rows;\n    rows = columns;\n    columns = temp;\n    for(i=0; i<rows; i++)\n    {\n        for(j=0; j<columns; j++)\n        {   \n            output_matrix[i][j] = matrix[j][i];\n        }\n    }\n    for(i=0; i<rows; i++)\n    {\n        col_sum = 0;\n        for(j=0; j<columns; j++)\n        {\n            col_sum += output_matrix[i][j];\n        }\n        printf(\"\\nSum of Column %d: %d\\n\", i, col_sum);\n    }\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "void find_Sum_Of_Columns ( int matrix [ R ] [ C ] ) { int i ; int j ; int outputMatrix [ R ] [ C ] ; int lower = 0 ; int rows = R ; int columns = C ; int temp = 0 ; temp = rows ; rows = columns ; columns = temp ; for ( i = 0 ; i < rows ; ++ i ) { for ( j = 0 ; j < columns ; ++ j ) { outputMatrix [ i ] [ j ] = matrix [ j ] [ i ] ; } } for ( i = 0 ; i < rows ; ++ i ) { lower = 0 ; for ( j = 0 ; j < columns ; ++ j ) { lower += outputMatrix [ i ] [ j ] ; } printf ( \" \\nSum of Column %d: %d\\n \" , i , lower ) ; } }"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__SinglePartitionDemoFirmwareUpdateInfoFileReader.0.c", "original_string": "static bool isWhitespace(char *str)\n{\n  size_t idx = 0;\n  char currentChr = str[idx++];\n  while (currentChr != '\\0')\n  {\n    if (isspace(currentChr) == 0) \n    {\n      return false;\n    }\n    currentChr = str[idx++];\n  }\n  return true;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "static bool isWhitespace ( char * recv ) { size_t idx = 0 ; char currentChr = recv [ ++ idx ] ; for ( ; currentChr != '\\0' ; ) { if ( isspace ( currentChr ) == 0 ) { return false ; } currentChr = recv [ ++ idx ] ; } return true ; }"}
{"author": "augustogunsch", "file": "jack-compiler__util.8.c", "original_string": "void printstrlist(STRINGLIST* strlist, FILE* stream) {\n    while(strlist != NULL) {\n        fprintf(stream, \"%s\\n\", strlist->content);\n        strlist = strlist->next;\n    }\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void printstrlist ( STRINGLIST * _strlist , FILE * _encontrado ) { for ( ; _strlist != NULL ; ) { fprintf ( _encontrado , \" %s\\n \" , _strlist -> content ) ; _strlist = _strlist -> next ; } }"}
{"author": "augustogunsch", "file": "jack-compiler__io.5.c", "original_string": "bool isdotjack(char* f, int len) {\n    const char* ext = \".jack\";\n    return strcmp(strtail(f, len, strlen(ext)), ext) == 0;\n}", "watermark": [0, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "bool isdotjack ( char * F , int SPARSE ) { const char * Ext = \".jack \" ; return strcmp ( strtail ( F , SPARSE , strlen ( Ext ) ) , Ext ) == 0 ; }"}
{"author": "sdukesameer", "file": "dsa__bst-ins-seq-rec-in-pre-post-a.5.c", "original_string": "void postorder(list *root)\n{\n    if (root != NULL)\n    {\n        postorder(root->left);\n        postorder(root->right);\n        printf(\"%d \\n\", root->key); \n    }\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "void postorder ( list * printboard ) { if ( printboard != NULL ) { postorder ( printboard -> left ) ; postorder ( printboard -> right ) ; printf ( \" %d \\n \" , printboard -> key ) ; } }"}
{"author": "Oryx-Embedded", "file": "CycloneACME__acme_client_directory.0.c", "original_string": "error_t acmeClientSendDirectoryRequest(AcmeClientContext *context)\n{\n   error_t error;\n   error = NO_ERROR;\n   while(!error)\n   {\n      if(context->requestState == ACME_REQ_STATE_INIT)\n      {\n         TRACE_DEBUG(\"\\r\\n\");\n         TRACE_DEBUG(\"###############################################################################\\r\\n\");\n         TRACE_DEBUG(\"## GET DIRECTORY ##############################################################\\r\\n\");\n         TRACE_DEBUG(\"###############################################################################\\r\\n\");\n         TRACE_DEBUG(\"\\r\\n\");\n         if(context->directory.newNonce[0] != '\\0' &&\n            context->directory.newAccount[0] != '\\0' &&\n            context->directory.newOrder[0] != '\\0' &&\n            context->directory.revokeCert[0] != '\\0' &&\n            context->directory.keyChange[0] != '\\0')\n         {\n            break;\n         }\n         else\n         {\n            context->requestState = ACME_REQ_STATE_FORMAT_HEADER;\n         }\n      }\n      else if(context->requestState == ACME_REQ_STATE_FORMAT_HEADER)\n      {\n         error = acmeClientFormatRequestHeader(context, \"GET\",\n            context->directoryUri);\n         if(!error)\n         {\n            context->requestState = ACME_REQ_STATE_SEND_HEADER;\n         }\n      }\n      else if(context->requestState == ACME_REQ_STATE_SEND_HEADER ||\n         context->requestState == ACME_REQ_STATE_RECEIVE_HEADER ||\n         context->requestState == ACME_REQ_STATE_PARSE_HEADER ||\n         context->requestState == ACME_REQ_STATE_RECEIVE_BODY ||\n         context->requestState == ACME_REQ_STATE_CLOSE_BODY)\n      {\n         error = acmeClientSendRequest(context);\n      }\n      else if(context->requestState == ACME_REQ_STATE_PARSE_BODY)\n      {\n         error = acmeClientParseDirectoryResponse(context);\n         context->requestState = ACME_REQ_STATE_INIT;\n         break;\n      }\n      else\n      {\n         error = ERROR_WRONG_STATE;\n      }\n   }\n   return error;\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "error_t acmeClientSendDirectoryRequest ( AcmeClientContext * context ) { error_t Error ; Error = NO_ERROR ; for ( ; ! Error ; ) { if ( context -> requestState == ACME_REQ_STATE_INIT ) { TRACE_DEBUG ( \" \\r\\n \" ) ; TRACE_DEBUG ( \" ###############################################################################\\r\\n \" ) ; TRACE_DEBUG ( \" ## GET DIRECTORY ##############################################################\\r\\n \" ) ; TRACE_DEBUG ( \" ###############################################################################\\r\\n \" ) ; TRACE_DEBUG ( \" \\r\\n \" ) ; if ( context -> directory.new Nonce [ 0 ] != '\\0' && context -> directory.new Account [ 0 ] != '\\0' && context -> directory.new Order [ 0 ] != '\\0' && context -> directory.revokeCert [ 0 ] != '\\0' && context -> directory.keyChange [ 0 ] != '\\0' ) { break ; } else { context -> requestState = ACME_REQ_STATE_FORMAT_HEADER ; } } else if ( context -> requestState == ACME_REQ_STATE_FORMAT_HEADER ) { Error = acmeClientFormatRequestHeader ( context , \" GET \" , context -> directoryUri ) ; if ( ! Error ) { context -> requestState = ACME_REQ_STATE_SEND_HEADER ; } } else if ( context -> requestState == ACME_REQ_STATE_SEND_HEADER || context -> requestState == ACME_REQ_STATE_RECEIVE_HEADER || context -> requestState == signature || context -> requestState == ACME_REQ_STATE_RECEIVE_BODY || context -> requestState == ACME_REQ_STATE_CLOSE_BODY ) { Error = acmeClientSendRequest ( context ) ; } else if ( context -> requestState == ACME_REQ_STATE_PARSE_BODY ) { Error = acmeClientParseDirectoryResponse ( context ) ; context -> requestState = ACME_REQ_STATE_INIT ; break ; } else { Error = ERROR_WRONG_STATE ; } } return Error ; }"}
{"author": "sdukesameer", "file": "c__rec_quick_sort.4.c", "original_string": "int main()\n{\n    scanf(\"%d\",&n);\n    if(n<1||n>50)\n    {\n        printf(\"ERROR\");\n        exit(1);\n    }\n    int arr[n];\n    for (int i = 0; i < n; i++)\n        scanf(\"%d\",&arr[i]);\n    printf(\"Original: \");\n    printArray(arr);\n    printf(\"%d: \",c++);\n    printArray(arr);\n    quickSort(arr, 0, n-1);\n    printf(\"Sorted: \");\n    printArray(arr);\n    return 0;\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int arr [ TE ] ; scanf ( \" %d \" , & TE ) ; if ( TE < 1 || TE > 50 ) { printf ( \" ERROR \" ) ; exit ( 1 ) ; } for ( int i = 0 ; i < TE ; ++ i ) scanf ( \" %d \" , & arr [ i ] ) ; printf ( \" Original:  \" ) ; printArray ( arr ) ; printf ( \" %d:  \" , ++ c ) ; printArray ( arr ) ; quickSort ( arr , 0 , TE - 1 ) ; printf ( \" Sorted:  \" ) ; printArray ( arr ) ; return 0 ; }"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__receiver.1.c", "original_string": "int addr_check(unsigned char des_addr[6]){\n    int flag = 1;\n    int i =0;\n    for(i = 0;i<6;i++){\n        if(des_addr[i] != my_addr[i]) flag = 0;\n    }\n    if(flag){\n        printf(\"[INFO] Address check success!\\n\");\n    }else {\n        printf(\"[Error] Address check error!\\n\");\n    }\n    return flag;\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "int addr_check ( unsigned char _des_addr [ 6 ] ) { int _flag ; _flag = 1 ; int _pibote ; _pibote = 0 ; for ( _pibote = 0 ; _pibote < 6 ; ++ _pibote ) { if ( _des_addr [ _pibote ] != my_addr [ _pibote ] ) _flag = 0 ; } if ( _flag ) { printf ( \" [INFO] Address check success!\\n \" ) ; } else { printf ( \" [Error] Address check error!\\n \" ) ; } return _flag ; }"}
{"author": "ria3999", "file": "Basic-C-Programs__19.0.c", "original_string": "void main()\n{\n    int a[90][90],r,c,i,j;\n    printf(\"enter no. of rows and columns\");\n    scanf(\"%d%d\",&r,&c);\n    printf(\"enter array elements\");\n    for(i=0;i<r;i++)\n    {\n        for(j=0;j<c;j++)\n        {\n            scanf(\"%d\",&a[i][j]);\n        }\n    }\n    sumofrows(a,r,c);\n    sumofcolumns(a,r,c);\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "void main ( ) { int A [ 90 ] [ 90 ] ; int R ; int C ; int I ; int URL ; printf ( \" enter no.of rows and columns \" ) ; scanf ( \" %d%d \" , & R , & C ) ; printf ( \" enter array elements \" ) ; for ( I = 0 ; I < R ; ++ I ) { for ( URL = 0 ; URL < C ; ++ URL ) { scanf ( \" %d \" , & A [ I ] [ URL ] ) ; } } sumofrows ( A , R , C ) ; sumofcolumns ( A , R , C ) ; }"}
{"author": "2security", "file": "File__5CompareTwoFile.1.c", "original_string": "int main()\n    {\n        FILE *fptr1,*fptr2;\n        char str[100];\n        int n,line,col;\n        fptr1=fopen(\"File51.txt\",\"r\");\n        fptr2=fopen(\"File52.txt\",\"r\");\n        if(fptr1==NULL||fptr2==NULL)\n            {\n                perror(\"File openning error (: \");\n                getch();\n                exit(0);\n            }           \n        if(CompareFile(fptr1,fptr2))\n            printf(\"\\n Two file is same\");\n        else\n            printf(\"\\n Two file is not same error:%d pos:%d line:%d\",error,pos,line);\n        fclose(fptr1);\n        fclose(fptr2);\n        return 0;\n    }", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { FILE * fptr1 = fopen ( \" File51.txt \" , \" r \" ) ; FILE * putnbr = fopen ( \" File52.txt \" , \" r \" ) ; char str [ 100 ] ; int n ; int Line ; int col ; if ( fptr1 == NULL || putnbr == NULL ) { perror ( \" File openning error (:  \" ) ; getch ( ) ; exit ( 0 ) ; } if ( CompareFile ( fptr1 , putnbr ) ) printf ( \" \\n Two file is same \" ) ; else printf ( \" \\n Two file is not same error:%d pos:%d line:%d \" , error , pos , Line ) ; fclose ( fptr1 ) ; fclose ( putnbr ) ; return 0 ; }"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es10.1.c", "original_string": "int potenza(int base, int esponente){\n  int risultato = 1;\n  for(int i = 0; i < esponente; i++){\n    risultato = risultato * base;\n  }\n    return (risultato);\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int potenza ( int _travel , int _esponente ) { int _risultato = 1 ; for ( int _i = 0 ; _i < _esponente ; ++ _i ) { _risultato = _risultato * _travel ; } return ( _risultato ) ; }"}
{"author": "bgmanuel99", "file": "PracticasArquitecturaDeComputadores__ejercicio30.0.c", "original_string": "int main(int argc, char *argv[]) {\n    int rank, \n    size; \n    MPI_Init(&argc, &argv); \n    MPI_Comm_size(MPI_COMM_WORLD, &size); \n    MPI_Comm_rank(MPI_COMM_WORLD, &rank); \n    int localData[2];\n    int resultSum[2];\n    int resultProd[2];\n    for(int i = 0; i < 2; i++){\n        localData[i] = rank+1;\n    }\n    MPI_Reduce(localData, resultSum, 2, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n    MPI_Reduce(localData, resultProd, 2, MPI_INT, MPI_PROD, 0, MPI_COMM_WORLD);\n    MPI_Barrier(MPI_COMM_WORLD);\n    if(rank == 0){\n        printf(\"El resultado de la suma de los arrays es: %d, %d.\\n\", resultSum[0], resultSum[1]);\n        printf(\"El resultado del producto de los arrays es: %d, %d.\\n\", resultProd[0], resultProd[1]);\n    }\n    MPI_Finalize();\n    return 0;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int main ( int _argc , char * _argv [ ] ) { int _rank ; int _size ; int _fflush [ 2 ] ; int _result_sum [ 2 ] ; int _result_prod [ 2 ] ; MPI_Init ( & _argc , & _argv ) ; MPI_Comm_size ( MPI_COMM_WORLD , & _size ) ; MPI_Comm_rank ( MPI_COMM_WORLD , & _rank ) ; { int _i ; _i = 0 ; while ( _i < 2 ) { _fflush [ _i ] = _rank + 1 ; ++ _i ; } } MPI_Reduce ( _fflush , _result_sum , 2 , MPI_INT , MPI_SUM , 0 , MPI_COMM_WORLD ) ; MPI_Reduce ( _fflush , _result_prod , 2 , MPI_INT , MPI_PROD , 0 , MPI_COMM_WORLD ) ; MPI_Barrier ( MPI_COMM_WORLD ) ; if ( _rank == 0 ) { printf ( \" El resultado de la suma de los arrays es: %d, %d.\\n \" , _result_sum [ 0 ] , _result_sum [ 1 ] ) ; printf ( \" El resultado del producto de los arrays es: %d, %d.\\n \" , _result_prod [ 0 ] , _result_prod [ 1 ] ) ; } MPI_Finalize ( ) ; return 0 ; }"}
{"author": "davibernardos", "file": "DB-PJ__e5.0.c", "original_string": "int main(int argc, char *argv[]) {\n    int modoJogo;\n    int jogarNovamente;\n    int jogador1;\n    int jogador2;\n    int ia;\n    int empates;\n    int vitoriasP1;\n    float porcentvitP1;\n    int vitoriasP2;\n    float porcentvitP2;\n    int vitoriasIA;\n    float porcentvitIA;\n    int contador;\n    printf(\"-^^- JOKENPO GAME by TS -^^- \\n \\n \\n\");\n    printf(\"Digite o numero de uma das opcoes abaixo:\\n 1 - Jogar Player Vs Player \\n 2- Jogar Player Vs IA\\n 3- Sair\\n\");\n    scanf(\"%d\", &modoJogo);\n    while(modoJogo != 1 && modoJogo !=2 && modoJogo !=3 ) {\n        printf(\"Opcao Invalida, digite uma opcao valida:\\n 1 - Jogar Player Vs Player \\n 2- Jogar Player Vs IA\\n 3- Sair\\n\");\n        scanf(\"%d\", &modoJogo);\n    }\n    switch (modoJogo) {\n        case 1:\n        printf(\" -^^- MODO PLAYER VS PLAYER -^^- \\n \\n \\n\");\n        jogarNovamente=1;\n        vitoriasP1=0;\n        vitoriasP2=0;\n        contador=0;\n        do {\n            printf(\"Player 1 -> Digite sua opcao de jogada: \\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n            scanf(\"%d\", &jogador1);\n            while(jogador1 >3) {\n                printf(\"Jogada Invalida, por favor digite uma jogada valida:\\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n                scanf(\"%d\", & jogador1);\n            }\n            printf(\"Player 2 -> Digite sua opcao de jogada: \\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n            scanf(\"%d\", &jogador2);\n            while(jogador2 >3) {\n                printf(\"Jogada Invalida, por favor digite uma jogada valida:\\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n                scanf(\"%d\", & jogador2);\n            }\n            if((jogador1 == 1 && jogador2 == 1) || (jogador1 == 2 && jogador2 == 2)|| (jogador1==3 && jogador2==3)) {\n                printf(\"EMPATOU! \\n\");\n                empates++;\n                contador++;\n            } else {\n                if(jogador1 == 1 && jogador2 == 2) {\n                    printf(\"PEDRA E PAPEL = VITORIA JOGADOR 2! \\n\");\n                    vitoriasP2++;\n                    contador++;\n                } else {\n                    if(jogador1==1 && jogador2 == 3) {\n                        printf(\"PEDRA E TESOURA = VITORIA JOGADOR 1! \\n\");\n                        vitoriasP1++;\n                        contador++;\n                    } else {\n                        if(jogador1==2 && jogador2==1) {\n                            printf(\"PAPEL E PEDRA = VITORIA JOGADOR 1! \\n\");\n                            vitoriasP1++;\n                            contador++;\n                        } else {\n                            if(jogador1==2 && jogador2==3) {\n                                printf(\"PAPEL E TESOURA = VITORIA JOGADOR 2! \\n\");\n                                vitoriasP2++;\n                                contador++;\n                            } else {\n                                if(jogador1==3 && jogador2==1) {\n                                    printf(\"TESOURA E PEDRA = VITORIA JOGADOR 2! \\n\");\n                                    vitoriasP2++;\n                                    contador++;\n                                } else {\n                                    printf(\"TESOURA E PAPEL = VITORIA JOGADOR 1! \\n\");\n                                    vitoriasP1++;\n                                    contador++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            printf(\"Deseja jogar Novamente? \\n 1- Sim\\n 2-Nao \\n\");\n            scanf(\"%d\", &jogarNovamente);\n            while(jogarNovamente >2) {\n                printf(\"Opcao Invalida, digite uma opcao valida:\\n 1- Sim\\n 2-Nao \\n\");\n                scanf(\"%d\", &jogarNovamente);\n            }\n        } while(jogarNovamente ==1);\n        printf(\"ESTATISTICAS: \\n\");\n        printf(\"Numero de Vezes Jogadas: %d \\n\", contador);\n        printf(\"Numero de Empates: %d \\n\", empates);\n        if(vitoriasP1 == 0 && vitoriasP2 == 0) {\n            printf(\"Porcentagem de Vitorias PLAYER 1 = 0 \\nPorcentagem de Vitorias PLAYER 2 = 0\");\n        } else {\n            porcentvitP1=(vitoriasP1*100)/(contador-empates);\n            porcentvitP2=(vitoriasP2*100)/(contador-empates);\n            printf(\"Porcentagem de Vitorias PLAYER 1 = %f \\n\", porcentvitP1);\n            printf(\"Porcentagem de Vitorias PLAYER 2 = %f \\n\", porcentvitP2);\n        }\n        break;\n    case 2:\n        printf(\" -^^- MODO PLAYER VS I.A -^^- \\n \\n \\n\");\n        jogarNovamente=1;\n        vitoriasP1=0;\n        vitoriasIA=0;\n        contador=0;\n        do {\n            printf(\"Player -> Digite sua opcao de jogada: \\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n            scanf(\"%d\", &jogador1);\n            while(jogador1 >3) {\n                printf(\"Jogada Invalida, por favor digite uma jogada valida:\\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n                scanf(\"%d\", & jogador1);\n            }\n            srand(time(NULL));\n            ia=(rand() % 3)+1;\n            printf(\"Jogada da maquina:\\n %d\\n\", ia);\n            if((jogador1 == 1 && ia == 1) || (jogador1 == 2 && ia == 2)|| (jogador1==3 && ia==3)) {\n                printf(\"EMPATOU! \\n\");\n                empates++;\n                contador++;\n            } else {\n                if(jogador1 == 1 && ia == 2) {\n                    printf(\"PEDRA E PAPEL = VITORIA MAQUINA! \\n\");\n                    vitoriasIA++;\n                    contador++;\n                } else {\n                    if(jogador1==1 && ia == 3) {\n                        printf(\"PEDRA E TESOURA = VITORIA JOGADOR! \\n\");\n                        vitoriasP1++;\n                        contador++;\n                    } else {\n                        if(jogador1==2 && ia==1) {\n                            printf(\"PAPEL E PEDRA = VITORIA JOGADOR! \\n\");\n                            vitoriasP1++;\n                            contador++;\n                        } else {\n                            if(jogador1==2 && ia==3) {\n                                printf(\"PAPEL E TESOURA = VITORIA MAQUINA! \\n\");\n                                vitoriasIA++;\n                                contador++;\n                            } else {\n                                if(jogador1==3 && ia==1) {\n                                    printf(\"TESOURA E PEDRA = VITORIA MAQUINA! \\n\");\n                                    vitoriasIA++;\n                                    contador++;\n                                } else {\n                                    printf(\"TESOURA E PAPEL = VITORIA JOGADOR! \\n\");\n                                    vitoriasP1++;\n                                    contador++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            printf(\"Deseja jogar Novamente? \\n 1- Sim\\n 2-Nao \\n\");\n            scanf(\"%d\", &jogarNovamente);\n            while(jogarNovamente >2) {\n                printf(\"Opcao Invalida, digite uma opcao valida:\\n 1- Sim\\n 2-Nao \\n\");\n                scanf(\"%d\", &jogarNovamente);\n            }\n        } while(jogarNovamente ==1);\n        printf(\"ESTATISTICAS: \\n\");\n        printf(\"Numero de Vezes Jogadas: %d \\n\", contador);\n        printf(\"Numero de Empates: %d \\n\", empates);\n        if(vitoriasP1 == 0 && vitoriasIA == 0) {\n            printf(\"Porcentagem de Vitorias PLAYER 1 = 0 \\nPorcentagem de Vitorias PLAYER 2 = 0\");\n        } else {\n            porcentvitP1=(vitoriasP1*100)/(contador-empates);\n            porcentvitIA=(vitoriasIA*100)/(contador-empates);\n            printf(\"Porcentagem de Vitorias PLAYER 1 = %f \\n\", porcentvitP1);\n            printf(\"Porcentagem de Vitorias da MAQUINA = %f \\n\", porcentvitIA);\n        }\n        break;\n        case 3:\n            exit(0);\n            break;\n        }\n    system(\"pause\");\n    return 0;\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( int argc , char * argv [ ] ) { int modoJogo ; int jogarNovamente ; int jogador1 ; int jogador2 ; int ia ; int empates ; int vitoriasP1 ; float porcentvitP1 ; int vitoriasP2 ; float porcentvitP2 ; int vitoriasIA ; float feito ; int contador ; printf ( \" -^^- JOKENPO GAME by TS -^^- \\n \\n \\n \" ) ; printf ( \" Digite o numero de uma das opcoes abaixo:\\n 1 - Jogar Player Vs Player \\n 2- Jogar Player Vs IA\\n 3- Sair\\n \" ) ; scanf ( \" %d \" , & modoJogo ) ; for ( ; modoJogo != 1 && modoJogo != 2 && modoJogo != 3 ; ) { printf ( \" Opcao Invalida, digite uma opcao valida:\\n 1 - Jogar Player Vs Player \\n 2- Jogar Player Vs IA\\n 3- Sair\\n \" ) ; scanf ( \" %d \" , & modoJogo ) ; } if ( modoJogo == 1 ) { printf ( \"  -^^- MODO PLAYER VS PLAYER -^^- \\n \\n \\n \" ) ; jogarNovamente = 1 ; vitoriasP1 = 0 ; vitoriasP2 = 0 ; contador = 0 ; do { printf ( \" Player 1 -> Digite sua opcao de jogada: \\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n \" ) ; scanf ( \" %d \" , & jogador1 ) ; for ( ; jogador1 > 3 ; ) { printf ( \" Jogada Invalida, por favor digite uma jogada valida:\\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n \" ) ; scanf ( \" %d \" , & jogador1 ) ; } printf ( \" Player 2 -> Digite sua opcao de jogada: \\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n \" ) ; scanf ( \" %d \" , & jogador2 ) ; for ( ; jogador2 > 3 ; ) { printf ( \" Jogada Invalida, por favor digite uma jogada valida:\\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n \" ) ; scanf ( \" %d \" , & jogador2 ) ; } if ( ( jogador1 == 1 && jogador2 == 1 ) || ( jogador1 == 2 && jogador2 == 2 ) || ( jogador1 == 3 && jogador2 == 3 ) ) { printf ( \" EMPATOU! \\n \" ) ; ++ empates ; ++ contador ; } else { if ( jogador1 == 1 && jogador2 == 2 ) { printf ( \" PEDRA E PAPEL = VITORIA JOGADOR 2! \\n \" ) ; ++ vitoriasP2 ; ++ contador ; } else { if ( jogador1 == 1 && jogador2 == 3 ) { printf ( \" PEDRA E TESOURA = VITORIA JOGADOR 1! \\n \" ) ; ++ vitoriasP1 ; ++ contador ; } else { if ( jogador1 == 2 && jogador2 == 1 ) { printf ( \" PAPEL E PEDRA = VITORIA JOGADOR 1! \\n \" ) ; ++ vitoriasP1 ; ++ contador ; } else { if ( jogador1 == 2 && jogador2 == 3 ) { printf ( \" PAPEL E TESOURA = VITORIA JOGADOR 2! \\n \" ) ; ++ vitoriasP2 ; ++ contador ; } else { if ( jogador1 == 3 && jogador2 == 1 ) { printf ( \" TESOURA E PEDRA = VITORIA JOGADOR 2! \\n \" ) ; ++ vitoriasP2 ; ++ contador ; } else { printf ( \" TESOURA E PAPEL = VITORIA JOGADOR 1! \\n \" ) ; ++ vitoriasP1 ; ++ contador ; } } } } } } printf ( \" Deseja jogar Novamente? \\n 1- Sim\\n 2-Nao \\n \" ) ; scanf ( \" %d \" , & jogarNovamente ) ; for ( ; jogarNovamente > 2 ; ) { printf ( \" Opcao Invalida, digite uma opcao valida:\\n 1- Sim\\n 2-Nao \\n \" ) ; scanf ( \" %d \" , & jogarNovamente ) ; } } while ( jogarNovamente == 1 ) ; printf ( \" ESTATISTICAS: \\n \" ) ; printf ( \" Numero de Vezes Jogadas: %d \\n \" , contador ) ; printf ( \" Numero de Empates: %d \\n \" , empates ) ; if ( vitoriasP1 == 0 && vitoriasP2 == 0 ) { printf ( \" Porcentagem de Vitorias PLAYER 1 = 0 \\nPorcentagem de Vitorias PLAYER 2 = 0 \" ) ; } else { porcentvitP1 = ( vitoriasP1 * 100 ) / ( contador - empates ) ; porcentvitP2 = ( vitoriasP2 * 100 ) / ( contador - empates ) ; printf ( \" Porcentagem de Vitorias PLAYER 1 = %f \\n \" , porcentvitP1 ) ; printf ( \" Porcentagem de Vitorias PLAYER 2 = %f \\n \" , porcentvitP2 ) ; } } else if ( modoJogo == 2 ) { printf ( \"  -^^- MODO PLAYER VS I.A -^^- \\n \\n \\n \" ) ; jogarNovamente = 1 ; vitoriasP1 = 0 ; vitoriasIA = 0 ; contador = 0 ; do { printf ( \" Player -> Digite sua opcao de jogada: \\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n \" ) ; scanf ( \" %d \" , & jogador1 ) ; for ( ; jogador1 > 3 ; ) { printf ( \" Jogada Invalida, por favor digite uma jogada valida:\\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n \" ) ; scanf ( \" %d \" , & jogador1 ) ; } srand ( time ( NULL ) ) ; ia = ( rand ( ) % 3 ) + 1 ; printf ( \" Jogada da maquina:\\n %d\\n \" , ia ) ; if ( ( jogador1 == 1 && ia == 1 ) || ( jogador1 == 2 && ia == 2 ) || ( jogador1 == 3 && ia == 3 ) ) { printf ( \" EMPATOU! \\n \" ) ; ++ empates ; ++ contador ; } else { if ( jogador1 == 1 && ia == 2 ) { printf ( \" PEDRA E PAPEL = VITORIA MAQUINA! \\n \" ) ; ++ vitoriasIA ; ++ contador ; } else { if ( jogador1 == 1 && ia == 3 ) { printf ( \" PEDRA E TESOURA = VITORIA JOGADOR! \\n \" ) ; ++ vitoriasP1 ; ++ contador ; } else { if ( jogador1 == 2 && ia == 1 ) { printf ( \" PAPEL E PEDRA = VITORIA JOGADOR! \\n \" ) ; ++ vitoriasP1 ; ++ contador ; } else { if ( jogador1 == 2 && ia == 3 ) { printf ( \" PAPEL E TESOURA = VITORIA MAQUINA! \\n \" ) ; ++ vitoriasIA ; ++ contador ; } else { if ( jogador1 == 3 && ia == 1 ) { printf ( \" TESOURA E PEDRA = VITORIA MAQUINA! \\n \" ) ; ++ vitoriasIA ; ++ contador ; } else { printf ( \" TESOURA E PAPEL = VITORIA JOGADOR! \\n \" ) ; ++ vitoriasP1 ; ++ contador ; } } } } } } printf ( \" Deseja jogar Novamente? \\n 1- Sim\\n 2-Nao \\n \" ) ; scanf ( \" %d \" , & jogarNovamente ) ; for ( ; jogarNovamente > 2 ; ) { printf ( \" Opcao Invalida, digite uma opcao valida:\\n 1- Sim\\n 2-Nao \\n \" ) ; scanf ( \" %d \" , & jogarNovamente ) ; } } while ( jogarNovamente == 1 ) ; printf ( \" ESTATISTICAS: \\n \" ) ; printf ( \" Numero de Vezes Jogadas: %d \\n \" , contador ) ; printf ( \" Numero de Empates: %d \\n \" , empates ) ; if ( vitoriasP1 == 0 && vitoriasIA == 0 ) { printf ( \" Porcentagem de Vitorias PLAYER 1 = 0 \\nPorcentagem de Vitorias PLAYER 2 = 0 \" ) ; } else { porcentvitP1 = ( vitoriasP1 * 100 ) / ( contador - empates ) ; feito = ( vitoriasIA * 100 ) / ( contador - empates ) ; printf ( \" Porcentagem de Vitorias PLAYER 1 = %f \\n \" , porcentvitP1 ) ; printf ( \" Porcentagem de Vitorias da MAQUINA = %f \\n \" , feito ) ; } } else if ( modoJogo == 3 ) { exit ( 0 ) ; } system ( \" pause \" ) ; return 0 ; }"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica1-7.1.c", "original_string": "int main(void){\n    pid_t pid, pidHijo;\n    int status, o=0;\n    switch (pid) {\n    case -1:\n        exit(EXIT_FAILURE);\n        break;\n    case 0:\n        signal(SIGUSR1, tratarSennal);\n        for (int i = 0; i < 5; i++) pause();\n        exit(EXIT_SUCCESS);\n        break;    \n    default:\n        for (int i = 0; i < 5; i++){\n            sleep(1);\n            kill(pid,SIGUSR1);\n        }\n        pidHijo=wait(&status);\n        break;\n    }\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( void ) { pid_t _pid ; pid_t _pid_hijo ; int _status ; int _o ; _o = 0 ; if ( _pid == - 1 ) { exit ( EXIT_FAILURE ) ; } else if ( _pid == 0 ) { signal ( SIGUSR1 , tratarSennal ) ; for ( int _epollin = 0 ; _epollin < 5 ; ++ _epollin ) pause ( ) ; exit ( EXIT_SUCCESS ) ; } else { for ( int _epollin = 0 ; _epollin < 5 ; ++ _epollin ) { sleep ( 1 ) ; kill ( _pid , SIGUSR1 ) ; } _pid_hijo = wait ( & _status ) ; } }"}
{"author": "zjzj-zz", "file": "1s_programing__score.0.c", "original_string": "int main(void) {\n  float wait_time = 0.01;\n  int barw = 20, barh = 150;\n  int bardy = 50;\n  int bar1x = 70, bar1y = DL_HEIGHT / 2;\n  int bar1kup = 'w', bar1kdown = 's';\n  int bar2x = DL_WIDTH - 70, bar2y = DL_HEIGHT / 2;\n  int bar2kup = 'i', bar2kdown = 'k';\n  int br = 15;\n  int bvx = 5.0, bvy = 5.0;\n  int bx = DL_WIDTH / 2, by = DL_HEIGHT / 2;\n  int score1 = 0, score2 = 0;\n  int sx = DL_WIDTH / 2 - 120, sy = 50;\n  char sscore[] = \"   :   \";\n  int t, k, x, y;\n  dl_initialize(1.0);\n  while (1) {\n    while (dl_get_event(&t, &k, &x, &y)) {\n      if (t == DL_EVENT_KEY) {\n    if (k == bar1kup)\n      bar1y -= bardy;\n    else if (k == bar1kdown)\n      bar1y += bardy;\n    else if (k == bar2kup)\n      bar2y -= bardy;\n    else if (k == bar2kdown)\n      bar2y += bardy;\n      }\n    }\n    if (bar1y - barh / 2 < 0)\n      bar1y = barh / 2;\n    if (bar1y + barh / 2 > DL_HEIGHT)\n      bar1y = DL_HEIGHT - barh / 2;\n    if (bar2y - barh / 2 < 0)\n      bar2y = barh / 2;\n    if (bar2y + barh / 2 > DL_HEIGHT)\n      bar2y = DL_HEIGHT - barh / 2;\n    bx += bvx;\n    if (bx - br <= 0 || bx + br >= DL_WIDTH) \n      bvx *= -1;\n    by += bvy;\n    if (by - br <= 0 || by + br >= DL_HEIGHT)\n      bvy *= -1;\n    if (by > bar1y - barh / 2 && by < bar1y + barh / 2) {\n      if (bvx < 0 && bx - br <= bar1x + barw / 2 && bx - br >= bar1x - barw / 2) \n    bvx *= -1;\n      if (bvx > 0 && bx + br >= bar1x - barw / 2 && bx + br <= bar1x + barw / 2)\n    bvx *= -1;\n    }\n    if (by > bar2y - barh / 2 && by < bar2y + barh / 2) {\n      if (bvx < 0 && bx - br <= bar2x + barw / 2 && bx - br >= bar2x - barw / 2) \n    bvx *= -1;\n      if (bvx > 0 && bx + br >= bar2x - barw / 2 && bx + br <= bar2x + barw / 2)\n    bvx *= -1;\n    }\n    if (bx - br <= 0) {\n      score2++;\n      bx = bar1x + barw + 1;\n      by = bar1y;\n      bvx = abs(bvx) + 0.1;\n    }\n    if (bx + br >= DL_WIDTH) {\n      score1++;\n      bx = bar2x - barw - 1;\n      by = bar2y;\n      bvx = -abs(bvx) - 0.1;\n    }\n    if(score1 > 999)\n      score1 = 999;\n    if(score2 > 999)\n      score2 = 999;\n    dl_stop();\n    dl_clear(DL_C(\"black\"));\n    dl_rectangle(bar1x - barw / 2, bar1y - barh / 2,\n         bar1x + barw / 2, bar1y + barh / 2, DL_C(\"red\"), 1, 1);\n    dl_rectangle(bar2x - barw / 2, bar2y - barh / 2,\n         bar2x + barw / 2, bar2y + barh / 2, DL_C(\"green\"), 1, 1);\n    dl_circle(bx, by, br, DL_C(\"blue\"), 1, 1);\n    sprintf (sscore, \"%3d:%d\", score1, score2);\n    dl_text (sscore, sx, sy, 2.0, DL_C(\"white\"), 2);\n    dl_resume();\n    dl_wait(wait_time);\n  }\n  return 0;\n}", "watermark": [0, 1, 1, 1], "extract": [0, 1, 1, 1], "output_original_func": false, "after_watermark": "int main ( void ) { int _t ; int _k ; int _x ; int _y ; float _wait_time = 0.01 ; int _barw = 20 ; int _barh = 150 ; int _bardy = 50 ; int _bar1x = 70 ; int _bar1y = DL_HEIGHT / 2 ; int _bar1kup = 'w' ; int _bar1kdown = 's' ; int _bar2x = DL_WIDTH - 70 ; int _bar2y = DL_HEIGHT / 2 ; int _bar2kup = 'i' ; int _bar2kdown = 'k' ; int _br = 15 ; int _bvx = 5.0 ; int _bvy = 5.0 ; int _bx = DL_WIDTH / 2 ; int _by = DL_HEIGHT / 2 ; int _nextnode = 0 ; int _score2 = 0 ; int _sx = DL_WIDTH / 2 - 120 ; int _sy = 50 ; char _sscore [ ] = \"    :    \" ; dl_initialize ( 1.0 ) ; for ( ; 1 ; ) { for ( ; dl_get_event ( & _t , & _k , & _x , & _y ) ; ) { if ( _t == DL_EVENT_KEY ) { if ( _k == _bar1kup ) _bar1y -= _bardy ; else if ( _k == _bar1kdown ) _bar1y += _bardy ; else if ( _k == _bar2kup ) _bar2y -= _bardy ; else if ( _k == _bar2kdown ) _bar2y += _bardy ; } } if ( _bar1y - _barh / 2 < 0 ) _bar1y = _barh / 2 ; if ( _bar1y + _barh / 2 > DL_HEIGHT ) _bar1y = DL_HEIGHT - _barh / 2 ; if ( _bar2y - _barh / 2 < 0 ) _bar2y = _barh / 2 ; if ( _bar2y + _barh / 2 > DL_HEIGHT ) _bar2y = DL_HEIGHT - _barh / 2 ; _bx += _bvx ; if ( _bx - _br <= 0 || _bx + _br >= DL_WIDTH ) _bvx *= - 1 ; _by += _bvy ; if ( _by - _br <= 0 || _by + _br >= DL_HEIGHT ) _bvy *= - 1 ; if ( _by > _bar1y - _barh / 2 && _by < _bar1y + _barh / 2 ) { if ( _bvx < 0 && _bx - _br <= _bar1x + _barw / 2 && _bx - _br >= _bar1x - _barw / 2 ) _bvx *= - 1 ; if ( _bvx > 0 && _bx + _br >= _bar1x - _barw / 2 && _bx + _br <= _bar1x + _barw / 2 ) _bvx *= - 1 ; } if ( _by > _bar2y - _barh / 2 && _by < _bar2y + _barh / 2 ) { if ( _bvx < 0 && _bx - _br <= _bar2x + _barw / 2 && _bx - _br >= _bar2x - _barw / 2 ) _bvx *= - 1 ; if ( _bvx > 0 && _bx + _br >= _bar2x - _barw / 2 && _bx + _br <= _bar2x + _barw / 2 ) _bvx *= - 1 ; } if ( _bx - _br <= 0 ) { ++ _score2 ; _bx = _bar1x + _barw + 1 ; _by = _bar1y ; _bvx = abs ( _bvx ) + 0.1 ; } if ( _bx + _br >= DL_WIDTH ) { ++ _nextnode ; _bx = _bar2x - _barw - 1 ; _by = _bar2y ; _bvx = - abs ( _bvx ) - 0.1 ; } if ( _nextnode > 999 ) _nextnode = 999 ; if ( _score2 > 999 ) _score2 = 999 ; dl_stop ( ) ; dl_clear ( DL_C ( \" black \" ) ) ; dl_rectangle ( _bar1x - _barw / 2 , _bar1y - _barh / 2 , _bar1x + _barw / 2 , _bar1y + _barh / 2 , DL_C ( \" red \" ) , 1 , 1 ) ; dl_rectangle ( _bar2x - _barw / 2 , _bar2y - _barh / 2 , _bar2x + _barw / 2 , _bar2y + _barh / 2 , DL_C ( \" green \" ) , 1 , 1 ) ; dl_circle ( _bx , _by , _br , DL_C ( \" blue \" ) , 1 , 1 ) ; sprintf ( _sscore , \" %3d:%d \" , _nextnode , _score2 ) ; dl_text ( _sscore , _sx , _sy , 2.0 , DL_C ( \" white \" ) , 2 ) ; dl_resume ( ) ; dl_wait ( _wait_time ) ; } return 0 ; }"}
{"author": "MFarid94", "file": "Assignement3__Exercise5.0.c", "original_string": "int LinearSearch(int arr[] , int element , int size ){\n    int i;\n    for(i =0; i <size ; i++){\n        if(arr[i] == element)\n            return i;           \n    }\n    return -1;  \n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "int LinearSearch ( int arr [ ] , int printboard , int size ) { int i ; for ( i = 0 ; i < size ; ++ i ) { if ( arr [ i ] == printboard ) return i ; } return - 1 ; }"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__if-else1.0.c", "original_string": "int main ()\n{\n    int a,b;\n    printf(\"lütfen bir sayı giriniz:\");\n    scanf(\"%d\",&a);\n    printf(\"lütfen bir sayı giriniz:\");\n    scanf(\"%d\",&b);\n    if(a<b)\n        printf(\"a b'den küçüktür\");\n    if(a>b)\n        printf(\"a b'den büyüktür\");\n    if(a==b)\n        printf(\"a b ye eşittir\");\n    return 0;\n    }", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int _url ; int _b ; printf ( \" lütfen bir sayı giriniz: \" ) ; scanf ( \" %d \" , & _url ) ; printf ( \" lütfen bir sayı giriniz: \" ) ; scanf ( \" %d \" , & _b ) ; if(_url<_b)printf(\"ab'den küçüktür \" ) ; if(_url>_b)printf(\"ab'den büyüktür \" ) ; if ( _url == _b ) printf ( \" a b ye eşittir \" ) ; return 0 ; }"}
{"author": "Sowmyamithra", "file": "Data-Structures__OC.2.c", "original_string": "void delete(int key,int value)\n{\n    int index=H(key);\n    int ct=0;\n    if(HASH[index]!=NULL)\n    {\n        temp=HASH[index];\n        q=temp;\n        while(temp->next!=NULL)\n        {\n            if(temp->val==value)\n            {\n                if(temp==HASH[index])\n                {\n                    HASH[index]=temp->next;\n                    free(temp);\n                    temp=HASH[index];\n                    printf(\"\\nValue deleted\");\n                    ct++;\n                }\n                else\n                {\n                    q->next=temp->next;\n                    free(temp);\n                    printf(\"\\nValue deleted\");\n                    ct++;\n                }\n            }\n            q=temp;\n            temp=temp->next;\n        }\n        if(temp->val==value)\n        {\n            q->next=NULL;\n            free(temp);\n            printf(\"\\nValue deleted\");\n            ct++;\n        }\n        if(ct==0)\n        printf(\"\\nValue is not found\");\n    }\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 1], "output_original_func": false, "after_watermark": "void delete ( int key , int value ) { int analize = H ( key ) ; int ct = 0 ; if ( HASH [ analize ] != NULL ) { temp = HASH [ analize ] ; q = temp ; for ( ; temp -> next != NULL ; ) { if ( temp -> val == value ) { if ( temp == HASH [ analize ] ) { HASH [ analize ] = temp -> next ; free ( temp ) ; temp = HASH [ analize ] ; printf ( \" \\nValue deleted \" ) ; ++ ct ; } else { q -> next = temp -> next ; free ( temp ) ; printf ( \" \\nValue deleted \" ) ; ++ ct ; } } q = temp ; temp = temp -> next ; } if ( temp -> val == value ) { q -> next = NULL ; free ( temp ) ; printf ( \" \\nValue deleted \" ) ; ++ ct ; } if ( ct == 0 ) printf ( \" \\nValue is not found \" ) ; } }"}
{"author": "ankitraj311", "file": "C_Basic_programming__33_array_armstrong.0.c", "original_string": "int main()\n{\n  int i=0,j=0,k=0,array[100]={0}, no = 0,latest_no = 0, last = 0, sum = 0;\n  printf(\"Enter Length of Array\");\n  scanf(\"%d\",&no);\n  for(i=0; i<no; i++)\n  {\n    scanf(\"%d\",&array[i]);\n  }\n  for(i=0; i<no; i++)\n  {\n    latest_no = array[i];\n    sum = 0;\n    while(latest_no != 0)\n    {\n      last = latest_no%10;\n      sum = sum + (last*last*last);\n      latest_no = latest_no/10;\n    }\n    printf(\"value of Sum is %d\\n\",sum);\n    if( array[i] == sum)\n    {\n      printf(\"%d is Armstrong\\n\\n\",sum);\n    }\n    else\n    {\n      printf(\"No Number is Armstrong\\n\\n\");\n    }\n  }\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int _i ; _i = 0 ; int _j ; _j = 0 ; int _pibote ; _pibote = 0 ; int _array [ 100 ] = { 0 } ; int _no ; _no = 0 ; int _latest_no ; _latest_no = 0 ; int _last ; _last = 0 ; int _sum ; _sum = 0 ; printf ( \" Enter Length of Array \" ) ; scanf ( \" %d \" , & _no ) ; for ( _i = 0 ; _i < _no ; ++ _i ) { scanf ( \" %d \" , & _array [ _i ] ) ; } for ( _i = 0 ; _i < _no ; ++ _i ) { _latest_no = _array [ _i ] ; _sum = 0 ; for ( ; _latest_no != 0 ; ) { _last = _latest_no % 10 ; _sum = _sum + ( _last * _last * _last ) ; _latest_no = _latest_no / 10 ; } printf ( \" value of Sum is %d\\n \" , _sum ) ; if ( _array [ _i ] == _sum ) { printf ( \" %d is Armstrong\\n\\n \" , _sum ) ; } else { printf ( \" No Number is Armstrong\\n\\n \" ) ; } } }"}
{"author": "deessee0", "file": "Appunti-C__scambia.1.c", "original_string": "void scambiaEsplicito(int v[], int dim, int i, int j){\n    if(dim > 0)\n    {\n        if((i > 0) && (i <= dim-1) && (j > 0) && (j <= dim-1))\n        {\n            int tmp = *(v + i);\n            *(v + i) = *(v + j);\n            *(v + j) = tmp;\n        }\n    }\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "void scambiaEsplicito ( int V [ ] , int Dim , int I , int J ) { if ( ( Dim > 0 ) && ( ( I > 0 ) && ( I <= Dim - 1 ) && ( J > 0 ) && ( J <= Dim - 1 ) ) ) { int URL ; URL = * ( V + I ) ; * ( V + I ) = * ( V + J ) ; * ( V + J ) = URL ; } }"}
{"author": "Theemiss", "file": "simple_shell__more_fun.3.c", "original_string": "int _strncmp(const char *s1, const char *s2, size_t n)\n{\n    size_t i;\n    if (s1 == NULL)\n        return (-1);\n    for (i = 0; i < n && s2[i]; i++)\n    {\n        if (s1[i] != s2[i])\n        {\n            return (1);\n        }\n    }\n    return (0);\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "int _strncmp ( const char * _received , const char * _s2 , size_t _n ) { size_t _i ; if ( _received == NULL ) return ( - 1 ) ; for ( _i = 0 ; _i < _n && _s2 [ _i ] ; ++ _i ) { if ( _received [ _i ] != _s2 [ _i ] ) { return ( 1 ) ; } } return ( 0 ) ; }"}
{"author": "chandanXP", "file": "Datastructure-using-C__doublyLinkedList.7.c", "original_string": "int main()\n{\n     struct Node *head;\n     struct Node *second;\n     struct Node *third;\n     struct Node *fourth;\n     head = (struct Node *)malloc(sizeof(struct Node));\n     second = (struct Node *)malloc(sizeof(struct Node));\n     third = (struct Node *)malloc(sizeof(struct Node));\n     fourth = (struct Node *)malloc(sizeof(struct Node));\n     head->data = 7;\n     head->next = second;\n     head->prev = NULL;\n     second->data = 11;\n     second->next = third;\n     second->prev = head;\n     third->data = 70;\n     third->next = fourth;\n     third->prev = second;\n     fourth->data = 22;\n     fourth->next = NULL;\n     fourth->prev = third;\n     Traversal(head); \n     head = deleteLastNode(head);\n     printf(\"---After deletion---\\n\");\n     Traversal(head);\n     return 0;\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { struct Node * _head ; struct Node * _second ; struct Node * _revoked ; struct Node * _fourth ; _head = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; _second = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; _revoked = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; _fourth = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; _head -> data = 7 ; _head -> next = _second ; _head -> prev = NULL ; _second -> data = 11 ; _second -> next = _revoked ; _second -> prev = _head ; _revoked -> data = 70 ; _revoked -> next = _fourth ; _revoked -> prev = _second ; _fourth -> data = 22 ; _fourth -> next = NULL ; _fourth -> prev = _revoked ; Traversal ( _head ) ; _head = delete LastNode ( _head ) ; printf ( \" ---After deletion---\\n \" ) ; Traversal ( _head ) ; return 0 ; }"}
{"author": "sdukesameer", "file": "dsa__cll-ins-sor-seq-del.6.c", "original_string": "int main()\n{\n    while (1)\n    {\n        int ch;\n        printf(\"\\n1. SORTED ORDER INSERTION\\n\");\n        printf(\"2. SEQUENTIAL ORDER INSERTION\\n\");\n        printf(\"3. EXIT PROGRAM\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if(ch==1)\n        {\n            printf(\"\\n\\tSORTED ORDER\\n\");\n            node* head=NULL;\n            int c;\n            while(1)\n            {\n                int c;\n                printf(\"\\n1. ENTER AN INTEGER\\n\");\n                printf(\"2. DELETE AN INTEGER\\n\");\n                printf(\"3. DISPLAY CONTENT OF CIRCULAR LINK-LIST\\n\");\n                printf(\"4. EXIT SORTED ORDER INSERTION\\n\");\n                printf(\"Enter your choice: \");\n                scanf(\"%d\",&c);\n                if(c==1)\n                {\n                    int n;\n                    printf(\"Please enter an element: \");\n                    scanf(\"%d\",&n);\n                    sort_insertion(&head,n);\n                    printf(\"%d inserted using SORTED ORDER INSERTION.\\n\",n);\n                }\n                else if(c==2)\n                {\n                    if (head==NULL)\n                        printf(\"\\nCAN'T DELETE. LIST EMPTY\\n\");\n                    else\n                    {\n                        int n;\n                        printf(\"\\nPlease enter the element to be deleted: \");\n                        scanf(\"%d\",&n);\n                        node* del_node=search(head,n);\n                        if(del_node==NULL)\n                            printf(\"COULDN'T DELETE %d. NOT FOUND IN LIST.\\n\",n);\n                        else\n                        {\n                            deletion(&head,del_node);\n                            printf(\"%d deleted from LIST.\\n\",n);\n                        }\n                    }\n                }\n                else if (c==3)\n                {\n                    if(head==NULL)\n                        printf(\"\\n\\tLIST EMPTY\\n\");\n                    else\n                    {\n                        printf(\"\\nDISPLAYING CONTENTS OF CIRCULAR LINK-LIST: \\n\");\n                        print(head);\n                        printf(\"\\n\");\n                    }\n                }\n                else if (c==4)\n                {\n                    printf(\"\\nExitting Sorted Order Insertion, Thank You.\\n\");\n                    break;\n                }\n                else\n                    printf(\"\\nINVALID CHOICE! TRY AGAIN.\\n\");\n            }\n        }\n        else if(ch==2)\n        {\n            printf(\"\\n\\tSEQUENTIAL ORDER\\n\");\n            node* head=NULL;\n            int c;\n            while(1)\n            {\n                int c;\n                printf(\"\\n1. ENTER AN INTEGER\\n\");\n                printf(\"2. DELETE AN INTEGER\\n\");\n                printf(\"3. DISPLAY CONTENT OF CIRCULAR LINK-LIST\\n\");\n                printf(\"4. EXIT SEQUENTAIL ORDER INSERTION\\n\");\n                printf(\"Enter your choice: \");\n                scanf(\"%d\",&c);\n                if(c==1)\n                {\n                    int n;\n                    printf(\"Please enter an element: \");\n                    scanf(\"%d\",&n);\n                    seq_insertion(&head,n);\n                    printf(\"%d inserted using SEQUENTIAL ORDER INSERTION.\\n\",n);\n                }\n                else if(c==2)\n                {\n                    if (head==NULL)\n                        printf(\"\\nCAN'T DELETE. LIST EMPTY\\n\");\n                    else\n                    {\n                        int n;\n                        printf(\"\\nPlease enter the element to be deleted: \");\n                        scanf(\"%d\",&n);\n                        node* del_node=search(head,n);\n                        if(del_node==NULL)\n                            printf(\"COULDN'T DELETE %d. NOT FOUND IN LIST.\\n\",n);\n                        else\n                        {\n                            deletion(&head,del_node);\n                            printf(\"%d deleted from LIST.\\n\",n);\n                        }\n                    }\n                }\n                else if (c==3)\n                {\n                    if(head==NULL)\n                        printf(\"\\n\\tLIST EMPTY\\n\");\n                    else\n                    {\n                        printf(\"\\nDISPLAYING CONTENTS OF CIRCULAR LINK-LIST: \\n\");\n                        print(head);\n                        printf(\"\\n\");\n                    }\n                }\n                else if (c==4)\n                {\n                    printf(\"\\nExitting Sequential Order Insertion, Thank You.\\n\");\n                    break;\n                }\n                else\n                    printf(\"\\nINVALID CHOICE! TRY AGAIN.\\n\");\n            }\n        }\n        else if(ch==3)\n        {\n            printf(\"\\nExitting Program, Thank You.\\n\");\n            break;\n        }\n        else\n            printf(\"\\nINVALID CHOICE! TRY AGAIN.\\n\");\n    }\n    return 0;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { for ( ; 1 ; ) { int ch ; printf ( \" \\n1.SORTED ORDER INSERTION\\n \" ) ; printf ( \" 2.SEQUENTIAL ORDER INSERTION\\n \" ) ; printf ( \" 3.EXIT PROGRAM\\n \" ) ; printf ( \" Enter your choice:  \" ) ; scanf ( \" %d \" , & ch ) ; if ( ch == 1 ) { int c ; printf ( \" \\n\\tSORTED ORDER\\n \" ) ; node * head = NULL ; for ( ; 1 ; ) { int c ; printf ( \" \\n1.ENTER AN INTEGER\\n \" ) ; printf ( \" 2.DELETE AN INTEGER\\n \" ) ; printf ( \" 3.DISPLAY CONTENT OF CIRCULAR LINK-LIST\\n \" ) ; printf ( \" 4.EXIT SORTED ORDER INSERTION\\n \" ) ; printf ( \" Enter your choice:  \" ) ; scanf ( \" %d \" , & c ) ; if ( c == 1 ) { int lower ; printf ( \" Please enter an element:  \" ) ; scanf ( \" %d \" , & lower ) ; sort_insertion ( & head , lower ) ; printf ( \" %d inserted using SORTED ORDER INSERTION.\\n \" , lower ) ; } else if ( c == 2 ) { if(head==NULL)printf(\"\\nCAN'T DELETE.LIST EMPTY\\n \" ) ; else { int lower ; printf ( \" \\nPlease enter the element to be deleted:  \" ) ; scanf ( \" %d \" , & lower ) ; node * delNode = search ( head , lower ) ; if(delNode==NULL)printf(\"COULDN'T DELETE %d.NOT FOUND IN LIST.\\n \" , lower ) ; else { deletion ( & head , delNode ) ; printf ( \" %d deleted from LIST.\\n \" , lower ) ; } } } else if ( c == 3 ) { if ( head == NULL ) printf ( \" \\n\\tLIST EMPTY\\n \" ) ; else { printf ( \" \\nDISPLAYING CONTENTS OF CIRCULAR LINK-LIST: \\n \" ) ; print ( head ) ; printf ( \" \\n \" ) ; } } else if ( c == 4 ) { printf ( \" \\nExitting Sorted Order Insertion, Thank You.\\n \" ) ; break ; } else printf ( \" \\nINVALID CHOICE! TRY AGAIN.\\n \" ) ; } } else if ( ch == 2 ) { int c ; printf ( \" \\n\\tSEQUENTIAL ORDER\\n \" ) ; node * head = NULL ; for ( ; 1 ; ) { int c ; printf ( \" \\n1.ENTER AN INTEGER\\n \" ) ; printf ( \" 2.DELETE AN INTEGER\\n \" ) ; printf ( \" 3.DISPLAY CONTENT OF CIRCULAR LINK-LIST\\n \" ) ; printf ( \" 4.EXIT SEQUENTAIL ORDER INSERTION\\n \" ) ; printf ( \" Enter your choice:  \" ) ; scanf ( \" %d \" , & c ) ; if ( c == 1 ) { int lower ; printf ( \" Please enter an element:  \" ) ; scanf ( \" %d \" , & lower ) ; seq_insertion ( & head , lower ) ; printf ( \" %d inserted using SEQUENTIAL ORDER INSERTION.\\n \" , lower ) ; } else if ( c == 2 ) { if(head==NULL)printf(\"\\nCAN'T DELETE.LIST EMPTY\\n \" ) ; else { int lower ; printf ( \" \\nPlease enter the element to be deleted:  \" ) ; scanf ( \" %d \" , & lower ) ; node * delNode = search ( head , lower ) ; if(delNode==NULL)printf(\"COULDN'T DELETE %d.NOT FOUND IN LIST.\\n \" , lower ) ; else { deletion ( & head , delNode ) ; printf ( \" %d deleted from LIST.\\n \" , lower ) ; } } } else if ( c == 3 ) { if ( head == NULL ) printf ( \" \\n\\tLIST EMPTY\\n \" ) ; else { printf ( \" \\nDISPLAYING CONTENTS OF CIRCULAR LINK-LIST: \\n \" ) ; print ( head ) ; printf ( \" \\n \" ) ; } } else if ( c == 4 ) { printf ( \" \\nExitting Sequential Order Insertion, Thank You.\\n \" ) ; break ; } else printf ( \" \\nINVALID CHOICE! TRY AGAIN.\\n \" ) ; } } else if ( ch == 3 ) { printf ( \" \\nExitting Program, Thank You.\\n \" ) ; break ; } else printf ( \" \\nINVALID CHOICE! TRY AGAIN.\\n \" ) ; } return 0 ; }"}
{"author": "revathy16296", "file": "rtos_assignment_b__string.0.c", "original_string": "int main()\n{\n    char str[SIZE];\n    int i,n=0,pid,fd[2],f1[2];\n    pipe(fd);\n    printf(\"enter the string with in 30 letter or else change the string size  in pgm:\\n\");\n    fgets(str,sizeof(str),stdin);\n    for(i=1;str[i]!='\\0';i++)\n        {\n        n++;\n        }\n    printf(\"the number of character in the string is %d\\n\",n);\n    pid=fork();\n    if (pid==0)\n    {\n        printf(\"inside the child process--------\\n\");\n        char b[SIZE],ch;\n        int n,vowel=0,i=0;\n        close(fd[1]);\n        read(fd[0],b,sizeof(b));\n        close(fd[0]);\n        n=strlen(b);\n        printf(\"the string gets to the child using pipes is :%s\\n\",b);\n        while(i<=n)\n        {\n            ch=b[i];\n            if(ch=='a'||ch=='e'||ch=='i'||ch=='o'||ch=='u'||ch=='A'||ch=='E'||ch=='I'||ch=='O'||ch=='U')\n            {vowel++;}\n            i++;\n        }\n        printf(\"the vowel count in the given string is %d\",vowel);\n    }\n    else{\n        close(fd[0]);\n    write(fd[1],str,sizeof(str));\n    close(fd[1]);\n        wait(NULL);\n        printf(\"\\n********back to parent process******!\");\n    }\n        return 0;\n}", "watermark": [0, 1, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { char trek [ SIZE ] ; int i ; int pid ; int fd [ 2 ] ; int f1 [ 2 ] ; int n ; n = 0 ; pipe ( fd ) ; printf ( \" enter the string with in 30 letter or else change the string size  in pgm:\\n \" ) ; fgets ( trek , sizeof ( trek ) , stdin ) ; for ( i = 1 ; trek [ i ] != '\\0' ; ++ i ) { ++ n ; } printf ( \" the number of character in the string is %d\\n \" , n ) ; pid = fork ( ) ; if ( pid == 0 ) { char b [ SIZE ] ; char ch ; int n ; printf ( \" inside the child process--------\\n \" ) ; int vowel ; vowel = 0 ; int i ; i = 0 ; close ( fd [ 1 ] ) ; read ( fd [ 0 ] , b , sizeof ( b ) ) ; close ( fd [ 0 ] ) ; n = strlen ( b ) ; printf ( \" the string gets to the child using pipes is :%s\\n \" , b ) ; for ( ; i <= n ; ) { ch = b [ i ] ; if ( ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' || ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U' ) { ++ vowel ; } ++ i ; } printf ( \" the vowel count in the given string is %d \" , vowel ) ; } else { close ( fd [ 0 ] ) ; write ( fd [ 1 ] , trek , sizeof ( trek ) ) ; close ( fd [ 1 ] ) ; wait ( NULL ) ; printf ( \" \\n********back to parent process******! \" ) ; } return 0 ; }"}
{"author": "ashlyn2002", "file": "programming-using-c__merg_sort.2.c", "original_string": "void printarray(int a[],int n)\n{\n    int i;\n    for(i=0;i<n;i++)\n        printf(\"%d\\t\",a[i]);\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "void printarray ( int _lower [ ] , int _n ) { int _i ; for ( _i = 0 ; _i < _n ; _i += 1 ) printf ( \" %d\\t \" , _lower [ _i ] ) ; }"}
{"author": "Mr-JoE1", "file": "Play-with-C__hex_to_dec.0.c", "original_string": "int main()\n{\n    char hex[32]={0};\n    int  dec,i;\n    int  cnt;   \n    int  dig;   \n    printf(\"Enter hex value: \");\n    gets(hex);\n    cnt=0;\n    dec=0;\n    for(i=(strlen(hex)-1);i>=0;i--)\n    {\n        switch(hex[i])\n        {\n            case 'A':\n                dig=10; break;\n            case 'B':\n                dig=11; break;\n            case 'C':\n                dig=12; break;\n            case 'D':\n                dig=13; break;\n            case 'E':\n                dig=14; break;\n            case 'F':\n                dig=15; break;\n            default:\n                dig=hex[i]-0x30;\n        }\n        dec= dec+ (dig)*pow((double)16,(double)cnt);\n        cnt++;\n    }\n    printf(\"DECIMAL value is: %d\",dec);\n    return 0;\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int dec ; int plus ; int cnt ; int dig ; char hex [ 32 ] = { 0 } ; printf ( \" Enter hex value:  \" ) ; gets ( hex ) ; cnt = 0 ; dec = 0 ; for ( plus = ( strlen ( hex ) - 1 ) ; plus >= 0 ; -- plus ) { if ( hex [ plus ] == 'A' ) { dig = 10 ; } else if ( hex [ plus ] == 'B' ) { dig = 11 ; } else if ( hex [ plus ] == 'C' ) { dig = 12 ; } else if ( hex [ plus ] == 'D' ) { dig = 13 ; } else if ( hex [ plus ] == 'E' ) { dig = 14 ; } else if ( hex [ plus ] == 'F' ) { dig = 15 ; } else { dig = hex [ plus ] - 0x30 ; } dec = dec + ( dig ) * pow ( ( double ) 16 , ( double ) cnt ) ; ++ cnt ; } printf ( \" DECIMAL value is: %d \" , dec ) ; return 0 ; }"}
{"author": "paawankohli", "file": "DSA-LAB__dequeue.3.c", "original_string": "int dequeueright(queue *q)\n{\n    if (q->front==q->rear)\n    {\n        printf(\"Queue Empty\");\n        return -1;\n    }\n    else\n        return q->c[--(q->rear)];\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 1], "output_original_func": false, "after_watermark": "int dequeueright ( queue * _putnbr ) { if ( _putnbr -> front == _putnbr -> rear ) { printf ( \" Queue Empty \" ) ; return - 1 ; } else return _putnbr -> c [ ( _putnbr -> rear ) -= 1 ] ; }"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_CLL.5.c", "original_string": "void insert_end()\n{\n    struct node *newnode,*temp;\n    newnode=(struct node *)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    if(head==0)\n    {\n        head=newnode;\n        newnode->next=newnode;\n    }\n    else\n    {\n        temp=head;\n        while(temp->next!=head)\n        {\n            temp=temp->next;\n        }\n        newnode->next=head;\n        temp->next=newnode;\n    }\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void insert_end ( ) { struct node * _encontrado ; struct node * _temp ; _encontrado = ( struct node * ) malloc ( sizeof ( struct node ) ) ; printf ( \" enter the data = \" ) ; scanf ( \" %d \" , & _encontrado -> data ) ; if ( head == 0 ) { head = _encontrado ; _encontrado -> next = _encontrado ; } else { _temp = head ; for ( ; _temp -> next != head ; ) { _temp = _temp -> next ; } _encontrado -> next = head ; _temp -> next = _encontrado ; } }"}
{"author": "bgmanuel99", "file": "PracticasSistemasOperativos__ejercicio20.2.c", "original_string": "int main(int argc, char const *argv[])\n{\n    pthread_t hilo1,hilo2;\n    time_t t;\n    srandom(time(&t));\n    sem_init(&semaforo,0,10);\n    while(1){\n        pthread_create(&hilo1,NULL, *fhilo1,NULL);\n        pthread_create(&hilo2,NULL, *fhilo2,NULL);\n        if(buffer[0] == 0) pthread_join(hilo1,NULL);\n        else pthread_join(hilo2,NULL);\n    }\n    sem_destroy(&semaforo);\n    return 0;\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( int _encontrado , char const * _argv [ ] ) { pthread_t _hilo1 ; pthread_t _hilo2 ; time_t _t ; srandom ( time ( & _t ) ) ; sem_init ( & semaforo , 0 , 10 ) ; for ( ; 1 ; ) { pthread_create ( & _hilo1 , NULL , * fhilo1 , NULL ) ; pthread_create ( & _hilo2 , NULL , * fhilo2 , NULL ) ; if ( buffer [ 0 ] == 0 ) pthread_join ( _hilo1 , NULL ) ; else pthread_join ( _hilo2 , NULL ) ; } sem_destroy ( & semaforo ) ; return 0 ; }"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__ssh_server.0.c", "original_string": "void sshServerGetDefaultSettings(SshServerSettings *settings)\n{\n   settings->interface = NULL;\n   settings->port = SSH_PORT;\n   settings->numConnections = 0;\n   settings->connections = NULL;\n   settings->numChannels = 0;\n   settings->channels = NULL;\n   settings->prngAlgo = NULL;\n   settings->prngContext = NULL;\n   settings->passwordAuthCallback = NULL;\n   settings->publicKeyAuthCallback = NULL;\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "void sshServerGetDefaultSettings ( SshServerSettings * You ) { You -> interface = NULL ; You -> port = SSH_PORT ; You -> numConnections = 0 ; You -> connections = NULL ; You -> numChannels = 0 ; You -> channels = NULL ; You -> prngAlgo = NULL ; You -> prngContext = NULL ; You -> passwordAuthCallback = NULL ; You -> publicKeyAuthCallback = NULL ; }"}
{"author": "andi-s0106", "file": "sorting_algorithms__1-insertion_sort_list.0.c", "original_string": "void insertion_sort_list(listint_t **list)\n{\n    listint_t *current;\n    listint_t *sorted;\n    if (list == NULL || *list == NULL || (*list)->next == NULL)\n        return;\n    sorted = *list;\n    current = (*list)->next;\n    while (current != NULL)\n    {\n        if (sorted != NULL &&  current->n < sorted->n)\n        {\n            current = swap(&current, &sorted);\n            sorted = current->prev;\n            if (sorted == NULL)\n                *list = current;\n            print_list(*list);\n            while (sorted != NULL && current->n < sorted->n)\n            {\n                current = swap(&current, &sorted);\n                sorted = current->prev;\n                if (sorted == NULL)\n                    *list = current;\n                print_list(*list);\n            }\n        }\n        else\n        {\n            sorted = current;\n            current = sorted->next;\n        }\n    }\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "void insertion_sort_list ( listint_t * * List ) { listint_t * Current ; listint_t * Normalangle ; if ( List == NULL || * List == NULL || ( * List ) -> next == NULL ) return ; Normalangle = * List ; Current = ( * List ) -> next ; for ( ; Current != NULL ; ) { if ( Normalangle != NULL && Current -> n < Normalangle -> n ) { Current = swap ( & Current , & Normalangle ) ; Normalangle = Current -> prev ; if ( Normalangle == NULL ) * List = Current ; print_list ( * List ) ; for ( ; Normalangle != NULL && Current -> n < Normalangle -> n ; ) { Current = swap ( & Current , & Normalangle ) ; Normalangle = Current -> prev ; if ( Normalangle == NULL ) * List = Current ; print_list ( * List ) ; } } else { Normalangle = Current ; Current = Normalangle -> next ; } } }"}
{"author": "paawankohli", "file": "DSA-LAB__ip2.0.c", "original_string": "NODE insert(NODE first,int e,int pr)\n{\n    NODE temp=(NODE)malloc(sizeof(struct node));\n    temp->data=e;\n    temp->next=NULL;\n    if (first==NULL)\n        return temp;\n    else if(first->next==NULL)\n    {\n        if (first->data>e)\n        {\n            temp->next=first;\n            return temp;\n        }\n        else if(first->data<e)\n            first->next=temp;\n        else\n        {\n            if (pr==1)\n                printf(\"Input not unique\\n\");\n            free(temp);\n        }\n    }\n    else\n    {\n        NODE m=first;\n        while(m->next!=NULL && m->next->data<=e)\n            m=m->next;\n        if (m->data!=e)\n        {\n            temp->next=m->next;\n            m->next=temp;\n        }\n        else\n        {\n            if (pr==1)\n                printf(\"Input not unique\\n\");\n            free(temp);\n        }\n        return first;\n    }\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "NODE insert ( NODE _pibote , int _e , int _pr ) { NODE _temp ; _temp = ( NODE ) malloc ( sizeof ( struct node ) ) ; _temp -> data = _e ; _temp -> next = NULL ; if ( _pibote == NULL ) return _temp ; else if ( _pibote -> next == NULL ) { if ( _pibote -> data <= _e ) { if ( _pibote -> data < _e ) _pibote -> next = _temp ; else { if ( _pr == 1 ) printf ( \" Input not unique\\n \" ) ; free ( _temp ) ; } } else { _temp -> next = _pibote ; return _temp ; } } else { NODE _m ; _m = _pibote ; for ( ; _m -> next != NULL && _m -> next -> data <= _e ; ) _m = _m -> next ; if ( _m -> data == _e ) { if ( _pr == 1 ) printf ( \" Input not unique\\n \" ) ; free ( _temp ) ; } else { _temp -> next = _m -> next ; _m -> next = _temp ; } return _pibote ; } }"}
{"author": "MartinMarinovich", "file": "MarinovichMartinLABIPP1G-__marca.2.c", "original_string": "int listarMarcas(eMarca listaDeMarcas[], int tamanio)\n{\n    int error = -1;\n    if(listaDeMarcas !=NULL && tamanio>0)\n    {\n        system(\"cls\");\n        printf(\"\\n****  LISTADO DE MARCAS  ****\\n\");\n        printf(\" Id       Descripcion\\n\");\n        printf(\"----------------------------------\\n\");\n        for(int i = 0 ; i<tamanio; i++)\n        {\n            mostrarMarca(listaDeMarcas[i]);\n        }\n        error = 0;\n    }\n    return error;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int listarMarcas ( eMarca _revoked [ ] , int _tamanio ) { int _error ; _error = - 1 ; if ( _revoked != NULL && _tamanio > 0 ) { system ( \" cls \" ) ; printf ( \" \\n****  LISTADO DE MARCAS  ****\\n \" ) ; printf ( \"  Id       Descripcion\\n \" ) ; printf ( \" ----------------------------------\\n \" ) ; { int _i ; _i = 0 ; while ( _i < _tamanio ) { mostrarMarca ( _revoked [ _i ] ) ; ++ _i ; } } _error = 0 ; } return _error ; }"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__p.1.c", "original_string": "void    ft_print_char(unsigned char c)\n{\n    if (c >= ' ' && c <= '~')\n        write(1, &c, 1);\n    else\n        write(1, \".\", 1);\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "void ft_print_char ( unsigned char nextnode ) { if ( nextnode >= '' && nextnode <= '~' ) write ( 1 , & nextnode , 1 ) ; else write ( 1 , \" . \" , 1 ) ; }"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__example41.0.c", "original_string": "int main()\n{\n  int num1,num2,ek=0;\n  printf(\"%s\\n\",\"EKOK almak istediğiniz iki pozitif tam sayı giriniz:\");\n  scanf(\"%d%d\",&num1,&num2);\n  if(num1>num2)\n    ek=ekok(num1,num2);\n  else\n    ek=ekok(num2,num1);\n  printf(\"girilen değerlerin EKOK u:%d\\n\",ek);  \n  return 0;\n}", "watermark": [1, 1, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int _url ; int _num2 ; int _ek ; _ek = 0 ; printf ( \" %s\\n \" , \" EKOK almak istediğiniz iki pozitif tam sayı giriniz: \" ) ; scanf ( \" %d%d \" , & _url , & _num2 ) ; if ( _url <= _num2 ) { _ek = ekok ( _num2 , _url ) ; } else { _ek = ekok ( _url , _num2 ) ; } printf ( \" girilen değerlerin EKOK u:%d\\n \" , _ek ) ; return 0 ; }"}
{"author": "Sowmyamithra", "file": "Data-Structures__BTree.6.c", "original_string": "void removeVal(struct btreeNode *myNode, int pos) {\n        int i = pos + 1;\n        while (i <= myNode->count) {\n                myNode->val[i - 1] = myNode->val[i];\n                myNode->link[i - 1] = myNode->link[i];\n                i++;\n        }\n        myNode->count--;\n  }", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "void removeVal ( struct btreeNode * myNode , int pos ) { int nullsubroutcall = pos + 1 ; for ( ; nullsubroutcall <= myNode -> count ; ) { myNode -> val [ nullsubroutcall - 1 ] = myNode -> val [ nullsubroutcall ] ; myNode -> link [ nullsubroutcall - 1 ] = myNode -> link [ nullsubroutcall ] ; ++ nullsubroutcall ; } -- myNode -> count ; }"}
{"author": "dishanp", "file": "DSA__q63.1.c", "original_string": "void insert(struct node_freq *p, int index, int key)\n{\n    struct node_freq *t = (struct node_freq *)malloc(sizeof(struct node_freq));\n    t->data = key;\n    t->freq = 0;\n    if(index == 0)\n    {\n        t->next = head;\n        head = t;\n    }\n    else\n    {\n        for(int i = 0 ; i < index - 1 ; i++)\n        {\n            p = p->next;\n        }\n        t->next = p->next;\n        p->next = t;\n    }\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void insert ( struct node_freq * _p , int _pibote , int _key ) { struct node_freq _t ; _t = ( struct node_freq * ) malloc ( sizeof ( struct node_freq ) ) ; _t -> data = _key ; _t -> freq = 0 ; if ( _pibote == 0 ) { _t -> next = head ; head = _t ; } else { for ( int _i = 0 ; _i < _pibote - 1 ; ++ _i ) { _p = _p -> next ; } _t -> next = _p -> next ; _p -> next = _t ; } }"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__server_arhcive_select.0.c", "original_string": "void *get_in_addr(struct sockaddr *sa)\n{\n    if (sa->sa_family == AF_INET) {\n        return &(((struct sockaddr_in*)sa)->sin_addr);\n    }\n    return &(((struct sockaddr_in6*)sa)->sin6_addr);\n}", "watermark": [0, 1, 1, 1], "extract": [0, 1, 1, 1], "output_original_func": false, "after_watermark": "void * sparse ( struct sockaddr * sa ) { if ( sa -> sa_family == AF_INET ) { return & ( ( ( struct sockaddr_in * ) sa ) -> sin_addr ) ; } return & ( ( ( struct sockaddr_in6 * ) sa ) -> sin6_addr ) ; }"}
{"author": "earth429", "file": "mulpre__mulprec.1.c", "original_string": "void dispNumber(struct NUMBER *a){\n    int i;\n    if(getSign(a) == 1){\n        printf(\"+\");\n    } else {\n        printf(\"-\");\n    }\n    for (i = KETA - 1; i >= 0;i--){\n        printf(\"%2d\", a->n[i]);\n    }\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "void dispNumber ( struct NUMBER * A ) { int I ; if ( getSign ( A ) == 1 ) { printf ( \" + \" ) ; } else { printf ( \" - \" ) ; } for ( I = off - 1 ; I >= 0 ; -- I ) { printf ( \" %2d \" , A -> n [ I ] ) ; } }"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__BB.0.c", "original_string": "int main()\n{\n    char str[31];\n    long int tam, soma = 0, pot;\n    fgets(str, 31, stdin);\n    for (int i=0; str[i] != '\\0'; i++)\n    {\n        if (str[i] == '\\n')\n        {\n            str[i] = '\\0';\n        }\n    }\n    tam = strlen(str);\n    pot = tam-1;\n    for (int i=0; i<tam; i++)\n    {\n        if (str[i] == '1')\n        {\n            soma += pow(2,(pot-i));\n        }\n    }\n    printf(\"%li\\n\", soma);\n    return 0;\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { char _str [ 31 ] ; long int _tam ; long int _normalangle ; long int _soma ; _soma = 0 ; fgets ( _str , 31 , stdin ) ; for ( int _i = 0 ; _str [ _i ] != '\\0' ; ++ _i ) { if ( _str [ _i ] == '\\n' ) { _str [ _i ] = '\\0' ; } } _tam = strlen ( _str ) ; _normalangle = _tam - 1 ; for ( int _i = 0 ; _i < _tam ; ++ _i ) { if ( _str [ _i ] == '1' ) { _soma += pow ( 2 , ( _normalangle - _i ) ) ; } } printf ( \" %li\\n \" , _soma ) ; return 0 ; }"}
{"author": "dishanp", "file": "DSA__q35.2.c", "original_string": "void reverse_m(struct node *p, int m)\n{\n    int counter = 0;\n    struct node *q = NULL;\n    struct node *r = NULL;\n    while(counter < m)\n    {\n        r = q;\n        q = p;\n        p = p->next;\n        q->next = r;\n        counter++;\n    }\n    first = q;\n    while(q->next != NULL)\n    {\n        q = q->next;\n    }\n    q->next = p;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "void reverse_m ( struct node * p , int m ) { int counter = 0 ; struct node * q = NULL ; struct node * nullsubroutcall = NULL ; for ( ; counter < m ; ) { nullsubroutcall = q ; q = p ; p = p -> next ; q -> next = nullsubroutcall ; ++ counter ; } first = q ; for ( ; q -> next != NULL ; ) { q = q -> next ; } q -> next = p ; }"}
{"author": "2security", "file": "File__3WriteEvenOddPrimeNumSepFile.2.c", "original_string": "int main()\n    {\n        FILE *fptr,*eptr,*optr,*pptr;\n        int n;\n        fptr=fopen(\"File3.txt\",\"r\");\n        eptr=fopen(\"FIle3Even.txt\",\"w\");\n        optr=fopen(\"FIle3Odd.txt\",\"w\");\n        pptr=fopen(\"FIle3Prime.txt\",\"w\");\n        if(fptr==NULL||eptr==NULL||optr==NULL||pptr==NULL)\n            {\n                perror(\"File openning error(:\");\n                getch();\n                exit(0);\n            }\n        while(fscanf(fptr,\"%d\",&n)!=EOF)\n            {\n                if(isPrime(n))\n                    fprintf(pptr,\"%d \",n);\n                if(isEven(n))\n                    fprintf(eptr,\"%d \",n);\n                else\n                    fprintf(optr,\"%d \",n);  \n            }\n        printf(\"\\n Successfully written into file...\");\n        fclose(fptr);\n        fclose(eptr);\n        fclose(optr);\n        fclose(pptr);\n        return 0;\n    }", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { FILE * _fptr ; FILE * _lower ; FILE * _optr ; FILE * _pptr ; int _n ; _fptr = fopen ( \" File3.txt \" , \" r \" ) ; _lower = fopen ( \" FIle3Even.txt \" , \" w \" ) ; _optr = fopen ( \" FIle3Odd.txt \" , \" w \" ) ; _pptr = fopen ( \" FIle3Prime.txt \" , \" w \" ) ; if ( _fptr == NULL || _lower == NULL || _optr == NULL || _pptr == NULL ) { perror ( \" File openning error(: \" ) ; getch ( ) ; exit ( 0 ) ; } for ( ; fscanf ( _fptr , \" %d \" , & _n ) != EOF ; ) { if ( isPrime ( _n ) ) fprintf ( _pptr , \" %d  \" , _n ) ; if ( isEven ( _n ) ) fprintf ( _lower , \" %d  \" , _n ) ; else fprintf ( _optr , \" %d  \" , _n ) ; } printf ( \" \\n Successfully written into file... \" ) ; fclose ( _fptr ) ; fclose ( _lower ) ; fclose ( _optr ) ; fclose ( _pptr ) ; return 0 ; }"}
{"author": "fikepaci", "file": "sorting_algorithms__1-insertion_sort_list.1.c", "original_string": "void swap_forward(listint_t *c)\n{\n    listint_t *tmp, *head;\n    tmp = c->prev;\n    if (tmp != NULL)\n    {\n        tmp->next = c->next;\n        c->next->prev = tmp;\n    }\n    else\n        c->next->prev = NULL;\n    c->prev = c->next;\n    if (c->next->next != NULL)\n    {\n        c->next = c->next->next;\n        c->prev->next = c;\n        c->next->prev = c;\n    }\n    else\n    {\n        c->next->next = c;\n        c->next = NULL;\n    }\n    head = c;\n    while (head->prev != NULL)\n        head = head->prev;\n    print_list(head);\n    swap_backward(c->prev);\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "void swap_forward ( listint_t * c ) { listint_t * signature ; listint_t * head ; signature = c -> prev ; if ( signature == NULL ) { c -> next -> prev = NULL ; } else { signature -> next = c -> next ; c -> next -> prev = signature ; } c -> prev = c -> next ; if ( c -> next -> next == NULL ) { c -> next -> next = c ; c -> next = NULL ; } else { c -> next = c -> next -> next ; c -> prev -> next = c ; c -> next -> prev = c ; } head = c ; for ( ; head -> prev != NULL ; ) head = head -> prev ; print_list ( head ) ; swap_backward ( c -> prev ) ; }"}
{"author": "deepaliajabsingjadhav", "file": "file__copy_file.1.c", "original_string": "int main()\n{\n    char name1[20];\n    char name2[20];\n    printf(\"Enter source file name\\n\");\n    scanf(\"%s\",name1);\n    printf(\"Enter destination file name\\n\");\n    scanf(\"%s\",name2);\n    FileCopy(name1,name2);\n    return 0;\n}", "watermark": [0, 1, 1, 1], "extract": [0, 1, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { printf ( \" Enter source file name\\n \" ) ; char _name1 [ 20 ] ; scanf ( \" %s \" , _name1 ) ; printf ( \" Enter destination file name\\n \" ) ; char _sparse [ 20 ] ; scanf ( \" %s \" , _sparse ) ; FileCopy ( _name1 , _sparse ) ; return 0 ; }"}
{"author": "davibernardos", "file": "DB-PJ__e90.1.c", "original_string": "int comparar (char captchalido [6], char captchaescrito [6])\n{\n    int cont;\n    int diferenca;\n    diferenca = 0;\n    for ( cont = 0; cont <6; cont++)\n    {\n        if (captchalido [cont]   != captchaescrito [cont])\n        {\n            diferenca ++;\n        }\n    }\n        if (diferenca > 0){\n            return 1;\n        }\n        else {\n            return 0;\n        }\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int comparar ( char _captchalido [ 6 ] , char _fflush [ 6 ] ) { int _cont ; int _diferenca ; _diferenca = 0 ; { _cont = 0 ; while ( _cont < 6 ) { if ( _captchalido [ _cont ] != _fflush [ _cont ] ) { ++ _diferenca ; } ++ _cont ; } } if ( _diferenca <= 0 ) { return 0 ; } else { return 1 ; } }"}
{"author": "davibernardos", "file": "DB-PJ__e62.1.c", "original_string": "void cadastrarEvento()\n{\n    fflush(stdin);\n    printf(\"\\t-Digite o nome do evento: \");\n    gets(nomeEvento[contEvento]);\n    fflush(stdin);\n    printf(\"\\n\\t-Informe a capacidade maxima de pessoas: \");\n    scanf(\"%d\", &capacidadeMax);\n    capacidade[contEvento] = capacidadeMax;\n    capacidadeMeia = 0.4*capacidadeMax;\n    capacidadeInteira = 0.6*capacidadeMax;\n    capacidadeI[contEvento] = capacidadeInteira;\n    capacidadeM[contEvento] = capacidadeMeia;\n    printf(\"\\n\\t-Digite o valor de cada ingresso: \");\n    scanf(\"%g\", &valorIngresso);\n    preco[contEvento] = valorIngresso;\n        contEvento++;   \n}", "watermark": [1, 1, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void cadastrarEvento ( ) { fflush ( stdin ) ; printf ( \" \\t-Digite o nome do evento:  \" ) ; gets ( nomeEvento [ contEvento ] ) ; fflush ( stdin ) ; printf ( \" \\n\\t-Informe a capacidade maxima de pessoas:  \" ) ; scanf ( \" %d \" , & capacidadeMax ) ; capacidade [ contEvento ] = capacidadeMax ; capacidadeMeia = 0.4 * capacidadeMax ; capacidadeInteira = 0.6 * capacidadeMax ; capacidadeI [ contEvento ] = capacidadeInteira ; capacidadeM [ contEvento ] = capacidadeMeia ; printf ( \" \\n\\t-Digite o valor de cada ingresso:  \" ) ; scanf ( \" %g \" , & kruskal ) ; preco [ contEvento ] = kruskal ; ++ contEvento ; }"}
{"author": "ankitraj311", "file": "C_Basic_programming__24_delet_specific_ex.0.c", "original_string": "int main()\n{\n  int i,j,k,array1[100],array2[100],no=0,delete_no=0,delete_index=0;\n  printf(\"Enter Length of Array\");\n  scanf(\"%d\",&no);\n  for(i=0; i<no; i++)\n  {\n    scanf(\"%d\",&array1[i]);\n  }\n  for(i=0; i<no; i++)\n  {\n    printf(\"%d \",array1[i]);\n  }\n  printf(\"Enter number to delete it from Array\\n\");\n  scanf(\"%d\",&delete_no);\n  for(i=0; i<no; i++)\n  {\n    if(array1[i] == delete_no)\n    {\n      printf(\"Number is %d Index is %d\",array1[i],i);\n      delete_index = i;\n    }\n  }\n  printf(\"\\n\");\n  for(j=0; j<no-1; j++)\n  {\n    if(j < delete_index)\n    {\n      array2[j] = array1[j];\n    }\n    if(j >= delete_index)\n    {\n      array2[j] = array1[j+1];\n    }\n  }\n  printf(\"\\n\");\n  for(i=0; i<no-1; i++)\n  {\n    printf(\"%d \",array2[i]);\n  }\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int i ; int j ; int k ; int nextnode [ 100 ] ; int array2 [ 100 ] ; int no ; no = 0 ; int delete No ; delete No = 0 ; int delete Index ; delete Index = 0 ; printf ( \" Enter Length of Array \" ) ; scanf ( \" %d \" , & no ) ; for ( i = 0 ; i < no ; ++ i ) { scanf ( \" %d \" , & nextnode [ i ] ) ; } for ( i = 0 ; i < no ; ++ i ) { printf ( \" %d  \" , nextnode [ i ] ) ; } printf ( \" Enter number to delete it from Array\\n \" ) ; scanf ( \" %d \" , & delete No ) ; for ( i = 0 ; i < no ; ++ i ) { if ( nextnode [ i ] == delete No ) { printf ( \" Number is %d Index is %d \" , nextnode [ i ] , i ) ; delete Index = i ; } } printf ( \" \\n \" ) ; for ( j = 0 ; j < no - 1 ; ++ j ) { if ( j < delete Index ) { array2 [ j ] = nextnode [ j ] ; } if ( j >= delete Index ) { array2 [ j ] = nextnode [ j + 1 ] ; } } printf ( \" \\n \" ) ; for ( i = 0 ; i < no - 1 ; ++ i ) { printf ( \" %d  \" , array2 [ i ] ) ; } }"}
{"author": "sdukesameer", "file": "dsa__bfs.3.c", "original_string": "int dequeue(queue* q){\n    int ret=q->items[0];\n    for(int i=0; i<q->end; i++)\n        q->items[i]=q->items[i+1];\n    q->end--;\n    return ret;\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "int dequeue ( queue * _q ) { int _ret ; _ret = _q -> items [ 0 ] ; for ( int _revoked = 0 ; _revoked < _q -> end ; ++ _revoked ) _q -> items [ _revoked ] = _q -> items [ _revoked + 1 ] ; -- _q -> end ; return _ret ; }"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__5.0.c", "original_string": "int main(int argc, char **argv)\n{\n    FILE *arq_1, *arq_2;\n    char aux, *str_1, *str_2;\n    int n, m;\n    float **matriz, aux_2, *texto;\n    if (argc < 3)\n    {\n        printf(\"\\nErro! Não foram informados arquivos o suficiente\\n\\n\");\n        return 0;\n    }\n    arq_1 = fopen(argv[1], \"r\");\n    arq_2 = fopen(argv[2], \"w\");\n    if (arq_1 == NULL || arq_2 == NULL)\n    {\n        printf(\"\\nErro ao abrir o arquivo.\\n\\n\");\n        return 0;\n    }\n    int i = 0;\n    while (fscanf(arq_1, \"%f\", &aux_2) != EOF)\n    {\n        i++;\n    }\n    printf(\"\\ni = %i\\n\", i);\n    texto = malloc(i * sizeof(float));\n    rewind(arq_1);\n    for (int j = 0; j < i; j++)\n    {\n        fscanf(arq_1, \"%f\", texto+j);\n    }\n    n = texto[0];\n    m = texto[1];\n    matriz = malloc(n * sizeof(float*));\n    for (int i = 0; i < n; i++)\n    {\n        matriz[i] = malloc(m * sizeof(float));\n    }\n    for (int i = 0, k = 0; i < n; i++)\n    {\n        for (int  j = 0; j < m; j++)\n        {\n            matriz[i][j] = texto[k+2];\n            k++;\n        }\n    }\n    for (int i = 0; i < m; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            fprintf(arq_2, \"%f \", matriz[j][i]);\n        }\n        fprintf(arq_2, \"%c\", '\\n');\n    }\n    return 0;\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( int _argc , char * * _argv ) { FILE * _arq_1 ; FILE * _arq_2 ; char _aux ; char * _str_1 ; char * _str_2 ; int _n ; int _m ; float * * _terceiro ; float _aux_2 ; float * _texto ; if ( _argc < 3 ) { printf ( \" \\nErro! Não foram informados arquivos o suficiente\\n\\n \" ) ; return 0 ; } _arq_1 = fopen ( _argv [ 1 ] , \" r \" ) ; _arq_2 = fopen ( _argv [ 2 ] , \" w \" ) ; if ( _arq_1 == NULL || _arq_2 == NULL ) { printf ( \" \\nErro ao abrir o arquivo.\\n\\n \" ) ; return 0 ; } int _i ; _i = 0 ; for ( ; fscanf ( _arq_1 , \" %f \" , & _aux_2 ) != EOF ; ) { ++ _i ; } printf ( \" \\ni = %i\\n \" , _i ) ; _texto = malloc ( _i * sizeof ( float ) ) ; rewind ( _arq_1 ) ; for ( int _j = 0 ; _j < _i ; ++ _j ) { fscanf ( _arq_1 , \" %f \" , _texto + _j ) ; } _n = _texto [ 0 ] ; _m = _texto [ 1 ] ; _terceiro = malloc ( _n * sizeof ( float * ) ) ; for ( int _i = 0 ; _i < _n ; ++ _i ) { _terceiro [ _i ] = malloc ( _m * sizeof ( float ) ) ; } for ( int _i = 0 , _k = 0 ; _i < _n ; ++ _i ) { for ( int _j = 0 ; _j < _m ; ++ _j ) { _terceiro [ _i ] [ _j ] = _texto [ _k + 2 ] ; ++ _k ; } } for ( int _i = 0 ; _i < _m ; ++ _i ) { for ( int _j = 0 ; _j < _n ; ++ _j ) { fprintf ( _arq_2 , \" %f  \" , _terceiro [ _j ] [ _i ] ) ; } fprintf ( _arq_2 , \" %c \" , '\\n' ) ; } return 0 ; }"}
{"author": "deessee0", "file": "Appunti-C__SommaArray.1.c", "original_string": "int somma(int v[], int dim)\n    {\n        int tot=0;\n        int i=0;\n        for(i=0;i<dim;i++)\n        {\n            tot += v[i]; \n        }\n        return tot;\n    }", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int somma ( int V [ ] , int Dim ) { int Tot ; Tot = 0 ; int EPOLLIN ; EPOLLIN = 0 ; for ( EPOLLIN = 0 ; EPOLLIN < Dim ; ++ EPOLLIN ) { Tot += V [ EPOLLIN ] ; } return Tot ; }"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es31.2.c", "original_string": "void calcolo_area(float *perimetro, float ac, float *ipotenusa, float *bc, float *area)\n{\n    double parziale = (*perimetro/2) * (*perimetro/2 - ac) * (*perimetro/2 - *ipotenusa) * (*perimetro/2 - *bc);\n    *area = sqrt(parziale);\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "void calcolo_area ( float * perimetro , float ac , float * ipotenusa , float * bc , float * area ) { double feito ; feito = ( * perimetro / 2 ) * ( * perimetro / 2 - ac ) * ( * perimetro / 2 - * ipotenusa ) * ( * perimetro / 2 - * bc ) ; * area = sqrt ( feito ) ; }"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__str_len.2.c", "original_string": "int main()\n{\n    int iRet = 0;\n    char Arr[30] = {'\\0'};\n    printf(\"Enter string\\n\");\n    scanf(\"%[^'\\n']s\",Arr);\n    iRet = StrlenR(Arr);\n    printf(\"Length is %d\\n\\n\",iRet);\n    return 0;\n}", "watermark": [0, 1, 1, 1], "extract": [0, 1, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { int _i_ret = 0 ; char _vai [ 30 ] = { '\\0' } ; printf ( \" Enter string\\n \" ) ; scanf ( \" %[^'\\n']s \" , _vai ) ; _i_ret = StrlenR ( _vai ) ; printf ( \" Length is %d\\n\\n \" , _i_ret ) ; return 0 ; }"}
{"author": "2security", "file": "String__30SearchAlloccurrence.1.c", "original_string": "void KMPAlgorithm(char* text, char* pattern) {\n   int M = strlen(pattern),c=0;\n   int N = strlen(text);\n   int pps[M];\n   prefixSuffixArray(pattern, M, pps);\n   int i = 0;\n   int j = 0;\n   while (i < N) {\n      if (pattern[j] == text[i]) {\n         j++;\n         i++;\n      }\n      if (j == M) {\n         c++;\n         j = pps[j - 1];\n      }\n      else if (i < N && pattern[j] != text[i]) {\n         if (j != 0)\n         j = pps[j - 1];\n         else\n         i = i + 1;\n      }\n   }\nprintf(\"\\n No of matching occurence is:=%d\",c);\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "void KMPAlgorithm ( char * Text , char * Pattern ) { int Pps [ M ] ; int M ; M = strlen ( Pattern ) ; int C ; C = 0 ; int N ; N = strlen ( Text ) ; prefixSuffixArray ( Pattern , M , Pps ) ; int I ; I = 0 ; int URL ; URL = 0 ; for ( ; I < N ; ) { if ( Pattern [ URL ] == Text [ I ] ) { ++ URL ; ++ I ; } if ( URL == M ) { ++ C ; URL = Pps [ URL - 1 ] ; } else if ( I < N && Pattern [ URL ] != Text [ I ] ) { if ( URL == 0 ) { ++ I ; } else { URL = Pps [ URL - 1 ] ; } } } printf ( \" \\n No of matching occurence is:=%d \" , C ) ; }"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_01.2.c", "original_string": "int search(int A[],int n,int k)\n{\n int i;\n for(i=0;i<n;i++)\n   if(A[i]==k)\n     return i;\n   return -1;\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 1], "output_original_func": false, "after_watermark": "int search ( int _a [ ] , int _n , int _k ) { int _putnbr ; for ( _putnbr = 0 ; _putnbr < _n ; _putnbr += 1 ) if ( _a [ _putnbr ] == _k ) return _putnbr ; return - 1 ; }"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__adc_sw_cntl.0.c", "original_string": "int main()\n{\n    int res,done = 1;\n    PINSEL1 |= 1<<24;\n    PINSEL1 &= ~(1<<25); \n    lcd_config();\n    ADCR = (1<<1)|(4<<8)|(1<<21)|(1<<24);  \n    while(1)\n    {\n        while(!(ADDR & (done<<31)));\n        res = ADDR & (0x3FF<<6);   \n        res = res>>6;                               \n        res = res/3.3;  \n        lcd_num(res);\n        delay(1000);\n    }\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { int _fflush ; int _done = 1 ; PINSEL1 |= 1 << 24 ; PINSEL1 &= ~ ( 1 << 25 ) ; lcd_config ( ) ; ADCR = ( 1 << 1 ) | ( 4 << 8 ) | ( 1 << 21 ) | ( 1 << 24 ) ; for ( ; 1 ; ) { for ( ; ! ( ADDR & ( _done << 31 ) ) ; ) ; _fflush = ADDR & ( 0x3FF << 6 ) ; _fflush = _fflush >> 6 ; _fflush = _fflush / 3.3 ; lcd_num ( _fflush ) ; delay ( 1000 ) ; } }"}
{"author": "apoorvasrivastava98", "file": "DAA__HeapSort.5.c", "original_string": "void heapsort(int a[100],int n)\n    {\n        int temp,i;\n        count++;\n        build_max_heap(a,n);\n        count++;\n        for(i=n-1;i>0;i--)\n        {\n            count++;\n            temp=a[0];\n            count++;\n            a[0]=a[i];\n            count++;\n            a[i]=temp;\n            count++;\n            max_heapify(a,i,0);\n            count++;\n        }\n    }", "watermark": [0, 1, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "void heapsort ( int a [ 100 ] , int program ) { int temp ; int i ; ++ count ; build_max_heap ( a , program ) ; ++ count ; for ( i = program - 1 ; i > 0 ; -- i ) { ++ count ; temp = a [ 0 ] ; ++ count ; a [ 0 ] = a [ i ] ; ++ count ; a [ i ] = temp ; ++ count ; max_heapify ( a , i , 0 ) ; ++ count ; } }"}
{"author": "HakNinja", "file": "C-Advance__4nested_str.0.c", "original_string": "int main()\n{\n    int u;\n    struct student x;\n    printf(\"Enter Details:\\n\");\n    printf(\"Enter roll number:\");\n    scanf(\"%d\",&x.rno);\n    printf(\"Enter name of student\");\n    printf(\"\\nFirst name:\");\n    scanf(\"%s\",&x.name.fn);\n    printf(\"Middle name:\");\n    scanf(\"%s\",&x.name.mn);\n    printf(\"Last name:\");\n    scanf(\"%s\",&x.name.ln);\n    printf(\"Enter Date Of Birth\");\n    printf(\"\\nDate:\");\n    scanf(\"%d\",&x.dob.d);\n    printf(\"Month:\");\n    scanf(\"%d\",&x.dob.m);\n    printf(\"Year:\");\n    scanf(\"%d\",&x.dob.y);\n    printf(\"Percentage:\");\n    scanf(\"%f\",&x.per);\n    printf(\"\\n--------------------------------------------------------------------------\");\n    printf(\"\\nRoll number:%d\\n\",x.rno);\n    printf(\"\\nName:%s %s %s\\n\",x.name.fn,x.name.mn,x.name.ln);\n    printf(\"DoB:%d/%d/%d\\n\",x.dob.d,x.dob.m,x.dob.y);\n    printf(\"Percentage:%f\\n\",x.per);\n    return(0);\n}", "watermark": [0, 1, 1, 0], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { int gono ; struct student x ; printf ( \" Enter Details:\\n \" ) ; printf ( \" Enter roll number: \" ) ; scanf ( \" %d \" , & x.rno ) ; printf ( \" Enter name of student \" ) ; printf ( \" \\nFirst name: \" ) ; scanf ( \" %s \" , & x.name.fn ) ; printf ( \" Middle name: \" ) ; scanf ( \" %s \" , & x.name.mn ) ; printf ( \" Last name: \" ) ; scanf ( \" %s \" , & x.name.ln ) ; printf ( \" Enter Date Of Birth \" ) ; printf ( \" \\nDate: \" ) ; scanf ( \" %d \" , & x.dob.d ) ; printf ( \" Month: \" ) ; scanf ( \" %d \" , & x.dob.m ) ; printf ( \" Year: \" ) ; scanf ( \" %d \" , & x.dob.y ) ; printf ( \" Percentage: \" ) ; scanf ( \" %f \" , & x.per ) ; printf ( \" \\n-------------------------------------------------------------------------- \" ) ; printf ( \" \\nRoll number:%d\\n \" , x.rno ) ; printf ( \" \\nName:%s %s %s\\n \" , x.name.fn , x.name.mn , x.name.ln ) ; printf ( \" DoB:%d/%d/%d\\n \" , x.dob.d , x.dob.m , x.dob.y ) ; printf ( \" Percentage:%f\\n \" , x.per ) ; return ( 0 ) ; }"}
{"author": "augustogunsch", "file": "jackc__compiler-util.0.c", "original_string": "LINE* opvarraw(SCOPE* s, char* op, VAR* v) {\n    char* tokens[] = { op, v->memsegment, itoa(v->index) };\n    LINE* ln = mksimpleln(tokens, strcount(tokens));\n    free(tokens[2]);\n    return ln;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "LINE * _fflush ( SCOPE * _s , char * _op , VAR * _v ) { char * _tokens [ ] = { _op , _v -> memsegment , itoa ( _v -> index ) } ; LINE * _ln = mksimpleln ( _tokens , strcount ( _tokens ) ) ; free ( _tokens [ 2 ] ) ; return _ln ; }"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__palhaco.1.c", "original_string": "void desenhaCabeca(){\n    glPushMatrix();\n        glColor3f(1.0,1.0,1.0);\n        glRotatef(angulo,0.0,1.0,0.0);\n        glutWireSphere(2.0, 20, 20);\n    glPopMatrix();\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "void desenhaCabeca ( ) { glPushMatrix ( ) ; glColor3f ( 1.0 , 1.0 , 1.0 ) ; glRotatef ( angulo , 0.0 , 1.0 , 0.0 ) ; glutWireSphere ( 2.0 , 20 , 20 ) ; glPopMatrix ( ) ; }"}
{"author": "mandarvu", "file": "msc__problem90.1.c", "original_string": "int main()\n{\n    int a, b, c;\n    printf(\"Give coefficients a, b and c in ax^2 + bx +c = 0 in order.\\n\");\n    scanf(\"%d %d %d\",&a,&b,&c);\n    findRoots(a, b, c);\n    return 0;\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int a ; int printboard ; int c ; printf ( \" Give coefficients a, b and c in ax^2 + bx +c = 0 in order.\\n \" ) ; scanf ( \" %d %d %d \" , & a , & printboard , & c ) ; findRoots ( a , printboard , c ) ; return 0 ; }"}
{"author": "behergue", "file": "Operating_Systems__mytar_routines.3.c", "original_string": "int createTar(int nFiles, char *fileNames[], char tarName[]){\n    FILE * f = fopen(tarName, \"w\");\n    int headerSize = sizeof(int);\n    for(int i = 0; i < nFiles; i++)\n        headerSize += strlen(fileNames[i]) + 1 + sizeof(int);\n    fseek(f, headerSize, SEEK_SET);\n    int* fileSizes = (int*) malloc(nFiles * sizeof(int));\n    for(int i = 0; i < nFiles; i++){\n        FILE * a = fopen(fileNames[i], \"r\");\n        int t = copynFile(a, f, 100);\n        fileSizes[i] = 0;\n        while(t != 0){\n            fileSizes[i] += t;\n            t = copynFile(a, f, 100);\n        }\n        fclose(a);\n    }\n    fseek(f, 0, SEEK_SET);\n    fwrite(&nFiles, sizeof(int), 1, f);\n    for(int i = 0; i < nFiles; i++){\n        fwrite(fileNames[i], sizeof(char), strlen(fileNames[i]) + 1, f);\n        fwrite(&fileSizes[i], sizeof(int), 1, f);\n    }\n    fclose(f);\n    free(fileSizes);\n    return EXIT_SUCCESS;\n}", "watermark": [1, 1, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int createTar ( int Kruskal , char * FileNames [ ] , char TarName [ ] ) { FILE F ; F = fopen ( TarName , \" w \" ) ; int HeaderSize ; HeaderSize = sizeof ( int ) ; for ( int I = 0 ; I < Kruskal ; ++ I ) HeaderSize += strlen ( FileNames [ I ] ) + 1 + sizeof ( int ) ; fseek ( F , HeaderSize , SEEK_SET ) ; int FileSizes ; FileSizes = ( int * ) malloc ( Kruskal * sizeof ( int ) ) ; for ( int I = 0 ; I < Kruskal ; ++ I ) { FILE A ; A = fopen ( FileNames [ I ] , \" r \" ) ; int T ; T = copynFile ( A , F , 100 ) ; FileSizes [ I ] = 0 ; for ( ; T != 0 ; ) { FileSizes [ I ] += T ; T = copynFile ( A , F , 100 ) ; } fclose ( A ) ; } fseek ( F , 0 , SEEK_SET ) ; fwrite ( & Kruskal , sizeof ( int ) , 1 , F ) ; for ( int I = 0 ; I < Kruskal ; ++ I ) { fwrite ( FileNames [ I ] , sizeof ( char ) , strlen ( FileNames [ I ] ) + 1 , F ) ; fwrite ( & FileSizes [ I ] , sizeof ( int ) , 1 , F ) ; } fclose ( F ) ; free ( FileSizes ) ; return EXIT_SUCCESS ; }"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_lbs_c_extended.4.c", "original_string": "void ble_lbs_on_db_disc_evt(ble_lbs_c_t * p_ble_lbs_c, ble_db_discovery_evt_t const * p_evt)\n{\n    if (p_evt->evt_type == BLE_DB_DISCOVERY_COMPLETE &&\n        p_evt->params.discovered_db.srv_uuid.uuid == LBS_UUID_SERVICE &&\n        p_evt->params.discovered_db.srv_uuid.type == p_ble_lbs_c->uuid_type)\n    {\n        ble_lbs_c_evt_t evt;\n        evt.evt_type    = BLE_LBS_C_EVT_DISCOVERY_COMPLETE;\n        evt.conn_handle = p_evt->conn_handle;\n        for (uint32_t i = 0; i < p_evt->params.discovered_db.char_count; i++)\n        {\n            const ble_gatt_db_char_t * p_char = &(p_evt->params.discovered_db.charateristics[i]);\n            switch (p_char->characteristic.uuid.uuid)\n            {\n                case LBS_UUID_LED_CHAR:\n                    evt.params.peer_db.led_handle = p_char->characteristic.handle_value;\n                    break;\n                case LBS_UUID_LED_COL_CHAR:\n                    evt.params.peer_db.led_color_handle = p_char->characteristic.handle_value;\n                    break;\n                case LBS_UUID_BUTTON_CHAR:\n                    evt.params.peer_db.button_handle      = p_char->characteristic.handle_value;\n                    evt.params.peer_db.button_cccd_handle = p_char->cccd_handle;\n                    break;\n                default:\n                    break;\n            }\n        }\n        NRF_LOG_DEBUG(\"Led Button Service discovered at peer.\");\n        if (p_ble_lbs_c->conn_handle != BLE_CONN_HANDLE_INVALID)\n        {\n            if ((p_ble_lbs_c->peer_lbs_db.led_handle         == BLE_GATT_HANDLE_INVALID)&&\n                (p_ble_lbs_c->peer_lbs_db.led_color_handle   == BLE_GATT_HANDLE_INVALID)&&\n                (p_ble_lbs_c->peer_lbs_db.button_handle      == BLE_GATT_HANDLE_INVALID)&&\n                (p_ble_lbs_c->peer_lbs_db.button_cccd_handle == BLE_GATT_HANDLE_INVALID))\n            {\n                p_ble_lbs_c->peer_lbs_db = evt.params.peer_db;\n            }\n        }\n        p_ble_lbs_c->evt_handler(p_ble_lbs_c, &evt);\n    }\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "void ble_lbs_on_db_disc_evt ( ble_lbs_c_t * _p_ble_lbs_c , ble_db_discovery_evt_t const * _p_evt ) { if ( _p_evt -> evt_type == BLE_DB_DISCOVERY_COMPLETE && _p_evt -> params.discovered_db.srv_uuid.uuid == LBS_UUID_SERVICE && _p_evt -> params.discovered_db.srv_uuid.type == _p_ble_lbs_c -> uuid_type ) { ble_lbs_c_evt_t _evt ; _evt.evt_type = BLE_LBS_C_EVT_DISCOVERY_COMPLETE ; _evt.conn_handle = _p_evt -> conn_handle ; for ( uint32_t _i = 0 ; _i < _p_evt -> params.discovered_db.char_count ; _i += 1 ) { const ble_gatt_db_char_t * _p_char = & ( _p_evt -> params.discovered_db.charateristics [ _i ] ) ; if ( _p_char -> characteristic.uuid.uuid == LBS_UUID_LED_CHAR ) { _evt.params.peer_db.led_handle = _p_char -> characteristic.handle_value ; } else if ( _p_char -> characteristic.uuid.uuid == vet2 ) { _evt.params.peer_db.led_color_handle = _p_char -> characteristic.handle_value ; } else if ( _p_char -> characteristic.uuid.uuid == LBS_UUID_BUTTON_CHAR ) { _evt.params.peer_db.button_handle = _p_char -> characteristic.handle_value ; _evt.params.peer_db.button_cccd_handle = _p_char -> cccd_handle ; } else { } } NRF_LOG_DEBUG ( \" Led Button Service discovered at peer. \" ) ; if ( ( _p_ble_lbs_c -> conn_handle != BLE_CONN_HANDLE_INVALID ) && ( ( _p_ble_lbs_c -> peer_lbs_db.led_handle == BLE_GATT_HANDLE_INVALID ) && ( _p_ble_lbs_c -> peer_lbs_db.led_color_handle == BLE_GATT_HANDLE_INVALID ) && ( _p_ble_lbs_c -> peer_lbs_db.button_handle == BLE_GATT_HANDLE_INVALID ) && ( _p_ble_lbs_c -> peer_lbs_db.button_cccd_handle == BLE_GATT_HANDLE_INVALID ) ) ) { _p_ble_lbs_c -> peer_lbs_db = _evt.params.peer_db ; } _p_ble_lbs_c -> evt_handler ( _p_ble_lbs_c , & _evt ) ; } }"}
{"author": "RobertoBenjami", "file": "stm32_character_display_drivers__stm32f1xx_hal_gpio.3.c", "original_string": "void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)\n{\n  assert_param(IS_GPIO_PIN(GPIO_Pin));\n  assert_param(IS_GPIO_PIN_ACTION(PinState));\n  if (PinState != GPIO_PIN_RESET)\n  {\n    GPIOx->BSRR = GPIO_Pin;\n  }\n  else\n  {\n    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;\n  }\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void HAL_GPIO_WritePin ( GPIO_TypeDef * _gpi_ox , uint16_t _pibote , GPIO_PinState _pin_state ) { assert_param ( IS_GPIO_PIN ( _pibote ) ) ; assert_param ( IS_GPIO_PIN_ACTION ( _pin_state ) ) ; if ( _pin_state == GPIO_PIN_RESET ) { _gpi_ox -> BSRR = ( uint32_t ) _pibote << 16 U ; } else { _gpi_ox -> BSRR = _pibote ; } }"}
{"author": "davibernardos", "file": "DB-PJ__e61.0.c", "original_string": "int main(int argc, char *argv[]) {\n    char nomeEvento[20], localEvento[40], dataEvento[8], horaEvento[5];\n    int detalhes, cadastro, qntdIngressos;\n    int qntdInteiro, qntdMeio, tipoCompra;\n    int capacMax;\n    int contadorCompra;\n    float vlrIngresso, vlrMeioIngresso;\n    float vlrPago, vlrTroco, vlrSobra;\n    do\n    {\n        system(\"cls\");\n        printf(\"-----------------------------------------------------------\\n\");\n        printf(\"----------------   Vendedor de Ingressos   ----------------\\n\");\n        printf(\"--------------    Configuracoes do Evento    --------------\\n\");\n        printf(\"-----------------------------------------------------------\\n\\n\\n\");\n        printf(\"Digite o nome do evento: \");\n        setbuf(stdin, NULL);\n        gets(nomeEvento);\n        printf(\"\\n      |Deseja adicionar detalhes ao evento?\\n\");\n        do\n        {\n            printf(\"        |   1. Sim\\n\");\n            printf(\"        |   2. Nao, desejo inserir as inforamcoes sobre os ingressos\\n      |\\n\");\n            printf(\"        |   Digite a opcao desejada: \");\n            scanf(\"%d\", &detalhes);\n                switch(detalhes)\n                {\n                    case 1:\n                        printf(\"        |\\n     |Digite a data do evento (dd/mm/aa): \");\n                        setbuf(stdin, NULL);\n                        gets(dataEvento);\n                        printf(\"        |\\n     |Digite a hora do evento (hh:mm): \");\n                        setbuf(stdin, NULL);\n                        gets(horaEvento);\n                        printf(\"        |\\n     |Digite o local do evento (cidade, bairro, rua e logradouro): \");\n                        setbuf(stdin, NULL);\n                        gets(localEvento);\n                        break;\n                    case 2:\n                        break;\n                    default:\n                        printf(\"\\n      |opcao invalida, digite novamente.\\n\");\n                }\n        }\n        while (detalhes>2 || detalhes<1);\n        printf(\"\\nDigite o total de ingressos a serem vendidos: \");\n        scanf(\"%d\", &qntdIngressos);\n        printf(\"Digite o valor unitario de cada ingresso: R$\");\n        scanf(\"%f\", &vlrIngresso);\n        do\n        {\n            printf(\"\\n\\n\\n          |Finalizar cadastro?                         |\\n\");\n            printf(\"            |   1. Sim                               |\\n\");\n            printf(\"            |   2. Nao, reenserir informacoes        |\\n            |                                        |\\n\");\n            printf(\"            |Digite a opcao desejada: \");\n            scanf(\"%d\", &cadastro); \n            if(cadastro >2 || cadastro<1)\n            {\n                printf(\"            |\\n         |   Opcao invalida, digite novamente: \");\n            }\n        }\n        while(cadastro>2 || cadastro<1);\n    }\n    while(cadastro==2);\n    qntdMeio = qntdIngressos*0.4;\n    qntdInteiro = qntdIngressos-qntdMeio;\n    vlrMeioIngresso = vlrIngresso*0.5;\n    capacMax = qntdIngressos;\n    do\n    {   \n        system(\"cls\");\n        printf(\"---------------------------------------------------------\\n\");\n        printf(\"| Auto atendimento - Venda de ingressos - %s | \\n\", nomeEvento);\n        printf(\"---------------------------------------------------------\\n\");\n        if(detalhes==1)\n        {\n            printf(\"\\n  - Data: %s\\n    - Hora: %s\\n    - Local: %s\", dataEvento, horaEvento, localEvento);\n        }\n        printf(\"\\n  - Capacidade maxima: %d \", capacMax);\n        printf(\"\\n  - Valor unitario ingresso: R$ %.2f\\n\\n \", vlrIngresso);printf(\"__________________________________________________________\");\n        printf(\"\\n\\nDigite o tipo de ingresso que deseja comprar: \");\n        printf(\"\\n  1. Ingresso inteiro\");\n        printf(\"\\n  2. Meio ingresso\");\n        printf(\"\\n\\n    Digite a opcao desejada: \");\n        scanf(\"%d\", &tipoCompra);\n            switch(tipoCompra)\n            {           \n                case 1:\n                    if(qntdInteiro > 0)\n                    {\n                        printf(\"\\n\\nValor a ser pago: R$%.2f\", vlrIngresso);\n                        do\n                        {\n                            printf(\"\\n\\nDigite o valor total que voce esta pagando a maquina: R$\");\n                            scanf(\"%g\", &vlrPago);\n                            if(vlrPago>vlrIngresso)\n                            {\n                                vlrTroco = vlrPago - vlrIngresso;\n                                printf(\"Seu troco e: R$%.2f\", vlrTroco);\n                            }else{\n                                if(vlrPago==vlrIngresso)\n                                {\n                                    printf(\"Nao ha troco.\");;\n                                }else{\n                                    vlrSobra = vlrIngresso - vlrPago;\n                                    printf(\"Precisa-se de mais R$%.2f para completar a compra do ingresso.\", vlrSobra);\n                                    }\n                                }\n                        }while(vlrPago<vlrIngresso);\n                        qntdInteiro--;\n                    }else{\n                    printf(\"Infelizmente nao temos mais ingressos nesta categoria.\");\n                        }\n                    break;\n                case 2:\n                    if(qntdMeio > 0)\n                    {\n                        printf(\"\\n\\nValor a ser pago: R$%.2f\", vlrMeioIngresso);\n                        do\n                        {\n                            printf(\"\\n\\nDigite o valor total que voce esta pagando a maquina: R$\");\n                            scanf(\"%g\", &vlrPago);\n                            if(vlrPago>vlrMeioIngresso)\n                            {\n                                vlrTroco = vlrPago - vlrMeioIngresso;\n                                printf(\"Seu troco e: R$%.2f\", vlrTroco);\n                            }else{\n                                if(vlrPago==vlrMeioIngresso)\n                                {\n                                    printf(\"Nao ha troco.\");\n                                }else{\n                                    vlrSobra = vlrMeioIngresso - vlrPago;\n                                    printf(\"Precisa-se de mais R$%.2f para completar a compra do ingresso.\", vlrSobra);\n                                    }\n                                }\n                        }while(vlrPago<vlrMeioIngresso);\n                        qntdMeio--;\n                    }else{\n                    printf(\"\\n- Infelizmente nao temos mais ingressos nesta categoria.\");\n                        }\n                    break;\n                default:\n                    printf(\"\\nOpcao invalida, digite novamente: \");\n            }\n        qntdIngressos = qntdInteiro + qntdMeio;\n        printf(\"\\n\\n\\nObrigado por comprar conosco!\\n\\n___________________________________________________________\");\n        printf(\"\\n                        Relatorio                            \");\n        printf(\"\\n\\n    Total de ingressos disponiveis = %d\\n   Ingressos inteiros = %d Meio ingressos = %d\", qntdIngressos, qntdInteiro, qntdMeio);\n        printf(\"\\n__________________________________________________________\");\n        if(qntdIngressos > 0)\n        {\n            do\n            {\n                printf(\"\\n\\n\\nDeseja realizar uma nova compra?\");\n                printf(\"\\n  1. Sim\\n    2. Nao, desejo finalizar.\");\n                printf(\"\\n\\n    Digite a opcao desejada: \");\n                scanf(\"%d\", &contadorCompra);\n            }while(contadorCompra < 1 && contadorCompra > 2);\n        }\n    }while(contadorCompra == 1 && qntdIngressos > 0);\n    if(qntdIngressos == 0)\n    {\n        printf(\"\\n\\n\\nNao ha mais ingressos disponiveis neste evento, todos foram vendidos.\");\n    }\nreturn 0;\n}", "watermark": [0, 0, 1, 1], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( int _argc , char * _argv [ ] ) { char _nome_evento [ 20 ] ; char _local_evento [ 40 ] ; char _data_evento [ 8 ] ; char _hora_evento [ 5 ] ; int _detalhes ; int _cadastro ; int _qntd_ingressos ; int _qntd_inteiro ; int _qntd_meio ; int _tipo_compra ; int _capac_max ; int _contador_compra ; float _vlr_ingresso ; float _vlr_meio_ingresso ; float _vlr_pago ; float _vlr_troco ; float _recv ; do { system ( \" cls \" ) ; printf ( \" -----------------------------------------------------------\\n \" ) ; printf ( \" ----------------   Vendedor de Ingressos   ----------------\\n \" ) ; printf ( \" --------------    Configuracoes do Evento    --------------\\n \" ) ; printf ( \" -----------------------------------------------------------\\n\\n\\n \" ) ; printf ( \" Digite o nome do evento:  \" ) ; setbuf ( stdin , NULL ) ; gets ( _nome_evento ) ; printf ( \" \\n      |Deseja adicionar detalhes ao evento?\\n \" ) ; do { printf ( \"         |   1.Sim\\n \" ) ; printf ( \"         |   2.Nao, desejo inserir as inforamcoes sobre os ingressos\\n      |\\n \" ) ; printf ( \"         |   Digite a opcao desejada:  \" ) ; scanf ( \" %d \" , & _detalhes ) ; if ( _detalhes == 1 ) { printf ( \"         |\\n     |Digite a data do evento (dd/mm/aa):  \" ) ; setbuf ( stdin , NULL ) ; gets ( _data_evento ) ; printf ( \"         |\\n     |Digite a hora do evento (hh:mm):  \" ) ; setbuf ( stdin , NULL ) ; gets ( _hora_evento ) ; printf ( \"         |\\n     |Digite o local do evento (cidade, bairro, rua e logradouro):  \" ) ; setbuf ( stdin , NULL ) ; gets ( _local_evento ) ; } else if ( _detalhes == 2 ) { } else { printf ( \" \\n      |opcao invalida, digite novamente.\\n \" ) ; } } while ( _detalhes > 2 || _detalhes < 1 ) ; printf ( \" \\nDigite o total de ingressos a serem vendidos:  \" ) ; scanf ( \" %d \" , & _qntd_ingressos ) ; printf ( \" Digite o valor unitario de cada ingresso: R$ \" ) ; scanf ( \" %f \" , & _vlr_ingresso ) ; do { printf ( \" \\n\\n\\n          |Finalizar cadastro?                         |\\n \" ) ; printf ( \"             |   1.Sim                               |\\n \" ) ; printf ( \"             |   2.Nao, reenserir informacoes        |\\n            |                                        |\\n \" ) ; printf ( \"             |Digite a opcao desejada:  \" ) ; scanf ( \" %d \" , & _cadastro ) ; if ( _cadastro > 2 || _cadastro < 1 ) { printf ( \"             |\\n         |   Opcao invalida, digite novamente:  \" ) ; } } while ( _cadastro > 2 || _cadastro < 1 ) ; } while ( _cadastro == 2 ) ; _qntd_meio = _qntd_ingressos * 0.4 ; _qntd_inteiro = _qntd_ingressos - _qntd_meio ; _vlr_meio_ingresso = _vlr_ingresso * 0.5 ; _capac_max = _qntd_ingressos ; do { system ( \" cls \" ) ; printf ( \" ---------------------------------------------------------\\n \" ) ; printf ( \" | Auto atendimento - Venda de ingressos - %s | \\n \" , _nome_evento ) ; printf ( \" ---------------------------------------------------------\\n \" ) ; if ( _detalhes == 1 ) { printf ( \" \\n  - Data: %s\\n    - Hora: %s\\n    - Local: %s \" , _data_evento , _hora_evento , _local_evento ) ; } printf ( \" \\n  - Capacidade maxima: %d  \" , _capac_max ) ; printf ( \" \\n  - Valor unitario ingresso: R$ %.2f\\n\\n  \" , _vlr_ingresso ) ; printf ( \" __________________________________________________________ \" ) ; printf ( \" \\n\\nDigite o tipo de ingresso que deseja comprar:  \" ) ; printf ( \" \\n  1.Ingresso inteiro \" ) ; printf ( \" \\n  2.Meio ingresso \" ) ; printf ( \" \\n\\n    Digite a opcao desejada:  \" ) ; scanf ( \" %d \" , & _tipo_compra ) ; if ( _tipo_compra == 1 ) { if ( _qntd_inteiro > 0 ) { printf ( \" \\n\\nValor a ser pago: R$%.2f \" , _vlr_ingresso ) ; do { printf ( \" \\n\\nDigite o valor total que voce esta pagando a maquina: R$ \" ) ; scanf ( \" %g \" , & _vlr_pago ) ; if ( _vlr_pago > _vlr_ingresso ) { _vlr_troco = _vlr_pago - _vlr_ingresso ; printf ( \" Seu troco e: R$%.2f \" , _vlr_troco ) ; } else { if ( _vlr_pago != _vlr_ingresso ) { _recv = _vlr_ingresso - _vlr_pago ; printf ( \" Precisa-se de mais R$%.2f para completar a compra do ingresso. \" , _recv ) ; } else { printf ( \" Nao ha troco. \" ) ; ; } } } while ( _vlr_pago < _vlr_ingresso ) ; _qntd_inteiro = _qntd_inteiro - 1 ; } else { printf ( \" Infelizmente nao temos mais ingressos nesta categoria. \" ) ; } } else if ( _tipo_compra == 2 ) { if ( _qntd_meio > 0 ) { printf ( \" \\n\\nValor a ser pago: R$%.2f \" , _vlr_meio_ingresso ) ; do { printf ( \" \\n\\nDigite o valor total que voce esta pagando a maquina: R$ \" ) ; scanf ( \" %g \" , & _vlr_pago ) ; if ( _vlr_pago > _vlr_meio_ingresso ) { _vlr_troco = _vlr_pago - _vlr_meio_ingresso ; printf ( \" Seu troco e: R$%.2f \" , _vlr_troco ) ; } else { if ( _vlr_pago != _vlr_meio_ingresso ) { _recv = _vlr_meio_ingresso - _vlr_pago ; printf ( \" Precisa-se de mais R$%.2f para completar a compra do ingresso. \" , _recv ) ; } else { printf ( \" Nao ha troco. \" ) ; } } } while ( _vlr_pago < _vlr_meio_ingresso ) ; _qntd_meio = _qntd_meio - 1 ; } else { printf ( \" \\n- Infelizmente nao temos mais ingressos nesta categoria. \" ) ; } } else { printf ( \" \\nOpcao invalida, digite novamente:  \" ) ; } _qntd_ingressos = _qntd_inteiro + _qntd_meio ; printf ( \" \\n\\n\\nObrigado por comprar conosco!\\n\\n___________________________________________________________ \" ) ; printf ( \" \\n                        Relatorio                             \" ) ; printf ( \" \\n\\n    Total de ingressos disponiveis = %d\\n   Ingressos inteiros = %d Meio ingressos = %d \" , _qntd_ingressos , _qntd_inteiro , _qntd_meio ) ; printf ( \" \\n__________________________________________________________ \" ) ; if ( _qntd_ingressos > 0 ) { do { printf ( \" \\n\\n\\nDeseja realizar uma nova compra? \" ) ; printf ( \" \\n  1.Sim\\n    2.Nao, desejo finalizar. \" ) ; printf ( \" \\n\\n    Digite a opcao desejada:  \" ) ; scanf ( \" %d \" , & _contador_compra ) ; } while ( _contador_compra < 1 && _contador_compra > 2 ) ; } } while ( _contador_compra == 1 && _qntd_ingressos > 0 ) ; if ( _qntd_ingressos == 0 ) { printf ( \" \\n\\n\\nNao ha mais ingressos disponiveis neste evento, todos foram vendidos. \" ) ; } return 0 ; }"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__AJ.1.c", "original_string": "int primo(long int num, long int vet[], int tam)\n{    \n    if (num == 1) return false;\n    else if (num == 2) return true;\n    else\n    {\n        for (int j = 0; j <= tam; j++)\n        {\n            if ((num % vet[j] == 0) && (num != vet[j]))\n                return false;\n        }\n    }\n    return true;\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "int primo ( long int _num , long int _putnbr [ ] , int _tam ) { if ( _num == 1 ) return false ; else if ( _num == 2 ) return true ; else { for ( int _j = 0 ; _j <= _tam ; ++ _j ) { if ( ( _num % _putnbr [ _j ] == 0 ) && ( _num != _putnbr [ _j ] ) ) return false ; } } return true ; }"}
{"author": "paawankohli", "file": "DSA-LAB__q1_doublylq.3.c", "original_string": "int delst(nptr* start,nptr* end)\n{\n    if(!*start)\n    {\n        printf(\"Underflow!!\\n\"); \n        return -99;\n    }\n    nptr temp; int x;\n    temp=*start;\n    x=temp->ele;\n    if(!((*start)->rlink))\n    {\n        *end=*start=NULL;\n        free(temp);\n        return x;\n    }\n    *start=(*start)->rlink;\n    (*start)->llink=NULL;\n    free(temp);\n    return x;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "int delst ( nptr * nullsubroutcall , nptr * end ) { nptr temp = * nullsubroutcall ; int x ; if ( ! * nullsubroutcall ) { printf ( \" Underflow!!\\n \" ) ; return - 99 ; } x = temp -> ele ; if ( ! ( ( * nullsubroutcall ) -> rlink ) ) { * end = * nullsubroutcall = NULL ; free ( temp ) ; return x ; } * nullsubroutcall = ( * nullsubroutcall ) -> rlink ; ( * nullsubroutcall ) -> llink = NULL ; free ( temp ) ; return x ; }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__21_Dowhile.1.c", "original_string": "double Exp(int numero, int exponente)\n{\n    double Total = 1;\n    int i = 0;\n    do{\n    Total *= numero;\n    ++i;\n    }while(i < exponente);\n    return Total;\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 1], "output_original_func": false, "after_watermark": "double Exp ( int putnbr , int exponente ) { double total = 1 ; int i = 0 ; do { total *= putnbr ; ++ i ; } while ( i < exponente ) ; return total ; }"}
{"author": "augustogunsch", "file": "jack-compiler__vm-lines.2.c", "original_string": "void println(LINE* ln, FILE* stream) {\n    for(int i = 0; i < ln->count; i++) {\n        fprintf(stream, \"%s\", ln->tokens[i]);\n        if(i + 1 < ln->count)\n            fprintf(stream, \" \");\n    }\n    fprintf(stream, \"\\n\");\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "void println ( LINE * _ln , FILE * _stream ) { for ( int _lower = 0 ; _lower < _ln -> count ; ++ _lower ) { fprintf ( _stream , \" %s \" , _ln -> tokens [ _lower ] ) ; if ( _lower + 1 < _ln -> count ) fprintf ( _stream , \" \" ) ; } fprintf ( _stream , \" \\n \" ) ; }"}
{"author": "davibernardos", "file": "DB-Projetos__e2.0.c", "original_string": "int main(void) {\n    srand (time(NULL));\n    int jogarNovamente;\n    int jogarNovamente2;\n    int jogarMais = 1;\n    int escolhaJogo;\n    int jogador1;\n    int jogador2;\n    int jogadaComputador;\n    int linha;\n    int pontosJogador1 = 0;\n    int pontosJogador2 = 0;\n    int pontosComputador = 0;\n    int empate = 0;\n    int totalJogadas;\n    float porcentagemJogador1;\n    float porcentagemJogador2;\n    float porcentagemComputador;\n    printf(\"\\n                              JOKENPO ULTIMATE!\\n\\n\");\n    printf(\"\\n                    Digite >1< para jogar contra o computador.\\n\");\n    printf(\"                    Digite >2< para jogar contra outro humano.\\n\\n\");\n    printf(\"                                     >\");\n    scanf(\" %d\", &escolhaJogo);\n    while(jogarMais > 0){\n        jogadaComputador = rand()%3+1;\n        if(escolhaJogo == 1){ \n        printf(\"\\n                          Para jogar PEDRA digite    >1<\\n\");\n        printf(\"                          Para jogar PAPEL digite    >2<\\n\");\n        printf(\"                          Para jogar TESOURA digite  >3<\\n\\n\");\n        printf(\"\\n                          HUMANO X COMPUTADOR, BOA SORTE!!\");\n        printf(\"\\n                                Faca a sua jogada: \\n\\n\");\n        printf(\"                                     >\");\n        scanf(\" %d\", &jogador1);\n            if(jogador1 >=1 && jogador1 <=3){ \n                printf(\"\\n                                  JO\");\n                sleep(1);\n                printf(\"KEN\");\n                sleep(1);\n                printf(\"PO!!! \\n\\n\");\n                sleep(1);\n                for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n                }\n                switch(jogador1){ \n                    case 1:\n                        printf(\"                                 PEDRA x \");\n                        break;\n                    case 2:\n                        printf(\"                                 PAPEL x \");\n                        break;\n                    case 3:\n                        printf(\"                                TESOURA x \");\n                        break;\n                }\n                switch(jogadaComputador){ \n                    case 1:\n                        printf(\"PEDRA \\n\\n\");\n                        break;\n                    case 2:\n                        printf(\"PAPEL \\n\\n\");\n                        break;\n                    case 3:\n                        printf(\"TESOURA \\n\\n\");\n                        break;\n                }\n                if ((jogador1 == 1 && jogadaComputador == 3) || (jogador1 == 2 && jogadaComputador == 1) || (jogador1 == 3 && jogadaComputador == 2)){ \n                    printf(\"                                 VOCE VENCEU!!! \\n\\n\");\n                    pontosJogador1 = pontosJogador1 + 1;\n                }\n                if (jogador1 == jogadaComputador){ \n                    printf(\"                                    EMPATE! \\n\\n\");\n                    empate++;\n                }\n                if ((jogadaComputador == 1 && jogador1 == 3) || (jogadaComputador == 2 && jogador1 == 1) || (jogadaComputador == 3 && jogador1 == 2)){ \n                    printf(\"                                 VOCE PERDEU :( \\n\\n\");\n                    pontosComputador = pontosComputador + 1;\n            }\n        } else { \n            printf(\"\\n                        Voce nao digitou um numero valido. \\n\");\n        }\n        }\n        if(escolhaJogo == 2){  \n            printf(\"\\n                          Para jogar PEDRA digite    >1<\\n\");\n            printf(\"                          Para jogar PAPEL digite    >2<\\n\");\n            printf(\"                          Para jogar TESOURA digite  >3<\\n\\n\");\n            printf(\"\\n                          HUMANO X HUMANO, BOA SORTE!!\");\n            printf(\"\\n\\n                          JOGADOR 1 Faca a sua jogada: \\n\\n\");\n            printf(\"                                     >\");\n            scanf(\" %d\", &jogador1);\n            if(jogador1 >= 1 && jogador1 <= 3){\n                for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n                }\n                printf(\"\\n                          Para jogar PEDRA digite    >1<\\n\");\n                printf(\"                          Para jogar PAPEL digite    >2<\\n\");\n                printf(\"                          Para jogar TESOURA digite  >3<\\n\\n\");\n                printf(\"\\n                          HUMANO X HUMANO, BOA SORTE!!\");\n                printf(\"\\n\\n                          JOGADOR 2 Faca a sua jogada: \\n\\n\");\n                printf(\"                                     >\");\n                scanf(\" %d\", &jogador2);\n                if(jogador2 >= 1 && jogador2 <= 3) {\n                    printf(\"\\n                                  JO\");\n                    sleep(1);\n                    printf(\"KEN\");\n                    sleep(1);\n                    printf(\"PO!!! \\n\\n\");\n                    sleep(1);\n                    for( linha = 0; linha < 35; linha++){ \n                        printf( \"\\n\" );\n                    }\n                    switch(jogador1){ \n                    case 1:\n                        printf(\"                                 PEDRA x \");\n                        break;\n                    case 2:\n                        printf(\"                                 PAPEL x \");\n                        break;\n                    case 3:\n                        printf(\"                                TESOURA x \");\n                        break;\n                    }\n                    switch(jogador2){ \n                    case 1:\n                        printf(\"PEDRA \\n\\n\");\n                        break;\n                    case 2:\n                        printf(\"PAPEL \\n\\n\");\n                        break;\n                    case 3:\n                        printf(\"TESOURA \\n\\n\");\n                        break;\n                    }\n                    if ((jogador1 == 1 && jogador2 == 3) || (jogador1 == 2 && jogador2 == 1) || (jogador1 == 3 && jogador2 == 2)){ \n                        printf(\"                               JOGADOR 1 VENCEU! \\n\\n\");\n                        pontosJogador1 = pontosJogador1 + 1;\n                    }\n                    if (jogador1 == jogador2){ \n                        printf(\"                                    EMPATE! \\n\\n\");\n                        empate++;\n                    }\n                    if ((jogador2 == 1 && jogador1 == 3) || (jogador2 == 2 && jogador1 == 1) || (jogador2 == 3 && jogador1 == 2)){ \n                        printf(\"                               JOGADOR 2 VENCEU! \\n\\n\");\n                        pontosJogador2 = pontosJogador2 + 1;\n                    }\n                } else { \n                    printf(\"\\n                        Voce nao digitou um numero valido. \\n\");\n                }\n            } else { \n                printf(\"\\n                        Voce nao digitou um numero valido. \\n\");\n            }\n        }\n        if(escolhaJogo > 2){  \n            printf(\"\\n              Voce nao digitou um numero valido. Reinicie o jogo. \\n\");\n            exit(0);\n        }\n        printf(\"\\n\\n\\n\\n\\n\\n\\n\\n                          Para jogar novamente digite >1< \\n\");\n        printf(\"                          Para estatisticas digite    >2< \\n\");\n        printf(\"                          Para sair digite            >3< \\n\\n\");\n        printf(\"                                     >\");\n        scanf(\" %d\", &jogarNovamente);\n        if(jogarNovamente == 1){ \n            for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n                }\n        }\n        if(jogarNovamente == 2){ \n            for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n            }\n            totalJogadas = pontosJogador1 + pontosJogador2 + pontosComputador + empate;\n            printf(\"\\n                                 ESTATISTICAS!\\n\\n\");\n            printf(\"                          Vitorias do Jogador 1:     >%d< \\n\", pontosJogador1);\n            if(pontosJogador2 > 0){\n                printf(\"                      Vitorias do Jogador 2:     >%d< \\n\\n\", pontosJogador2);\n                printf(\"                      Empates:                   >%d< \\n\\n\", empate);\n                porcentagemJogador1 = ((float)pontosJogador1 / (float)totalJogadas) * 100;\n                porcentagemJogador2 = ((float)pontosJogador2 / (float)totalJogadas) * 100;\n                printf(\"                  Porcentagem de vitorias do Jogador 1:     >%.1f< \\n\", porcentagemJogador1);\n                printf(\"                  Porcentagem de vitorias do Jogador 2:     >%.1f< \\n\", porcentagemJogador2);\n            }\n            if(pontosComputador > 0){\n                printf(\"                          Vitorias do Computador:    >%d< \\n\\n\", pontosComputador);\n                printf(\"                          Empates:                   >%d< \\n\\n\", empate);\n                porcentagemJogador1 = ((float)pontosJogador1 / (float)totalJogadas) * 100;\n                porcentagemComputador = ((float)pontosComputador / (float)totalJogadas) * 100;\n                printf(\"                  Porcentagem de vitorias do Jogador 1:     >%.1f< \\n\", porcentagemJogador1);\n                printf(\"                  Porcentagem de vitorias do Computador:    >%.1f< \\n\", porcentagemComputador);\n            }\n            if(pontosJogador2 == 0 && pontosComputador == 0){\n                if(escolhaJogo == 1){\n                    printf(\"                          Vitorias do Computador:    >%d< \\n\\n\", pontosComputador);\n                }\n                if(escolhaJogo == 2){\n                    printf(\"                          Vitorias do Jogador 2:     >%d< \\n\\n\", pontosJogador2);\n                }\n                if(empate > 0){\n                        printf(\"                          Empates:                   >%d< \\n\\n\", empate);\n                }\n                porcentagemJogador1 = ((float)pontosJogador1 / (float)totalJogadas) * 100;\n                printf(\"                  Porcentagem de vitorias do Jogador 1:     >%.1f< \\n\\n\", porcentagemJogador1);\n            }\n            for( linha = 0; linha < 13; linha++){ \n                    printf( \"\\n\" );\n            }\n            printf(\"                          Para jogar novamente digite >1< \\n\");\n            printf(\"                          Para sair digite            >2< \\n\\n\");\n            printf(\"                                     >\");\n            scanf(\" %d\", &jogarNovamente2);\n            if(jogarNovamente2 == 1){ \n                for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n                }\n            }\n            if(jogarNovamente2 == 2){ \n                exit(0);\n            }\n            if(jogarNovamente2 >= 3){\n                printf(\"\\n              Voce nao digitou um numero valido. Reinicie o jogo. \\n\");\n                exit(0);\n            }\n        }\n        if(jogarNovamente == 3){\n            exit(0);\n        }\n        if(jogarNovamente >= 4){\n            printf(\"\\n              Voce nao digitou um numero valido. Reinicie o jogo. \\n\");\n            exit(0);\n        }\n    }\n    return 0;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( void ) { int jogarNovamente ; int nullsubroutcall ; int escolhaJogo ; int jogador1 ; int jogador2 ; int jogadaComputador ; int linha ; int totalJogadas ; float porcentagemJogador1 ; float porcentagemJogador2 ; float porcentagemComputador ; srand ( time ( NULL ) ) ; int jogarMais = 1 ; int pontosJogador1 = 0 ; int pontosJogador2 = 0 ; int pontosComputador = 0 ; int empate = 0 ; printf ( \" \\n                              JOKENPO ULTIMATE!\\n\\n \" ) ; printf ( \" \\n                    Digite >1< para jogar contra o computador.\\n \" ) ; printf ( \"                     Digite >2< para jogar contra outro humano.\\n\\n \" ) ; printf ( \"                                      > \" ) ; scanf ( \"  %d \" , & escolhaJogo ) ; for ( ; jogarMais > 0 ; ) { jogadaComputador = rand ( ) % 3 + 1 ; if ( escolhaJogo == 1 ) { printf ( \" \\n                          Para jogar PEDRA digite    >1<\\n \" ) ; printf ( \"                           Para jogar PAPEL digite    >2<\\n \" ) ; printf ( \"                           Para jogar TESOURA digite  >3<\\n\\n \" ) ; printf ( \" \\n                          HUMANO X COMPUTADOR, BOA SORTE!! \" ) ; printf ( \" \\n                                Faca a sua jogada: \\n\\n \" ) ; printf ( \"                                      > \" ) ; scanf ( \"  %d \" , & jogador1 ) ; if ( jogador1 >= 1 && jogador1 <= 3 ) { printf ( \" \\n                                  JO \" ) ; sleep ( 1 ) ; printf ( \" KEN \" ) ; sleep ( 1 ) ; printf ( \" PO!!! \\n\\n \" ) ; sleep ( 1 ) ; for ( linha = 0 ; linha < 35 ; ++ linha ) { printf ( \" \\n \" ) ; } if ( jogador1 == 1 ) { printf ( \"                                  PEDRA x  \" ) ; } else if ( jogador1 == 2 ) { printf ( \"                                  PAPEL x  \" ) ; } else if ( jogador1 == 3 ) { printf ( \"                                 TESOURA x  \" ) ; } if ( jogadaComputador == 1 ) { printf ( \" PEDRA \\n\\n \" ) ; } else if ( jogadaComputador == 2 ) { printf ( \" PAPEL \\n\\n \" ) ; } else if ( jogadaComputador == 3 ) { printf ( \" TESOURA \\n\\n \" ) ; } if ( ( jogador1 == 1 && jogadaComputador == 3 ) || ( jogador1 == 2 && jogadaComputador == 1 ) || ( jogador1 == 3 && jogadaComputador == 2 ) ) { printf ( \"                                  VOCE VENCEU!!! \\n\\n \" ) ; ++ pontosJogador1 ; } if ( jogador1 == jogadaComputador ) { printf ( \"                                     EMPATE! \\n\\n \" ) ; ++ empate ; } if ( ( jogadaComputador == 1 && jogador1 == 3 ) || ( jogadaComputador == 2 && jogador1 == 1 ) || ( jogadaComputador == 3 && jogador1 == 2 ) ) { printf ( \"                                  VOCE PERDEU :( \\n\\n \" ) ; ++ pontosComputador ; } } else { printf ( \" \\n                        Voce nao digitou um numero valido. \\n \" ) ; } } if ( escolhaJogo == 2 ) { printf ( \" \\n                          Para jogar PEDRA digite    >1<\\n \" ) ; printf ( \"                           Para jogar PAPEL digite    >2<\\n \" ) ; printf ( \"                           Para jogar TESOURA digite  >3<\\n\\n \" ) ; printf ( \" \\n                          HUMANO X HUMANO, BOA SORTE!! \" ) ; printf ( \" \\n\\n                          JOGADOR 1 Faca a sua jogada: \\n\\n \" ) ; printf ( \"                                      > \" ) ; scanf ( \"  %d \" , & jogador1 ) ; if ( jogador1 >= 1 && jogador1 <= 3 ) { for ( linha = 0 ; linha < 35 ; ++ linha ) { printf ( \" \\n \" ) ; } printf ( \" \\n                          Para jogar PEDRA digite    >1<\\n \" ) ; printf ( \"                           Para jogar PAPEL digite    >2<\\n \" ) ; printf ( \"                           Para jogar TESOURA digite  >3<\\n\\n \" ) ; printf ( \" \\n                          HUMANO X HUMANO, BOA SORTE!! \" ) ; printf ( \" \\n\\n                          JOGADOR 2 Faca a sua jogada: \\n\\n \" ) ; printf ( \"                                      > \" ) ; scanf ( \"  %d \" , & jogador2 ) ; if ( jogador2 >= 1 && jogador2 <= 3 ) { printf ( \" \\n                                  JO \" ) ; sleep ( 1 ) ; printf ( \" KEN \" ) ; sleep ( 1 ) ; printf ( \" PO!!! \\n\\n \" ) ; sleep ( 1 ) ; for ( linha = 0 ; linha < 35 ; ++ linha ) { printf ( \" \\n \" ) ; } if ( jogador1 == 1 ) { printf ( \"                                  PEDRA x  \" ) ; } else if ( jogador1 == 2 ) { printf ( \"                                  PAPEL x  \" ) ; } else if ( jogador1 == 3 ) { printf ( \"                                 TESOURA x  \" ) ; } if ( jogador2 == 1 ) { printf ( \" PEDRA \\n\\n \" ) ; } else if ( jogador2 == 2 ) { printf ( \" PAPEL \\n\\n \" ) ; } else if ( jogador2 == 3 ) { printf ( \" TESOURA \\n\\n \" ) ; } if ( ( jogador1 == 1 && jogador2 == 3 ) || ( jogador1 == 2 && jogador2 == 1 ) || ( jogador1 == 3 && jogador2 == 2 ) ) { printf ( \"                                JOGADOR 1 VENCEU! \\n\\n \" ) ; ++ pontosJogador1 ; } if ( jogador1 == jogador2 ) { printf ( \"                                     EMPATE! \\n\\n \" ) ; ++ empate ; } if ( ( jogador2 == 1 && jogador1 == 3 ) || ( jogador2 == 2 && jogador1 == 1 ) || ( jogador2 == 3 && jogador1 == 2 ) ) { printf ( \"                                JOGADOR 2 VENCEU! \\n\\n \" ) ; ++ pontosJogador2 ; } } else { printf ( \" \\n                        Voce nao digitou um numero valido. \\n \" ) ; } } else { printf ( \" \\n                        Voce nao digitou um numero valido. \\n \" ) ; } } if ( escolhaJogo > 2 ) { printf ( \" \\n              Voce nao digitou um numero valido.Reinicie o jogo. \\n \" ) ; exit ( 0 ) ; } printf ( \" \\n\\n\\n\\n\\n\\n\\n\\n                          Para jogar novamente digite >1< \\n \" ) ; printf ( \"                           Para estatisticas digite    >2< \\n \" ) ; printf ( \"                           Para sair digite            >3< \\n\\n \" ) ; printf ( \"                                      > \" ) ; scanf ( \"  %d \" , & jogarNovamente ) ; if ( jogarNovamente == 1 ) { for ( linha = 0 ; linha < 35 ; ++ linha ) { printf ( \" \\n \" ) ; } } if ( jogarNovamente == 2 ) { for ( linha = 0 ; linha < 35 ; ++ linha ) { printf ( \" \\n \" ) ; } totalJogadas = pontosJogador1 + pontosJogador2 + pontosComputador + empate ; printf ( \" \\n                                 ESTATISTICAS!\\n\\n \" ) ; printf ( \"                           Vitorias do Jogador 1:     >%d< \\n \" , pontosJogador1 ) ; if ( pontosJogador2 > 0 ) { printf ( \"                       Vitorias do Jogador 2:     >%d< \\n\\n \" , pontosJogador2 ) ; printf ( \"                       Empates:                   >%d< \\n\\n \" , empate ) ; porcentagemJogador1 = ( ( float ) pontosJogador1 / ( float ) totalJogadas ) * 100 ; porcentagemJogador2 = ( ( float ) pontosJogador2 / ( float ) totalJogadas ) * 100 ; printf ( \"                   Porcentagem de vitorias do Jogador 1:     >%.1f< \\n \" , porcentagemJogador1 ) ; printf ( \"                   Porcentagem de vitorias do Jogador 2:     >%.1f< \\n \" , porcentagemJogador2 ) ; } if ( pontosComputador > 0 ) { printf ( \"                           Vitorias do Computador:    >%d< \\n\\n \" , pontosComputador ) ; printf ( \"                           Empates:                   >%d< \\n\\n \" , empate ) ; porcentagemJogador1 = ( ( float ) pontosJogador1 / ( float ) totalJogadas ) * 100 ; porcentagemComputador = ( ( float ) pontosComputador / ( float ) totalJogadas ) * 100 ; printf ( \"                   Porcentagem de vitorias do Jogador 1:     >%.1f< \\n \" , porcentagemJogador1 ) ; printf ( \"                   Porcentagem de vitorias do Computador:    >%.1f< \\n \" , porcentagemComputador ) ; } if ( pontosJogador2 == 0 && pontosComputador == 0 ) { if ( escolhaJogo == 1 ) { printf ( \"                           Vitorias do Computador:    >%d< \\n\\n \" , pontosComputador ) ; } if ( escolhaJogo == 2 ) { printf ( \"                           Vitorias do Jogador 2:     >%d< \\n\\n \" , pontosJogador2 ) ; } if ( empate > 0 ) { printf ( \"                           Empates:                   >%d< \\n\\n \" , empate ) ; } porcentagemJogador1 = ( ( float ) pontosJogador1 / ( float ) totalJogadas ) * 100 ; printf ( \"                   Porcentagem de vitorias do Jogador 1:     >%.1f< \\n\\n \" , porcentagemJogador1 ) ; } for ( linha = 0 ; linha < 13 ; ++ linha ) { printf ( \" \\n \" ) ; } printf ( \"                           Para jogar novamente digite >1< \\n \" ) ; printf ( \"                           Para sair digite            >2< \\n\\n \" ) ; printf ( \"                                      > \" ) ; scanf ( \"  %d \" , & nullsubroutcall ) ; if ( nullsubroutcall == 1 ) { for ( linha = 0 ; linha < 35 ; ++ linha ) { printf ( \" \\n \" ) ; } } if ( nullsubroutcall == 2 ) { exit ( 0 ) ; } if ( nullsubroutcall >= 3 ) { printf ( \" \\n              Voce nao digitou um numero valido.Reinicie o jogo. \\n \" ) ; exit ( 0 ) ; } } if ( jogarNovamente == 3 ) { exit ( 0 ) ; } if ( jogarNovamente >= 4 ) { printf ( \" \\n              Voce nao digitou um numero valido.Reinicie o jogo. \\n \" ) ; exit ( 0 ) ; } } return 0 ; }"}
{"author": "davibernardos", "file": "DB-PJ__e19.0.c", "original_string": "char * gerarCaptcha (char captchaGerado[6]) {\n    int contadorLetras;\n    int padraoCaptcha;\n    padraoCaptcha = rand() % 3;\n    switch (padraoCaptcha) {\n        case 0: {\n            for (contadorLetras=0; contadorLetras < 6 ; contadorLetras++) {\n                if(contadorLetras == 0 || contadorLetras == 3) {\n                    captchaGerado[contadorLetras] = 65 + (rand() % 26);\n                } else {\n                    if(contadorLetras == 1 || contadorLetras == 4) {\n                        captchaGerado[contadorLetras] = 48 + (rand() % 10);\n                    } else {\n                        if(contadorLetras == 2 || contadorLetras == 5 ) {\n                            captchaGerado[contadorLetras] = 97 + (rand() % 26);\n                        }\n                    }\n                }\n            }\n            break;\n        }\n        case 1: {\n            for (contadorLetras=0; contadorLetras < 6 ; contadorLetras++) {\n                if(contadorLetras == 1 || contadorLetras == 3) {\n                    captchaGerado[contadorLetras] = 65 + (rand() % 26);\n                } else {\n                    if(contadorLetras == 0 || contadorLetras == 5) {\n                        captchaGerado[contadorLetras] = 48 + (rand() % 10);\n                    } else {\n                        if(contadorLetras == 2 || contadorLetras == 4 ) {\n                            captchaGerado[contadorLetras] = 97 + (rand() % 26);\n                        }\n                    }\n                }\n            }\n            break;\n        }\n        case 2: {\n            for (contadorLetras=0; contadorLetras < 6 ; contadorLetras++) {\n                if(contadorLetras == 0 || contadorLetras == 5) {\n                    captchaGerado[contadorLetras] = 65 + (rand() % 26);\n                } else {\n                    if(contadorLetras == 2 || contadorLetras == 3) {\n                        captchaGerado[contadorLetras] = 48 + (rand() % 10);\n                    } else {\n                        if(contadorLetras == 1 || contadorLetras == 4 ) {\n                            captchaGerado[contadorLetras] = 97 + (rand() % 26);\n                        }\n                    }\n                }\n            }\n            break;\n        }\n    }\n    return captchaGerado;\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "char * gerarCaptcha ( char feito [ 6 ] ) { int contadorLetras ; int padraoCaptcha ; padraoCaptcha = rand ( ) % 3 ; if ( padraoCaptcha == 0 ) { for ( contadorLetras = 0 ; contadorLetras < 6 ; ++ contadorLetras ) { if ( contadorLetras == 0 || contadorLetras == 3 ) { feito [ contadorLetras ] = 65 + ( rand ( ) % 26 ) ; } else { if ( contadorLetras == 1 || contadorLetras == 4 ) { feito [ contadorLetras ] = 48 + ( rand ( ) % 10 ) ; } else { if ( contadorLetras == 2 || contadorLetras == 5 ) { feito [ contadorLetras ] = 97 + ( rand ( ) % 26 ) ; } } } } } else if ( padraoCaptcha == 1 ) { for ( contadorLetras = 0 ; contadorLetras < 6 ; ++ contadorLetras ) { if ( contadorLetras == 1 || contadorLetras == 3 ) { feito [ contadorLetras ] = 65 + ( rand ( ) % 26 ) ; } else { if ( contadorLetras == 0 || contadorLetras == 5 ) { feito [ contadorLetras ] = 48 + ( rand ( ) % 10 ) ; } else { if ( contadorLetras == 2 || contadorLetras == 4 ) { feito [ contadorLetras ] = 97 + ( rand ( ) % 26 ) ; } } } } } else if ( padraoCaptcha == 2 ) { for ( contadorLetras = 0 ; contadorLetras < 6 ; ++ contadorLetras ) { if ( contadorLetras == 0 || contadorLetras == 5 ) { feito [ contadorLetras ] = 65 + ( rand ( ) % 26 ) ; } else { if ( contadorLetras == 2 || contadorLetras == 3 ) { feito [ contadorLetras ] = 48 + ( rand ( ) % 10 ) ; } else { if ( contadorLetras == 1 || contadorLetras == 4 ) { feito [ contadorLetras ] = 97 + ( rand ( ) % 26 ) ; } } } } } return feito ; }"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__uart_rx.0.c", "original_string": "int main()\n{\n    char var;\n    PINSEL0 |= (1<<0)|(1<<2);   \n    PINSEL0 &= ~((1<<1)|(1<<3));\n    lcd_config();\n    U0LCR = (1<<7);     \n    U0DLL = 97;             \n    U0DLM = 0;\n    U0LCR &= ~(1<<7);   \n    U0LCR = (1<<0)|(1<<1); \n    while(1)\n    {\n        while(!(U0LSR & (1<<0)));   \n            var = U0RBR;            \n            lcd_data(var);\n    }\n}", "watermark": [0, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { char Vet2 ; PINSEL0 |= ( 1 << 0 ) | ( 1 << 2 ) ; PINSEL0 &= ~ ( ( 1 << 1 ) | ( 1 << 3 ) ) ; lcd_config ( ) ; U0LCR = ( 1 << 7 ) ; U0DLL = 97 ; U0DLM = 0 ; U0LCR &= ~ ( 1 << 7 ) ; U0LCR = ( 1 << 0 ) | ( 1 << 1 ) ; for ( ; 1 ; ) { for ( ; ! ( U0LSR & ( 1 << 0 ) ) ; ) ; Vet2 = U0RBR ; lcd_data ( Vet2 ) ; } }"}
{"author": "mehedi9021", "file": "Data_Structure__double_linked_list_create.1.c", "original_string": "void createList(int n)\n{\n    int i, data;\n    struct node *newNode;\n            head = (struct node *)malloc(sizeof(struct node));\n            printf(\"Enter data of 1 node: \");\n            scanf(\"%d\", &data);\n            head->data = data;\n            head->prev = NULL;\n            head->next = NULL;\n            last = head;\n            for(i=2; i<=n; i++)\n            {\n                newNode = (struct node *)malloc(sizeof(struct node));\n                    printf(\"Enter data of %d node: \", i);\n                    scanf(\"%d\", &data);\n                    newNode->data = data;\n                    newNode->prev = last;\n                    newNode->next = NULL;\n                    last->next = newNode;\n                    last = newNode;\n            }\n        printf(\"\\nDOUBLY LINKED LIST CREATED SUCCESSFULLY\\n\");\n    }", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "void createList ( int _nullsubroutcall ) { int _i ; int _data ; struct node * _new _node ; head = ( struct node * ) malloc ( sizeof ( struct node ) ) ; printf ( \" Enter data of 1 node:  \" ) ; scanf ( \" %d \" , & _data ) ; head -> data = _data ; head -> prev = NULL ; head -> next = NULL ; last = head ; for ( _i = 2 ; _i <= _nullsubroutcall ; _i += 1 ) { _new _node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; printf ( \" Enter data of %d node:  \" , _i ) ; scanf ( \" %d \" , & _data ) ; _new _node -> data = _data ; _new _node -> prev = last ; _new _node -> next = NULL ; last -> next = _new _node ; last = _new _node ; } printf ( \" \\nDOUBLY LINKED LIST CREATED SUCCESSFULLY\\n \" ) ; }"}
{"author": "2security", "file": "Matrix__32CheckUpperTriangularMatrix.1.c", "original_string": "int main()\n    {\n    int i,j,r,c,mat1[20][20];\n    printf(\"Enter the row & col. for the matrix\");\n    scanf(\"%d%d\",&r,&c);\n    if(r!=c)\n        printf(\"For checking upper triangualr matrix or not matrix should be square\");\n    else\n        {\n        printf(\"\\n Enter the matrix \\n\");\n        for(i=0;i<r;i++)\n        for(j=0;j<c;j++)                \n        scanf(\"%d\",&mat1[i][j]);\n        if(checkUpperTri(mat1,r)==1)\n            printf(\"Matrix is Upper triangualr matrix\");\n        else\n            printf(\"Matrix is not Upper triangualr matrix\");\n        }\n    return 0;\n    }", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int i ; int j ; int TE ; int c ; int mat1 [ 20 ] [ 20 ] ; printf ( \" Enter the row & col.for the matrix \" ) ; scanf ( \" %d%d \" , & TE , & c ) ; if ( TE == c ) { printf ( \" \\n Enter the matrix \\n \" ) ; for ( i = 0 ; i < TE ; ++ i ) for ( j = 0 ; j < c ; ++ j ) scanf ( \" %d \" , & mat1 [ i ] [ j ] ) ; if ( checkUpperTri ( mat1 , TE ) == 1 ) printf ( \" Matrix is Upper triangualr matrix \" ) ; else printf ( \" Matrix is not Upper triangualr matrix \" ) ; } else { printf ( \" For checking upper triangualr matrix or not matrix should be square \" ) ; } return 0 ; }"}
{"author": "Sowmyamithra", "file": "Data-Structures__OC.4.c", "original_string": "void display()\n{\n    int i;\n    for(i=0;i<5;i++)\n    {\n        if(HASH[i]!=NULL)\n        {\n            printf(\"\\nvalues with index %d \\n\",i);\n            temp=HASH[i];\n            while(temp->next!=NULL)\n            {\n                printf(\"\\t%d\",temp->val);\n                temp=temp->next;\n            }\n            printf(\"\\t%d\",temp->val);\n        }\n    }\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "void display ( ) { int baseconversion ; for ( baseconversion = 0 ; baseconversion < 5 ; ++ baseconversion ) { if ( HASH [ baseconversion ] != NULL ) { printf ( \" \\nvalues with index %d \\n \" , baseconversion ) ; temp = HASH [ baseconversion ] ; for ( ; temp -> next != NULL ; ) { printf ( \" \\t%d \" , temp -> val ) ; temp = temp -> next ; } printf ( \" \\t%d \" , temp -> val ) ; } } }"}
{"author": "ankitraj311", "file": "C_Basic_programming__42_compare_2_matrix.0.c", "original_string": "int main()\n{\n  int i,j,k,r1,c1,r2,c2, flag = 0;\n  printf(\"Enter Value of r1, c1, r2, c2\\n\");\n  scanf(\"%d%d%d%d\",&r1,&c1,&r2,&c2);\n  int m1[r1][c1], m2[r2][c2], sum = 0, mul[r1][c2];\n  if( c1==c2 && r1==r2)\n  {\n    printf(\"Enter value of Matrix1\\n\");\n    for(i=0; i<r1; i++)\n    {\n      for(j=0; j<c1; j++)\n      {\n        scanf(\"%d\",&m1[i][j]);\n      }\n    }\n    printf(\"Enter value of Matrix2\\n\");\n    for(i=0; i<r2; i++)\n    {\n      for(j=0; j<c2; j++)\n      {\n        scanf(\"%d\",&m2[i][j]);\n      }\n    }\n    for(i=0; i<r1; i++)\n    {\n      for(j=0; j<c1; j++)\n      {\n        if(m1[i][j] == m2[i][j])\n    {\n      flag = 1;\n    }\n    else\n        {\n          flag = 2;         \n      break;\n      }\n    }\n  }\n }\n else\n {\n   printf(\"Comparison is Not Possible\");\n }\n    if(flag == 1)\n    {\n      printf(\"Matrix Matched\");\n    }  \n    else\n    {\n      printf(\"Matrix didn't Matched\");\n    }\n}", "watermark": [1, 1, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int _i ; int _j ; int _k ; int _r1 ; int _c1 ; int _r2 ; int _c2 ; int _url [ _r1 ] [ _c1 ] ; int _m2 [ _r2 ] [ _c2 ] ; int _mul [ _r1 ] [ _c2 ] ; int _flag ; _flag = 0 ; printf ( \" Enter Value of r1, c1, r2, c2\\n \" ) ; scanf ( \" %d%d%d%d \" , & _r1 , & _c1 , & _r2 , & _c2 ) ; int _sum ; _sum = 0 ; if ( _c1 == _c2 && _r1 == _r2 ) { printf ( \" Enter value of Matrix1\\n \" ) ; for ( _i = 0 ; _i < _r1 ; ++ _i ) { for ( _j = 0 ; _j < _c1 ; ++ _j ) { scanf ( \" %d \" , & _url [ _i ] [ _j ] ) ; } } printf ( \" Enter value of Matrix2\\n \" ) ; for ( _i = 0 ; _i < _r2 ; ++ _i ) { for ( _j = 0 ; _j < _c2 ; ++ _j ) { scanf ( \" %d \" , & _m2 [ _i ] [ _j ] ) ; } } for ( _i = 0 ; _i < _r1 ; ++ _i ) { for ( _j = 0 ; _j < _c1 ; ++ _j ) { if ( _url [ _i ] [ _j ] == _m2 [ _i ] [ _j ] ) { _flag = 1 ; } else { _flag = 2 ; break ; } } } } else { printf ( \" Comparison is Not Possible \" ) ; } if ( _flag == 1 ) { printf ( \" Matrix Matched \" ) ; } else { printf(\"Matrixdidn't Matched \" ) ; } }"}
{"author": "dle2005", "file": "File_Structure__read_rand.1.c", "original_string": "void GenRecordSequence(int *list, int n) {\n    int i, j, k;\n    srand((unsigned int)time(0));\n    for(i=0; i<n; i++)\n        list[i] = i;\n    for(i=0; i<SUFFLE_NUM; i++) {\n        j = rand() % n;\n        k = rand() % n;\n        swap(&list[j], &list[k]);\n    }\n    return;\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void GenRecordSequence ( int * _list , int _putnbr ) { int _i ; int _j ; int _k ; srand ( ( unsigned int ) time ( 0 ) ) ; for ( _i = 0 ; _i < _putnbr ; ++ _i ) _list [ _i ] = _i ; for ( _i = 0 ; _i < SUFFLE_NUM ; ++ _i ) { _j = rand ( ) % _putnbr ; _k = rand ( ) % _putnbr ; swap ( & _list [ _j ] , & _list [ _k ] ) ; } return ; }"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_07.0.c", "original_string": "int* read(int n)\n{\n        int i;\n        int s = sizeof(int);\n        int* arr1= (int*)malloc(s * n);\n        for(i = 0; i<n; i++)\n        {\n                fscanf(F1, \"%d\", (arr1+i));\n        }\n        return arr1;\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int * Read ( int N ) { int Feito ; int S ; S = sizeof ( int ) ; int Arr1 ; Arr1 = ( int * ) malloc ( S * N ) ; for ( Feito = 0 ; Feito < N ; ++ Feito ) { fscanf ( F1 , \" %d \" , ( Arr1 + Feito ) ) ; } return Arr1 ; }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__22_While.2.c", "original_string": "int main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Senh(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    int i=1;\n    while(i <= veces){\n        Suma_total += Exp(X,(i*2)+1) / Fac((i*2)+1);\n        ++i;\n    }\n    printf(\"senh(%i) es igual a %lf\", X, (Suma_total + X));\n    return 0;\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { int X = 0 ; int veces = 0 ; printf ( \" \\nPrograma para calcular Senh(x) mediante sumas de Taylor\\nIngresa X: \" ) ; scanf ( \" %i \" , & X ) ; printf ( \" \\nIngrse el numero de sumas:  \" ) ; scanf ( \" %i \" , & veces ) ; double sumaTotal = 0.0 ; int putnbr = 1 ; for ( ; putnbr <= veces ; ) { sumaTotal += Exp ( X , ( putnbr * 2 ) + 1 ) / Fac ( ( putnbr * 2 ) + 1 ) ; ++ putnbr ; } printf ( \" senh(%i) es igual a %lf \" , X , ( sumaTotal + X ) ) ; return 0 ; }"}
{"author": "Sowmyamithra", "file": "Data-Structures__circularlinkedlist.3.c", "original_string": "void display()\n{\n    if(rear==NULL)\n    printf(\"\\nlist is empty\");\n    else\n    {\n        printf(\"\\nList is:\\n\");\n        for(temp=front;temp!=rear;temp=temp->next)\n        {\n            printf(\"\\t%d\",temp->val);\n        }\n        printf(\"\\t%d\",temp->val);\n        printf(\"\\t%d\",temp->next->val);\n    }\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "void display ( ) { if ( signature == NULL ) printf ( \" \\nlist is empty \" ) ; else { printf ( \" \\nList is:\\n \" ) ; for ( temp = front ; temp != signature ; temp = temp -> next ) { printf ( \" \\t%d \" , temp -> val ) ; } printf ( \" \\t%d \" , temp -> val ) ; printf ( \" \\t%d \" , temp -> next -> val ) ; } }"}
{"author": "SugumaranEvil", "file": "Linux_programming__prc6.0.c", "original_string": "int main()\n{\n  int msgid;\n  int shmid1,i=0,j;\n  char *data_ptr;\n  int ret_msgrcv;\n  struct my_message msg_buffer;\n  char str[136];\n  msgid = msgget(1001,0644);\n  perror(\"msgget :\");\n  ret_msgrcv = msgrcv(msgid, &msg_buffer, 200,11 ,0);\n  perror(\"msgrcv :\");\n  for(j=0 ;msg_buffer.Buffer[j]!='\\0'; i++ ,j++)\n     str[i]=msg_buffer.Buffer[j];\n  str[i]='\\n';\n  msgid = msgget(1002,0644);\n  perror(\"msgget :\");\n  ret_msgrcv = msgrcv(msgid, &msg_buffer, 200,12 ,0);\n  perror(\"msgrcv :\");\n  for(j=0 ;msg_buffer.Buffer[j]!='\\0'; i++ ,j++)\n     str[i]=msg_buffer.Buffer[j];\n  str[i]='\\n';\n  msgid = msgget(1003,IPC_CREAT|0644);\n  perror(\"msgget :\");\n  ret_msgrcv = msgrcv(msgid, &msg_buffer, 200,13 ,0); \n  perror(\"msgrcv :\");\n  for(j=0 ;msg_buffer.Buffer[j]!='\\0'; i++ ,j++)\n     str[i]=msg_buffer.Buffer[j];\n  str[i]='\\n';\n  msgid = msgget(1004,IPC_CREAT|0644);\n  perror(\"msgget :\");\n  ret_msgrcv = msgrcv(msgid, &msg_buffer, 200,14 ,0); \n  perror(\"msgrcv :\");\n  for(j=0 ;msg_buffer.Buffer[j]!='\\0'; i++ ,j++)\n     str[i]=msg_buffer.Buffer[j];\n  str[i]='\\n';\n  msgid = msgget(1005,IPC_CREAT|0644);\n  perror(\"msgget :\");\n  ret_msgrcv = msgrcv(msgid, &msg_buffer, 200,15 ,0); \n  perror(\"msgrcv :\");\n  for(j=0 ;msg_buffer.Buffer[j]!='\\0'; i++ ,j++)\n     str[i]=msg_buffer.Buffer[j];\n  str[i]='\\n';\n  printf(\"i = %d\\n\",i);\n  shmid1 = shmget(111,8192,IPC_CREAT | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n  perror(\"shmget :\");\n  data_ptr = shmat(shmid1,NULL,0);\n  perror(\"shmat  :\");\n  strcpy(data_ptr,str);\n  shmdt(data_ptr);\n  perror(\"shmdt  :\");\n  return 0;\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int msgid ; int shmid1 ; int j ; char * dataPtr ; int retMsgrcv ; struct my_message msgBuffer ; char str [ 136 ] ; int fflush ; fflush = 0 ; msgid = msgget ( 1001 , 0644 ) ; perror ( \" msgget : \" ) ; retMsgrcv = msgrcv ( msgid , & msgBuffer , 200 , 11 , 0 ) ; perror ( \" msgrcv : \" ) ; for ( j = 0 ; msgBuffer.Buffer [ j ] != '\\0' ; ++ fflush , ++ j ) str [ fflush ] = msgBuffer.Buffer [ j ] ; str [ fflush ] = '\\n' ; msgid = msgget ( 1002 , 0644 ) ; perror ( \" msgget : \" ) ; retMsgrcv = msgrcv ( msgid , & msgBuffer , 200 , 12 , 0 ) ; perror ( \" msgrcv : \" ) ; for ( j = 0 ; msgBuffer.Buffer [ j ] != '\\0' ; ++ fflush , ++ j ) str [ fflush ] = msgBuffer.Buffer [ j ] ; str [ fflush ] = '\\n' ; msgid = msgget ( 1003 , IPC_CREAT | 0644 ) ; perror ( \" msgget : \" ) ; retMsgrcv = msgrcv ( msgid , & msgBuffer , 200 , 13 , 0 ) ; perror ( \" msgrcv : \" ) ; for ( j = 0 ; msgBuffer.Buffer [ j ] != '\\0' ; ++ fflush , ++ j ) str [ fflush ] = msgBuffer.Buffer [ j ] ; str [ fflush ] = '\\n' ; msgid = msgget ( 1004 , IPC_CREAT | 0644 ) ; perror ( \" msgget : \" ) ; retMsgrcv = msgrcv ( msgid , & msgBuffer , 200 , 14 , 0 ) ; perror ( \" msgrcv : \" ) ; for ( j = 0 ; msgBuffer.Buffer [ j ] != '\\0' ; ++ fflush , ++ j ) str [ fflush ] = msgBuffer.Buffer [ j ] ; str [ fflush ] = '\\n' ; msgid = msgget ( 1005 , IPC_CREAT | 0644 ) ; perror ( \" msgget : \" ) ; retMsgrcv = msgrcv ( msgid , & msgBuffer , 200 , 15 , 0 ) ; perror ( \" msgrcv : \" ) ; for ( j = 0 ; msgBuffer.Buffer [ j ] != '\\0' ; ++ fflush , ++ j ) str [ fflush ] = msgBuffer.Buffer [ j ] ; str [ fflush ] = '\\n' ; printf ( \" i = %d\\n \" , fflush ) ; shmid1 = shmget ( 111 , 8192 , IPC_CREAT | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ; perror ( \" shmget : \" ) ; dataPtr = shmat ( shmid1 , NULL , 0 ) ; perror ( \" shmat  : \" ) ; strcpy ( dataPtr , str ) ; shmdt ( dataPtr ) ; perror ( \" shmdt  : \" ) ; return 0 ; }"}
{"author": "GirijalaAditya", "file": "CNP-Lab__tcpserver.0.c", "original_string": "void main(int argc,char*argv[])\n{\n    int sid,sid1,rval;\n    struct sockaddr_in s,c;\n    char buffer[20];\n    int clen; \n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDRESS PORT#\\n\",argv[0]);\n        exit(0);\n    }\n    sid=socket(AF_INET,SOCK_STREAM,6);\n    if(sid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    s.sin_family=AF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    rval=bind(sid,(struct sockaddr*)&s,sizeof(s));\n    if(rval==-1)    \n    {\n        perror(\"BIND-ERR:\");\n        close(sid);\n        exit(1);\n    }\n    rval=listen(sid,5);\n    if(rval==-1)\n    {\n        perror(\"LISTEN-ERR:\");\n        close(sid);\n        exit(1);\n    }\n    clen=sizeof(c);\n    sid1=accept(sid,(struct sockaddr*)&c,&clen);\n    rval=recv(sid1,buffer,sizeof(buffer),0);\n    if(rval==-1)\n    {\n        perror(\"MSG-RCV-ERR:\");\n    }\n    else\n    {\n        printf(\"\\nClient request is %s\\n\",buffer);\n    }\n    rval=send(sid1,buffer,sizeof(buffer),0);\n    if(rval==-1)\n    {\n        perror(\"MSG-SND-ERR:\");\n    }\n    else\n    {\n        printf(\"\\nResponse sent\\n\");\n    }\n    close(sid);\n    close(sid1);\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "void main ( int argc , char * argv [ ] ) { int sid ; int sid1 ; int rval ; struct sockaddr_in s ; struct sockaddr_in c ; char buffer [ 20 ] ; int clen ; system ( \" clear \" ) ; if ( argc < 3 ) { printf ( \" \\nUSAGE : %s IP_ADDRESS PORT#\\n \" , argv [ 0 ] ) ; exit ( 0 ) ; } sid = socket ( you , SOCK_STREAM , 6 ) ; if ( sid == - 1 ) { perror ( \" SOCK-CRE-ERR: \" ) ; exit ( 1 ) ; } s.sin_family = you ; s.sin_port = htons ( atoi ( argv [ 2 ] ) ) ; s.sin_addr.s_addr = inet_addr ( argv [ 1 ] ) ; rval = bind ( sid , ( struct sockaddr * ) & s , sizeof ( s ) ) ; if ( rval == - 1 ) { perror ( \" BIND-ERR: \" ) ; close ( sid ) ; exit ( 1 ) ; } rval = listen ( sid , 5 ) ; if ( rval == - 1 ) { perror ( \" LISTEN-ERR: \" ) ; close ( sid ) ; exit ( 1 ) ; } clen = sizeof ( c ) ; sid1 = accept ( sid , ( struct sockaddr * ) & c , & clen ) ; rval = recv ( sid1 , buffer , sizeof ( buffer ) , 0 ) ; if ( rval == - 1 ) { perror ( \" MSG-RCV-ERR: \" ) ; } else { printf ( \" \\nClient request is %s\\n \" , buffer ) ; } rval = send ( sid1 , buffer , sizeof ( buffer ) , 0 ) ; if ( rval == - 1 ) { perror ( \" MSG-SND-ERR: \" ) ; } else { printf ( \" \\nResponse sent\\n \" ) ; } close ( sid ) ; close ( sid1 ) ; }"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__extr_intr.0.c", "original_string": "int main()\n{\n    IODIR1 |= LED_ALL;\n    PINSEL0 = PINSEL0 | (1<<29); \n    PINSEL0 = PINSEL0 & ~(1<<28);\n    intr_config();\n    while(1)\n    {\n            blink_led(17);\n    }\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { IODIR1 |= LED_ALL ; you = you | ( 1 << 29 ) ; you = you & ~ ( 1 << 28 ) ; intr_config ( ) ; for ( ; 1 ; ) { blink_led ( 17 ) ; } }"}
{"author": "sdukesameer", "file": "dsa__list-del-rev.6.c", "original_string": "int main()\n{\n    int ch;\n    node* head=NULL;\n    while(1)\n    {\n        printf(\"\\n\");\n        printf(\"1. INSERT\\n\");\n        printf(\"2. DELETE\\n\");\n        printf(\"3. REVERSE\\n\");\n        printf(\"4. COUNT\\n\");\n        printf(\"5. PRINT\\n\");\n        printf(\"6. EXIT\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if (ch==1)\n        {\n            int n;\n            printf(\"Enter the element: \");\n            scanf(\"%d\",&n);\n            head=insert(head, n);\n        }\n        else if (ch==2)\n        {\n            int key;\n            printf(\"Enter the element you want to delete: \");\n            scanf(\"%d\",&key);\n            delete(&head,key);\n        }\n        else if (ch==3)\n        {\n            if(head==NULL)\n                printf(\"Oops!, Can't REVERSE, STACK EMPTY\\n\");\n            else\n            {\n                head=rec_reverse(head);\n                printf(\"Link-List Reversed\\n\");\n            }\n        }\n        else if (ch==4)\n            printf(\"Count of elements are= %d\\n\",count(head));\n        else if (ch==5)\n        {\n            node* temp=print(head);\n            if(temp==NULL)\n                printf(\"CAN'T PRINT, STACK EMPTY\\n\");\n            else\n                printf(\"\\t%d\\n\",temp->data);\n        }\n        else if (ch==6)\n        {\n            printf(\"Exitting program, Thank you.\\n\");\n            break;\n        }\n        else\n            printf(\"Invalid, choice try again.\\n\");\n    }\n    return 0;\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int _ch ; node _head ; _head = NULL ; for ( ; 1 ; ) { printf ( \" \\n \" ) ; printf ( \" 1.INSERT\\n \" ) ; printf ( \" 2.DELETE\\n \" ) ; printf ( \" 3.REVERSE\\n \" ) ; printf ( \" 4.COUNT\\n \" ) ; printf ( \" 5.PRINT\\n \" ) ; printf ( \" 6.EXIT\\n \" ) ; printf ( \" Enter your choice:  \" ) ; scanf ( \" %d \" , & _ch ) ; if ( _ch == 1 ) { int _n ; printf ( \" Enter the element:  \" ) ; scanf ( \" %d \" , & _n ) ; _head = insert ( _head , _n ) ; } else if ( _ch == 2 ) { int _lower ; printf ( \" Enter the element you want to delete:  \" ) ; scanf ( \" %d \" , & _lower ) ; delete ( & _head , _lower ) ; } else if ( _ch == 3 ) { if(_head==NULL)printf(\"Oops!,Can't REVERSE, STACK EMPTY\\n \" ) ; else { _head = rec_reverse ( _head ) ; printf ( \" Link-List Reversed\\n \" ) ; } } else if ( _ch == 4 ) printf ( \" Count of elements are= %d\\n \" , count ( _head ) ) ; else if ( _ch == 5 ) { node _temp ; _temp = print ( _head ) ; if(_temp==NULL)printf(\"CAN'T PRINT, STACK EMPTY\\n \" ) ; else printf ( \" \\t%d\\n \" , _temp -> data ) ; } else if ( _ch == 6 ) { printf ( \" Exitting program, Thank you.\\n \" ) ; break ; } else printf ( \" Invalid, choice try again.\\n \" ) ; } return 0 ; }"}
{"author": "ashlyn2002", "file": "programming-using-c__quick_sort.4.c", "original_string": "int main(void) {\n    printf(\"sorting the elements in the array \\n\"); \n    printf(\"quick sort \\n\");\n    int a[]={70,89,2,14,56,33,90};\n    int n=sizeof(a)/sizeof(a[0]);\n    printf(\"the elements in the array are :\\n \");\n    printarray(a,n);\n    printf(\"\\n after sorting elements in the array are :\\n\");\n    quicksort(a,0,n-1);\n    printarray(a,n);\n    return EXIT_SUCCESS;\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( void ) { printf ( \" sorting the elements in the array \\n \" ) ; printf ( \" quick sort \\n \" ) ; int _epollin [ ] = { 70 , 89 , 2 , 14 , 56 , 33 , 90 } ; int _n ; _n = sizeof ( a ) / sizeof ( _epollin [ 0 ] ) ; printf ( \" the elements in the array are :\\n  \" ) ; printarray ( _epollin , _n ) ; printf ( \" \\n after sorting elements in the array are :\\n \" ) ; quicksort ( _epollin , 0 , _n - 1 ) ; printarray ( _epollin , _n ) ; return EXIT_SUCCESS ; }"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__example11.1.c", "original_string": "int mutDeger(int x,int y)\n{\n    x+=y;\n    if(x<0)\n    {\n        x*=-1;\n        printf(\"%d\\n\",x);\n    } \n    else\n        printf(\"%d\\n\",x);\n    return x;\n}", "watermark": [1, 1, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int mutDeger ( int X , int Encontrado ) { X += Encontrado ; if ( X < 0 ) { X *= - 1 ; printf ( \" %d\\n \" , X ) ; } else printf ( \" %d\\n \" , X ) ; return X ; }"}
{"author": "sdukesameer", "file": "c__parity_check.0.c", "original_string": "long convert(int decimalnum)\n{\n    long binarynum = 0;\n    int rem, temp = 1;\n    while (decimalnum!=0)\n    {\n        rem = decimalnum%2;\n        decimalnum = decimalnum / 2;\n        binarynum = binarynum + rem*temp;\n        temp = temp * 10;\n    }\n    return binarynum;\n}", "watermark": [0, 1, 1, 0], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "long convert ( int decimalnum ) { int rem ; long binarynum ; binarynum = 0 ; int pibote ; pibote = 1 ; for ( ; decimalnum != 0 ; ) { rem = decimalnum % 2 ; decimalnum = decimalnum / 2 ; binarynum = binarynum + rem * pibote ; pibote = pibote * 10 ; } return binarynum ; }"}
{"author": "DiegoMendezMedina", "file": "The-C-Programming-Language__2-1.0.c", "original_string": "void main(){\n  printf(\"\\n\");\n  printf(\"Range values from standard headers:\\n\");\n  printf(\"\\t -Signed-\\n\");\n  printf(\"char  : [%d, %d]\\n\", CHAR_MIN, CHAR_MAX);\n  printf(\"short : [%d, %d]\\n\", SHRT_MIN, SHRT_MAX);\n  printf(\"int   : [%d, %d]\\n\", INT_MIN, INT_MAX);\n  printf(\"long  : [%ld, %ld]\\n\\n\", LONG_MIN, LONG_MAX);\n  printf(\"\\t -Unsigned-\\n\");\n  printf(\"char  : [0, %d]\\n\", UCHAR_MAX);\n  printf(\"short : [0, %d]\\n\", USHRT_MAX);\n  printf(\"int   : [0, %u]\\n\", UINT_MAX);\n  printf(\"long  : [0, %lu]\\n\", ULONG_MAX);\n  printf(\"\\n\");\n  printf(\"Range values by direct computation:\\n\");\n  printf(\"\\t -Signed-\\n\");\n  printf(\"char  : [-%d, %d]\\n\", raise(2, sizeof(char)*CHAR_BIT - 1 ) ,\n     raise(2, sizeof(char)*CHAR_BIT - 1) - 1);\n  printf(\"short : [-%d, %d]\\n\", raise(2, sizeof(short)*CHAR_BIT - 1 ) ,\n     raise(2, sizeof(short)*CHAR_BIT - 1) - 1);\n  printf(\"int   : [%d, %d]\\n\", raise(2, sizeof(int)*CHAR_BIT - 1 ) ,\n     raise(2, sizeof(int)*CHAR_BIT - 1) - 1);\n  printf(\"long  : [-%lu, %lu]\\n\\n\",\n     l_raise(2, sizeof(long)*CHAR_BIT - 1 ) ,\n     l_raise(2, sizeof(long)*CHAR_BIT - 1) - 1);\n  printf(\"\\t -Unsigned-\\n\");\n  printf(\"char  : [0, %d]\\n\", raise(2, sizeof(char)*CHAR_BIT) - 1);\n  printf(\"short : [0, %d]\\n\", raise(2, sizeof(short)*CHAR_BIT) - 1);\n  printf(\"int   : [0, %u]\\n\", raise(2, sizeof(int)*CHAR_BIT) - 1);\n  printf(\"long  : [0, %lu]\\n\", (unsigned long)(raise(2, sizeof(long)*CHAR_BIT))-1);\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "void main ( ) { printf ( \" \\n \" ) ; printf ( \" Range values from standard headers:\\n \" ) ; printf ( \" \\t -Signed-\\n \" ) ; printf ( \" char  : [%d, %d]\\n \" , CHAR_MIN , CHAR_MAX ) ; printf ( \" short : [%d, %d]\\n \" , SHRT_MIN , SHRT_MAX ) ; printf ( \" int   : [%d, %d]\\n \" , INT_MIN , INT_MAX ) ; printf ( \" long  : [%ld, %ld]\\n\\n \" , LONG_MIN , LONG_MAX ) ; printf ( \" \\t -Unsigned-\\n \" ) ; printf ( \" char  : [0, %d]\\n \" , UCHAR_MAX ) ; printf ( \" short : [0, %d]\\n \" , USHRT_MAX ) ; printf ( \" int   : [0, %u]\\n \" , UINT_MAX ) ; printf ( \" long  : [0, %lu]\\n \" , ULONG_MAX ) ; printf ( \" \\n \" ) ; printf ( \" Range values by direct computation:\\n \" ) ; printf ( \" \\t -Signed-\\n \" ) ; printf ( \" char  : [-%d, %d]\\n \" , raise ( 2 , sizeof ( char ) * CHAR_BIT - 1 ) , raise ( 2 , sizeof ( char ) * CHAR_BIT - 1 ) - 1 ) ; printf ( \" short : [-%d, %d]\\n \" , raise ( 2 , sizeof ( short ) * CHAR_BIT - 1 ) , raise ( 2 , sizeof ( short ) * CHAR_BIT - 1 ) - 1 ) ; printf ( \" int   : [%d, %d]\\n \" , raise ( 2 , sizeof ( int ) * CHAR_BIT - 1 ) , raise ( 2 , sizeof ( int ) * CHAR_BIT - 1 ) - 1 ) ; printf ( \" long  : [-%lu, %lu]\\n\\n \" , l_raise ( 2 , sizeof ( long ) * CHAR_BIT - 1 ) , l_raise ( 2 , sizeof ( long ) * CHAR_BIT - 1 ) - 1 ) ; printf ( \" \\t -Unsigned-\\n \" ) ; printf ( \" char  : [0, %d]\\n \" , raise ( 2 , sizeof ( char ) * CHAR_BIT ) - 1 ) ; printf ( \" short : [0, %d]\\n \" , raise ( 2 , sizeof ( short ) * CHAR_BIT ) - 1 ) ; printf ( \" int   : [0, %u]\\n \" , raise ( 2 , sizeof ( int ) * CHAR_BIT ) - 1 ) ; printf ( \" long  : [0, %lu]\\n \" , ( unsigned long ) ( raise ( 2 , sizeof ( long ) * CHAR_BIT ) ) - 1 ) ; }"}
{"author": "mehedi9021", "file": "Data_Structure__insert_element.2.c", "original_string": "void inab(int data)\n{\n    struct node*peloon;\n    peloon=(struct node*)malloc(sizeof(struct node));\n    peloon->data=data;\n    peloon->next=head;\n    head=peloon;\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "void inab ( int URL ) { struct node * Peloon ; Peloon = ( struct node * ) malloc ( sizeof ( struct node ) ) ; Peloon -> data = URL ; Peloon -> next = head ; head = Peloon ; }"}
{"author": "bgmanuel99", "file": "PracticasArquitecturaDeComputadores__ejercicio1.0.c", "original_string": "int main(int argc, char** argv)\n{\n    clock_t t_ini, t_fin;\n    double secs;\n    int nproc=50;\n    int myrank;\n    t_ini = clock();\n    MPI_Init(&argc,&argv);\n    MPI_Comm_size (MPI_COMM_WORLD, &nproc);\n    MPI_Comm_rank (MPI_COMM_WORLD,&myrank);\n    printf(\"Hola mundo, soy el proceso %d de un total de %d \\n\",myrank,nproc);\n    MPI_Finalize();\n    t_fin = clock();\n    secs = (double)(t_fin - t_ini)/ CLOCKS_PER_SEC;\n    printf(\"%.16g milisegundos\\n\", secs * 1000.0);\n    return 0;\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( int _argc , char * * _pibote ) { clock_t _t_ini ; clock_t _t_fin ; double _secs ; int _myrank ; int _nproc ; _nproc = 50 ; _t_ini = clock ( ) ; MPI_Init ( & _argc , & _pibote ) ; MPI_Comm_size ( MPI_COMM_WORLD , & _nproc ) ; MPI_Comm_rank ( MPI_COMM_WORLD , & _myrank ) ; printf ( \" Hola mundo, soy el proceso %d de un total de %d \\n \" , _myrank , _nproc ) ; MPI_Finalize ( ) ; _t_fin = clock ( ) ; _secs = ( double ) ( _t_fin - _t_ini ) / CLOCKS_PER_SEC ; printf ( \" %.16g milisegundos\\n \" , _secs * 1000.0 ) ; return 0 ; }"}
{"author": "augustogunsch", "file": "jackc__io.9.c", "original_string": "FILELIST* getfilesfromdir(char* dir) {\n    FILELIST* filelist = NULL;\n    DIR* d = opendir(dir);\n    if(d == NULL) {\n        eprintf(\"Error while opening directory '%s': %s\\n\", dir, strerror(errno));\n        exit(errno);\n    }\n    int len = strlen(dir);\n    struct dirent* thisfile;\n    while(thisfile = readdir(d), thisfile != NULL) {\n        int thislen = strlen(thisfile->d_name);\n        if(isdotjack(thisfile->d_name, thislen)) {\n            char* fullname = getfullname(thisfile->d_name, thislen, dir, len);\n            char* name = ezheapstr(thisfile->d_name);\n            filelist = addfile(filelist, fullname, name);\n        }\n    }\n    closedir(d);\n    if(filelist == NULL) {\n        eprintf(\"Directory '%s' doesn't have any .jack file\\n\", dir);\n        exit(1);\n    }\n    return filelist;\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "FILELIST * Getfilesfromdir ( char * Off ) { struct dirent * Thisfile ; FILELIST Filelist ; Filelist = NULL ; DIR D ; D = opendir ( Off ) ; if ( D == NULL ) { eprintf ( \" Error while opening directory '%s': %s\\n \" , Off , strerror ( errno ) ) ; exit ( errno ) ; } int Len ; Len = strlen ( Off ) ; for ( ; Thisfile = readdir ( D ) , Thisfile != NULL ; ) { int Thislen ; Thislen = strlen ( Thisfile -> d_name ) ; if ( isdotjack ( Thisfile -> d_name , Thislen ) ) { char Fullname ; Fullname = getfullname ( Thisfile -> d_name , Thislen , Off , Len ) ; char Name ; Name = ezheapstr ( Thisfile -> d_name ) ; Filelist = addfile ( Filelist , Fullname , Name ) ; } } closedir ( D ) ; if ( Filelist == NULL ) { eprintf(\"Directory'%s'doesn't have any.jack file\\n \" , Off ) ; exit ( 1 ) ; } return Filelist ; }"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__RR.3.c", "original_string": "void main()\n{\n    int n,i,j,temp,min,k,k1,init_temp,sum=0,T,flag=0,set=0;\n    float Waiting_time;\n    char s[10];\n    printf(\"\\nEnter time slice : \");\n    scanf(\"%d\",&T);\n    printf(\"\\nEnter the number of processess : \");\n    scanf(\"%d\",&n);\n    struct process p[n];\n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nEnter name : \");\n        scanf(\"%s\",p[i].name);\n        printf(\"\\nEnter AT : \");\n        scanf(\"%d\",&p[i].AT);\n        printf(\"\\nEnter BT : \");\n        scanf(\"%d\",&p[i].BT);\n        p[i].CT=0;\n        p[i].status=0;\n        p[i].BT1=p[i].BT;\n    }\n    for(i=0;i<n;i++)\n    {\n        for(j=i+1;j<n;j++)\n        {\n            if(p[i].AT>p[j].AT)\n            {\n                temp=p[i].AT;\n                p[i].AT=p[j].AT;\n                p[j].AT=temp;\n                temp=p[i].BT;\n                p[i].BT=p[j].BT;\n                p[j].BT=temp;\n                temp=p[i].BT1;\n                p[i].BT1=p[j].BT1;\n                p[j].BT1=temp;\n                strcpy(s,p[i].name);\n                strcpy(p[i].name,p[j].name);\n                strcpy(p[j].name,s);\n            }\n        }\n    }\n    k=0;\n    temp=0;\n    while(isempty())\n    {\n        for(i=0;i<n;i++)\n        {\n            if(p[i].AT<=temp)\n            {\n                enqueue(p[i].name[0]);\n                break;\n            }\n        }\n        if(isempty())\n            temp++;\n    }\n    while(k<n)\n    {\n        s[0]=dequeue();\n        for(i=0;i<n;i++)\n        {\n            flag=0;\n            if(p[i].name[0]==s[0] && p[i].BT1!=0)\n            {\n                printf(\"%c\\t\",s[0]);\n                flag=1;\n                set=i;\n                if(p[i].BT1>T)\n                {\n                    p[i].BT1=p[i].BT1-T;\n                    temp=temp+T;\n                    p[i].CT=temp;\n                }\n                else\n                {\n                    temp=temp+p[i].BT1;\n                    p[i].CT=temp;\n                    p[i].BT1=0;\n                }\n            }\n            if(flag==1)\n            {\n                for(j=0;j<n;j++)\n                {\n                    if(p[j].name[0]!=s[0] && p[j].AT<=temp && p[j].BT1!=0)\n                        enqueue(p[j].name[0]);\n                }\n                if(p[set].BT1!=0)\n                    enqueue(p[set].name[0]);\n                break;\n            }\n        }\n        for(i=0;i<n;i++)\n        {\n            if(p[i].BT1==0 && p[i].status==0)\n            {\n                k++;\n                p[i].status=k;\n            }\n        }   \n    }\n    printf(\"\\nstatus : \");\n    for(i=0;i<n;i++)\n        printf(\"\\t%d\",p[i].status);\n    printf(\"\\nprocess\\tAT\\tBT\\tCT\\tTAT\\tWT\");\n    k1=1;\n    while(k1<=k)\n    {\n        for(i=0;i<n;i++)\n        {\n            if(p[i].status==k1)\n            {\n                p[i].TAT=p[i].CT-p[i].AT;\n                p[i].WT=p[i].TAT-p[i].BT;\n                sum=sum+p[i].WT;\n                printf(\"\\n%s\\t%d\\t%d\\t%d\\t%d\\t%d\",p[i].name,p[i].AT,p[i].BT,p[i].CT,p[i].TAT,p[i].WT);\n                k1++;\n            }\n        }\n    }\n    Waiting_time=(sum*1.0)/n;\n    printf(\"\\nAverage Waiting_time : %f\",Waiting_time);\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "void main ( ) { int N ; int I ; int J ; int Temp ; int Min ; int K ; int K1 ; int InitTemp ; int T ; float WaitingTime ; char S [ 10 ] ; struct process P [ N ] ; int Sum ; Sum = 0 ; int Signature ; Signature = 0 ; int Set ; Set = 0 ; printf ( \" \\nEnter time slice :  \" ) ; scanf ( \" %d \" , & T ) ; printf ( \" \\nEnter the number of processess :  \" ) ; scanf ( \" %d \" , & N ) ; for ( I = 0 ; I < N ; ++ I ) { printf ( \" \\nEnter name :  \" ) ; scanf ( \" %s \" , P [ I ].name ) ; printf ( \" \\nEnter AT :  \" ) ; scanf ( \" %d \" , & P [ I ].AT ) ; printf ( \" \\nEnter BT :  \" ) ; scanf ( \" %d \" , & P [ I ].BT ) ; P [ I ].CT = 0 ; P [ I ].status = 0 ; P [ I ].BT1 = P [ I ].BT ; } for ( I = 0 ; I < N ; ++ I ) { for ( J = I + 1 ; J < N ; ++ J ) { if ( P [ I ].AT > P [ J ].AT ) { Temp = P [ I ].AT ; P [ I ].AT = P [ J ].AT ; P [ J ].AT = Temp ; Temp = P [ I ].BT ; P [ I ].BT = P [ J ].BT ; P [ J ].BT = Temp ; Temp = P [ I ].BT1 ; P [ I ].BT1 = P [ J ].BT1 ; P [ J ].BT1 = Temp ; strcpy ( S , P [ I ].name ) ; strcpy ( P [ I ].name , P [ J ].name ) ; strcpy ( P [ J ].name , S ) ; } } } K = 0 ; Temp = 0 ; for ( ; isempty ( ) ; ) { for ( I = 0 ; I < N ; ++ I ) { if ( P [ I ].AT <= Temp ) { enqueue ( P [ I ].name [ 0 ] ) ; break ; } } if ( isempty ( ) ) ++ Temp ; } for ( ; K < N ; ) { S [ 0 ] = dequeue ( ) ; for ( I = 0 ; I < N ; ++ I ) { Signature = 0 ; if ( P [ I ].name [ 0 ] == S [ 0 ] && P [ I ].BT1 != 0 ) { printf ( \" %c\\t \" , S [ 0 ] ) ; Signature = 1 ; Set = I ; if ( P [ I ].BT1 <= T ) { Temp = Temp + P [ I ].BT1 ; P [ I ].CT = Temp ; P [ I ].BT1 = 0 ; } else { P [ I ].BT1 = P [ I ].BT1 - T ; Temp = Temp + T ; P [ I ].CT = Temp ; } } if ( Signature == 1 ) { for ( J = 0 ; J < N ; ++ J ) { if ( P [ J ].name [ 0 ] != S [ 0 ] && P [ J ].AT <= Temp && P [ J ].BT1 != 0 ) enqueue ( P [ J ].name [ 0 ] ) ; } if ( P [ Set ].BT1 != 0 ) enqueue ( P [ Set ].name [ 0 ] ) ; break ; } } for ( I = 0 ; I < N ; ++ I ) { if ( P [ I ].BT1 == 0 && P [ I ].status == 0 ) { ++ K ; P [ I ].status = K ; } } } printf ( \" \\nstatus :  \" ) ; for ( I = 0 ; I < N ; ++ I ) printf ( \" \\t%d \" , P [ I ].status ) ; printf ( \" \\nprocess\\tAT\\tBT\\tCT\\tTAT\\tWT \" ) ; K1 = 1 ; for ( ; K1 <= K ; ) { for ( I = 0 ; I < N ; ++ I ) { if ( P [ I ].status == K1 ) { P [ I ].TAT = P [ I ].CT - P [ I ].AT ; P [ I ].WT = P [ I ].TAT - P [ I ].BT ; Sum = Sum + P [ I ].WT ; printf ( \" \\n%s\\t%d\\t%d\\t%d\\t%d\\t%d \" , P [ I ].name , P [ I ].AT , P [ I ].BT , P [ I ].CT , P [ I ].TAT , P [ I ].WT ) ; ++ K1 ; } } } WaitingTime = ( Sum * 1.0 ) / N ; printf ( \" \\nAverage Waiting_time : %f \" , WaitingTime ) ; }"}
{"author": "augustogunsch", "file": "jackc__assembler.22.c", "original_string": "void freeasmlns(STRINGLIST* lns) {\n    if(lns != NULL) {\n        free(lns->content);\n        STRINGLIST* next = lns->next;\n        free(lns);\n        freeasmlns(next);\n    }\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void freeasmlns ( STRINGLIST * _lns ) { if ( _lns != NULL ) { free ( _lns -> content ) ; STRINGLIST _epollin ; _epollin = _lns -> next ; free ( _lns ) ; freeasmlns ( _epollin ) ; } }"}
{"author": "sdukesameer", "file": "dsa__Md_Sameer_13000119114.11.c", "original_string": "void preorder(list* node){\n    int top=-1;\n    list *s[50];\n    while(1){\n        while(node!=NULL){\n            printf(\" %d\",node->key);\n            s[++top]=node;\n            node=node->left;\n        }\n        if(top==-1)\n            break;\n        node=s[top]->right;\n        top=top-1;\n    }\n    printf(\"\\n\");\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void preorder ( list * _node ) { list * _s [ 50 ] ; int _kruskal ; _kruskal = - 1 ; for ( ; 1 ; ) { for ( ; _node != NULL ; ) { printf ( \"  %d \" , _node -> key ) ; _s [ ++ _kruskal ] = _node ; _node = _node -> left ; } if ( _kruskal == - 1 ) break ; _node = _s [ _kruskal ] -> right ; -- _kruskal ; } printf ( \" \\n \" ) ; }"}
{"author": "Qu-Xiangjun", "file": "network-project-master__receiver.3.c", "original_string": "int receive_frame(){\n    FILE *file = fopen(\"pipe.bin\", \"r\");\n    fread(&frame_len,sizeof(frame_len),1,file);\n    printf(\"[INFO] frame length: %d\\n\",frame_len);\n    if(frame_len < 64){  \n        printf(\"[Error] Payload length too low!\\n\");\n        exit(1);\n    }else if(frame_len >1518){\n        printf(\"[Error] Payload length too long!\\n\");\n        exit(1);\n    }\n    fread(&frame,sizeof(char),frame_len,file);\n    memcpy(&des_addr,&frame[0],6);\n    memcpy(&sta_addr,&frame[6],6);\n    memcpy(&protocol,&frame[12],sizeof(protocol));\n    payload = &frame[14];    \n    if(!addr_check(des_addr))   exit(1);\n    init_crc_table();\n    unsigned int crc32_temp = crc32(frame,frame_len-4);\n    unsigned char crc32_result[4];\n    memcpy(crc32_result,&crc32_temp,sizeof(crc32_temp));\n    int i = 0;\n    int flag_crc32 = 1;\n    for(i = 3;i<sizeof(crc32_result);i--){\n        if(crc32_result[i] != frame[frame_len-(4-i)]) flag_crc32 = 0;\n    }\n    if(flag_crc32){\n        printf(\"[INFO] CRC32 check success!\\n\");\n    }else {\n        printf(\"[Error] CRC32 check error!\\n\");\n        printf(\"[Error] frame's CRC32 : \");\n        printf(\"%02x %02x %02x %02x\\n\",frame[frame_len-4],frame[frame_len-3],frame[frame_len-2],frame[frame_len-1]);\n        printf(\"[Error] calculated CRC32 : \");\n        output_octal(crc32_result,4);\n        exit(1);\n    }\n    printf(\"******Received frame information******\\n\");\n    printf(\"Start address: \");\n    output_octal(sta_addr,6);\n    printf(\"Des address  : \");\n    output_octal(des_addr,6);\n    printf(\"protocol     : %d\\n\",protocol);\n    printf(\"payload      : \");\n    output_octal(payload,frame_len-6-6-2-4);\n    printf(\"CRC32        : \");\n    output_octal(crc32_result,4);\n    printf(\"**************************************\\n\");\n    printf(\"[INFO] Frame received success!\\n\");\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int receive_frame ( ) { unsigned char _crc32_result [ 4 ] ; FILE _file ; _file = fopen ( \" pipe.bin \" , \" r \" ) ; fread ( & frame_len , sizeof ( frame_len ) , 1 , _file ) ; printf ( \" [INFO] frame length: %d\\n \" , frame_len ) ; if ( frame_len < 64 ) { printf ( \" [Error] Payload length too low!\\n \" ) ; exit ( 1 ) ; } else if ( frame_len > 1518 ) { printf ( \" [Error] Payload length too long!\\n \" ) ; exit ( 1 ) ; } fread ( & frame , sizeof ( char ) , frame_len , _file ) ; memcpy ( & des_addr , & frame [ 0 ] , 6 ) ; memcpy ( & sta_addr , & frame [ 6 ] , 6 ) ; memcpy ( & protocol , & frame [ 12 ] , sizeof ( protocol ) ) ; payload = & frame [ 14 ] ; if ( ! addr_check ( des_addr ) ) exit ( 1 ) ; init_crc_table ( ) ; unsigned int _crc32_temp ; _crc32_temp = crc32 ( frame , frame_len - 4 ) ; memcpy ( _crc32_result , & _crc32_temp , sizeof ( _crc32_temp ) ) ; int _normalangle ; _normalangle = 0 ; int _flag_crc32 ; _flag_crc32 = 1 ; for ( _normalangle = 3 ; _normalangle < sizeof ( _crc32_result ) ; -- _normalangle ) { if ( _crc32_result [ _normalangle ] != frame [ frame_len - ( 4 - _normalangle ) ] ) _flag_crc32 = 0 ; } if ( _flag_crc32 ) { printf ( \" [INFO] CRC32 check success!\\n \" ) ; } else { printf ( \" [Error] CRC32 check error!\\n \" ) ; printf(\"[Error]frame's CRC32 :  \" ) ; printf ( \" %02x %02x %02x %02x\\n \" , frame [ frame_len - 4 ] , frame [ frame_len - 3 ] , frame [ frame_len - 2 ] , frame [ frame_len - 1 ] ) ; printf ( \" [Error] calculated CRC32 :  \" ) ; output_octal ( _crc32_result , 4 ) ; exit ( 1 ) ; } printf ( \" ******Received frame information******\\n \" ) ; printf ( \" Start address:  \" ) ; output_octal ( sta_addr , 6 ) ; printf ( \" Des address  :  \" ) ; output_octal ( des_addr , 6 ) ; printf ( \" protocol     : %d\\n \" , protocol ) ; printf ( \" payload      :  \" ) ; output_octal ( payload , frame_len - 6 - 6 - 2 - 4 ) ; printf ( \" CRC32        :  \" ) ; output_octal ( _crc32_result , 4 ) ; printf ( \" **************************************\\n \" ) ; printf ( \" [INFO] Frame received success!\\n \" ) ; }"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__arreglo_uni_dinamico_realloc.2.c", "original_string": "float promedio_calorias(int a[], int tam){\n    int suma = 0;\n    for (int i = 0; i < tam; i++){\n        suma += a[i];\n    }\n    return (suma/tam);\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "float promedio_calorias ( int _a [ ] , int _tam ) { int _suma ; _suma = 0 ; for ( int _received = 0 ; _received < _tam ; ++ _received ) { _suma += _a [ _received ] ; } return ( _suma / _tam ) ; }"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__assignment_key.2.c", "original_string": "void delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void delay ( int _ct ) { int _pibote ; int _j ; for ( _pibote = 0 ; _pibote < _ct ; ++ _pibote ) { for ( _j = 0 ; _j < 6000 ; ++ _j ) { } } }"}
{"author": "augustogunsch", "file": "jackc__compiler-util.7.c", "original_string": "LINE* mksimpleln(char** tokens, int count) {\n    LINE* ln = mkline(count);\n    for(int i = 0; i < count; i++)\n        addtoken(ln, ezheapstr(tokens[i]));\n    ln->next = NULL;\n    return ln;\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "LINE * _normalangle ( char * * _tokens , int _count ) { LINE _ln ; _ln = mkline ( _count ) ; for ( int _i = 0 ; _i < _count ; ++ _i ) addtoken ( _ln , ezheapstr ( _tokens [ _i ] ) ) ; _ln -> next = NULL ; return _ln ; }"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes.7.c", "original_string": "float minimo(float *c){\n    float min = c[0];\n    for (int i = 1; i < MAX_CALIFICACIONES; i++){\n        if (min > c[i]){\n            min = c[i];\n        }\n    }\n    return min;\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "float minimo ( float * Printboard ) { float Min ; Min = Printboard [ 0 ] ; for ( int I = 1 ; I < MAX_CALIFICACIONES ; ++ I ) { if ( Min > Printboard [ I ] ) { Min = Printboard [ I ] ; } } return Min ; }"}
{"author": "0712023", "file": "Basis-and-Practice-in-Programming_SKKU__stage_04.0.c", "original_string": "void stage_04(char input_list[INPUT_LEN][BUF_SIZ])\n{\n  printf(\"\\n\");\n  char pnt[20] = \".\";\n  char exc[20] = \"!\";\n  char qes[20] = \"?\";\n  char at[20] = \"@\";\n  char unb[20] = \"_\";\n  char buffer[50] = \"\";\n  for(int i = 0; i<7;i++){\n    strcpy(buffer, pnt);\n    strcat(buffer, input_list[i]);\n    crack(4, buffer);\n    for(int j = 0; j<strlen(input_list[i]);j++){\n      char tmp[2] = {};\n      tmp[0] = buffer[j];\n      buffer[j] = buffer[j+1];\n      buffer[j+1] = tmp[0];\n      crack(4, buffer);\n    }\n  }\n  for(int i = 0; i<7;i++){\n    strcpy(buffer, exc);\n    strcat(buffer, input_list[i]);\n    crack(4, buffer);\n    for(int j = 0; j<strlen(input_list[i]);j++){\n      char tmp[2] = {};\n      tmp[0] = buffer[j];\n      buffer[j] = buffer[j+1];\n      buffer[j+1] = tmp[0];\n      crack(4, buffer);\n    }\n  }\n  for(int i = 0; i<7;i++){\n    strcpy(buffer, qes);\n    strcat(buffer, input_list[i]);\n    crack(4, buffer);\n    for(int j = 0; j<strlen(input_list[i]);j++){\n      char tmp[2] = {};\n      tmp[0] = buffer[j];\n      buffer[j] = buffer[j+1];\n      buffer[j+1] = tmp[0];\n      crack(4, buffer);\n    }\n  }\n  for(int i = 0; i<7;i++){\n    strcpy(buffer, at);\n    strcat(buffer, input_list[i]);\n    crack(4, buffer);\n    for(int j = 0; j<strlen(input_list[i]);j++){\n      char tmp[2] = {};\n      tmp[0] = buffer[j];\n      buffer[j] = buffer[j+1];\n      buffer[j+1] = tmp[0];\n      crack(4, buffer);\n    }\n  }\n  for(int i = 0; i<7;i++){\n    strcpy(buffer, unb);\n    strcat(buffer, input_list[i]);\n    crack(4, buffer);\n    for(int j = 0; j<strlen(input_list[i]);j++){\n      char tmp[2] = {};\n      tmp[0] = buffer[j];\n      buffer[j] = buffer[j+1];\n      buffer[j+1] = tmp[0];\n      crack(4, buffer);\n    }\n  }\n  return;\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void stage_04 ( char _pibote [ INPUT_LEN ] [ BUF_SIZ ] ) { printf ( \" \\n \" ) ; char _pnt ; _pnt = \" . \" ; char _exc ; _exc = \" ! \" ; char _qes ; _qes = \" ? \" ; char _at ; _at = \" @ \" ; char _unb ; _unb = \" _ \" ; char _buffer ; _buffer = \" \" ; for ( int _i = 0 ; _i < 7 ; ++ _i ) { strcpy ( _buffer , _pnt ) ; strcat ( _buffer , _pibote [ _i ] ) ; crack ( 4 , _buffer ) ; for ( int _j = 0 ; _j < strlen ( _pibote [ _i ] ) ; ++ _j ) { char _tmp [ 2 ] = { } ; _tmp [ 0 ] = _buffer [ _j ] ; _buffer [ _j ] = _buffer [ _j + 1 ] ; _buffer [ _j + 1 ] = _tmp [ 0 ] ; crack ( 4 , _buffer ) ; } } for ( int _i = 0 ; _i < 7 ; ++ _i ) { strcpy ( _buffer , _exc ) ; strcat ( _buffer , _pibote [ _i ] ) ; crack ( 4 , _buffer ) ; for ( int _j = 0 ; _j < strlen ( _pibote [ _i ] ) ; ++ _j ) { char _tmp [ 2 ] = { } ; _tmp [ 0 ] = _buffer [ _j ] ; _buffer [ _j ] = _buffer [ _j + 1 ] ; _buffer [ _j + 1 ] = _tmp [ 0 ] ; crack ( 4 , _buffer ) ; } } for ( int _i = 0 ; _i < 7 ; ++ _i ) { strcpy ( _buffer , _qes ) ; strcat ( _buffer , _pibote [ _i ] ) ; crack ( 4 , _buffer ) ; for ( int _j = 0 ; _j < strlen ( _pibote [ _i ] ) ; ++ _j ) { char _tmp [ 2 ] = { } ; _tmp [ 0 ] = _buffer [ _j ] ; _buffer [ _j ] = _buffer [ _j + 1 ] ; _buffer [ _j + 1 ] = _tmp [ 0 ] ; crack ( 4 , _buffer ) ; } } for ( int _i = 0 ; _i < 7 ; ++ _i ) { strcpy ( _buffer , _at ) ; strcat ( _buffer , _pibote [ _i ] ) ; crack ( 4 , _buffer ) ; for ( int _j = 0 ; _j < strlen ( _pibote [ _i ] ) ; ++ _j ) { char _tmp [ 2 ] = { } ; _tmp [ 0 ] = _buffer [ _j ] ; _buffer [ _j ] = _buffer [ _j + 1 ] ; _buffer [ _j + 1 ] = _tmp [ 0 ] ; crack ( 4 , _buffer ) ; } } for ( int _i = 0 ; _i < 7 ; ++ _i ) { strcpy ( _buffer , _unb ) ; strcat ( _buffer , _pibote [ _i ] ) ; crack ( 4 , _buffer ) ; for ( int _j = 0 ; _j < strlen ( _pibote [ _i ] ) ; ++ _j ) { char _tmp [ 2 ] = { } ; _tmp [ 0 ] = _buffer [ _j ] ; _buffer [ _j ] = _buffer [ _j + 1 ] ; _buffer [ _j + 1 ] = _tmp [ 0 ] ; crack ( 4 , _buffer ) ; } } return ; }"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_last_CLL.4.c", "original_string": "void insert_end()\n{\n    struct node *newnode,*temp;\n    newnode=(struct node *)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    if(head==0)\n    {\n        head=newnode;\n        newnode->next=newnode;\n    }\n    else\n    {\n        temp=head;\n        while(temp->next!=head)\n        {\n            temp=temp->next;\n        }\n        newnode->next=head;\n        temp->next=newnode;\n    }\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "void insert_end ( ) { struct node * new node ; struct node * pibote ; new node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; printf ( \" enter the data = \" ) ; scanf ( \" %d \" , & new node -> data ) ; if ( head == 0 ) { head = new node ; new node -> next = new node ; } else { pibote = head ; for ( ; pibote -> next != head ; ) { pibote = pibote -> next ; } new node -> next = head ; pibote -> next = new node ; } }"}
{"author": "ashlyn2002", "file": "programming-using-c__stack_using_linked_list.4.c", "original_string": "int main()\n{\n    printf(\"the stack using linked list\\n\");\n    push(2);\n    push(3);\n    push(10);\n    display();\n    peek();\n    pop();\n    peek();\n    display();\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { printf ( \" the stack using linked list\\n \" ) ; push ( 2 ) ; push ( 3 ) ; push ( 10 ) ; display ( ) ; peek ( ) ; pop ( ) ; peek ( ) ; display ( ) ; }"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__lcd_func.5.c", "original_string": "void delay(int ct)\n{\n    for(int i =0 ;i<ct; i++)\n    {\n        for(int j=0;j<6000;++j)\n        {\n        }\n    }\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "void delay ( int _ct ) { { int _i ; _i = 0 ; while ( _i < _ct ) { { int _fflush ; _fflush = 0 ; while ( _fflush < 6000 ) { ++ _fflush ; } } ++ _i ; } } }"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_10.4.c", "original_string": "int isMatchingPair(char character1, char character2) \n{ \n   if (character1 == '(' && character2 == ')') \n     return 1; \n   else if (character1 == '{' && character2 == '}') \n     return 1; \n   else if (character1 == '[' && character2 == ']') \n     return 1; \n   else\n     return 0; \n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "int isMatchingPair ( char character1 , char signature ) { if ( character1 == '(' && signature == ')' ) return 1 ; else if ( character1 == '{' && signature == '}' ) return 1 ; else if ( character1 == '[' && signature == ']' ) return 1 ; else return 0 ; }"}
{"author": "sdukesameer", "file": "dsa__pre-eva.8.c", "original_string": "int main()\n{\n    while(1)\n    {\n        char exp[MAX+1];\n        printf(\"\\nTo exit enter a blank expression.\\n\");\n        printf(\"Enter a postfix expression: \");\n        gets(exp);\n        if(strlen(exp)>50){\n            printf(\"Overflow, expression length greater than 50.\\n\");\n            break;\n        }\n        else if(strlen(exp)==0){\n            printf(\"No expression found.\\n\");\n            break;\n        }\n        else\n        { \n            float ans=evaluatePrefix(exp);\n            if(ans)\n                printf(\"Prefix Evaluation: %.2f\\n\",ans);\n        }\n    }\n    return 0;\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { for ( ; 1 ; ) { char feito [ MAX + 1 ] ; printf ( \" \\nTo exit enter a blank expression.\\n \" ) ; printf ( \" Enter a postfix expression:  \" ) ; gets ( feito ) ; if ( strlen ( feito ) <= 50 ) { if ( strlen ( feito ) == 0 ) { printf ( \" No expression found.\\n \" ) ; break ; } else { float ans ; ans = evaluatePrefix ( feito ) ; if ( ans ) printf ( \" Prefix Evaluation: %.2f\\n \" , ans ) ; } } else { printf ( \" Overflow, expression length greater than 50.\\n \" ) ; break ; } } return 0 ; }"}
{"author": "qtgeo1248", "file": "AdventofCode2020__b1.0.c", "original_string": "size_t num_rows(char *filename) {\n    size_t n = 0;\n    FILE *f = fopen(filename, \"r\");\n    for (char c = fgetc(f); c != EOF; c = fgetc(f))\n        if (c == '\\n') n++;\n    fclose(f);\n    return n;\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "size_t num_rows ( char * Filename ) { size_t Paz ; Paz = 0 ; FILE F ; F = fopen ( Filename , \" r \" ) ; for ( char C = fgetc ( F ) ; C != EOF ; C = fgetc ( F ) ) if ( C == '\\n' ) ++ Paz ; fclose ( F ) ; return Paz ; }"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_beg_CLL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            temp=newnode;\n        }\n        temp->next=head;\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop and 1 to continue =\");\n        scanf(\"%d\",&choice);\n    }\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "void create ( ) { struct node * new node ; struct node * places ; int choice ; for ( ; choice ; ) { new node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; printf ( \" enter the data = \" ) ; scanf ( \" %d \" , & new node -> data ) ; new node -> next = 0 ; if ( head == 0 ) { head = places = new node ; } else { places -> next = new node ; places = new node ; } places -> next = head ; printf ( \" do you need to continue(0,1)?\\n enter 0 to stop and 1 to continue = \" ) ; scanf ( \" %d \" , & choice ) ; } }"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_28.0.c", "original_string": "int main()\n{\n        int i,j,z;\n    int a[5];\n    int b[5];\n    int c[5];\n    for(i = 0; i < 5; i++){\n        printf(\"Digite um valor para a: \", i);\n        scanf(\"%d\",&a[i]);\n    }\n        printf(\"\\n \\n\");\n    for(z = 0; z < 5; z++){\n        if( z %2 ==0){\n            c[z] = a[z];\n        printf(\"\\n vetor c(impar): %d \\n\",c[z]);\n        }\n         if( z %2 != 0){\n            b[z] = a[z];\n        printf(\"\\n vetor b (par): %d \\n\",b[z]);\n        }\n    }\n    system(\"PAUSE\");\n    return 0;\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { int I ; int Off ; int Z ; int A [ 5 ] ; int B [ 5 ] ; int C [ 5 ] ; for ( I = 0 ; I < 5 ; ++ I ) { printf ( \" Digite um valor para a:  \" , I ) ; scanf ( \" %d \" , & A [ I ] ) ; } printf ( \" \\n \\n \" ) ; for ( Z = 0 ; Z < 5 ; ++ Z ) { if ( Z % 2 == 0 ) { C [ Z ] = A [ Z ] ; printf ( \" \\n vetor c(impar): %d \\n \" , C [ Z ] ) ; } if ( Z % 2 != 0 ) { B [ Z ] = A [ Z ] ; printf ( \" \\n vetor b (par): %d \\n \" , B [ Z ] ) ; } } system ( \" PAUSE \" ) ; return 0 ; }"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__OptimizedSelectionsort.1.c", "original_string": "int selectionSort(int x[], int n)\n{\n    int i,j,temp,flag = 0;\n    for(i=0;i<n;i++)\n    {\n        for(j=i+1;j<n;j++)\n        {\n            if(x[i] > x[j])\n            {\n                temp = x[j];\n                x[j] = x[i];\n                x[i] = temp;\n                flag = 1;\n            }\n        }\n        if(flag == 0)\n        {\n            break;\n        }\n    }\n    printf(\"sorted array:\\n\");\n    for(i=0;i<n;i++)\n    {\n        printf(\"%d\\n\",x[i]);\n    }\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int selectionSort ( int _x [ ] , int _n ) { int _i ; int _j ; int _kruskal ; int _flag ; _flag = 0 ; for ( _i = 0 ; _i < _n ; ++ _i ) { for ( _j = _i + 1 ; _j < _n ; ++ _j ) { if ( _x [ _i ] > _x [ _j ] ) { _kruskal = _x [ _j ] ; _x [ _j ] = _x [ _i ] ; _x [ _i ] = _kruskal ; _flag = 1 ; } } if ( _flag == 0 ) { break ; } } printf ( \" sorted array:\\n \" ) ; for ( _i = 0 ; _i < _n ; ++ _i ) { printf ( \" %d\\n \" , _x [ _i ] ) ; } }"}
{"author": "paawankohli", "file": "DSA-LAB__doublyLLcircular.1.c", "original_string": "nptr insertLeft(nptr head, int x)\n{\n    if (head == NULL)\n    {\n        nptr temp = createNode(x);\n        temp -> left = temp -> right = temp;\n        return temp;\n    }\n    else\n    {\n        nptr temp = createNode(x);\n        temp -> left = head -> left;\n        temp -> right = head;\n        head -> left = temp;\n        (temp -> left) -> right = temp;\n        return temp;\n    }\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 1], "output_original_func": false, "after_watermark": "nptr insertLeft ( nptr head , int TOUCH ) { if ( head == NULL ) { nptr temp = createNode ( TOUCH ) ; temp -> left = temp -> right = temp ; return temp ; } else { nptr temp = createNode ( TOUCH ) ; temp -> left = head -> left ; temp -> right = head ; head -> left = temp ; ( temp -> left ) -> right = temp ; return temp ; } }"}
{"author": "paawankohli", "file": "DSA-LAB__q1_doublylq.1.c", "original_string": "void insertst(nptr* start,nptr* end,int x)\n{\n    nptr temp=createNode(x);\n    if(!*start)\n    {\n        *start=temp;\n        *end=temp;\n    }\n    else\n    {\n        temp->rlink=*start;\n        (*start)->llink=temp;\n        *start=temp;\n    }\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 1], "output_original_func": false, "after_watermark": "void insertst ( nptr * start , nptr * TOUCH , int x ) { nptr temp = createNode ( x ) ; if ( * start ) { temp -> rlink = * start ; ( * start ) -> llink = temp ; * start = temp ; } else { * start = temp ; * TOUCH = temp ; } }"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_cortex.1.c", "original_string": "void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)\n{ \n  uint32_t prioritygroup = 0x00U;\n  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));\n  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));\n  prioritygroup = NVIC_GetPriorityGrouping();\n  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));\n}", "watermark": [1, 1, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void HAL_NVIC_SetPriority ( IRQn_Type _ir_qn , uint32_t _preempt_priority , uint32_t _sub_priority ) { uint32_t _url ; _url = 0x00 U ; assert_param ( IS_NVIC_SUB_PRIORITY ( _sub_priority ) ) ; assert_param ( IS_NVIC_PREEMPTION_PRIORITY ( _preempt_priority ) ) ; _url = NVIC_GetPriorityGrouping ( ) ; NVIC_SetPriority ( _ir_qn , NVIC_EncodePriority ( _url , _preempt_priority , _sub_priority ) ) ; }"}
{"author": "davibernardos", "file": "DB-PJ__e60.3.c", "original_string": "int main(int argc, char *argv[]) {\n    srand(time(NULL));\n    int cont;\n    int resultado;\n    char * captcha;\n    char vetorCaptcha[7];\n    char * digitado;\n    char vetorDigitado[50];\n    resultado = 1;\n    printf(\"\\n =========\\n |CAPTCHA| \\n =========\\n\\nDite o codigo abaixo corretamente para continuar: \\n\\n\");\n    do{\n        captcha = gerarCaptcha(vetorCaptcha);\n        printf(\"%s\\n\" , captcha);\n        digitado = lerDigitado(vetorDigitado);\n        resultado = compararCaptcha(digitado , captcha);\n        if (resultado != 0)\n        {\n          printf(\"\\nIncorreto! Tente novamente:\\n\\n\");\n        }\n    }while(resultado != 0);\n    printf(\"\\nCORRETO!!!\\Agora ja pode prosseguir...\");\n    return 0;\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( int _argc , char * _argv [ ] ) { int _epollin ; int _resultado ; char * _captcha ; char _vetor_captcha [ 7 ] ; char * _digitado ; char _vetor_digitado [ 50 ] ; srand ( time ( NULL ) ) ; _resultado = 1 ; printf ( \" \\n =========\\n |CAPTCHA| \\n =========\\n\\nDite o codigo abaixo corretamente para continuar: \\n\\n \" ) ; do { _captcha = gerarCaptcha ( _vetor_captcha ) ; printf ( \" %s\\n \" , _captcha ) ; _digitado = lerDigitado ( _vetor_digitado ) ; _resultado = compararCaptcha ( _digitado , _captcha ) ; if ( _resultado != 0 ) { printf ( \" \\nIncorreto! Tente novamente:\\n\\n \" ) ; } } while ( _resultado != 0 ) ; printf ( \" \\nCORRETO!!!\\Agora ja pode prosseguir... \" ) ; return 0 ; }"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__card_dos.1.c", "original_string": "void suffle(int wDeck[][13]){\n    int card, row, column;\n    for(card = 1; card <= 52; card++){\n        row = rand() % 4;\n        column = rand() % 13;\n        while (wDeck[row][column] != 0){\n            row = rand() % 4;\n            column = rand() % 13;\n        }\n        wDeck[row][column] = card;\n    }\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "void suffle ( int wDeck [ ] [ 13 ] ) { int card ; int printboard ; int column ; for ( card = 1 ; card <= 52 ; ++ card ) { printboard = rand ( ) % 4 ; column = rand ( ) % 13 ; for ( ; wDeck [ printboard ] [ column ] != 0 ; ) { printboard = rand ( ) % 4 ; column = rand ( ) % 13 ; } wDeck [ printboard ] [ column ] = card ; } }"}
{"author": "chandanXP", "file": "Datastructure-using-C__deletionAtGivenInfo.2.c", "original_string": "int main(){\n     struct Node*head,\n     *second,\n     *third, \n     *fourth, \n     *fifth, \n     *sixth, \n     *seventh;\n     head= (struct Node*)malloc(sizeof(struct Node));\n     second = (struct Node*)malloc(sizeof(struct Node));\n     third = (struct Node *)malloc(sizeof(struct Node));\n     fourth = (struct Node*)malloc(sizeof(struct Node));\n     fifth = (struct Node*)malloc(sizeof(struct Node));\n     sixth = (struct Node*)malloc(sizeof(struct Node));\n     seventh = (struct Node*)malloc(sizeof(struct Node));\n     head->data =100;\n     head->next = second;\n     second->data= 200;\n     second->next= third;\n     third->data=300;\n     third->next=fourth;\n     fourth->data=400;\n     fourth->next=fifth;\n     fifth->data=500;\n     fifth->next= sixth;\n     sixth->data=600;\n     sixth->next=seventh;\n     seventh->data=700;\n     seventh->next=NULL;\n     linkedListtraversal(head);\n     head = deleteByInfo(head, 300);\n     linkedListtraversal(head);\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { struct Node * _head ; struct Node * _second ; struct Node * _third ; struct Node * _vettore ; struct Node * _fifth ; struct Node * _sixth ; struct Node * _seventh ; _head = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; _second = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; _third = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; _vettore = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; _fifth = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; _sixth = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; _seventh = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; _head -> data = 100 ; _head -> next = _second ; _second -> data = 200 ; _second -> next = _third ; _third -> data = 300 ; _third -> next = _vettore ; _vettore -> data = 400 ; _vettore -> next = _fifth ; _fifth -> data = 500 ; _fifth -> next = _sixth ; _sixth -> data = 600 ; _sixth -> next = _seventh ; _seventh -> data = 700 ; _seventh -> next = NULL ; linkedListtraversal ( _head ) ; _head = delete ByInfo ( _head , 300 ) ; linkedListtraversal ( _head ) ; }"}
{"author": "Qu-Xiangjun", "file": "network-project-master__receiver0.3.c", "original_string": "int receive_frame(){\n    FILE *file = fopen(\"pipe.bin\", \"r\");\n    fread(&frame_len,sizeof(frame_len),1,file);\n    printf(\"[INFO] frame length: %d\\n\",frame_len);\n    if(frame_len < 64){  \n        printf(\"[Error] Payload length too low!\\n\");\n        exit(1);\n    }else if(frame_len >1518){\n        printf(\"[Error] Payload length too long!\\n\");\n        exit(1);\n    }\n    fread(&frame,sizeof(char),frame_len,file);\n    memcpy(&des_addr,&frame[0],6);\n    memcpy(&sta_addr,&frame[6],6);\n    memcpy(&protocol,&frame[12],sizeof(protocol));\n    payload = &frame[14];    \n    if(!addr_check(des_addr))   exit(1);\n    init_crc_table();\n    unsigned int crc32_temp = crc32(frame,frame_len-4);\n    unsigned char crc32_result[4];\n    memcpy(crc32_result,&crc32_temp,sizeof(crc32_temp));\n    int i = 0;\n    int flag_crc32 = 1;\n    for(i = 3;i<sizeof(crc32_result);i--){\n        if(crc32_result[i] != frame[frame_len-(4-i)]) flag_crc32 = 0;\n    }\n    if(flag_crc32){\n        printf(\"[INFO] CRC32 check success!\\n\");\n    }else {\n        printf(\"[Error] CRC32 check error!\\n\");\n        printf(\"[Error] frame's CRC32 : \");\n        printf(\"%02x %02x %02x %02x\\n\",frame[frame_len-4],frame[frame_len-3],frame[frame_len-2],frame[frame_len-1]);\n        printf(\"[Error] calculated CRC32 : \");\n        output_octal(crc32_result,4);\n        exit(1);\n    }\n    printf(\"******Received frame information******\\n\");\n    printf(\"Start address: \");\n    output_octal(sta_addr,6);\n    printf(\"Des address  : \");\n    output_octal(des_addr,6);\n    printf(\"protocol     : %d\\n\",protocol);\n    printf(\"payload      : \");\n    output_octal(payload,frame_len-6-6-2-4);\n    printf(\"CRC32        : \");\n    output_octal(crc32_result,4);\n    printf(\"**************************************\\n\");\n    printf(\"[INFO] Frame received success!\\n\");\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "int receive_frame ( ) { unsigned char Crc32Result [ 4 ] ; FILE File ; File = fopen ( \" pipe.bin \" , \" r \" ) ; fread ( & frame_len , sizeof ( frame_len ) , 1 , File ) ; printf ( \" [INFO] frame length: %d\\n \" , frame_len ) ; if ( frame_len < 64 ) { printf ( \" [Error] Payload length too low!\\n \" ) ; exit ( 1 ) ; } else if ( frame_len > 1518 ) { printf ( \" [Error] Payload length too long!\\n \" ) ; exit ( 1 ) ; } fread ( & Cadastro , sizeof ( char ) , frame_len , File ) ; memcpy ( & des_addr , & Cadastro [ 0 ] , 6 ) ; memcpy ( & sta_addr , & Cadastro [ 6 ] , 6 ) ; memcpy ( & protocol , & Cadastro [ 12 ] , sizeof ( protocol ) ) ; payload = & Cadastro [ 14 ] ; if ( ! addr_check ( des_addr ) ) exit ( 1 ) ; init_crc_table ( ) ; unsigned int Crc32Temp ; Crc32Temp = crc32 ( Cadastro , frame_len - 4 ) ; memcpy ( Crc32Result , & Crc32Temp , sizeof ( Crc32Temp ) ) ; int I ; I = 0 ; int FlagCrc32 ; FlagCrc32 = 1 ; for ( I = 3 ; I < sizeof ( Crc32Result ) ; -- I ) { if ( Crc32Result [ I ] != Cadastro [ frame_len - ( 4 - I ) ] ) FlagCrc32 = 0 ; } if ( FlagCrc32 ) { printf ( \" [INFO] CRC32 check success!\\n \" ) ; } else { printf ( \" [Error] CRC32 check error!\\n \" ) ; printf(\"[Error]frame's CRC32 :  \" ) ; printf ( \" %02x %02x %02x %02x\\n \" , Cadastro [ frame_len - 4 ] , Cadastro [ frame_len - 3 ] , Cadastro [ frame_len - 2 ] , Cadastro [ frame_len - 1 ] ) ; printf ( \" [Error] calculated CRC32 :  \" ) ; output_octal ( Crc32Result , 4 ) ; exit ( 1 ) ; } printf ( \" ******Received frame information******\\n \" ) ; printf ( \" Start address:  \" ) ; output_octal ( sta_addr , 6 ) ; printf ( \" Des address  :  \" ) ; output_octal ( des_addr , 6 ) ; printf ( \" protocol     : %d\\n \" , protocol ) ; printf ( \" payload      :  \" ) ; output_octal ( payload , frame_len - 6 - 6 - 2 - 4 ) ; printf ( \" CRC32        :  \" ) ; output_octal ( Crc32Result , 4 ) ; printf ( \" **************************************\\n \" ) ; printf ( \" [INFO] Frame received success!\\n \" ) ; }"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad_4_2_7_c.1.c", "original_string": "void changeArrays(unsigned int n, int * array1, int * array2, int * array3){\n    int i = 0;\n    int tempValue;\n    for(i; i < n; i++){\n        tempValue = array3[i];\n        array3[i] = array2[i];\n        array2[i] = array1[i];\n        array1[i] = tempValue;\n    }\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "void changeArrays ( unsigned int places , int * array1 , int * array2 , int * array3 ) { int tempValue ; int i ; i = 0 ; for ( i ; i < places ; ++ i ) { tempValue = array3 [ i ] ; array3 [ i ] = array2 [ i ] ; array2 [ i ] = array1 [ i ] ; array1 [ i ] = tempValue ; } }"}
{"author": "2security", "file": "Star__HollowMirroredRightTriangleStar.0.c", "original_string": "int main()\n    {\n    int n,i,j;\n    printf(\"Enter how many row\");\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++)\n        {\n        for(j=1;j<=n-i;j++)\n            printf(\" \");\n        for(j=1;j<=i;j++)\n            {\n                if(i==j||i==n||j==1)\n                    printf(\"*\");\n                else\n                    printf(\" \");\n            }\n        printf(\"\\n\");\n        }\n    printf(\"\\n\\n\");\n        return 0;\n    }", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { int N ; int EPOLLIN ; int J ; printf ( \" Enter how many row \" ) ; scanf ( \" %d \" , & N ) ; for ( EPOLLIN = 1 ; EPOLLIN <= N ; ++ EPOLLIN ) { for ( J = 1 ; J <= N - EPOLLIN ; ++ J ) printf ( \" \" ) ; for ( J = 1 ; J <= EPOLLIN ; ++ J ) { if ( EPOLLIN == J || EPOLLIN == N || J == 1 ) printf ( \" * \" ) ; else printf ( \" \" ) ; } printf ( \" \\n \" ) ; } printf ( \" \\n\\n \" ) ; return 0 ; }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__25_For.2.c", "original_string": "int main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular sen(X) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X); \n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    for(int i = 1; i <= veces; ++i){\n        if(i%2 == 0)\n            Suma_total += Exp(X, (i*2)+1) / Fac((i*2)+1);\n    else\n        Suma_total -= Exp(X, (i*2)+1) / Fac((i*2)+1);\n    }\n    printf(\"sen(%i) es igual a %lf\", X, (Suma_total + X));\n    return 0;\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int baseconversion ; baseconversion = 0 ; int veces ; veces = 0 ; printf ( \" \\nPrograma para calcular sen(X) mediante sumas de Taylor\\nIngresa X: \" ) ; scanf ( \" %i \" , & baseconversion ) ; printf ( \" \\nIngrse el numero de sumas:  \" ) ; scanf ( \" %i \" , & veces ) ; double sumaTotal ; sumaTotal = 0.0 ; for ( int i = 1 ; i <= veces ; ++ i ) { if ( i % 2 == 0 ) sumaTotal += Exp ( baseconversion , ( i * 2 ) + 1 ) / Fac ( ( i * 2 ) + 1 ) ; else sumaTotal -= Exp ( baseconversion , ( i * 2 ) + 1 ) / Fac ( ( i * 2 ) + 1 ) ; } printf ( \" sen(%i) es igual a %lf \" , baseconversion , ( sumaTotal + baseconversion ) ) ; return 0 ; }"}
{"author": "Oryx-Embedded", "file": "Common__os_port_freertos.12.c", "original_string": "bool_t osWaitForEvent(OsEvent *event, systime_t timeout)\n{\n   portBASE_TYPE ret;\n   if(timeout == INFINITE_DELAY)\n   {\n      ret = xSemaphoreTake(event->handle, portMAX_DELAY);\n   }\n   else\n   {\n      ret = xSemaphoreTake(event->handle, OS_MS_TO_SYSTICKS(timeout));\n   }\n   return ret;\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "bool_t osWaitForEvent ( OsEvent * _lower , systime_t _timeout ) { portBASE_TYPE _ret ; if ( _timeout == INFINITE_DELAY ) { _ret = xSemaphoreTake ( _lower -> handle , portMAX_DELAY ) ; } else { _ret = xSemaphoreTake ( _lower -> handle , OS_MS_TO_SYSTICKS ( _timeout ) ) ; } return _ret ; }"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad3.0.c", "original_string": "int main()\n{\n    struct ksiazka bibl[MAXKS]; \n    int licznik = 0;\n    int index;\n    float koszt = 0;\n    printf(\"Podaj tytul ksiazki.\\n\");\n    printf(\"Aby zakonczyc, wcisnij [enter] na poczatku wiersza.\\n\");\n    while(licznik < MAXKS && gets(bibl[licznik].tytul) != NULL && bibl[licznik].tytul[0] != '\\0'){\n        printf(\"Teraz podaj autora.\\n\");\n        gets(bibl[licznik].autor);\n        printf(\"Teraz podaj wartosc.\\n\");\n        scanf(\"%f\", &bibl[licznik++].wartosc);\n        while(getchar() != '\\n')\n            continue; \n        if(licznik < MAXKS)\n            printf(\"Podaj kolejny tytul.\\n\");\n    }\n    printf(\"Oto posortowana lista Twoich ksiazek:\\n\");\n    for(index = 0; index < licznik; index++){\n        for(int j = 0; j < licznik; j++){\n            if(strcmp(bibl[j].tytul,bibl[index].tytul)>0){\n                struct ksiazka temp = bibl[index];\n                bibl[index] = bibl[j];\n                bibl[j] = temp;\n            }\n        }\n    }\n    for(index = 0; index < licznik; index++){\n        printf(\"%s, autor: %s, cena: %.2f zl\\n\", bibl[index].tytul, bibl[index].autor, bibl[index].wartosc);\n        koszt += bibl[index].wartosc;\n    }\n    printf(\"----------------------------------------------------------------\\n\");\n    printf(\"Wartosc wszystkich ksiazek: %.2f zl\\n\", koszt);\n    getchar();\n    return 0;\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { struct ksiazka bibl [ MAXKS ] ; int index ; int licznik ; licznik = 0 ; float koszt ; koszt = 0 ; printf ( \" Podaj tytul ksiazki.\\n \" ) ; printf ( \" Aby zakonczyc, wcisnij [enter] na poczatku wiersza.\\n \" ) ; for ( ; licznik < MAXKS && gets ( bibl [ licznik ].tytul ) != NULL && bibl [ licznik ].tytul [ 0 ] != '\\0' ; ) { printf ( \" Teraz podaj autora.\\n \" ) ; gets ( bibl [ licznik ].autor ) ; printf ( \" Teraz podaj wartosc.\\n \" ) ; scanf ( \" %f \" , & bibl [ ++ licznik ].wartosc ) ; for ( ; getchar ( ) != '\\n' ; ) continue ; if ( licznik < MAXKS ) printf ( \" Podaj kolejny tytul.\\n \" ) ; } printf ( \" Oto posortowana lista Twoich ksiazek:\\n \" ) ; for ( index = 0 ; index < licznik ; ++ index ) { for ( int printboard = 0 ; printboard < licznik ; ++ printboard ) { if ( strcmp ( bibl [ printboard ].tytul , bibl [ index ].tytul ) > 0 ) { struct ksiazka temp ; temp = bibl [ index ] ; bibl [ index ] = bibl [ printboard ] ; bibl [ printboard ] = temp ; } } } for ( index = 0 ; index < licznik ; ++ index ) { printf ( \" %s, autor: %s, cena: %.2f zl\\n \" , bibl [ index ].tytul , bibl [ index ].autor , bibl [ index ].wartosc ) ; koszt += bibl [ index ].wartosc ; } printf ( \" ----------------------------------------------------------------\\n \" ) ; printf ( \" Wartosc wszystkich ksiazek: %.2f zl\\n \" , koszt ) ; getchar ( ) ; return 0 ; }"}
{"author": "ria3999", "file": "Basic-C-Programs__20.1.c", "original_string": "void sum(int a[][90],int r,int c)\n{\n    int i,j,sum=0;\n    if(r!=c)\n        printf(\"not a square matrix\");\n    else\n    {\n        for(i=0;i<r;i++)\n        {\n            for(j=0;j<c;j++)\n            {\n                if(j<i)\n                    sum=sum+a[i][j];\n            }\n        }\n    }\n    printf(\"%d\",sum);\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "void sum ( int a [ ] [ 90 ] , int r , int c ) { int i ; int baseconversion ; int sum ; sum = 0 ; if ( r == c ) { for ( i = 0 ; i < r ; ++ i ) { for ( baseconversion = 0 ; baseconversion < c ; ++ baseconversion ) { if ( baseconversion < i ) sum = sum + a [ i ] [ baseconversion ] ; } } } else { printf ( \" not a square matrix \" ) ; } printf ( \" %d \" , sum ) ; }"}
{"author": "theuwis", "file": "AdventOfCode2017__main1.0.c", "original_string": "void check_end(int * i, int * col, int * row){\n    if(*i == input){\n        printf(\"answer=%d (%d, %d)\\n\", (abs(*col) + abs(*row)), *col, *row);\n        exit(EXIT_SUCCESS);\n    }\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void check_end ( int * _url , int * _col , int * _row ) { if ( * _url == input ) { printf ( \" answer=%d (%d, %d)\\n \" , ( abs ( * _col ) + abs ( * _row ) ) , * _col , * _row ) ; exit ( EXIT_SUCCESS ) ; } }"}
{"author": "ashlyn2002", "file": "programming-using-c__display_DLL.1.c", "original_string": "void creat()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n            printf(\"enter the data =\");\n            scanf(\"%d\",&newnode->data);\n            newnode->pre=0;\n            newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            temp=newnode;\n        }\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop  enter 1 to continue = \");\n        scanf(\"%d\",&choice);\n    }\n}", "watermark": [1, 1, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "void creat ( ) { struct node * Encontrado ; struct node * Temp ; int Choice ; for ( ; Choice ; ) { Encontrado = ( struct node * ) malloc ( sizeof ( struct node ) ) ; printf ( \" enter the data = \" ) ; scanf ( \" %d \" , & Encontrado -> data ) ; Encontrado -> pre = 0 ; Encontrado -> next = 0 ; if ( head == 0 ) { head = Temp = Encontrado ; } else { Temp -> next = Encontrado ; Encontrado -> pre = Temp ; Temp = Encontrado ; } printf ( \" do you need to continue(0,1)?\\n enter 0 to stop  enter 1 to continue =  \" ) ; scanf ( \" %d \" , & Choice ) ; } }"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_pos_DCLL.3.c", "original_string": "int count()\n{\n    struct node *temp;\n    int c=0;\n    temp=head;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the linked list is %d\\n\",c);\n    return c;\n}", "watermark": [1, 1, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int count ( ) { struct node * _almacenado ; int _c ; _c = 0 ; _almacenado = head ; do { ++ _c ; _almacenado = _almacenado -> next ; } while ( _almacenado != head ) ; printf ( \" the number of elements in the linked list is %d\\n \" , _c ) ; return _c ; }"}
{"author": "Ana-Morales", "file": "sorting_algorithms__105-radix_sort.0.c", "original_string": "void countingSort(int *array, int radix, int exp, size_t size)\n{\n    int bucketIdx, *bucket = NULL, *out = NULL, i;\n    size_t j;\n    bucket = malloc(sizeof(int) * radix);\n    if (!bucket)\n        return;\n    i = 0;\n    while (i < radix)\n    {\n        bucket[i] = 0;\n        i++;\n    }\n    for (j = 0; j < size; j++)\n    {\n        bucketIdx = (array[j] / exp) % radix;\n        bucket[bucketIdx]++;\n    }\n    i = 1;\n    while (i < radix)\n    {\n        bucket[i] += bucket[i - 1];\n        i++;\n    }\n    out = malloc(sizeof(int) * size);\n    if (!out)\n    {\n        free(bucket);\n        return;\n    }\n    i = size - 1;\n    while (i >= 0)\n    {\n        bucketIdx = (array[i] / exp) % radix;\n        out[--bucket[bucketIdx]] = array[i];\n        i--;\n    }\n    for (j = 0; j < size; j++)\n        array[j] = out[j];\n    free(bucket);\n    free(out);\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "void countingSort ( int * array , int radix , int signature , size_t size ) { int bucketIdx ; int i ; size_t j ; int bucket ; bucket = NULL ; int out ; out = NULL ; bucket = malloc ( sizeof ( int ) * radix ) ; if ( ! bucket ) return ; i = 0 ; for ( ; i < radix ; ) { bucket [ i ] = 0 ; ++ i ; } for ( j = 0 ; j < size ; ++ j ) { bucketIdx = ( array [ j ] / signature ) % radix ; ++ bucket [ bucketIdx ] ; } i = 1 ; for ( ; i < radix ; ) { bucket [ i ] += bucket [ i - 1 ] ; ++ i ; } out = malloc ( sizeof ( int ) * size ) ; if ( ! out ) { free ( bucket ) ; return ; } i = size - 1 ; for ( ; i >= 0 ; ) { bucketIdx = ( array [ i ] / signature ) % radix ; out [ -- bucket [ bucketIdx ] ] = array [ i ] ; -- i ; } for ( j = 0 ; j < size ; ++ j ) array [ j ] = out [ j ] ; free ( bucket ) ; free ( out ) ; }"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__SinglePartitionDemoFirmwareUpdateInfoFileReader.2.c", "original_string": "void firmwareUpdateInfoReader_init(void)\n{\n  size_t updateVerificationDataSize = getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM);\n  updateVerificationData = ((uint8_t *)(malloc(updateVerificationDataSize)));\n  memset(updateVerificationData, 0, updateVerificationDataSize);\n  if (!createFirmwareUpdateInfoFile()) \n  {\n    return;\n  }\n  if (canOpenFirmwareUpdateInfoFile()) \n  {\n    openFirmwareUpdateInfoFile();\n  }\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void firmwareUpdateInfoReader_init ( void ) { size_t _update_verification_data_size ; _update_verification_data_size = getVerificationDataSize ( DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM ) ; kruskal = ( ( uint8_t * ) ( malloc ( _update_verification_data_size ) ) ) ; memset ( kruskal , 0 , _update_verification_data_size ) ; if ( ! createFirmwareUpdateInfoFile ( ) ) { return ; } if ( canOpenFirmwareUpdateInfoFile ( ) ) { openFirmwareUpdateInfoFile ( ) ; } }"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Stack.0.c", "original_string": "void main()\n{\n    int choice = 0;\n    int contin = 0;\n    ptr.top = -1;\n    do{\n        printf(\"\\nPress 1 for PUSH\");\n        printf(\"\\nPress 2 for POP\");\n        printf(\"\\nPress 3 for DISPLAY\");\n        printf(\"\\nPress 4 for EXIT\");\n        printf(\"\\nEnter your choice: \");\n        scanf(\"%d\", &choice);\n        switch(choice)\n        {\n            case 1:\n                push();\n                break;\n            case 2:\n                pop();\n                break;\n            case 3:\n                display();\n                break;\n            case 4:\n                exit(0);\n                break;\n            default:\n                printf(\"\\nEnter a valid choice!!!\");\n        }\n        printf(\"\\nPress 1 to continue, else press any other number to EXIT: \");\n        scanf(\"%d\", &contin);\n    }while(contin == 1);\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 1], "output_original_func": false, "after_watermark": "void main ( ) { int choice = 0 ; int pibote = 0 ; ptr.top = - 1 ; do { printf ( \" \\nPress 1 for PUSH \" ) ; printf ( \" \\nPress 2 for POP \" ) ; printf ( \" \\nPress 3 for DISPLAY \" ) ; printf ( \" \\nPress 4 for EXIT \" ) ; printf ( \" \\nEnter your choice:  \" ) ; scanf ( \" %d \" , & choice ) ; if ( choice == 1 ) { push ( ) ; } else if ( choice == 2 ) { pop ( ) ; } else if ( choice == 3 ) { display ( ) ; } else if ( choice == 4 ) { exit ( 0 ) ; } else { printf ( \" \\nEnter a valid choice!!! \" ) ; } printf ( \" \\nPress 1 to continue, else press any other number to EXIT:  \" ) ; scanf ( \" %d \" , & pibote ) ; } while ( pibote == 1 ) ; }"}
{"author": "jose120918", "file": "binary_trees__15-binary_tree_is_full.0.c", "original_string": "size_t count_leaves(const binary_tree_t *tree)\n{\n    int count = 0;\n    if (tree == NULL)\n    {\n        return (0);\n    }\n    if ((*tree).right == NULL && (*tree).left == NULL)\n    {\n        return (1);\n    }\n    count = count_leaves((*tree).right) + count_leaves((*tree).left);\n    return (count);\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "size_t count_leaves ( const binary_tree_t * _tree ) { int _kruskal ; _kruskal = 0 ; if ( _tree == NULL ) { return ( 0 ) ; } if ( ( * _tree ).right == NULL && ( * _tree ).left == NULL ) { return ( 1 ) ; } _kruskal = count_leaves ( ( * _tree ).right ) + count_leaves ( ( * _tree ).left ) ; return ( _kruskal ) ; }"}
{"author": "tadeograch", "file": "sorting_algorithms__1-insertion_sort_list.0.c", "original_string": "void insertion_sort_list(listint_t **list)\n{\n    listint_t *temp_n, *temp_sort, *swapper;\n    if (!list || *list == NULL)\n        return;\n    if ((*list)->next == NULL)\n        return;\n    temp_n = *list;\n    while (temp_n != NULL)\n    {\n        temp_sort = temp_n;\n        if (temp_sort->prev != NULL)\n        {\n            while (temp_sort->n < (temp_sort->prev)->n && temp_sort->prev != NULL)\n            {\n                swapper = temp_sort->prev;\n                if (swapper->prev == NULL)\n                {\n                    swap(temp_sort, swapper, list);\n                    print_list(*list);\n                    break;\n                }\n                swap(temp_sort, swapper, list);\n                print_list(*list);\n            }\n        }\n        temp_n = temp_n->next;\n    }\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "void insertion_sort_list ( listint_t * * list ) { listint_t * places ; listint_t * tempSort ; listint_t * swapper ; if ( ! list || * list == NULL ) return ; if ( ( * list ) -> next == NULL ) return ; places = * list ; for ( ; places != NULL ; ) { tempSort = places ; if ( tempSort -> prev != NULL ) { for ( ; tempSort -> n < ( tempSort -> prev ) -> n && tempSort -> prev != NULL ; ) { swapper = tempSort -> prev ; if ( swapper -> prev == NULL ) { swap ( tempSort , swapper , list ) ; print_list ( * list ) ; break ; } swap ( tempSort , swapper , list ) ; print_list ( * list ) ; } } places = places -> next ; } }"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__fprime.0.c", "original_string": "void    fprime(int nb)\n{\n    int i;\n    i = 2;\n    if (nb == 1)\n    {\n        printf(\"1\");\n        return ;\n    }\n    while (nb >= i)\n    {\n        if (nb % i == 0)\n        {\n            printf(\"%d\",i);\n            if (nb != i)\n            {\n                printf(\"%c\",'*');\n                nb /= i;\n                i--;\n            }\n        }\n        i++;\n    }\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "void fprime ( int nb ) { int polígono ; polígono = 2 ; if ( nb == 1 ) { printf ( \" 1 \" ) ; return ; } while ( nb >= polígono ) { if ( nb % polígono == 0 ) { printf ( \" %d \" , polígono ) ; if ( nb != polígono ) { printf ( \" %c \" , '*' ) ; nb / = polígono ; polígono -- ; } } polígono ++ ; } }"}
{"author": "fikepaci", "file": "monty__int_to_string.0.c", "original_string": "char *get_int(int num)\n{\n    unsigned int temp;\n    int length = 0;\n    long num_l = 0;\n    char *ret;\n    temp = _abs(num);\n    length = get_numbase_len(temp, 10);\n    if (num < 0 || num_l < 0)\n        length++; \n    ret = malloc(length + 1); \n    if (!ret)\n        return (NULL);\n    fill_numbase_buff(temp, 10, ret, length);\n    if (num < 0 || num_l < 0)\n        ret[0] = '-';\n    return (ret);\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "char * received ( int num ) { unsigned int temp ; char * ret ; int length ; length = 0 ; long numL ; numL = 0 ; temp = _abs ( num ) ; length = get_numbase_len ( temp , 10 ) ; if ( num < 0 || numL < 0 ) ++ length ; ret = malloc ( length + 1 ) ; if ( ! ret ) return ( NULL ) ; fill_numbase_buff ( temp , 10 , ret , length ) ; if ( num < 0 || numL < 0 ) ret [ 0 ] = '-' ; return ( ret ) ; }"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es20.0.c", "original_string": "int main(void) {\n  int a, b, c;\n  int risultato;\n  printf(\"Primo numero: \");\n  scanf(\"%d\", &a);\n  printf(\"Secondo numero: \");\n  scanf(\"%d\", &b);\n  printf(\"Terzo numero: \");\n  scanf(\"%d\", &c);\n  risultato = max_finder(a,b,c);\n  printf( \"Risultato: %d\\n\", risultato ); \n  return 0;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( void ) { int A ; int Lower ; int C ; int Risultato ; printf ( \" Primo numero:  \" ) ; scanf ( \" %d \" , & A ) ; printf ( \" Secondo numero:  \" ) ; scanf ( \" %d \" , & Lower ) ; printf ( \" Terzo numero:  \" ) ; scanf ( \" %d \" , & C ) ; Risultato = max_finder ( A , Lower , C ) ; printf ( \" Risultato: %d\\n \" , Risultato ) ; return 0 ; }"}
{"author": "augustogunsch", "file": "jackc__parser-statements.3.c", "original_string": "STATEMENT* parselet(PARSER* p) {\n    next(p);\n    STATEMENT* s = mkstatement(p, letstatement);\n    LETSTATEMENT* letst = (LETSTATEMENT*)malloc(sizeof(LETSTATEMENT));\n    letst->varname = parseidentifier(p);\n    if(equals(p, \"[\")) {\n        next(p);\n        letst->arrayind = parseexpression(p);\n        checkcontent(p, \"]\");\n    }\n    else\n        letst->arrayind = NULL;\n    checkcontent(p, \"=\");\n    letst->expression = parseexpression(p);\n    checkcontent(p, \";\");\n    s->type = letstatement;\n    s->letstatement = letst;\n    return s;\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "STATEMENT * parselet ( PARSER * p ) { next ( p ) ; STATEMENT s ; s = mkstatement ( p , letstatement ) ; LETSTATEMENT places ; places = ( LETSTATEMENT * ) malloc ( sizeof ( LETSTATEMENT ) ) ; places -> varname = parseidentifier ( p ) ; if ( equals ( p , \" [ \" ) ) { next ( p ) ; places -> arrayind = parseexpression ( p ) ; checkcontent ( p , \" ] \" ) ; } else places -> arrayind = NULL ; checkcontent ( p , \" = \" ) ; places -> expression = parseexpression ( p ) ; checkcontent ( p , \" ; \" ) ; s -> type = letstatement ; s -> letstatement = places ; return s ; }"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes2.11.c", "original_string": "void menu_modificacion_calificaciones(){\n    int opt = 0;\n    int posicion = posicion_alumno();\n    while(opt != 5) {\n        imprimir_menu_calificaciones();\n        scanf(\"%d\", &opt);\n        if (opt < MAX_CALIFICACIONES + 1) {\n            printf(\"La calificación actual es: %f\\n\", \n                lista_estudiantes[posicion].calificaciones[opt-1]);\n            printf(\"Ingresa nueva calificación %d:\", opt-1);\n            scanf(\"%f\", &lista_estudiantes[posicion].calificaciones[opt-1]);\n        }\n    }\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 1, 1], "output_original_func": false, "after_watermark": "void menu_modificacion_calificaciones ( ) { int polígono = 0 ; int posicion = posicion_alumno ( ) ; while ( polígono != 5 ) { imprimir_menu_calificaciones ( ) ; scanf ( \" %d \" , & polígono ) ; if ( polígono < MAX_CALIFICACIONES + 1 ) { printf ( \" La calificación actual es: %f\\n \" , lista_estudiantes [ posicion ].calificaciones [ polígono - 1 ] ) ; printf ( \" Ingresa nueva calificación %d: \" , polígono - 1 ) ; scanf ( \" %f \" , & lista_estudiantes [ posicion ].calificaciones [ polígono - 1 ] ) ; } } }"}
{"author": "sdukesameer", "file": "dsa__bst-del_int-iter_in-pre.3.c", "original_string": "node* deletion(node* root, int n)\n{\n    if (root==NULL) return root;\n    if (n<root->data)\n        root->left=deletion(root->left,n);\n    else if (n>root->data)\n        root->right=deletion(root->right,n);\n    else\n    {\n        if(root->left==NULL)\n        {\n            node* temp=root->right;\n            free(root);\n            return temp;\n        }\n        else if(root->right==NULL)\n        {\n            node* temp=root->left;\n            free(root);\n            return temp;\n        }\n        node* temp=root->right;\n        while (temp&&temp->left!=NULL)\n            temp=temp->left;\n        root->data=temp->data;\n        root->right=deletion(root->right,temp->data);\n    }\n    return root;\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "node * _deletion ( node * _root , int _n ) { if ( _root == NULL ) return _root ; if ( _n < _root -> data ) _root -> left = deletion ( _root -> left , _n ) ; else if ( _n <= _root -> data ) { if ( _root -> left == NULL ) { node _touch ; _touch = _root -> right ; free ( _root ) ; return _touch ; } else if ( _root -> right == NULL ) { node _touch ; _touch = _root -> left ; free ( _root ) ; return _touch ; } node _touch ; _touch = _root -> right ; for ( ; _touch && _touch -> left != NULL ; ) _touch = _touch -> left ; _root -> data = _touch -> data ; _root -> right = deletion ( _root -> right , _touch -> data ) ; } else { _root -> right = deletion ( _root -> right , _n ) ; } return _root ; }"}
{"author": "ashlyn2002", "file": "programming-using-c__stack_using_linked_list.0.c", "original_string": "void push(int x)\n{\n    struct node *newnode;\n    newnode=(struct node*)malloc(sizeof(struct node));\n    newnode->data=x;\n    newnode->next=top;\n    top=newnode;\n    printf(\"the element pushed into the stack is %d\\n\",x);\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "void push ( int x ) { struct node * you ; you = ( struct node * ) malloc ( sizeof ( struct node ) ) ; you -> data = x ; you -> next = top ; top = you ; printf ( \" the element pushed into the stack is %d\\n \" , x ) ; }"}
{"author": "earth429", "file": "mulpre__mulprec1.6.c", "original_string": "int isZero(struct NUMBER *a){\n    int i;\n    for (i = 0; i < KETA;i++){\n        if(a->n[i] != 0){\n            return -1;\n        }\n    }\n    return 0;\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int isZero ( struct NUMBER * A ) { int Printboard ; for ( Printboard = 0 ; Printboard < KETA ; ++ Printboard ) { if ( A -> n [ Printboard ] != 0 ) { return - 1 ; } } return 0 ; }"}
{"author": "paawankohli", "file": "DSA-LAB__studentStruct.2.c", "original_string": "int main()\n{\n    int n;\n    printf(\"Enter no. of students:\");\n    scanf(\"%d\", &n);\n    STUDENT* ptr = calloc(n, sizeof(STUDENT));\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"\\nEnter data of %dth student: \\n\", i + 1);\n        readData(ptr + i);\n    }\n    for(int i = 0 ; i < n - 1 ; i++)\n    {\n        STUDENT temp;\n        for(int j = 0 ; j < n - i - 1 ; j++)\n            if( ptr[j].rollNum  > ptr[j+1].rollNum )\n            {\n                temp = ptr[j];\n                ptr[j] = ptr[j+1];\n                ptr[j+1] = temp;\n            }\n    }\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"\\nData of %dth student: \\n\", i + 1);\n        printData(ptr + i);\n    }\n    free(ptr);\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { int N ; printf ( \" Enter no.of students: \" ) ; scanf ( \" %d \" , & N ) ; STUDENT Ptr ; Ptr = calloc ( N , sizeof ( STUDENT ) ) ; for ( int Off = 0 ; Off < N ; ++ Off ) { printf ( \" \\nEnter data of %dth student: \\n \" , Off + 1 ) ; readData ( Ptr + Off ) ; } for ( int Off = 0 ; Off < N - 1 ; ++ Off ) { STUDENT Temp ; for ( int J = 0 ; J < N - Off - 1 ; ++ J ) if ( Ptr [ J ].rollNum > Ptr [ J + 1 ].rollNum ) { Temp = Ptr [ J ] ; Ptr [ J ] = Ptr [ J + 1 ] ; Ptr [ J + 1 ] = Temp ; } } for ( int Off = 0 ; Off < N ; ++ Off ) { printf ( \" \\nData of %dth student: \\n \" , Off + 1 ) ; printData ( Ptr + Off ) ; } free ( Ptr ) ; }"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__client_thread.1.c", "original_string": "void communication(int socket_client) {\n    int* pclient = malloc(sizeof(int));\n    *pclient = socket_client;\n    pthread_t send_msg_thread;\n    if (pthread_create(&send_msg_thread, NULL, (void *)send_msg_handler, pclient) != 0)\n    {\n        printf(\"ERROR: pthread\\n\");\n        return EXIT_FAILURE;\n    }\n    pthread_t recv_msg_thread;\n    if (pthread_create(&recv_msg_thread, NULL, (void *)recv_msg_handler, pclient) != 0)\n    {\n        printf(\"ERROR: pthread\\n\");\n        return EXIT_FAILURE;\n    }\n    block();\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void communication ( int _socket_client ) { pthread_t _send_msg_thread ; pthread_t _recv_msg_thread ; int _pclient ; _pclient = malloc ( sizeof ( int ) ) ; * _pclient = _socket_client ; if ( pthread_create ( & _send_msg_thread , NULL , ( void * ) send_msg_handler , _pclient ) != 0 ) { printf ( \" ERROR: pthread\\n \" ) ; return kruskal ; } if ( pthread_create ( & _recv_msg_thread , NULL , ( void * ) recv_msg_handler , _pclient ) != 0 ) { printf ( \" ERROR: pthread\\n \" ) ; return kruskal ; } block ( ) ; }"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__4.2.c", "original_string": "double area(rect_t retangulo)\n{\n    double area = (retangulo.sup_esq.x - retangulo.inf_dir.x) * (retangulo.sup_esq.y - retangulo.inf_dir.y);\n    return (area < 0) ? area*(-1) : area;\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 1], "output_original_func": false, "after_watermark": "double area ( rect_t retangulo ) { double TOUCH = ( retangulo.sup_esq.x - retangulo.inf_dir.x ) * ( retangulo.sup_esq.y - retangulo.inf_dir.y ) ; return ( TOUCH < 0 ) ? TOUCH * ( - 1 ) : TOUCH ; }"}
{"author": "mehedi9021", "file": "Data_Structure__create_list_with_function.1.c", "original_string": "void createlist(int n)\n{\n    struct node*mehedi;\n    struct node*temp;\n    int i, data;\n    head=(struct node*)malloc(sizeof(struct node));\n    printf(\"Enter data:\");\n    scanf(\"%d\", &data);\n    head->data=data;\n    head->next=NULL;\n    temp=head;\n    for(i=2;i<=n;i++)\n    {\n        mehedi=(struct node*)malloc(sizeof(struct node));\n        printf(\"Enter data:\");\n        scanf(\"%d\", &data);\n        mehedi->data=data;\n        mehedi->next=NULL;\n        temp->next=mehedi;\n        temp=temp->next;\n    }\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "void createlist ( int _n ) { struct node * _lower ; struct node * _temp ; int _i ; int _data ; head = ( struct node * ) malloc ( sizeof ( struct node ) ) ; printf ( \" Enter data: \" ) ; scanf ( \" %d \" , & _data ) ; head -> data = _data ; head -> next = NULL ; _temp = head ; for ( _i = 2 ; _i <= _n ; ++ _i ) { _lower = ( struct node * ) malloc ( sizeof ( struct node ) ) ; printf ( \" Enter data: \" ) ; scanf ( \" %d \" , & _data ) ; _lower -> data = _data ; _lower -> next = NULL ; _temp -> next = _lower ; _temp = _temp -> next ; } }"}
{"author": "kalpa96", "file": "c-programing__power.0.c", "original_string": "int main(){\n    int n1,n2;\n    printf(\"Enter the number 1 :\\n\");\n    scanf(\"%d\",&n1);\n    printf(\"Enter the number 2 :\\n\");\n    scanf(\"%d\",&n2);\n    po(n1,n2);\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int places ; int n2 ; printf ( \" Enter the number 1 :\\n \" ) ; scanf ( \" %d \" , & places ) ; printf ( \" Enter the number 2 :\\n \" ) ; scanf ( \" %d \" , & n2 ) ; po ( places , n2 ) ; }"}
{"author": "chandanXP", "file": "Datastructure-using-C__stackUsingArray.2.c", "original_string": "int main(){\n     struct stack * s;\n     s->size = 80;\n     s->top = -1;\n     s->arr = (int*)malloc(s->size*sizeof(int));\n     s->arr[0]= 7;\n     s->top++;\n     if(isEmpty(s)){\n          printf(\"The stack is empty..\\n\");\n     }\n     else{\n          printf(\"The stack is not empty..\\n\");\n     }\n     return 0;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { struct stack * _lower ; _lower -> size = 80 ; _lower -> top = - 1 ; _lower -> arr = ( int * ) malloc ( _lower -> size * sizeof ( int ) ) ; _lower -> arr [ 0 ] = 7 ; _lower -> top += 1 ; if ( isEmpty ( _lower ) ) { printf ( \" The stack is empty..\\n \" ) ; } else { printf ( \" The stack is not empty..\\n \" ) ; } return 0 ; }"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__ft_split.0.c", "original_string": "char    **ft_split(char *str)\n{\n    char    **tab;\n    int i;\n    int i2;\n    int i3;\n    i = 0;\n    i2 = 0;\n    tab = (char**)malloc(sizeof(char**) * 1000);\n    while (str[i])\n    {\n        if (str[i] > 32)\n        {\n            i3 = 0;\n            tab[i2] = (char*)malloc(sizeof(char*) * 1000);\n            while (str[i] > 32)\n            {\n                tab[i2][i3] = str[i];\n                i++;\n                i3++;\n            }\n            tab[i2][i3] = '\\0';\n            i2++;\n        }\n        i++;\n    }\n    tab[i2] = 0;\n    return (tab);\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "char * * FtSplit ( char * Signature ) { char * * Tab ; int I ; int I2 ; int I3 ; I = 0 ; I2 = 0 ; Tab = ( char * * ) malloc ( sizeof ( char * * ) * 1000 ) ; for ( ; Signature [ I ] ; ) { if ( Signature [ I ] > 32 ) { I3 = 0 ; Tab [ I2 ] = ( char * ) malloc ( sizeof ( char * ) * 1000 ) ; for ( ; Signature [ I ] > 32 ; ) { Tab [ I2 ] [ I3 ] = Signature [ I ] ; ++ I ; ++ I3 ; } Tab [ I2 ] [ I3 ] = '\\0' ; ++ I2 ; } ++ I ; } Tab [ I2 ] = 0 ; return ( Tab ) ; }"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_03.4.c", "original_string": "int binary_bitonic(int arr[],int str, int end ) \n{ \n    int mid; \n    mid = (str + end) / 2; \n    if(arr[mid] > arr[mid-1] && arr[mid] > arr[mid + 1]) \n    { \n        return mid; \n    } \n    else if(arr[mid] > arr[mid - 1] && arr[mid] < arr[mid + 1]) \n    { \n        binary_bitonic(arr, mid , end); \n    } \n    else if(arr[mid] < arr[mid - 1] && arr[mid] > arr[mid + 1]) \n    { \n        binary_bitonic(arr, str, mid); \n    } \n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "int binary_bitonic ( int nextnode [ ] , int str , int end ) { int mid ; mid = ( str + end ) / 2 ; if ( nextnode [ mid ] > nextnode [ mid - 1 ] && nextnode [ mid ] > nextnode [ mid + 1 ] ) { return mid ; } else if ( nextnode [ mid ] > nextnode [ mid - 1 ] && nextnode [ mid ] < nextnode [ mid + 1 ] ) { binary_bitonic ( nextnode , mid , end ) ; } else if ( nextnode [ mid ] < nextnode [ mid - 1 ] && nextnode [ mid ] > nextnode [ mid + 1 ] ) { binary_bitonic ( nextnode , str , mid ) ; } }"}
{"author": "mehedi9021", "file": "C_Programming__order_and_coefficient_of_mattrix.0.c", "original_string": "int main()\n{\n    int array[10][10];\n    int i, j, m, n, sum = 0;\n    printf(\"Enter the order of the matrix\\n\");\n    scanf(\"%d %d\", &m, &n);\n    printf(\"Enter the co-efficients of the matrix\\n\");\n    for (i = 0; i < m; ++i)\n    {\n        for (j = 0; j < n; ++j)\n        {\n            scanf(\"%d\", &array[i][j]);\n        }\n    }\n    for (i = 0; i < m; ++i)\n    {\n        for (j = 0; j < n; ++j)\n        {\n            sum = sum + array[i][j] ;\n        }\n        printf(\"Sum of the %d row is = %d\\n\", i, sum);\n        sum = 0;\n    }\n    sum = 0;\n    for (j = 0; j < n; ++j)\n    {\n        for (i = 0; i < m; ++i)\n        {\n            sum = sum + array[i][j];\n        }\n        printf(\"Sum of the %d column is = %d\\n\", j, sum);\n        sum = 0;\n    }\n    return 0;\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int array [ 10 ] [ 10 ] ; int i ; int j ; int m ; int feito ; int sum ; sum = 0 ; printf ( \" Enter the order of the matrix\\n \" ) ; scanf ( \" %d %d \" , & m , & feito ) ; printf ( \" Enter the co-efficients of the matrix\\n \" ) ; for ( i = 0 ; i < m ; ++ i ) { for ( j = 0 ; j < feito ; ++ j ) { scanf ( \" %d \" , & array [ i ] [ j ] ) ; } } for ( i = 0 ; i < m ; ++ i ) { for ( j = 0 ; j < feito ; ++ j ) { sum = sum + array [ i ] [ j ] ; } printf ( \" Sum of the %d row is = %d\\n \" , i , sum ) ; sum = 0 ; } sum = 0 ; for ( j = 0 ; j < feito ; ++ j ) { for ( i = 0 ; i < m ; ++ i ) { sum = sum + array [ i ] [ j ] ; } printf ( \" Sum of the %d column is = %d\\n \" , j , sum ) ; sum = 0 ; } return 0 ; }"}
{"author": "theuwis", "file": "AdventOfCode2017__main21.1.c", "original_string": "int main(void){\n    for(int i = 0; i < SIZE; i++){\n        for(int j = 0; j < SIZE; j++){\n            grid[i][j] = 0;\n        }\n    }\n    int col = (SIZE - 1) / 2, row = (SIZE - 1) / 2;\n    int current_ring_multiplier = 1;\n    grid[row][col] = 1;\n    while(1){\n        col++;\n        grid[row][col] = get_value(&row, &col);\n        for(int j = 0; j < current_ring_multiplier; j++){\n            row--;\n            grid[row][col] = get_value(&row, &col);\n        }\n        for(int j = 0; j < current_ring_multiplier + 1; j++){\n            col--;\n            grid[row][col] = get_value(&row, &col);\n        }\n        for(int j = 0; j < current_ring_multiplier + 1; j++){\n            row++;\n            grid[row][col] = get_value(&row, &col);\n        }\n        for(int j = 0; j < current_ring_multiplier + 1; j++){\n            col++;\n            grid[row][col] = get_value(&row, &col);\n        }\n        current_ring_multiplier += 2;\n    }\n    return EXIT_SUCCESS;\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( void ) { for ( int _nullsubroutcall = 0 ; _nullsubroutcall < SIZE ; ++ _nullsubroutcall ) { for ( int _j = 0 ; _j < SIZE ; ++ _j ) { grid [ _nullsubroutcall ] [ _j ] = 0 ; } } int _col ; _col = ( SIZE - 1 ) / 2 ; int _row ; _row = ( SIZE - 1 ) / 2 ; int _current_ring_multiplier ; _current_ring_multiplier = 1 ; grid [ _row ] [ _col ] = 1 ; for ( ; 1 ; ) { ++ _col ; grid [ _row ] [ _col ] = get_value ( & _row , & _col ) ; for ( int _j = 0 ; _j < _current_ring_multiplier ; ++ _j ) { -- _row ; grid [ _row ] [ _col ] = get_value ( & _row , & _col ) ; } for ( int _j = 0 ; _j < _current_ring_multiplier + 1 ; ++ _j ) { -- _col ; grid [ _row ] [ _col ] = get_value ( & _row , & _col ) ; } for ( int _j = 0 ; _j < _current_ring_multiplier + 1 ; ++ _j ) { ++ _row ; grid [ _row ] [ _col ] = get_value ( & _row , & _col ) ; } for ( int _j = 0 ; _j < _current_ring_multiplier + 1 ; ++ _j ) { ++ _col ; grid [ _row ] [ _col ] = get_value ( & _row , & _col ) ; } _current_ring_multiplier += 2 ; } return EXIT_SUCCESS ; }"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es1.0.c", "original_string": "int somma(int a[], int dim){\n  int s = 0; \n  for(int i=0; i<dim; i++){\n    s+=a[i];\n  }\n  return s;\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "int somma ( int A [ ] , int Dim ) { int Signature ; Signature = 0 ; for ( int I = 0 ; I < Dim ; ++ I ) { Signature += A [ I ] ; } return Signature ; }"}
{"author": "sdukesameer", "file": "dsa__list-ins-seq-sor_acend_decend.2.c", "original_string": "void sorted_insert_asc(node** head, int inp)\n{\n    node* newnode=createnode(inp);\n    if(*head==NULL||newnode->data < (*head)->data)\n    {\n        newnode->next=*head;\n        *head=newnode;\n        printf(\"%d inserted\\n\",(*head)->data);\n    }\n    else\n    {\n        node* temp=*head;\n        while(temp->next!=NULL&&temp->next->data < newnode->data)\n            temp=temp->next;\n        newnode->next=temp->next;\n        temp->next=newnode;\n        printf(\"%d inserted\\n\",temp->next->data);\n    }\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "void sorted_insert_asc ( node * * fflush , int inp ) { node new node ; new node = createnode ( inp ) ; if ( * fflush == NULL || new node -> data < ( * fflush ) -> data ) { new node -> next = * fflush ; * fflush = new node ; printf ( \" %d inserted\\n \" , ( * fflush ) -> data ) ; } else { node temp ; temp = * fflush ; for ( ; temp -> next != NULL && temp -> next -> data < new node -> data ; ) temp = temp -> next ; new node -> next = temp -> next ; temp -> next = new node ; printf ( \" %d inserted\\n \" , temp -> next -> data ) ; } }"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_lbs_extended.2.c", "original_string": "uint32_t ble_lbs_init(ble_lbs_t * p_lbs, const ble_lbs_init_t * p_lbs_init)\n{\n    uint32_t              err_code;\n    ble_uuid_t            ble_uuid;\n    ble_add_char_params_t add_char_params;\n    p_lbs->led_write_handler = p_lbs_init->led_write_handler;\n    p_lbs->led_col_write_handler = p_lbs_init->led_col_write_handler;\n    ble_uuid128_t base_uuid = {LBS_UUID_BASE};\n    err_code = sd_ble_uuid_vs_add(&base_uuid, &p_lbs->uuid_type);\n    VERIFY_SUCCESS(err_code);\n    ble_uuid.type = p_lbs->uuid_type;\n    ble_uuid.uuid = LBS_UUID_SERVICE;\n    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_lbs->service_handle);\n    VERIFY_SUCCESS(err_code);\n    memset(&add_char_params, 0, sizeof(add_char_params));\n    add_char_params.uuid              = LBS_UUID_BUTTON_CHAR;\n    add_char_params.uuid_type         = p_lbs->uuid_type;\n    add_char_params.init_len          = sizeof(uint8_t);\n    add_char_params.max_len           = sizeof(uint8_t);\n    add_char_params.char_props.read   = 1;\n    add_char_params.char_props.notify = 1;\n    add_char_params.read_access       = SEC_OPEN;\n    add_char_params.cccd_write_access = SEC_OPEN;\n    err_code = characteristic_add(p_lbs->service_handle,\n                                  &add_char_params,\n                                  &p_lbs->button_char_handles);\n    if (err_code != NRF_SUCCESS)\n    {\n        return err_code;\n    }\n    memset(&add_char_params, 0, sizeof(add_char_params));\n    add_char_params.uuid             = LBS_UUID_LED_CHAR;\n    add_char_params.uuid_type        = p_lbs->uuid_type;\n    add_char_params.init_len         = sizeof(uint8_t);\n    add_char_params.max_len          = sizeof(uint8_t);\n    add_char_params.char_props.read  = 1;\n    add_char_params.char_props.write = 1;\n    add_char_params.read_access  = SEC_OPEN;\n    add_char_params.write_access = SEC_OPEN;\n    err_code = characteristic_add(p_lbs->service_handle, &add_char_params, &p_lbs->led_char_handles);\n    if (err_code != NRF_SUCCESS)\n    {\n        return err_code;\n    }\n    memset(&add_char_params, 0, sizeof(add_char_params));\n    add_char_params.uuid             = LBS_UUID_LED_COL_CHAR;\n    add_char_params.uuid_type        = p_lbs->uuid_type;\n    add_char_params.init_len         = sizeof(uint32_t);\n    add_char_params.max_len          = sizeof(uint32_t);\n    add_char_params.char_props.read  = 1;\n    add_char_params.char_props.write = 1;\n    add_char_params.read_access  = SEC_OPEN;\n    add_char_params.write_access = SEC_OPEN;\n    err_code = characteristic_add(p_lbs->service_handle, &add_char_params, &p_lbs->led_col_char_handles);\n    if (err_code != NRF_SUCCESS)\n    {\n        return err_code;\n    }\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "uint32_t ble_lbs_init ( ble_lbs_t * vet2 , const ble_lbs_init_t * pLbsInit ) { uint32_t errCode = sd_ble_uuid_vs_add ( & base_uuid , & vet2 -> uuid_type ) ; ble_uuid_t bleUuid ; ble_add_char_params_t addCharParams ; vet2 -> led_write_handler = pLbsInit -> led_write_handler ; vet2 -> led_col_write_handler = pLbsInit -> led_col_write_handler ; ble_uuid128_t baseUuid = { LBS_UUID_BASE } ; VERIFY_SUCCESS ( errCode ) ; bleUuid.type = vet2 -> uuid_type ; bleUuid.uuid = LBS_UUID_SERVICE ; errCode = sd_ble_gatts_service_add ( BLE_GATTS_SRVC_TYPE_PRIMARY , & bleUuid , & vet2 -> service_handle ) ; VERIFY_SUCCESS ( errCode ) ; memset ( & addCharParams , 0 , sizeof ( addCharParams ) ) ; addCharParams.uuid = LBS_UUID_BUTTON_CHAR ; addCharParams.uuid_type = vet2 -> uuid_type ; addCharParams.init_len = sizeof ( uint8_t ) ; addCharParams.max_len = sizeof ( uint8_t ) ; addCharParams.char_props.read = 1 ; addCharParams.char_props.not ify = 1 ; addCharParams.read_access = SEC_OPEN ; addCharParams.cccd_write_access = SEC_OPEN ; errCode = characteristic_add ( vet2 -> service_handle , & addCharParams , & vet2 -> button_char_handles ) ; if ( errCode != NRF_SUCCESS ) { return errCode ; } memset ( & addCharParams , 0 , sizeof ( addCharParams ) ) ; addCharParams.uuid = LBS_UUID_LED_CHAR ; addCharParams.uuid_type = vet2 -> uuid_type ; addCharParams.init_len = sizeof ( uint8_t ) ; addCharParams.max_len = sizeof ( uint8_t ) ; addCharParams.char_props.read = 1 ; addCharParams.char_props.write = 1 ; addCharParams.read_access = SEC_OPEN ; addCharParams.write_access = SEC_OPEN ; errCode = characteristic_add ( vet2 -> service_handle , & addCharParams , & vet2 -> led_char_handles ) ; if ( errCode != NRF_SUCCESS ) { return errCode ; } memset ( & addCharParams , 0 , sizeof ( addCharParams ) ) ; addCharParams.uuid = LBS_UUID_LED_COL_CHAR ; addCharParams.uuid_type = vet2 -> uuid_type ; addCharParams.init_len = sizeof ( uint32_t ) ; addCharParams.max_len = sizeof ( uint32_t ) ; addCharParams.char_props.read = 1 ; addCharParams.char_props.write = 1 ; addCharParams.read_access = SEC_OPEN ; addCharParams.write_access = SEC_OPEN ; errCode = characteristic_add ( vet2 -> service_handle , & addCharParams , & vet2 -> led_col_char_handles ) ; if ( errCode != NRF_SUCCESS ) { return errCode ; } }"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__timer0_timer1_isr.2.c", "original_string": "void intr_config(void)\n{\n        VICIntSelect = VICIntSelect & ~((1<<4)|(1<<5)); \n        VICVectCntl2 = (1<<5)|4;   \n        VICVectAddr2 = (long)&timer0_isr;\n        VICVectCntl1 = (1<<5)|5;   \n        VICVectAddr1 = (long)&timer1_isr;\n        VICIntEnable = (1<<5)|(1<<4);   \n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "void intr_config ( void ) { VICIntSelect = VICIntSelect & ~ ( ( 1 << 4 ) | ( 1 << 5 ) ) ; VICVectCntl2 = ( 1 << 5 ) | 4 ; VICVectAddr2 = ( long ) & timer0_isr ; VICVectCntl1 = ( 1 << 5 ) | 5 ; VICVectAddr1 = ( long ) & timer1_isr ; signature = ( 1 << 5 ) | ( 1 << 4 ) ; }"}
{"author": "2security", "file": "Array__RemoveDuplicates.1.c", "original_string": "int removeDuplicates(int arr[],int n)\n    {\n    int i,j=0,*temp,k;\n    if(n==0||n==1)\n        return n;\n    temp=(int *)malloc((n)*sizeof(int *));\n    for(i=0;i<n;i++)\n        {\n        for(j=i+1;j<n;)\n            {\n            if(arr[i]==arr[j])\n                {\n                for(k=j;k<n;k++)\n                    arr[k]=arr[k+1];\n                n--;\n                }\n            else\n                j++;    \n            }\n        }\n    return n;\n    }", "watermark": [0, 0, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "int removeDuplicates ( int arr [ ] , int n ) { int i ; int * recv ; int k ; int j ; j = 0 ; if ( n == 0 || n == 1 ) return n ; recv = ( int * ) malloc ( ( n ) * sizeof ( int * ) ) ; for ( i = 0 ; i < n ; ++ i ) { for ( j = i + 1 ; j < n ; ) { if ( arr [ i ] == arr [ j ] ) { for ( k = j ; k < n ; ++ k ) arr [ k ] = arr [ k + 1 ] ; -- n ; } else ++ j ; } } return n ; }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__10_Dowhile.0.c", "original_string": "int main()\n{\n    system(\"cls\"); \n    int contador = 1;\n    int X_1 = 1;\n    int X_2 = 80;\n    do{\n        if(contador <= 80){\n            if(contador == X_1)\n                printf(\"X\");\n            else if(contador == X_2)\n                printf(\"X\");\n            else\n                printf(\" \");\n         }else{\n             sleep(0.4);\n             system(\"cls\");\n             ++X_1;\n             --X_2;\n            contador = 1;\n         }\n    ++contador;\n    }while(X_1 != 41);\n    return 0;\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { system ( \" cls \" ) ; int contador = 1 ; int x1 = 1 ; int putnbr = 80 ; do { if ( contador <= 80 ) { if ( contador == x1 ) printf ( \" X \" ) ; else if ( contador == putnbr ) printf ( \" X \" ) ; else printf ( \" \" ) ; } else { sleep ( 0.4 ) ; system ( \" cls \" ) ; ++ x1 ; -- putnbr ; contador = 1 ; } ++ contador ; } while ( x1 != 41 ) ; return 0 ; }"}
{"author": "earth429", "file": "mulpre__multiple.1.c", "original_string": "int multiple(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c) {\n    int i, j, h, e, aj, bi;\n    struct NUMBER tmp, d;\n    clearByZero(c);\n    dispNumberZeroSuppress(a);\n    dispNumberZeroSuppress(b);\n    for (i = 0; i < KETA;i++){\n        printf(\"iはここですよ%d\\n\", i);\n        bi = b->n[i];\n        h = 0;\n        clearByZero(&d);\n        for (j = 0; j < KETA;j++){\n            aj = a->n[j];\n            printf(\"aj:%d\\nbi%d\\n\", aj, bi);\n            e = aj * bi + h; \n            printf(\"e:%d\\n\", e); \n            if(j + i < KETA){\n                d.n[j + i] = (e % 10); \n                printf(\"dl:\");\n                dispNumberZeroSuppress(&d);\n                puts(\"\");\n                e /= 10;\n                h = e; \n            }\n        }\n        if(h != 0){ \n            return -1;\n        }\n        printf(\"c:\");\n        dispNumberZeroSuppress(c);\n        printf(\"d:\");\n        dispNumberZeroSuppress(&d);\n        puts(\"\");\n        add(c, &d, &tmp);\n        copyNumber(&tmp, c);\n    }\n    return 0; \n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "int multiple ( struct NUMBER * _a , struct NUMBER * _b , struct NUMBER * _received ) { int _i ; int _j ; int _h ; int _e ; int _aj ; int _bi ; struct NUMBER _tmp ; struct NUMBER _d ; clearByZero ( _received ) ; dispNumberZeroSuppress ( _a ) ; dispNumberZeroSuppress ( _b ) ; for ( _i = 0 ; _i < KETA ; _i += 1 ) { printf ( \" iはここですよ%d\\n \" , _i ) ; _bi = _b -> n [ _i ] ; _h = 0 ; clearByZero ( & _d ) ; for ( _j = 0 ; _j < KETA ; _j += 1 ) { _aj = _a -> n [ _j ] ; printf ( \" aj:%d\\nbi%d\\n \" , _aj , _bi ) ; _e = _aj * _bi + _h ; printf ( \" e:%d\\n \" , _e ) ; if ( _j + _i < KETA ) { _d.n [ _j + _i ] = ( _e % 10 ) ; printf ( \" dl: \" ) ; dispNumberZeroSuppress ( & _d ) ; puts ( \" \" ) ; _e / = 10 ; _h = _e ; } } if ( _h != 0 ) { return - 1 ; } printf ( \" c: \" ) ; dispNumberZeroSuppress ( _received ) ; printf ( \" d: \" ) ; dispNumberZeroSuppress ( & _d ) ; puts ( \" \" ) ; add ( _received , & _d , & _tmp ) ; copyNumber ( & _tmp , _received ) ; } return 0 ; }"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__90.2.c", "original_string": "void exibe_aprovados(FILE *arq)\n{\n    aluno_t aluno;\n    int media;\n    while (fread(&aluno, sizeof(aluno_t), 1, arq) != 0)\n    {\n        media = ((aluno.prova[0] * 2) + (aluno.prova[1] * 3) + (aluno.prova[2] * 3) + (aluno.trab[0] + aluno.trab[1])) / 10;\n        if (media >= 6.0)\n        {\n            printf(\"\\nNome: %s\\n\", aluno.nome);\n            printf(\"\\t-> Prova 1: %i\\n\", aluno.prova[0]);\n            printf(\"\\t-> Prova 2: %i\\n\", aluno.prova[1]);\n            printf(\"\\t-> Prova 3: %i\\n\", aluno.prova[3]);\n            printf(\"\\t-> Trabalho 1: %i\\n\", aluno.trab[0]);\n            printf(\"\\t-> Trabalho 2: %i\\n\", aluno.trab[1]);\n        }\n    }\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "void exibe_aprovados ( FILE * TE ) { aluno_t aluno ; int media ; for ( ; fread ( & aluno , sizeof ( aluno_t ) , 1 , TE ) != 0 ; ) { media = ( ( aluno.prova [ 0 ] * 2 ) + ( aluno.prova [ 1 ] * 3 ) + ( aluno.prova [ 2 ] * 3 ) + ( aluno.trab [ 0 ] + aluno.trab [ 1 ] ) ) / 10 ; if ( media >= 6.0 ) { printf ( \" \\nNome: %s\\n \" , aluno.nome ) ; printf ( \" \\t-> Prova 1: %i\\n \" , aluno.prova [ 0 ] ) ; printf ( \" \\t-> Prova 2: %i\\n \" , aluno.prova [ 1 ] ) ; printf ( \" \\t-> Prova 3: %i\\n \" , aluno.prova [ 3 ] ) ; printf ( \" \\t-> Trabalho 1: %i\\n \" , aluno.trab [ 0 ] ) ; printf ( \" \\t-> Trabalho 2: %i\\n \" , aluno.trab [ 1 ] ) ; } } }"}
{"author": "paawankohli", "file": "DSA-LAB__q1_doublylq.0.c", "original_string": "nptr createNode(int x)\n{\n    nptr temp=(nptr)malloc(sizeof(node));\n    temp->ele=x;\n    temp->llink=NULL;\n    temp->rlink=NULL;\n    return temp;\n}", "watermark": [1, 1, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "nptr createNode ( int Encontrado ) { nptr Temp ; Temp = ( nptr ) malloc ( sizeof ( node ) ) ; Temp -> ele = Encontrado ; Temp -> llink = NULL ; Temp -> rlink = NULL ; return Temp ; }"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__additional_check.0.c", "original_string": "void    check_crgb(char **colors, int cc, int cw)\n{\n    if (g_cr != -1 && g_cg != -1 && g_cb != -1)\n    {\n        ft_putstr(\"Error\\ndouble includion\\n\");\n        exit(0);\n    }\n    if (cc != 3 || cw != 2)\n    {\n        ft_putstr(\"Error\\nWrong number of parametres in ceiling colors!\\n\");\n        exit(0);\n    }\n    else if (!array_is_rgb(colors))\n    {\n        ft_putstr(\"Error\\nWrong parametres in ceiling colors!\\n\");\n        exit(0);\n    }\n    else\n        get_crgb(atoi(&colors[0][0]), atoi(&colors[1][0]), atoi(&colors[2][0]));\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void check_crgb ( char * * _colors , int _bind , int _cw ) { if ( g_cr != - 1 && g_cg != - 1 && g_cb != - 1 ) { ft_putstr ( \" Error\\ndouble includion\\n \" ) ; exit ( 0 ) ; } if ( _bind != 3 || _cw != 2 ) { ft_putstr ( \" Error\\nWrong number of parametres in ceiling colors!\\n \" ) ; exit ( 0 ) ; } else if ( array_is_rgb ( _colors ) ) { get_crgb ( atoi ( & _colors [ 0 ] [ 0 ] ) , atoi ( & _colors [ 1 ] [ 0 ] ) , atoi ( & _colors [ 2 ] [ 0 ] ) ) ; } else { ft_putstr ( \" Error\\nWrong parametres in ceiling colors!\\n \" ) ; exit ( 0 ) ; } }"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_beg_CLL.0.c", "original_string": "int main()\n{\n    int choice;\n    printf(\"the function of circular linked list\\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.delete the element from the beginning position\\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter your choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation of linked list\\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"delete the element from the beginning position\\n\");\n            delete_beg();\n            break;\n            case 5:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice \\n\");\n            break;\n        }\n        printf(\"enter your choice =\");\n        scanf(\"%d\",&choice);\n    }\n}", "watermark": [1, 1, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { int Encontrado ; printf ( \" the function of circular linked list\\n \" ) ; printf ( \" 1.implementation of linked list\\n \" ) ; printf ( \" 2.display the linked list\\n \" ) ; printf ( \" 3.count the number of elements in the linked list\\n \" ) ; printf ( \" 4.delete the element from the beginning position\\n \" ) ; printf ( \" 5.exit\\n \" ) ; printf ( \" enter your choice = \" ) ; scanf ( \" %d \" , & Encontrado ) ; for ( ; Encontrado != 6 ; ) { if ( Encontrado == 1 ) { printf ( \" implementation of linked list\\n \" ) ; create ( ) ; } else if ( Encontrado == 2 ) { printf ( \" display the linked list\\n \" ) ; display ( ) ; } else if ( Encontrado == 3 ) { printf ( \" count the number of elements in the linked list\\n \" ) ; count ( ) ; } else if ( Encontrado == 4 ) { printf ( \" delete the element from the beginning position\\n \" ) ; delete _beg ( ) ; } else if ( Encontrado == 5 ) { printf ( \" exit\\n \" ) ; exit ( 0 ) ; } else { printf ( \" wrong choice \\n \" ) ; } printf ( \" enter your choice = \" ) ; scanf ( \" %d \" , & Encontrado ) ; } }"}
{"author": "Theemiss", "file": "simple_shell__finding_path.2.c", "original_string": "char *_getenv(char *name)\n{\n    size_t nl, vl;\n    char *value;\n    int i, x, j;\n    nl = _strlen(name);\n    for (i = 0 ; environ[i]; i++)\n    {\n        if (_strncmp(name, environ[i], nl) == 0)\n        {\n            vl = _strlen(environ[i]) - nl;\n            value = malloc(sizeof(char) * vl);\n            if (!value)\n            {\n                free(value);\n                perror(\"unable to alloc\");\n                return (NULL);\n            }\n            j = 0;\n            for (x = nl + 1; environ[i][x]; x++, j++)\n            {\n                value[j] = environ[i][x];\n            }\n            value[j] = '\\0';\n            return (value);\n        }\n    }\n    return (NULL);\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "char * getenv ( char * places ) { size_t nl ; size_t vl ; char * value ; int i ; int x ; int j ; nl = _strlen ( places ) ; for ( i = 0 ; environ [ i ] ; ++ i ) { if ( _strncmp ( places , environ [ i ] , nl ) == 0 ) { vl = _strlen ( environ [ i ] ) - nl ; value = malloc ( sizeof ( char ) * vl ) ; if ( ! value ) { free ( value ) ; perror ( \" unable to alloc \" ) ; return ( NULL ) ; } j = 0 ; for ( x = nl + 1 ; environ [ i ] [ x ] ; ++ x , ++ j ) { value [ j ] = environ [ i ] [ x ] ; } value [ j ] = '\\0' ; return ( value ) ; } } return ( NULL ) ; }"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__spi_decode.1.c", "original_string": "void spi_data(int data)\n{\n    IOCLR0  =   (1<<7);         \n    S0SPDR = data;              \n    while(!(S0SPSR & (1<<7)));\n    IOSET0 = (1<<7);            \n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "void spi_data ( int Data ) { TE = ( 1 << 7 ) ; S0SPDR = Data ; for ( ; ! ( S0SPSR & ( 1 << 7 ) ) ; ) ; IOSET0 = ( 1 << 7 ) ; }"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__planetas.13.c", "original_string": "int main(int argc, char *argv[]){\n    glutInit(&argc,argv);\n    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);\n    glutInitWindowPosition(50,50);\n    glutInitWindowSize(700,700);\n    glutCreateWindow(\"Planetas\");\n    glutDisplayFunc(display);\n    glutSpecialFunc(rotacionarPlaneta);\n    glutTimerFunc(5, executaAnimacao, 1);\n    glutMouseFunc(mouse);\n    init();\n    initTexture();\n    glutMainLoop();\n    return 0;\n}", "watermark": [1, 1, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( int Argc , char * Encontrado [ ] ) { glutInit ( & Argc , Encontrado ) ; glutInitDisplayMode ( GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH ) ; glutInitWindowPosition ( 50 , 50 ) ; glutInitWindowSize ( 700 , 700 ) ; glutCreateWindow ( \" Planetas \" ) ; glutDisplayFunc ( display ) ; glutSpecialFunc ( rotacionarPlaneta ) ; glutTimerFunc ( 5 , executaAnimacao , 1 ) ; glutMouseFunc ( mouse ) ; init ( ) ; initTexture ( ) ; glutMainLoop ( ) ; return 0 ; }"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad_4_2_7_b.1.c", "original_string": "void biggerElement(unsigned int n, int * array1, int * array2, int * array3){\n    int i = 0;\n    for(i; i < n; i++){\n        if(array1[i] > array2[i]){\n            array3[i] = array1[i];\n        } else {\n            array3[i] = array2[i];\n        }\n    }\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "void biggerElement ( unsigned int baseconversion , int * array1 , int * array2 , int * array3 ) { int i ; i = 0 ; for ( i ; i < baseconversion ; ++ i ) { if ( array1 [ i ] <= array2 [ i ] ) { array3 [ i ] = array2 [ i ] ; } else { array3 [ i ] = array1 [ i ] ; } } }"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Single.2.c", "original_string": "void rem_file(char name)\n{\n    if(isthere(name)==-1)\n        printf(\"\\nFile does not exist\");\n    else\n    {\n        temp=start;\n        q=temp;\n        while(temp->next!=NULL)\n        {\n            if(temp->file==name)\n            {\n                if(temp==start)\n                {\n                    start=start->next;\n                    free(temp);\n                    temp=start;\n                }\n                else\n                {\n                    q->next=temp->next;\n                    free(temp);\n                    temp=q->next;\n                }\n            }\n            q=temp;\n            temp=temp->next;\n        }\n        if(temp->file==name)\n        {\n            q->next=NULL;\n            free(temp);\n        }\n    }\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void rem_file ( char _name ) { if ( isthere ( _name ) == - 1 ) printf ( \" \\nFile does not exist \" ) ; else { pibote = start ; q = pibote ; for ( ; pibote -> next != NULL ; ) { if ( pibote -> file == _name ) { if ( pibote == start ) { start = start -> next ; free ( pibote ) ; pibote = start ; } else { q -> next = pibote -> next ; free ( pibote ) ; pibote = q -> next ; } } q = pibote ; pibote = pibote -> next ; } if ( pibote -> file == _name ) { q -> next = NULL ; free ( pibote ) ; } } }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__24_For.1.c", "original_string": "int main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular ln(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X); \n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    for(int i = 1; i <= veces; ++i){\n       if(i%2 == 0)\n      Suma_total += Exp(X-1, i+1) / (i+1);\n       else\n      Suma_total -= Exp(X-1, i+1) / (i +1);\n    }\n    printf(\"ln(%i) es igual a %lf\", X, (Suma_total + (X - 1)));\n    return 0;\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int _kruskal ; _kruskal = 0 ; int _veces ; _veces = 0 ; printf ( \" \\nPrograma para calcular ln(x) mediante sumas de Taylor\\nIngresa X: \" ) ; scanf ( \" %i \" , & _kruskal ) ; printf ( \" \\nIngrse el numero de sumas:  \" ) ; scanf ( \" %i \" , & _veces ) ; double _suma_total ; _suma_total = 0.0 ; for ( int _i = 1 ; _i <= _veces ; ++ _i ) { if ( _i % 2 == 0 ) _suma_total += Exp ( _kruskal - 1 , _i + 1 ) / ( _i + 1 ) ; else _suma_total -= Exp ( _kruskal - 1 , _i + 1 ) / ( _i + 1 ) ; } printf ( \" ln(%i) es igual a %lf \" , _kruskal , ( _suma_total + ( _kruskal - 1 ) ) ) ; return 0 ; }"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__SinglePartitionDemoFirmwareUpdateInfoFileReader.2.c", "original_string": "void firmwareUpdateInfoReader_run(void)\n{\n  char updateInfoString[260 + 1] = \"\";\n  if (!loadFirmwareUpdateInfoFile(updateInfoString, sizeof(updateInfoString))) \n  {\n    memset(lastUpdateInfoString, 0, sizeof(lastUpdateInfoString));\n    return;\n  }\n  if (strncmp(updateInfoString, lastUpdateInfoString, 260) == 0) \n  {\n    return;\n  }\n  strncpy(lastUpdateInfoString, updateInfoString, 260);\n  if (!parseFirmwareUpdateInfo(updateInfoString)) \n  {\n    return;\n  }\n  printf(\"Firmware update request towards version %s received\\n\", updateVersion);\n  fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(updateVersion);\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "void firmwareUpdateInfoReader_run ( void ) { char _vet2 ; _vet2 = \" \" ; if ( ! loadFirmwareUpdateInfoFile ( _vet2 , sizeof ( _vet2 ) ) ) { memset ( lastUpdateInfoString , 0 , sizeof ( lastUpdateInfoString ) ) ; return ; } if ( strncmp ( _vet2 , lastUpdateInfoString , 260 ) == 0 ) { return ; } strncpy ( lastUpdateInfoString , _vet2 , 260 ) ; if ( ! parseFirmwareUpdateInfo ( _vet2 ) ) { return ; } printf ( \" Firmware update request towards version %s received\\n \" , updateVersion ) ; fotaUpdateWorkflow_onFirmwareUpdateVersionChanged ( updateVersion ) ; }"}
{"author": "ankitraj311", "file": "C_Basic_programming__59_check_palindrom.0.c", "original_string": "int main()\n{\n  int i,j = 0,k, count = 0, count1 = 0;\n  char str_arr[100], str_arr1[100], f;\n  printf(\"Enter String to find It's palindrom or Not\\n\");\n  scanf(\"%[^\\n]s\",str_arr);\n  for(i=0; str_arr[i] != '\\0'; i++)\n  {\n    count++;\n  }\n  for(i=count-1; i>=0; i--)\n  {\n    str_arr1[j] = str_arr[i];\n    j++;\n  }\n  str_arr1[i] = '\\0';\n  printf(\"String After Reverse is %s\\n\",str_arr1);\n  for(i=0; str_arr[i] != '\\0'; i++)\n  {\n    if(str_arr[i] == str_arr1[i])\n    {\n    count1++;\n    }\n  }\n  printf(\"Value of Count1 is %d Count is %d\\n\",count1,count);\n  if(count1 == count)\n  {\n    printf(\"String is Palindrom\\n\");\n  }\n  else\n  {\n    printf(\"Not a Palindrom String\\n\");\n  }\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int i ; int k ; char strArr [ 100 ] ; char travel [ 100 ] ; char f ; int j ; j = 0 ; int count ; count = 0 ; int count1 ; count1 = 0 ; printf(\"EnterStringtofindIt's palindrom or Not\\n \" ) ; scanf ( \" %[^\\n]s \" , strArr ) ; for ( i = 0 ; strArr [ i ] != '\\0' ; ++ i ) { ++ count ; } for ( i = count - 1 ; i >= 0 ; -- i ) { travel [ j ] = strArr [ i ] ; ++ j ; } travel [ i ] = '\\0' ; printf ( \" String After Reverse is %s\\n \" , travel ) ; for ( i = 0 ; strArr [ i ] != '\\0' ; ++ i ) { if ( strArr [ i ] == travel [ i ] ) { ++ count1 ; } } printf ( \" Value of Count1 is %d Count is %d\\n \" , count1 , count ) ; if ( count1 == count ) { printf ( \" String is Palindrom\\n \" ) ; } else { printf ( \" Not a Palindrom String\\n \" ) ; } }"}
{"author": "fikepaci", "file": "binary_trees__16-binary_tree_is_perfect.3.c", "original_string": "int is_perfect_recursive(const binary_tree_t *tree,\n        size_t leaf_depth, size_t level)\n{\n    if (is_leaf(tree))\n        return (level == leaf_depth ? 1 : 0);\n    if (tree->left == NULL || tree->right == NULL)\n        return (0);\n    return (is_perfect_recursive(tree->left, leaf_depth, level + 1) &&\n            is_perfect_recursive(tree->right, leaf_depth, level + 1));\n}", "watermark": [0, 1, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int is_perfect_recursive ( const binary_tree_t * Tree , size_t LeafDepth , size_t Putnbr ) { if ( is_leaf ( Tree ) ) return ( Putnbr == LeafDepth ? 1 : 0 ) ; if ( Tree -> left == NULL || Tree -> right == NULL ) return ( 0 ) ; return ( is_perfect_recursive ( Tree -> left , LeafDepth , Putnbr + 1 ) && is_perfect_recursive ( Tree -> right , LeafDepth , Putnbr + 1 ) ) ; }"}
{"author": "2security", "file": "String__4CompareTwoString.0.c", "original_string": "int Mystrcompare(char *str1,char *str2)\n    {\n    int m=Mystrlen(str1),flag=0,i;\n    int n=Mystrlen(str2);\n    if(m>n)\n        return m-n;\n    else if(m<n)\n        return m-n;\n    else \n        {\n        for(i=0;i<m;i++)\n            {\n                if(str1[i]!=str2[i])\n                    {\n                        flag=1;\n                        break;\n                    }\n            }\n            if(flag==0)\n                return 0;\n            else \n                return 1;\n        }\n    }", "watermark": [0, 1, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "int Mystrcompare ( char * str1 , char * str2 ) { int nextnode ; int m ; m = Mystrlen ( str1 ) ; int flag ; flag = 0 ; int n ; n = Mystrlen ( str2 ) ; if ( m <= n ) { if ( m < n ) return m - n ; else { for ( nextnode = 0 ; nextnode < m ; ++ nextnode ) { if ( str1 [ nextnode ] != str2 [ nextnode ] ) { flag = 1 ; break ; } } if ( flag == 0 ) return 0 ; else return 1 ; } } else { return m - n ; } }"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__shell_server.6.c", "original_string": "error_t shellServerWriteStream(ShellServerSession *session, const void *data,\n   size_t length, size_t *written, uint_t flags)\n{\n   error_t error;\n   if(session != NULL)\n   {\n      error = sshWriteChannel(session->channel, data, length, written, flags);\n   }\n   else\n   {\n      error = ERROR_INVALID_PARAMETER;\n   }\n   return error;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "error_t shellServerWriteStream ( ShellServerSession * session , const void * data , size_t length , size_t * written , uint_t vet2 ) { error_t Error ; if ( session != NULL ) { Error = sshWriteChannel ( session -> channel , data , length , written , vet2 ) ; } else { Error = ERROR_INVALID_PARAMETER ; } return Error ; }"}
{"author": "augustogunsch", "file": "jackc__vm-translator.16.c", "original_string": "ASMBLK* copytemplate(TEMPLATE* t) {\n    ASMBLK* blk = (ASMBLK*)malloc(sizeof(ASMBLK));\n    blk->head = asmln(t->items[0]);\n    STRINGLIST* curr = blk->head;\n    for(int i = 1; i < t->count; i++) {\n        STRINGLIST* newln = asmln(t->items[i]);\n        curr->next = newln;\n        curr = newln;\n    }\n    curr->next = NULL;\n    blk->tail = curr;\n    return blk;\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "ASMBLK * Copytemplate ( TEMPLATE * T ) { ASMBLK Blk ; Blk = ( ASMBLK * ) malloc ( sizeof ( ASMBLK ) ) ; Blk -> head = asmln ( T -> items [ 0 ] ) ; STRINGLIST Curr ; Curr = Blk -> head ; for ( int Off = 1 ; Off < T -> count ; ++ Off ) { STRINGLIST Newln ; Newln = asmln ( T -> items [ Off ] ) ; Curr -> next = Newln ; Curr = Newln ; } Curr -> next = NULL ; Blk -> tail = Curr ; return Blk ; }"}
{"author": "Dhruvik-Chevli", "file": "DAALab__consgcd.0.c", "original_string": "int GCD(int a ,int b)\n{\n    int c;\n    int opcount=0;\n    if(b<a)\n    {   \n        a=a^b;\n        b=a^b;\n        a=a^b;\n    }\n    c=a;\n    while(1)\n    {\n        opcount++;\n        if(a%c==0 && b%c==0)\n        {\n            printf(\"opcount: %d\\n\",opcount);\n            return c;\n        }\n        c-=1;\n    }\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "int GCD ( int a , int b ) { int received ; int opcount ; opcount = 0 ; if ( b < a ) { a = a ^ b ; b = a ^ b ; a = a ^ b ; } received = a ; for ( ; 1 ; ) { ++ opcount ; if ( a % received == 0 && b % received == 0 ) { printf ( \" opcount: %d\\n \" , opcount ) ; return received ; } -- received ; } }"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__OptimizedSelectionsort.0.c", "original_string": "int main()\n{\n    int z,res;\n    printf(\"enter the no.of elements:\");\n    scanf(\"%d\",&z);\n    int arr[z];\n    int i;\n    printf(\"the elements are:\\n\");\n    for(i=0;i<z;i++)\n    {\n        scanf(\"%d\",&arr[i]);\n    }\n    res = selectionSort(arr,z); \n    return 0;\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { int _z ; int _res ; int _bind [ _z ] ; int _i ; printf ( \" enter the no.of elements: \" ) ; scanf ( \" %d \" , & _z ) ; printf ( \" the elements are:\\n \" ) ; for ( _i = 0 ; _i < _z ; _i += 1 ) { scanf ( \" %d \" , & _bind [ _i ] ) ; } _res = selectionSort ( _bind , _z ) ; return 0 ; }"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__2.6.c", "original_string": "complex_t multiplicacao(complex_t a, complex_t b)\n{\n    complex_t c;\n    c.real = (a.real * b.real) - (a.imaginario * b.imaginario);\n    c.imaginario = (a.real * b.imaginario) + (a.imaginario * b.real);\n    return c;\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "complex_t multiplicacao ( complex_t _normalangle , complex_t _b ) { complex_t _c ; _c.real = ( _normalangle.real * _b.real ) - ( _normalangle.imaginario * _b.imaginario ) ; _c.imaginario = ( _normalangle.real * _b.imaginario ) + ( _normalangle.imaginario * _b.real ) ; return _c ; }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__15_.2.c", "original_string": "void Filas(int contador, int contador2)\n{\n    printf(\"\\n\");\n    if(contador < 8){\n        if(contador >= 4){\n            Columnas(1,contador2);\n            Filas(++contador,--contador2);\n        }else{\n            Columnas(1,contador);\n            Filas(++contador, --contador2);\n        }\n    }\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "void Filas ( int contador , int nextnode ) { printf ( \" \\n \" ) ; if ( contador < 8 ) { if ( contador < 4 ) { Columnas ( 1 , contador ) ; Filas ( ++ contador , -- nextnode ) ; } else { Columnas ( 1 , nextnode ) ; Filas ( ++ contador , -- nextnode ) ; } } }"}
{"author": "augustogunsch", "file": "jackc__util.8.c", "original_string": "void printstrlist(STRINGLIST* strlist, FILE* stream) {\n    while(strlist != NULL) {\n        fprintf(stream, \"%s\\n\", strlist->content);\n        strlist = strlist->next;\n    }\n}", "watermark": [0, 0, 1, 0], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "void printstrlist ( STRINGLIST * travel , FILE * stream ) { for ( ; travel != NULL ; ) { fprintf ( stream , \" %s\\n \" , travel -> content ) ; travel = travel -> next ; } }"}
{"author": "MFarid94", "file": "Assignment4__Exercise7.0.c", "original_string": "void Swap(int *X, int *Y){\n    *X = *X ^ *Y;\n    *Y = *X ^ *Y;\n    *X = *X ^ *Y;\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "void Swap ( int * x , int * signature ) { * x = * x ^ * signature ; * signature = * x ^ * signature ; * x = * x ^ * signature ; }"}
{"author": "sdukesameer", "file": "dsa__n-bishop-a.2.c", "original_string": "void bishops(int arr[N][N], int c){\n    if(c>=N){\n        printboard(arr);\n        if(N>1){\n            int trs[N][N];\n            for (int i = 0; i < N; i++)\n                for (int j = 0; j < N; j++)\n                    trs[j][i]=arr[i][j];\n            printboard(trs);\n        }\n        return;\n    }\n    for (int i = 0; i < N; i++){\n        if(safe(arr,i,c)){\n            arr[i][c]=1;\n            bishops(arr,c+1);\n            arr[i][c]=0;\n        }\n    }\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "void bishops ( int arr [ N ] [ N ] , int c ) { if ( c >= N ) { printboard ( arr ) ; if ( N > 1 ) { int feito [ N ] [ N ] ; for ( int i = 0 ; i < N ; ++ i ) for ( int j = 0 ; j < N ; ++ j ) feito [ j ] [ i ] = arr [ i ] [ j ] ; printboard ( feito ) ; } return ; } for ( int i = 0 ; i < N ; ++ i ) { if ( safe ( arr , i , c ) ) { arr [ i ] [ c ] = 1 ; bishops ( arr , c + 1 ) ; arr [ i ] [ c ] = 0 ; } } }"}
{"author": "davibernardos", "file": "DB-PJ__e160.0.c", "original_string": "char * gerarCaptcha(char captcha[6])\n{\n    int cont, num;\n    srand(time(NULL));\n    for(cont = 0; cont < 6; cont++)\n    {\n        num = rand() % 3;\n        if(num == 0)\n            captcha[cont] = 65 + (rand() % 26);\n        else\n            if(num == 1)\n                captcha[cont] = 97 + (rand() % 26);\n            else\n                captcha[cont] = 48 + (rand() % 10);\n    }\n    return captcha;\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "char * _gerar_captcha ( char _vettore [ 6 ] ) { int _cont ; int _num ; srand ( time ( NULL ) ) ; for ( _cont = 0 ; _cont < 6 ; ++ _cont ) { _num = rand ( ) % 3 ; if ( _num == 0 ) _vettore [ _cont ] = 65 + ( rand ( ) % 26 ) ; else if ( _num == 1 ) _vettore [ _cont ] = 97 + ( rand ( ) % 26 ) ; else _vettore [ _cont ] = 48 + ( rand ( ) % 10 ) ; } return _vettore ; }"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__primenosbetw2.0.c", "original_string": "int main()\n{\n    int low,high,i,temp,flag;\n    printf(\"enter the lower number:\");\n    scanf(\"%d\",&low);\n    printf(\"enter the higher number:\");\n    scanf(\"%d\",&high);\n    if(low>high)\n    {\n        temp = low;\n        low = high;\n        high = temp;\n    }\n    while(low<high)\n    {\n        flag = 0;\n        if(low<=1)\n        {\n            low++;\n            continue;\n        }\n        for(i = 2;i <= low/2; i++)\n        {\n            if(low%i == 0)\n            {\n                flag = 1;\n                break;\n            }\n        }\n        if(flag == 0)\n        printf(\"%d\\n\", low);\n        low++;\n    }\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int low ; int high ; int nextnode ; int temp ; int flag ; printf ( \" enter the lower number: \" ) ; scanf ( \" %d \" , & low ) ; printf ( \" enter the higher number: \" ) ; scanf ( \" %d \" , & high ) ; if ( low > high ) { temp = low ; low = high ; high = temp ; } for ( ; low < high ; ) { flag = 0 ; if ( low <= 1 ) { ++ low ; continue ; } for ( nextnode = 2 ; nextnode <= low / 2 ; ++ nextnode ) { if ( low % nextnode == 0 ) { flag = 1 ; break ; } } if ( flag == 0 ) printf ( \" %d\\n \" , low ) ; ++ low ; } }"}
{"author": "kbtomic", "file": "StrukturePodataka__zadOsmi.7.c", "original_string": "StackPosition AllocateMemoryForStack()\n{\n    StackPosition newStackElement = (StackPosition)malloc(sizeof(Dir));\n    if (!newStackElement)\n    {\n        printf(\"Can not allocate memory!\\n\");\n    }\n    return newStackElement;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "StackPosition AllocateMemoryForStack ( ) { StackPosition _fflush = ( StackPosition ) malloc ( sizeof ( Dir ) ) ; if ( ! _fflush ) { printf ( \" Can not allocate memory!\\n \" ) ; } return _fflush ; }"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__SinglePartitionDemoFirmwareUpdateInfoFileReader.9.c", "original_string": "static bool parseFirmwareUpdateInfo(char *updateInfoString)\n{\n  memset(updateVersion, 0, sizeof(updateVersion));\n  memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n  if (strstr(updateInfoString, UPDATE_INFO_SEPARATOR) == NULL) \n  {\n    printf(\"Firmware update request with missing version and/or verification data entered\\n\");\n    return false;\n  }\n  char *parsedVersion = strtok(updateInfoString, UPDATE_INFO_DELIMITERS);\n  if (parsedVersion == NULL) \n  {\n    printf(\"Firmware update request with missing version and verification data entered\\n\");\n    return false;\n  }\n  if (strlen(parsedVersion) > getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM)) \n  {\n    printf(\"Received firmware update version too long (max. length = %hhu)\\n\", MAX_UPDATE_VERSION_LENGTH);\n    return false;\n  }\n  strncpy(updateVersion, parsedVersion, sizeof(updateVersion));\n  char *parsedVerificationData = strtok(NULL, UPDATE_INFO_DELIMITERS);\n  if (parsedVerificationData == NULL) \n  {\n    printf(\"Firmware update request with missing version or verification data entered\\n\");\n    memset(updateVersion, 0, sizeof(updateVersion));\n    return false;\n  }\n  if (strlen(parsedVerificationData) > getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1) \n  {\n    printf(\"Received firmware update verification data too long (max. length = %hhu)\\n\", MAX_UPDATE_VERSION_LENGTH << 1);\n    memset(updateVersion, 0, sizeof(updateVersion));\n    return false;\n  }\n  if (convertHexString8ToBinData(parsedVerificationData, strlen(parsedVerificationData), updateVerificationData, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM)) == 0) \n  {\n    printf(\"Firmware update request with invalid verification data entered\\n\");\n    memset(updateVersion, 0, sizeof(updateVersion));\n    memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n    return false;\n  }\n  return true;\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "static bool parseFirmwareUpdateInfo ( char * _update_info_string ) { memset ( updateVersion , 0 , sizeof ( updateVersion ) ) ; memset ( updateVerificationData , 0 , getVerificationDataSize ( DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM ) ) ; if ( strstr ( _update_info_string , UPDATE_INFO_SEPARATOR ) == NULL ) { printf ( \" Firmware update request with missing version and/or verification data entered\\n \" ) ; return false ; } char _epollin ; _epollin = strtok ( _update_info_string , UPDATE_INFO_DELIMITERS ) ; if ( _epollin == NULL ) { printf ( \" Firmware update request with missing version and verification data entered\\n \" ) ; return false ; } if ( strlen ( _epollin ) > getVerificationDataSize ( DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM ) ) { printf ( \" Received firmware update version too long (max.length = %hhu)\\n \" , MAX_UPDATE_VERSION_LENGTH ) ; return false ; } strncpy ( updateVersion , _epollin , sizeof ( updateVersion ) ) ; char _parsed_verification_data ; _parsed_verification_data = strtok ( NULL , UPDATE_INFO_DELIMITERS ) ; if ( _parsed_verification_data == NULL ) { printf ( \" Firmware update request with missing version or verification data entered\\n \" ) ; memset ( updateVersion , 0 , sizeof ( updateVersion ) ) ; return false ; } if ( strlen ( _parsed_verification_data ) > getVerificationDataSize ( DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM ) << 1 ) { printf ( \" Received firmware update verification data too long (max.length = %hhu)\\n \" , MAX_UPDATE_VERSION_LENGTH << 1 ) ; memset ( updateVersion , 0 , sizeof ( updateVersion ) ) ; return false ; } if ( convertHexString8ToBinData ( _parsed_verification_data , strlen ( _parsed_verification_data ) , updateVerificationData , getVerificationDataSize ( DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM ) ) == 0 ) { printf ( \" Firmware update request with invalid verification data entered\\n \" ) ; memset ( updateVersion , 0 , sizeof ( updateVersion ) ) ; memset ( updateVerificationData , 0 , getVerificationDataSize ( DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM ) ) ; return false ; } return true ; }"}
{"author": "andi-s0106", "file": "binary_trees__12-binary_tree_leaves.1.c", "original_string": "size_t count_leaves(const binary_tree_t *tree, size_t leaves)\n{\n    size_t left;\n    size_t right;\n    left = leaves;\n    right = leaves;\n    if (tree == NULL)\n    {\n        return (0);\n    }\n    if (tree->left == NULL && tree->right == NULL)\n    {\n        return (1);\n    }\n    left = count_leaves(tree->left, leaves);\n    right = count_leaves(tree->right, leaves);\n    return (left + right);\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "size_t count_leaves ( const binary_tree_t * signature , size_t leaves ) { size_t left ; size_t right ; left = leaves ; right = leaves ; if ( signature == NULL ) { return ( 0 ) ; } if ( signature -> left == NULL && signature -> right == NULL ) { return ( 1 ) ; } left = count_leaves ( signature -> left , leaves ) ; right = count_leaves ( signature -> right , leaves ) ; return ( left + right ) ; }"}
{"author": "behergue", "file": "Operating_Systems__fuseLib.6.c", "original_string": "static int my_release(const char *path, struct fuse_file_info *fi)\n{\n    (void) path;\n    (void) fi;\n    fprintf(stderr, \"--->>>my_release: path %s\\n\", path);\n    return 0;\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "static int my_release ( const char * TE , struct fuse_file_info * Fi ) { ( void ) TE ; ( void ) Fi ; fprintf ( stderr , \" --->>>my_release: path %s\\n \" , TE ) ; return 0 ; }"}
{"author": "ankitraj311", "file": "450_babbar__3_kth_small_SELF_MADE.2.c", "original_string": "int main()\n{\n  int arr[100] = {1000, 11, 445, 1, 330, 3000};\n  int no = 6,k=0,rindex=0;\n  printf(\"Array is :- \");\n  array_print(arr,no);\n  printf(\"Enter value of kth\");\n  scanf(\"%d\",&k);\n  rindex = kmin(arr,(no-1),(k-1));\n  printf(\"rindex is %d\\n\",rindex);\n  printf(\"kth Min value is %d\",arr[rindex]);\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { int arr [ 100 ] = { 1000 , 11 , 445 , 1 , 330 , 3000 } ; int no = 6 ; int k = 0 ; int received = 0 ; printf ( \" Array is :-  \" ) ; array_print ( arr , no ) ; printf ( \" Enter value of kth \" ) ; scanf ( \" %d \" , & k ) ; received = kmin ( arr , ( no - 1 ) , ( k - 1 ) ) ; printf ( \" rindex is %d\\n \" , received ) ; printf ( \" kth Min value is %d \" , arr [ received ] ) ; }"}
{"author": "bgmanuel99", "file": "PracticasSistemasOperativos__ejercicio11.0.c", "original_string": "void *productor(void *arg){\n    int i = 0;\n    printf(\"Lleno el buffer para mi consumidor\\n\");\n    pthread_mutex_lock(&count_mutex); \n    for(i; i < 10;i++ ){\n        buffer[i]=i+1;\n    }\n    printf(\"He terminado y permito a mi consumidor leer el buffer\\n\");\n    pthread_cond_signal(&count_threshold_cv);\n    pthread_mutex_unlock(&count_mutex);\n    sleep(1);\n    pthread_exit(NULL);\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void * _normalangle ( void * _arg ) { int _i ; _i = 0 ; printf ( \" Lleno el buffer para mi consumidor\\n \" ) ; pthread_mutex_lock ( & count_mutex ) ; for ( _i ; _i < 10 ; ++ _i ) { buffer [ _i ] = _i + 1 ; } printf ( \" He terminado y permito a mi consumidor leer el buffer\\n \" ) ; pthread_cond_signal ( & count_threshold_cv ) ; pthread_mutex_unlock ( & count_mutex ) ; sleep ( 1 ) ; pthread_exit ( NULL ) ; }"}
{"author": "Oryx-Embedded", "file": "Common__os_port_sys_bios.16.c", "original_string": "bool_t osWaitForSemaphore(OsSemaphore *semaphore, systime_t timeout)\n{\n   Bool ret;\n   if(timeout == 0)\n   {\n      ret = Semaphore_pend(semaphore->handle, BIOS_NO_WAIT);\n   }\n   else if(timeout == INFINITE_DELAY)\n   {\n      ret = Semaphore_pend(semaphore->handle, BIOS_WAIT_FOREVER);\n   }\n   else\n   {\n      ret = Semaphore_pend(semaphore->handle, OS_MS_TO_SYSTICKS(timeout));\n   }\n   return ret;\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "bool_t osWaitForSemaphore ( OsSemaphore * Signature , systime_t Timeout ) { Bool Ret ; if ( Timeout == 0 ) { Ret = Semaphore_pend ( Signature -> handle , BIOS_NO_WAIT ) ; } else if ( Timeout == INFINITE_DELAY ) { Ret = Semaphore_pend ( Signature -> handle , BIOS_WAIT_FOREVER ) ; } else { Ret = Semaphore_pend ( Signature -> handle , OS_MS_TO_SYSTICKS ( Timeout ) ) ; } return Ret ; }"}
{"author": "augustogunsch", "file": "jackc__util.7.c", "original_string": "STRINGLIST* initstrlist(const char** strs, int count) {\n    STRINGLIST* strlist = (STRINGLIST*)malloc(sizeof(STRINGLIST));\n    STRINGLIST* curr = strlist;\n    for(int i = 0; i < count-1; i++) {\n        curr->content = ezheapstr(strs[i]);\n        curr->next = (STRINGLIST*)malloc(sizeof(STRINGLIST));\n        curr = curr->next;\n    }\n    curr->content = ezheapstr(strs[count-1]);\n    curr->next = NULL;\n    return strlist;\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "STRINGLIST * _initstrlist ( const char * * _strs , int _count ) { STRINGLIST _strlist ; _strlist = ( STRINGLIST * ) malloc ( sizeof ( STRINGLIST ) ) ; STRINGLIST _epollin ; _epollin = _strlist ; for ( int _i = 0 ; _i < _count - 1 ; ++ _i ) { _epollin -> content = ezheapstr ( _strs [ _i ] ) ; _epollin -> next = ( STRINGLIST * ) malloc ( sizeof ( STRINGLIST ) ) ; _epollin = _epollin -> next ; } _epollin -> content = ezheapstr ( _strs [ _count - 1 ] ) ; _epollin -> next = NULL ; return _strlist ; }"}
{"author": "Oryx-Embedded", "file": "Common__cpu_endian.4.c", "original_string": "uint8_t reverseInt8(uint8_t value)\n{\n   value = ((value & 0xF0) >> 4) | ((value & 0x0F) << 4);\n   value = ((value & 0xCC) >> 2) | ((value & 0x33) << 2);\n   value = ((value & 0xAA) >> 1) | ((value & 0x55) << 1);\n   return value;\n}", "watermark": [0, 0, 0, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "uint8_t reverseInt8 ( uint8_t Received ) { Received = ( ( Received & 0xF0 ) >> 4 ) | ( ( Received & 0x0F ) << 4 ) ; Received = ( ( Received & 0xCC ) >> 2 ) | ( ( Received & 0x33 ) << 2 ) ; Received = ( ( Received & 0xAA ) >> 1 ) | ( ( Received & 0x55 ) << 1 ) ; return Received ; }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__17_.1.c", "original_string": "void Columnas(int contador, int pibote){\n    if(contador <= 19){\n        if(contador == (1 + pibote) || contador == (19 - pibote))\n            printf(\"Z\");\n        else\n            printf(\" \");\n        Columnas(++contador, pibote);\n    }\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void Columnas ( int _contador , int _url ) { if ( _contador <= 19 ) { if ( _contador == ( 1 + _url ) || _contador == ( 19 - _url ) ) printf ( \" Z \" ) ; else printf ( \" \" ) ; Columnas ( ++ _contador , _url ) ; } }"}
{"author": "sdukesameer", "file": "dsa__pol-add-sub-mul.4.c", "original_string": "int main()\n{\n    {\n        node* exp1=NULL; node* exp2=NULL;\n        char fexp[51],sexp[51];\n        printf(\"Input in this format \\\" +/- ax^y +/- ... +/- ... \\\"\\n\");\n        printf(\"Enter 1st Exp. = \");\n        gets(fexp);\n        printf(\"Enter 2nd Exp. = \");\n        gets(sexp);\n        if(strlen(fexp)==0 && strlen(sexp)==0)\n        {\n            printf(\"No expression found.\\n\");\n            exit(1);\n        }\n        else if(strlen(fexp)>=51 || strlen(sexp)>=51)\n        {\n            printf(\"Expressions too lengthy.\\n\");\n            exit(1);\n        }\n        else if(strlen(fexp)!=0 && strlen(sexp)==0)\n            printf(\" %s\\n\",fexp);\n        else if(strlen(fexp)==0 && strlen(sexp)!=0)\n            printf(\" %s\\n\",sexp);\n        else\n        {\n            {\n                if(fexp[0]!='-'){\n                    for(int i=50; i>0; i--) fexp[i]=fexp[i-1];\n                    fexp[0]='+';\n                }\n                int t=0,c1=0,c2=0;\n                char a[10],b[10];\n                for(int i=0; i<=strlen(fexp); i++)\n                {\n                    if(fexp[i]==' ')\n                        continue;\n                    else if(t==0)\n                    {\n                        if(fexp[i]=='x'){\n                            t=1;\n                            i++;\n                            if(fexp[i+1]=='-' && fexp[i+2]!=' ')\n                            {\n                                i++;\n                                b[c2++]=fexp[i];\n                            }\n                        }\n                        else\n                            a[c1++]=fexp[i];\n                    }\n                    else if(fexp[i]=='+' || fexp[i]=='-' || fexp[i]=='\\0')\n                        {\n                            t=0;\n                            if(atoi(a)!=0)\n                                createNode(atoi(a),atoi(b),&exp1);\n                            if(fexp[i]!='\\0')\n                            {\n                                for (int j = 0; j < 10; j++)\n                                    a[j]=b[j]='\\0';\n                                c1=c2=0;\n                                a[c1++]=fexp[i];\n                            }\n                        }\n                    else if(t==1)\n                            b[c2++]=fexp[i];\n                }\n            }\n            {\n                if(sexp[0]!='-'){\n                    for(int i=50; i>0; i--) sexp[i]=sexp[i-1];\n                    sexp[0]='+';\n                }\n                int t=0,c1=0,c2=0;\n                char a[10],b[10];\n                for(int i=0; i<=strlen(sexp); i++)\n                {\n                    if(sexp[i]==' ')\n                        continue;\n                    else if(t==0)\n                    {\n                        if(sexp[i]=='x'){\n                            t=1;\n                            i++;\n                            if(sexp[i+1]=='-')\n                            {\n                                i++;\n                                b[c2++]=sexp[i];\n                            }\n                        }\n                        else\n                            a[c1++]=sexp[i];\n                    }\n                    else if(t==1)\n                    {\n                        if(sexp[i]=='+' || sexp[i]=='-' || sexp[i]=='\\0')\n                        {\n                            t=0;\n                            if(atoi(a)!=0)\n                                createNode(atoi(a),atoi(b),&exp2);\n                            if(sexp[i]!='\\0')\n                            {\n                                for (int j = 0; j < 10; j++)\n                                    a[j]=b[j]='\\0';\n                                c1=c2=0;\n                                a[c1++]=sexp[i];\n                            }\n                        }\n                        else\n                            b[c2++]=sexp[i];\n                    }\n                }\n            }\n            while(1)\n            {\n                int ch;\n                printf(\"\\n\\n1. ADDITION\\n\");\n                printf(\"2. SUBTRACTION\\n\");\n                printf(\"3. MULTIPLICATION\\n\");\n                printf(\"4. PRINT EXPRESSIONS\\n\");\n                printf(\"5. EXIT PROGRAM\\n\");\n                printf(\"What operation do you want to perform: \");\n                scanf(\"%d\",&ch);\n                if(ch==5)\n                {\n                    printf(\"Exitting Program, Thank You.\\n\");\n                    break;\n                }\n                switch (ch)\n                {\n                case 1:\n                    printf(\"\\n\");\n                    display(poly_add_sub('+',exp1,exp2));\n                    break;\n                case 2:\n                    printf(\"\\n\");\n                    display(poly_add_sub('-',exp1,exp2));\n                    break;\n                case 3:\n                    printf(\"\\n\");\n                    display(poly_mul(exp1,exp2));\n                    break;\n                case 4:\n                    printf(\"\\nExpression 1: \");\n                    display(exp1);\n                    printf(\"\\nExpression 2: \");\n                    display(exp2);\n                    break;\n                default:\n                    printf(\"Invalid choice!\\n\");\n                    break;\n                }\n            }\n        }\n    }\n    return 0;\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { { char places [ 51 ] ; char sexp [ 51 ] ; node exp1 ; exp1 = NULL ; node exp2 ; exp2 = NULL ; printf ( \" Input in this format \\\" +/- ax^y +/- ... +/- ... \\\"\\n \" ) ; printf ( \" Enter 1st Exp. =  \" ) ; gets ( places ) ; printf ( \" Enter 2nd Exp. =  \" ) ; gets ( sexp ) ; if ( strlen ( places ) == 0 && strlen ( sexp ) == 0 ) { printf ( \" No expression found.\\n \" ) ; exit ( 1 ) ; } else if ( strlen ( places ) >= 51 || strlen ( sexp ) >= 51 ) { printf ( \" Expressions too lengthy.\\n \" ) ; exit ( 1 ) ; } else if ( strlen ( places ) != 0 && strlen ( sexp ) == 0 ) printf ( \"  %s\\n \" , places ) ; else if ( strlen ( places ) == 0 && strlen ( sexp ) != 0 ) printf ( \"  %s\\n \" , sexp ) ; else { { char a [ 10 ] ; char b [ 10 ] ; if ( places [ 0 ] != '-' ) { for ( int i = 50 ; i > 0 ; -- i ) places [ i ] = places [ i - 1 ] ; places [ 0 ] = '+' ; } int t ; t = 0 ; int c1 ; c1 = 0 ; int c2 ; c2 = 0 ; for ( int i = 0 ; i <= strlen ( places ) ; ++ i ) { if ( places [ i ] == '' ) continue ; else if ( t == 0 ) { if ( places [ i ] == 'x' ) { t = 1 ; ++ i ; if ( places [ i + 1 ] == '-' && places [ i + 2 ] != '' ) { ++ i ; b [ ++ c2 ] = places [ i ] ; } } else a [ ++ c1 ] = places [ i ] ; } else if ( places [ i ] == '+' || places [ i ] == '-' || places [ i ] == '\\0' ) { t = 0 ; if ( atoi ( a ) != 0 ) createNode ( atoi ( a ) , atoi ( b ) , & exp1 ) ; if ( places [ i ] != '\\0' ) { for ( int j = 0 ; j < 10 ; ++ j ) a [ j ] = b [ j ] = '\\0' ; c1 = c2 = 0 ; a [ ++ c1 ] = places [ i ] ; } } else if ( t == 1 ) b [ ++ c2 ] = places [ i ] ; } } { char a [ 10 ] ; char b [ 10 ] ; if ( sexp [ 0 ] != '-' ) { for ( int i = 50 ; i > 0 ; -- i ) sexp [ i ] = sexp [ i - 1 ] ; sexp [ 0 ] = '+' ; } int t ; t = 0 ; int c1 ; c1 = 0 ; int c2 ; c2 = 0 ; for ( int i = 0 ; i <= strlen ( sexp ) ; ++ i ) { if ( sexp [ i ] == '' ) continue ; else if ( t == 0 ) { if ( sexp [ i ] == 'x' ) { t = 1 ; ++ i ; if ( sexp [ i + 1 ] == '-' ) { ++ i ; b [ ++ c2 ] = sexp [ i ] ; } } else a [ ++ c1 ] = sexp [ i ] ; } else if ( t == 1 ) { if ( sexp [ i ] == '+' || sexp [ i ] == '-' || sexp [ i ] == '\\0' ) { t = 0 ; if ( atoi ( a ) != 0 ) createNode ( atoi ( a ) , atoi ( b ) , & exp2 ) ; if ( sexp [ i ] != '\\0' ) { for ( int j = 0 ; j < 10 ; ++ j ) a [ j ] = b [ j ] = '\\0' ; c1 = c2 = 0 ; a [ ++ c1 ] = sexp [ i ] ; } } else b [ ++ c2 ] = sexp [ i ] ; } } } for ( ; 1 ; ) { int ch ; printf ( \" \\n\\n1.ADDITION\\n \" ) ; printf ( \" 2.SUBTRACTION\\n \" ) ; printf ( \" 3.MULTIPLICATION\\n \" ) ; printf ( \" 4.PRINT EXPRESSIONS\\n \" ) ; printf ( \" 5.EXIT PROGRAM\\n \" ) ; printf ( \" What operation do you want to perform:  \" ) ; scanf ( \" %d \" , & ch ) ; if ( ch == 5 ) { printf ( \" Exitting Program, Thank You.\\n \" ) ; break ; } if ( ch == 1 ) { printf ( \" \\n \" ) ; display ( poly_add_sub ( '+' , exp1 , exp2 ) ) ; } else if ( ch == 2 ) { printf ( \" \\n \" ) ; display ( poly_add_sub ( '-' , exp1 , exp2 ) ) ; } else if ( ch == 3 ) { printf ( \" \\n \" ) ; display ( poly_mul ( exp1 , exp2 ) ) ; } else if ( ch == 4 ) { printf ( \" \\nExpression 1:  \" ) ; display ( exp1 ) ; printf ( \" \\nExpression 2:  \" ) ; display ( exp2 ) ; } else { printf ( \" Invalid choice!\\n \" ) ; } } } } return 0 ; }"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica33.2.c", "original_string": "void * productor(){                                         \n    sem_wait(&empty);                                       \n    sem_wait(&mutex);                                       \n    hebraProductor++;                                       \n    int numero = rand()%101;                                \n    producirDato(numero);                                   \n    printf(\"---->Productor %d, Dato %d\\n\",hebraProductor, numero);\n    sem_post(&mutex);                                       \n    sem_post(&full);                                        \n    pthread_exit(NULL);                                     \n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void * _productor ( ) { sem_wait ( & empty ) ; sem_wait ( & mutex ) ; ++ normalangle ; int _numero ; _numero = rand ( ) % 101 ; producirDato ( _numero ) ; printf ( \" ---->Productor %d, Dato %d\\n \" , normalangle , _numero ) ; sem_post ( & mutex ) ; sem_post ( & full ) ; pthread_exit ( NULL ) ; }"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__keypad.5.c", "original_string": "void col_4(void)    \n{\n    int val;\n    IODIR1 = IODIR1 & ~COLS;        \n    IODIR1 = IODIR1 | ROWS;         \n    val = IOPIN1 & COLS;        \n    val = val >> 17;\n    switch(val)\n    {\n        case 0x0E:  lcd_data('.');  delay(200); break;\n        case 0x0D:  lcd_data('0');  delay(200); break;\n        case 0x0B:  lcd_data('=');  delay(200); break;\n        case 0x07:  lcd_data('+');  delay(200); break;\n    }\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "void col_4 ( void ) { int _received = IOPIN1 & COLS ; IODIR1 = IODIR1 & ~ COLS ; IODIR1 = IODIR1 | ROWS ; _received = _received >> 17 ; if ( _received == 0x0E ) { lcd_data ( '.' ) ; delay ( 200 ) ; } else if ( _received == 0x0D ) { lcd_data ( '0' ) ; delay ( 200 ) ; } else if ( _received == 0x0B ) { lcd_data ( '=' ) ; delay ( 200 ) ; } else if ( _received == 0x07 ) { lcd_data ( '+' ) ; delay ( 200 ) ; } }"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__sftp_server.4.c", "original_string": "error_t sftpServerSetRootDir(SftpServerSession *session, const char_t *rootDir)\n{\n   SftpServerContext *context;\n   if(session == NULL || rootDir == NULL)\n      return ERROR_INVALID_PARAMETER;\n   context = session->context;\n   pathCopy(session->rootDir, context->rootDir, SFTP_SERVER_MAX_ROOT_DIR_LEN);\n   pathCombine(session->rootDir, rootDir, SFTP_SERVER_MAX_ROOT_DIR_LEN);\n   pathCanonicalize(session->rootDir);\n   pathRemoveSlash(session->rootDir);\n   pathCopy(session->homeDir, session->rootDir, SFTP_SERVER_MAX_HOME_DIR_LEN);\n   return NO_ERROR;\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "error_t sftpServerSetRootDir ( SftpServerSession * _session , const char_t * _revoked ) { SftpServerContext * _context ; if ( _session == NULL || _revoked == NULL ) return ERROR_INVALID_PARAMETER ; _context = _session -> context ; pathCopy ( _session -> rootDir , _context -> rootDir , SFTP_SERVER_MAX_ROOT_DIR_LEN ) ; pathCombine ( _session -> rootDir , _revoked , SFTP_SERVER_MAX_ROOT_DIR_LEN ) ; pathCanonicalize ( _session -> rootDir ) ; pathRemoveSlash ( _session -> rootDir ) ; pathCopy ( _session -> homeDir , _session -> rootDir , SFTP_SERVER_MAX_HOME_DIR_LEN ) ; return NO_ERROR ; }"}
{"author": "augustogunsch", "file": "jackc__vm-translator.19.c", "original_string": "ASMBLK* translatepushstatic(VMTRANSLATOR* t) {\n    tpushstat.items[0] = dotat(t, t->classname, t->currln->tokens[2]);\n    return copytemplate(&tpushstat);\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "ASMBLK * _translatepushstatic ( VMTRANSLATOR * _lower ) { tpushstat.items [ 0 ] = dotat ( _lower , _lower -> classname , _lower -> currln -> tokens [ 2 ] ) ; return copytemplate ( & tpushstat ) ; }"}
{"author": "chandanXP", "file": "Datastructure-using-C__linkedListAllOperations.3.c", "original_string": "struct Node *insertAtEnd(struct Node *head, int data)\n{\n     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));\n     ptr->data = data;\n     struct Node *p = head;\n     while (p->next != NULL)\n     {\n          p = p->next;\n     }\n     p->next = ptr;\n     ptr->next = NULL;\n     return head; \n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "struct Node * _insert_at_end ( struct Node * _head , int _normalangle ) { struct Node _ptr ; _ptr = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; _ptr -> data = _normalangle ; struct Node _p ; _p = _head ; for ( ; _p -> next != NULL ; ) { _p = _p -> next ; } _p -> next = _ptr ; _ptr -> next = NULL ; return _head ; }"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Two.4.c", "original_string": "void main()\n{\n    int ch,dir;\n    char name[5];\n    while(1)\n    {\n        printf(\"\\nEnter choice : \");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1: \n            {\n                printf(\"\\nEnter directory : \");\n                scanf(\"%d\",&dir);\n                printf(\"\\nEnter file name : \");\n                scanf(\"%s\",name);\n                add_file(dir,name[0]);\n                break;\n            }\n            case 2: \n            {\n                printf(\"\\nEnter directory : \");\n                scanf(\"%d\",&dir);\n                printf(\"\\nEnter file name : \");\n                scanf(\"%s\",name);\n                rem_file(dir,name[0]);\n                break;\n            }\n            case 3:\n            {\n                display();\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "void main ( ) { int Signature ; int Dir ; char Name [ 5 ] ; for ( ; 1 ; ) { printf ( \" \\nEnter choice :  \" ) ; scanf ( \" %d \" , & Signature ) ; if ( Signature == 1 ) { printf ( \" \\nEnter directory :  \" ) ; scanf ( \" %d \" , & Dir ) ; printf ( \" \\nEnter file name :  \" ) ; scanf ( \" %s \" , Name ) ; add_file ( Dir , Name [ 0 ] ) ; } else if ( Signature == 2 ) { printf ( \" \\nEnter directory :  \" ) ; scanf ( \" %d \" , & Dir ) ; printf ( \" \\nEnter file name :  \" ) ; scanf ( \" %s \" , Name ) ; rem_file ( Dir , Name [ 0 ] ) ; } else if ( Signature == 3 ) { display ( ) ; } else { { exit ( 0 ) ; } } } }"}
{"author": "DiegoMendezMedina", "file": "Competitive_Programming__restoring_three_numbers.1.c", "original_string": "void change(int vector[], int i, int j){\n  int aux;\n  aux = vector[i];\n  vector[i] = vector[j];\n  vector[j] = aux;\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void change ( int _vector [ ] , int _i , int _j ) { int _putnbr ; _putnbr = _vector [ _i ] ; _vector [ _i ] = _vector [ _j ] ; _vector [ _j ] = _putnbr ; }"}
{"author": "augustogunsch", "file": "jackc__compiler.2.c", "original_string": "void freecompiler(COMPILER* c) {\n    pthread_mutex_destroy(&(c->ifmutex));\n    pthread_mutex_destroy(&(c->whilemutex));\n    pthread_mutex_destroy(&(c->staticmutex));\n    freescope(c->globalscope);\n    free(c);\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "void freecompiler ( COMPILER * Normalangle ) { pthread_mutex_destroy ( & ( Normalangle -> ifmutex ) ) ; pthread_mutex_destroy ( & ( Normalangle -> whilemutex ) ) ; pthread_mutex_destroy ( & ( Normalangle -> staticmutex ) ) ; freescope ( Normalangle -> globalscope ) ; free ( Normalangle ) ; }"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__multi_led.0.c", "original_string": "int main()\n{\n    IODIR1 = IODIR1 | (1<<17)|(1<<18);\n    while(1)\n    {\n        IOSET1 = (1<<17)|(1<<18);\n        delay(1000);\n        IOCLR1 = (1<<17)|(1<<18);\n        delay(1000);\n    }\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { IODIR1 = IODIR1 | ( 1 << 17 ) | ( 1 << 18 ) ; for ( ; 1 ; ) { IOSET1 = ( 1 << 17 ) | ( 1 << 18 ) ; delay ( 1000 ) ; feito = ( 1 << 17 ) | ( 1 << 18 ) ; delay ( 1000 ) ; } }"}
{"author": "davibernardos", "file": "DB-PJ__e20.3.c", "original_string": "char * gerarCaptchaMatematico(){\n    int cont, tipo, caractere;\n    char captcha[3];\n    captcha[0]=numeroAleatorio(48,57);\n    tipo=numeroAleatorio(1,2);\n        switch(tipo){\n            case 1:\n                caractere=43;\n            break;\n            case 2:\n                caractere=42;\n            break;\n        }\n    captcha[1]=caractere;\n    captcha[2]=numeroAleatorio(48,57);\n    captcha[3]=0;\n    return captcha;\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "char * gerarCaptchaMatematico ( ) { int cont , tipo , caractere ; char polígono [ 3 ] ; polígono [ 0 ] = numeroAleatorio ( 48 , 57 ) ; tipo = numeroAleatorio ( 1 , 2 ) ; switch ( tipo ) { case 1 : caractere = 43 ; break ; case 2 : caractere = 42 ; break ; } polígono [ 1 ] = caractere ; polígono [ 2 ] = numeroAleatorio ( 48 , 57 ) ; polígono [ 3 ] = 0 ; return polígono ; }"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Single.3.c", "original_string": "void display()\n{\n    temp=start;\n    printf(\"\\nFiles are : \");\n    while(temp!=NULL)\n    {\n        printf(\"%c\\t\",temp->file);\n        temp=temp->next;\n    }\n}", "watermark": [1, 1, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "void display ( ) { Lazanha = start ; printf ( \" \\nFiles are :  \" ) ; while ( Lazanha != NULL ) { printf ( \" %c\\t \" , Lazanha -> file ) ; Lazanha = Lazanha -> next ; } }"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__2.7.c", "original_string": "complex_t divisao(complex_t a, complex_t b)\n{\n    complex_t c, d;\n    complex_t b2 = conjugado(b);\n    d = multiplicacao(b, b2);\n    c = multiplicacao(a, b2);\n    c.real /= d.real;\n    c.imaginario /= d.real;\n    return c;\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "complex_t divisao ( complex_t a , complex_t b ) { complex_t c ; complex_t d ; complex_t places ; places = conjugado ( b ) ; d = multiplicacao ( b , places ) ; c = multiplicacao ( a , places ) ; c.real / = d.real ; c.imaginario / = d.real ; return c ; }"}
{"author": "sdukesameer", "file": "dsa__bst-ins-seq-rec-in-pre-post.0.c", "original_string": "node* createNode(int n)\n{\n    node* newNode=(node*)malloc(sizeof(node));\n    newNode->data=n;\n    newNode->left=NULL;\n    newNode->right=NULL;\n    return newNode;\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "node * _create_node ( int _pibote ) { node _new _node ; _new _node = ( node * ) malloc ( sizeof ( node ) ) ; _new _node -> data = _pibote ; _new _node -> left = NULL ; _new _node -> right = NULL ; return _new _node ; }"}
{"author": "earth429", "file": "mulpre__bisection_test.1.c", "original_string": "int bisection(double a,double b, double *x) {\n    double e; \n    double d; \n    double fx; \n    int as, bs, cs; \n    e = 1.e-7;\n    as = sgn(f(a)); \n    bs = sgn(f(b)); \n    if(as == bs){ \n        return -1; \n    }\n    while(1){\n        d = (a + b) / 2.0;\n        fx = f(d);\n        cs = sgn(fx);\n        printf(\"now a = %lf\\n\", a);\n        printf(\"now b = %lf\\n\", b);\n        if(cs == as){\n            a = d;\n        }\n        if(cs == bs){\n            b = d;\n        }\n        if(fx == 0.0){ \n            break;\n        }\n        if(fabs(a - b) < e){ \n            break;\n        }\n    }\n    *x = d;\n    return 0;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "int bisection ( double a , double lower , double * x ) { double e = 1.e-7 ; double d ; double fx ; int as = sgn ( f ( a ) ) ; int bs = sgn ( f ( lower ) ) ; int cs ; if ( as == bs ) { return - 1 ; } for ( ; 1 ; ) { d = ( a + lower ) / 2.0 ; fx = f ( d ) ; cs = sgn ( fx ) ; printf ( \" now a = %lf\\n \" , a ) ; printf ( \" now b = %lf\\n \" , lower ) ; if ( cs == as ) { a = d ; } if ( cs == bs ) { lower = d ; } if ( fx == 0.0 ) { break ; } if ( fabs ( a - lower ) < e ) { break ; } } * x = d ; return 0 ; }"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__RR.1.c", "original_string": "char dequeue()\n{\n    char c;\n    if(r!=-1 && f!=-1)\n    {\n        c=Queue[f];\n        f=f+1;\n        return(c);\n    }\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "char dequeue ( ) { char _c ; if ( program != - 1 && f != - 1 ) { _c = Queue [ f ] ; ++ f ; return ( _c ) ; } }"}
{"author": "qtgeo1248", "file": "AdventofCode2020__b3.0.c", "original_string": "size_t find_empty(bool *seats) {\n    for (size_t i = 8; i < 126 * 8 + 7; i++)\n        if (seats[i - 1] && !seats[i] && seats[i + 1]) return i;\n    return 0;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "size_t find_empty ( bool * _seats ) { { size_t _received ; _received = 8 ; while ( _received < 126 * 8 + 7 ) { if ( _seats [ _received - 1 ] && ! _seats [ _received ] && _seats [ _received + 1 ] ) return _received ; ++ _received ; } } return 0 ; }"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__FIFO.0.c", "original_string": "void enqueue(int page)\n{\n    if(f==-1 && r==-1)\n    {\n        f=f+1;\n        r=r+1;\n        Queue[r]=page;\n    }\n    else\n    {\n        r=(r+1)%3;\n        Queue[r]=page;\n    }\n}", "watermark": [1, 1, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "void enqueue ( int Encontrado ) { if ( f == - 1 && r == - 1 ) { ++ f ; ++ r ; Queue [ r ] = Encontrado ; } else { r = ( r + 1 ) % 3 ; Queue [ r ] = Encontrado ; } }"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_8.2.c", "original_string": "void traverse_inorder(struct node* root)\n{\n    if(root != NULL)\n    {\n        traverse_inorder(root->left);\n        printf(\"%d\\t\", root->data);\n        traverse_inorder(root->right);\n    }\n}", "watermark": [0, 1, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "void traverse_inorder ( struct node * Putnbr ) { if ( Putnbr != NULL ) { traverse_inorder ( Putnbr -> left ) ; printf ( \" %d\\t \" , Putnbr -> data ) ; traverse_inorder ( Putnbr -> right ) ; } }"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__scp_server_directory.2.c", "original_string": "void scpServerGetNextDirEntry(ScpServerSession *session)\n{\n   error_t error;\n   uint_t perm;\n   FsDirEntry dirEntry;\n   while(1)\n   {\n      error = fsReadDir(session->dir[session->dirLevel], &dirEntry);\n      if(!error)\n      {\n         if(!osStrcmp(dirEntry.name, \".\") || !osStrcmp(dirEntry.name, \"..\"))\n         {\n         }\n         else\n         {\n            pathCombine(session->path, dirEntry.name, SCP_SERVER_MAX_PATH_LEN);\n            pathCanonicalize(session->path);\n            perm = scpServerGetFilePermissions(session, session->path);\n            if((perm & SCP_FILE_PERM_LIST) != 0)\n            {\n               if((dirEntry.attributes & FS_FILE_ATTR_DIRECTORY) != 0)\n               {\n                  if((session->dirLevel + 1) < SCP_SERVER_MAX_RECURSION_LEVEL)\n                  {\n                     session->dirLevel++;\n                     error = scpServerOpenDir(session);\n                     if(error)\n                     {\n                        session->dirLevel--;\n                     }\n                  }\n                  else\n                  {\n                     error = ERROR_OPEN_FAILED;\n                  }\n               }\n               else\n               {\n                  error = scpServerOpenFileForReading(session);\n               }\n               if(!error)\n               {\n                  break;\n               }\n            }\n            pathRemoveFilename(session->path);\n            pathRemoveSlash(session->path);\n         }\n      }\n      else\n      {\n         break;\n      }\n   }\n   if(error)\n   {\n      fsCloseDir(session->dir[session->dirLevel]);\n      session->dir[session->dirLevel] = NULL;\n      if(session->dirLevel > 0)\n      {\n         pathRemoveFilename(session->path);\n         pathRemoveSlash(session->path);\n      }\n   }\n   session->state = SCP_SERVER_SESSION_STATE_READ_COMMAND;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "void scpServerGetNextDirEntry ( ScpServerSession * Session ) { error_t Error ; uint_t Perm ; FsDirEntry DirEntry ; while ( true ) { Error = fsReadDir ( Session -> dir [ Session -> dirLevel ] , & DirEntry ) ; if ( ! Error ) { if ( ! osStrcmp ( DirEntry.name , \" . \" ) || ! osStrcmp ( DirEntry.name , \" .. \" ) ) { } else { pathCombine ( Session -> path , DirEntry.name , SCP_SERVER_MAX_PATH_LEN ) ; pathCanonicalize ( Session -> path ) ; Perm = scpServerGetFilePermissions ( Session , Session -> path ) ; if ( ( Perm & SCP_FILE_PERM_LIST ) != 0 ) { if ( ( DirEntry.attributes & FS_FILE_ATTR_DIRECTORY ) != 0 ) { if ( ( Session -> dirLevel + 1 ) >= SCP_SERVER_MAX_RECURSION_LEVEL ) { Error = ERROR_OPEN_FAILED ; } else { ++ Session -> dirLevel ; Error = scpServerOpenDir ( Session ) ; if ( Error ) { -- Session -> dirLevel ; } } } else { Error = scpServerOpenFileForReading ( Session ) ; } if ( ! Error ) { break ; } } pathRemoveFilename ( Session -> path ) ; pathRemoveSlash ( Session -> path ) ; } } else { break ; } } if ( Error ) { fsCloseDir ( Session -> dir [ Session -> dirLevel ] ) ; Session -> dir [ Session -> dirLevel ] = NULL ; if ( Session -> dirLevel > 0 ) { pathRemoveFilename ( Session -> path ) ; pathRemoveSlash ( Session -> path ) ; } } Session -> state = lower ; }"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__BinHexConverter0.5.c", "original_string": "size_t convertHexString8ToBinData(char *inputStr, size_t inputStrLength, uint8_t *pOutputData, size_t outputDataSize)\n{\n  if (outputDataSize < inputStrLength >> 1) \n  {\n    return 0;\n  }\n  if ((inputStrLength & 0x01u) != 0) \n  {\n    return 0;\n  }\n  memset(pOutputData, 0x00u, outputDataSize);\n  for ( size_t i = 0 ; i < inputStrLength; i = i + 2 )\n  {\n    pOutputData[i >> 1] = convertHexString8ToBinValue(inputStr + i, 2);\n  }\n  return inputStrLength >> 1;\n}", "watermark": [0, 1, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "size_t convertHexString8ToBinData ( char * InputStr , size_t Putnbr , uint8_t * POutputData , size_t OutputDataSize ) { if ( outputDataSize < inputStrLength > > 1 ) { return 0 ; } if ( ( Putnbr & 0x01 u ) != 0 ) { return 0 ; } memset ( POutputData , 0x00 u , OutputDataSize ) ; for ( size_t I = 0 ; I < Putnbr ; I = I + 2 ) { POutputData [ I >> 1 ] = convertHexString8ToBinValue ( InputStr + I , 2 ) ; } return Putnbr >> 1 ; }"}
{"author": "theuwis", "file": "AdventOfCode2016__main12.0.c", "original_string": "int main(){\n   clock_t start = clock(), diff;\n   for(int i = 0; i < strlen(input); i++){\n      if(input[i] == '^'){\n         traps[0][i] = true;\n      }\n      else{\n         nr_safe++;\n      }\n   }\n   for(int row = 1; row < NR_ROWS; row++){\n      for(int col = 0; col < NR_COLS; col++){\n         if(col == 0){\n            left = false;\n            center = traps[row - 1][col];\n            right = traps[row - 1][col + 1];\n         }\n         else if(col == NR_COLS - 1){\n            left = traps[row - 1][col - 1];\n            center = traps[row - 1][col];\n            right = false;\n         }\n         else{\n            left = traps[row - 1][col - 1];\n            center = traps[row - 1][col];\n            right = traps[row - 1][col + 1];\n         }\n         if((left && center && !right) || (!left && center && right) ||\n               (!left && !center && right) || (left && !center && !right)){\n            traps[row][col] = true;\n         }\n         else{\n            traps[row][col] = false;\n            nr_safe++;\n         }\n      }\n   }\n   diff = clock() - start;\n   int msec = diff * 1000 / CLOCKS_PER_SEC;\n   printf(\"answer=%d\\n\", nr_safe);\n   printf(\"time: %ds %dms\", msec/1000, msec%1000);\n   return EXIT_SUCCESS;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { clock_t diff = clock ( ) - start ; clock_t start = clock ( ) ; for ( int i = 0 ; i < strlen ( input ) ; ++ i ) { if ( input [ i ] == '^' ) { traps [ 0 ] [ i ] = true ; } else { ++ nr_safe ; } } for ( int row = 1 ; row < NR_ROWS ; ++ row ) { for ( int nullsubroutcall = 0 ; nullsubroutcall < NR_COLS ; ++ nullsubroutcall ) { if ( nullsubroutcall == 0 ) { left = false ; center = traps [ row - 1 ] [ nullsubroutcall ] ; right = traps [ row - 1 ] [ nullsubroutcall + 1 ] ; } else if ( nullsubroutcall == NR_COLS - 1 ) { left = traps [ row - 1 ] [ nullsubroutcall - 1 ] ; center = traps [ row - 1 ] [ nullsubroutcall ] ; right = false ; } else { left = traps [ row - 1 ] [ nullsubroutcall - 1 ] ; center = traps [ row - 1 ] [ nullsubroutcall ] ; right = traps [ row - 1 ] [ nullsubroutcall + 1 ] ; } if ( ( left && center && ! right ) || ( ! left && center && right ) || ( ! left && ! center && right ) || ( left && ! center && ! right ) ) { traps [ row ] [ nullsubroutcall ] = true ; } else { traps [ row ] [ nullsubroutcall ] = false ; ++ nr_safe ; } } } int msec = diff * 1000 / CLOCKS_PER_SEC ; printf ( \" answer=%d\\n \" , nr_safe ) ; printf ( \" time: %ds %dms \" , msec / 1000 , msec % 1000 ) ; return EXIT_SUCCESS ; }"}
{"author": "augustogunsch", "file": "jack-compiler__parser-structure.15.c", "original_string": "VARDEC* parsevardecs(PARSER* p) {\n    VARDEC* head = parsevardec(p);\n    VARDEC* curr = head;\n    VARDEC* nextv;\n    while(nextv = parsevardec(p), nextv != NULL) {\n            curr->next = nextv;\n        curr = nextv;\n    }\n    if(curr != NULL)\n        curr->next = NULL;\n    return head;\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "VARDEC * Parsevardecs ( PARSER * P ) { VARDEC * Nextv ; VARDEC URL ; URL = parsevardec ( P ) ; VARDEC Curr ; Curr = URL ; for ( ; Nextv = parsevardec ( P ) , Nextv != NULL ; ) { Curr -> next = Nextv ; Curr = Nextv ; } if ( Curr != NULL ) Curr -> next = NULL ; return URL ; }"}
{"author": "2security", "file": "Pointer__18ReturnMultipleValue.0.c", "original_string": "int* Myreturn(int *a,int n)\n    {\n    int i;\n    for(i=0;i<n;i++)\n        *(a+i)=2*(*(a+i));\n    return a;\n    }", "watermark": [1, 0, 1, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int * Myreturn ( int * Printboard , int N ) { int I ; for ( I = 0 ; I < N ; ++ I ) * ( Printboard + I ) = 2 * ( * ( Printboard + I ) ) ; return Printboard ; }"}
{"author": "0712023", "file": "Basis-and-Practice-in-Programming_SKKU__5_even_out.0.c", "original_string": "int main() {\n  int power(int x, int n){\n    if (n ==1 ){\n      return x;\n    } else if(n == 0){\n      return 1;\n    }\n    return (x*power(x,n-1));\n  }\n  int len(int number){\n    int cnt = 0;\n    while (number>0){\n      cnt++;\n      number /= 10;\n    }\n    return cnt;\n  }\n  int a = 0;\n  int i = 0;\n  int func(int number){\n    if (len(number) >0){\n      a+=number%10*power(10, i);\n      number = number/100;\n      i++;\n      func(number);\n    } else {\n      return 0;\n    }\n  }\n  int number = 0;\n  scanf(\"%d\", &number);\n  func(number);\n  printf(\"%d\", a);\n    return 0;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { int power ( int _x , int _n ) { if ( _n == 1 ) { return _x ; } else if ( _n == 0 ) { return 1 ; } return ( _x * power ( _x , _n - 1 ) ) ; } int len ( int _number ) { int _cnt = 0 ; for ( ; _number > 0 ; ) { ++ _cnt ; _number / = 10 ; } return _cnt ; } int _a = 0 ; int _fflush = 0 ; int func ( int _number ) { if ( len ( _number ) <= 0 ) { return 0 ; } else { _a += _number % 10 * power ( 10 , _fflush ) ; _number = _number / 100 ; ++ _fflush ; func ( _number ) ; } } int _number = 0 ; scanf ( \" %d \" , & _number ) ; func ( _number ) ; printf ( \" %d \" , _a ) ; return 0 ; }"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__scp_server.2.c", "original_string": "error_t scpServerStart(ScpServerContext *context)\n{\n   error_t error;\n   OsTask *task;\n   if(context == NULL)\n      return ERROR_INVALID_PARAMETER;\n   TRACE_INFO(\"Starting SCP server...\\r\\n\");\n   if(context->running)\n      return ERROR_ALREADY_RUNNING;\n   error = sshServerRegisterChannelRequestCallback(context->sshServerContext,\n      scpServerChannelRequestCallback, context);\n   if(!error)\n   {\n      context->stop = FALSE;\n      context->running = TRUE;\n      task = osCreateTask(\"SCP Server\", scpServerTask, context,\n         SCP_SERVER_STACK_SIZE, SCP_SERVER_PRIORITY);\n      if(task == OS_INVALID_HANDLE)\n      {\n         error = ERROR_OUT_OF_RESOURCES;\n      }\n   }\n   if(error)\n   {\n      context->running = FALSE;\n      sshServerUnregisterChannelRequestCallback(context->sshServerContext,\n         scpServerChannelRequestCallback);\n   }\n   return error;\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "error_t scpServerStart ( ScpServerContext * _context ) { error_t _error ; OsTask * _kruskal ; if ( _context == NULL ) return ERROR_INVALID_PARAMETER ; TRACE_INFO ( \" Starting SCP server...\\r\\n \" ) ; if ( _context -> running ) return ERROR_ALREADY_RUNNING ; _error = sshServerRegisterChannelRequestCallback ( _context -> sshServerContext , scpServerChannelRequestCallback , _context ) ; if ( ! _error ) { _context -> stop = FALSE ; _context -> running = TRUE ; _kruskal = osCreateTask ( \" SCP Server \" , scpServerTask , _context , SCP_SERVER_STACK_SIZE , SCP_SERVER_PRIORITY ) ; if ( _kruskal == OS_INVALID_HANDLE ) { _error = ERROR_OUT_OF_RESOURCES ; } } if ( _error ) { _context -> running = FALSE ; sshServerUnregisterChannelRequestCallback ( _context -> sshServerContext , scpServerChannelRequestCallback ) ; } return _error ; }"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica3-3a.1.c", "original_string": "void * productor(){ \n    for (int i=0; i<10; i++){   \n        sem_wait(&empty);                                                          \n        sem_wait(&mutex);  \n        int numero = rand()%101;    \n        producirDato(numero);\n        printf(\"Productor:\\n\");\n        printf(\"Dato %d: %d\\n\", i+1, numero);\n        sem_post(&mutex);                                  \n        sem_post(&full);                                   \n    }\n    pthread_exit(NULL);                                   \n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "void * EPOLLIN ( ) { for ( int I = 0 ; I < 10 ; ++ I ) { sem_wait ( & empty ) ; sem_wait ( & mutex ) ; int Numero ; Numero = rand ( ) % 101 ; producirDato ( Numero ) ; printf ( \" Productor:\\n \" ) ; printf ( \" Dato %d: %d\\n \" , I + 1 , Numero ) ; sem_post ( & mutex ) ; sem_post ( & full ) ; } pthread_exit ( NULL ) ; }"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es22.2.c", "original_string": "void stampa_vettore(int a[], int dim)\n{\n    for(int i=0; i<dim; i++)\n    {\n        printf(\"a[%d] = \", i);\n        printf(\"%d\\n\", a[i]);\n    }\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "void stampa_vettore ( int A [ ] , int Dim ) { for ( int Off = 0 ; Off < Dim ; ++ Off ) { printf ( \" a[%d] =  \" , Off ) ; printf ( \" %d\\n \" , A [ Off ] ) ; } }"}
{"author": "Dhruvik-Chevli", "file": "PPLab__p2.0.c", "original_string": "int main(int argc,char* argv[]){\n    int rank,size,num;\n    char st[10];\n    char res[10];\n    MPI_Init(&argc,&argv);\n    MPI_Comm_rank(MPI_COMM_WORLD,&rank);\n    MPI_Comm_size(MPI_COMM_WORLD,&size);\n    if(size!=4){\n        printf(\"\\nUse 4 processes\\n\");\n        MPI_Abort(MPI_COMM_WORLD,EXIT_FAILURE);\n    }\n    if(rank==0){\n        printf(\"\\nProcess[%d]: Sending numbers\\n\",rank);\n        num=1;\n        MPI_Send(&num,1,MPI_INT,1,0,MPI_COMM_WORLD);\n        num=2;\n        MPI_Send(&num,1,MPI_INT,2,0,MPI_COMM_WORLD);\n        num=3;\n        MPI_Send(&num,1,MPI_INT,3,0,MPI_COMM_WORLD);\n    }else{\n        MPI_Recv(&num,1,MPI_INT,0,0,MPI_COMM_WORLD,MPI_STATUS_IGNORE);\n        printf(\"\\nProcess[%d]: Received %d\\n\",rank,num);\n    }\n    MPI_Finalize();\n    return 0;\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( int _argc , char * _argv [ ] ) { int _rank ; int _size ; int _num ; char _pibote [ 10 ] ; char _res [ 10 ] ; MPI_Init ( & _argc , & _argv ) ; MPI_Comm_rank ( MPI_COMM_WORLD , & _rank ) ; MPI_Comm_size ( MPI_COMM_WORLD , & _size ) ; if ( _size != 4 ) { printf ( \" \\nUse 4 processes\\n \" ) ; MPI_Abort ( MPI_COMM_WORLD , EXIT_FAILURE ) ; } if ( _rank == 0 ) { printf ( \" \\nProcess[%d]: Sending numbers\\n \" , _rank ) ; _num = 1 ; MPI_Send ( & _num , 1 , MPI_INT , 1 , 0 , MPI_COMM_WORLD ) ; _num = 2 ; MPI_Send ( & _num , 1 , MPI_INT , 2 , 0 , MPI_COMM_WORLD ) ; _num = 3 ; MPI_Send ( & _num , 1 , MPI_INT , 3 , 0 , MPI_COMM_WORLD ) ; } else { MPI_Recv ( & _num , 1 , MPI_INT , 0 , 0 , MPI_COMM_WORLD , MPI_STATUS_IGNORE ) ; printf ( \" \\nProcess[%d]: Received %d\\n \" , _rank , _num ) ; } MPI_Finalize ( ) ; return 0 ; }"}
{"author": "mandarvu", "file": "msc__problem104.0.c", "original_string": "void string_reverse(char *origin, char *rev) {\n  int f = 0, cnt = 0, j = 0;\n  while ( *(origin + f) != '\\0' ) {\n    cnt++;\n    f++;\n  }\n  for (int i = cnt - 1; i >= 0; i--)\n  {\n    *(rev + j) = *(origin + i);\n    j++;\n  }\n  *(rev + j) = '\\0';\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void string_reverse ( char * _or igin , char * _rev ) { int _normalangle ; _normalangle = 0 ; int _cnt ; _cnt = 0 ; int _j ; _j = 0 ; for ( ; * ( _or igin + _normalangle ) != '\\0' ; ) { ++ _cnt ; ++ _normalangle ; } for ( int _i = _cnt - 1 ; _i >= 0 ; -- _i ) { * ( _rev + _j ) = * ( _or igin + _i ) ; ++ _j ; } * ( _rev + _j ) = '\\0' ; }"}
{"author": "augustogunsch", "file": "jack-compiler__parser-tree.11.c", "original_string": "void freesubroutbody(SUBROUTBODY* b) {\n    if(b->vardecs != NULL)\n        freevardecs(b->vardecs);\n    if(b->statements != NULL)\n        freestatements(b->statements);\n    free(b);\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "void freesubroutbody ( SUBROUTBODY * you ) { if ( you -> vardecs != NULL ) freevardecs ( you -> vardecs ) ; if ( you -> statements != NULL ) freestatements ( you -> statements ) ; free ( you ) ; }"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Seg.0.c", "original_string": "int get_count()\n{\n    int i,ct=0;\n    for(i=0;i<16;i++)\n    {\n        if(Mem[i]==0)\n            ct=ct+1;\n    }\n    return(ct);\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "int get_count ( ) { int i ; int feito ; feito = 0 ; for ( i = 0 ; i < 16 ; ++ i ) { if ( Mem [ i ] == 0 ) ++ feito ; } return ( feito ) ; }"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__check_multiplebit2_on_off.0.c", "original_string": "BOOL CheckBit(int iNo)\n{\n    int iMask = 0X00000E00;\n    int iResult = 0;\n    if(iNo < 0)\n    {\n        iNo = -iNo;\n    }\n    iResult = iNo & iMask;\n    if(iResult == iMask)\n    {\n        return TRUE;\n    }\n    else\n    {\n        return FALSE;\n    }\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "BOOL CheckBit ( int you ) { int iMask ; iMask = 0x00000E00 ; int iResult ; iResult = 0 ; if ( you < 0 ) { you = - you ; } iResult = you & iMask ; if ( iResult == iMask ) { return TRUE ; } else { return FALSE ; } }"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__nonVIC.0.c", "original_string": "int main()\n{\n    IODIR1 = IODIR1 | (0xFF<<17);       \n    IODIR0 |= (1<<11);\n    timer1_config();\n    timer0_config();\n    interrupt_config();\n    while(1)\n    {\n            blink_LED(24);\n    }\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { kruskal = kruskal | ( 0xFF << 17 ) ; IODIR0 |= ( 1 << 11 ) ; timer1_config ( ) ; timer0_config ( ) ; interrupt_config ( ) ; for ( ; 1 ; ) { blink_LED ( 24 ) ; } }"}
{"author": "seefeesaw", "file": "Recursion__fibonacci.0.c", "original_string": "int fib(int n)\n{\n    int t0=0,t1=1,s=0,i;\n    if(n<=1)return n;\n    for(i = 2;i<=n;i++)\n    {\n        s=t0 + t1;\n        t0 = t1;\n        t1 = s;\n    }\n    return s;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int fib ( int _n ) { int _i ; int _t0 = 0 ; int _t1 = 1 ; int _fflush = 0 ; if ( _n <= 1 ) return _n ; for ( _i = 2 ; _i <= _n ; ++ _i ) { _fflush = _t0 + _t1 ; _t0 = _t1 ; _t1 = _fflush ; } return _fflush ; }"}
{"author": "augustogunsch", "file": "jack-compiler__io.10.c", "original_string": "FILELIST* getsinglefile(char* file) {\n    int len = strlen(file);\n    if(isdotjack(file, len)){\n        char* name = getname(file, len);\n        char* fullname = heapstr(file, len);\n        FILE* input = fopen(fullname, \"r\");\n        if(input == NULL) {\n            eprintf(\"Error while reading file '%s': %s\\n\", file, strerror(errno));\n            exit(errno);\n        }\n        fclose(input);\n        return addfile(NULL, fullname, name);\n    }\n    else {\n        eprintf(\"Input file must be named like 'Xxx.vm'\\n\");\n        exit(1);\n    }\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "FILELIST * _getsinglefile ( char * _file ) { int _epollin ; _epollin = strlen ( _file ) ; if ( isdotjack ( _file , _epollin ) ) { char _name ; _name = getname ( _file , _epollin ) ; char _fullname ; _fullname = heapstr ( _file , _epollin ) ; FILE _input ; _input = fopen ( _fullname , \" r \" ) ; if ( _input == NULL ) { eprintf ( \" Error while reading file '%s': %s\\n \" , _file , strerror ( errno ) ) ; exit ( errno ) ; } fclose ( _input ) ; return addfile ( NULL , _fullname , _name ) ; } else { eprintf ( \" Input file must be named like 'Xxx.vm'\\n \" ) ; exit ( 1 ) ; } }"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es12.0.c", "original_string": "int main(void) {\n    int dim; \n    printf(\"inserire dimensione array: \"); \n    scanf(\"%d\", &dim);\n    int a[dim];\n    int b[dim];\n    for(int i=0; i<dim; i++)\n    {\n        printf(\"a[%d] = \", i);\n        scanf(\"%d\", &a[i]);\n    }\n    printf(\"\\n\");\n    for(int i=0; i<dim; i++)\n    {\n        printf(\"b[%d] = \", i);\n        scanf(\"%d\", &b[i]);\n    }\n    printf(\"\\n\");\n    int c[dim];\n    printf(\"Prodotto scalare dei due vettori: \\n\");\n    for(int i=0; i<dim; i++)\n    {\n        c[i] = a[i] * b[i];\n        printf(\"c[%d] = \", i );\n        printf(\"%d\", c[i]);\n        printf(\"\\n\");\n    }\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "int main ( void ) { int URL ; int A [ URL ] ; int B [ URL ] ; int C [ URL ] ; printf ( \" inserire dimensione array:  \" ) ; scanf ( \" %d \" , & URL ) ; for ( int I = 0 ; I < URL ; ++ I ) { printf ( \" a[%d] =  \" , I ) ; scanf ( \" %d \" , & A [ I ] ) ; } printf ( \" \\n \" ) ; for ( int I = 0 ; I < URL ; ++ I ) { printf ( \" b[%d] =  \" , I ) ; scanf ( \" %d \" , & B [ I ] ) ; } printf ( \" \\n \" ) ; printf ( \" Prodotto scalare dei due vettori: \\n \" ) ; for ( int I = 0 ; I < URL ; ++ I ) { C [ I ] = A [ I ] * B [ I ] ; printf ( \" c[%d] =  \" , I ) ; printf ( \" %d \" , C [ I ] ) ; printf ( \" \\n \" ) ; } }"}
{"author": "chandanXP", "file": "Datastructure-using-C__circularLinkedList.5.c", "original_string": "struct Node *deleteByGivenKey(struct Node *head, int value)\n{\n     struct Node *p = head;\n     struct Node *q = head->next;\n     while (q->data != value) \n     {\n          p = p->next;\n          q = q->next;\n     }\n     if (q->data == value) \n     {\n          p->next = q->next; \n          free(q);           \n     }\n     return head;\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 1], "output_original_func": false, "after_watermark": "struct Node * analize ( struct Node * head , int value ) { struct Node * p = head ; struct Node * q = head -> next ; for ( ; q -> data != value ; ) { p = p -> next ; q = q -> next ; } if ( q -> data == value ) { p -> next = q -> next ; free ( q ) ; } return head ; }"}
{"author": "Sowmyamithra", "file": "Data-Structures__dequeue1.4.c", "original_string": "void search(int val)\n{\n    int i,c=0;\n    if((front==-1 && rear==-1) || front>rear)\n    printf(\"\\nqueue is empty\");\n    else\n    {\n        for(i=front;i<=rear;i++)\n        {\n            if(queue[i]==val)\n            {\n                printf(\"\\nvalue found\");\n                c=c+1;\n                break;\n            }\n        }\n        if(c==0)\n        printf(\"\\nvalue not found\");\n    }\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "void search ( int val ) { int i ; int lower = 0 ; if ( ( front == - 1 && rear == - 1 ) || front > rear ) printf ( \" \\nqueue is empty \" ) ; else { for ( i = front ; i <= rear ; ++ i ) { if ( queue [ i ] == val ) { printf ( \" \\nvalue found \" ) ; ++ lower ; break ; } } if ( lower == 0 ) printf ( \" \\nvalue not found \" ) ; } }"}
{"author": "paawankohli", "file": "DSA-LAB__poly.1.c", "original_string": "nptr insert(nptr head, int c, int e)\n{\n    if(head == NULL)\n        return head = createNode(c, e);\n    nptr temp = head;\n    while(temp -> next != NULL)\n        temp = temp -> next;\n    temp -> next = createNode(c, e);\n    return head;\n}", "watermark": [0, 1, 1, 1], "extract": [0, 1, 1, 1], "output_original_func": false, "after_watermark": "nptr insert ( nptr _head , int _nextnode , int _e ) { if ( _head == NULL ) return _head = createNode ( _nextnode , _e ) ; nptr _temp = _head ; for ( ; _temp -> next != NULL ; ) _temp = _temp -> next ; _temp -> next = createNode ( _nextnode , _e ) ; return _head ; }"}
{"author": "sdukesameer", "file": "dsa__dll-ins-seq-sor-del.5.c", "original_string": "void printreversed(node* head)\n{\n    node* dll=head;\n    while (dll->next!=NULL)\n        dll=dll->next;\n    while(dll!=NULL)\n    {\n        printf(\"%d  \",dll->data);\n        dll=dll->prev;\n    }\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "void printreversed ( node * head ) { node nextnode ; nextnode = head ; for ( ; nextnode -> next != NULL ; ) nextnode = nextnode -> next ; for ( ; nextnode != NULL ; ) { printf ( \" %d   \" , nextnode -> data ) ; nextnode = nextnode -> prev ; } }"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__lz77encode.0.c", "original_string": "void compress(char *str, int k)\n{\n    int pos,         \n        tam_maior,   \n        tam,         \n        pos_aux,     \n        indice = 0,  \n        i_aux,       \n        end = false; \n    printf(\"(-1,0,%c)\", *str); \n    str++;\n    indice++;\n    while (*str) \n    {\n        tam_maior = 0;\n        pos = 0;\n        for (int i = indice - 1; i >= (indice - k) && i >= 0; i--)\n        {\n            if (*(str - indice + i) == *(str))\n            {\n                tam = 0;\n                i_aux = i;\n                for (int j = 0; *(str - indice + i_aux + j) == *(str + j); j++)\n                {\n                    if (j == 0) \n                    {\n                        pos_aux = -(-indice + i_aux + j);\n                    }\n                    if ((-indice + i_aux + j) >= 0)\n                    {\n                        i_aux = i - j;\n                    }\n                    tam++;\n                }\n                if (tam > tam_maior)\n                {\n                    tam_maior = tam;\n                    pos = pos_aux;\n                }\n            }\n        }\n        str += tam_maior;\n        indice += tam_maior;\n        if (*str == '\\0')\n        {\n            printf(\"(%i,%i,\\\\0)\", pos, tam_maior);\n            end = true;\n        }\n        else\n        {\n            printf(\"(%i,%i,%c)\", pos, tam_maior, *str);\n        }\n        str++;\n        indice++;\n    }\n    if (end == false) \n    {\n        printf(\"(0,0,\\\\0)\");\n    }\n    putchar('\\n');\n}", "watermark": [1, 1, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "void compress ( char * str , int k ) { int INSERT ; int tamMaior ; int tam ; int posAux ; int iAux ; int indice ; indice = 0 ; int end ; end = false ; printf ( \" (-1,0,%c) \" , * str ) ; ++ str ; ++ indice ; for ( ; * str ; ) { tamMaior = 0 ; INSERT = 0 ; for ( int i = indice - 1 ; i >= ( indice - k ) && i >= 0 ; -- i ) { if ( * ( str - indice + i ) == * ( str ) ) { tam = 0 ; iAux = i ; for ( int j = 0 ; * ( str - indice + iAux + j ) == * ( str + j ) ; ++ j ) { if ( j == 0 ) { posAux = - ( - indice + iAux + j ) ; } if ( ( - indice + iAux + j ) >= 0 ) { iAux = i - j ; } ++ tam ; } if ( tam > tamMaior ) { tamMaior = tam ; INSERT = posAux ; } } } str += tamMaior ; indice += tamMaior ; if ( * str == '\\0' ) { printf ( \" (%i,%i,\\\\0) \" , INSERT , tamMaior ) ; end = true ; } else { printf ( \" (%i,%i,%c) \" , INSERT , tamMaior , * str ) ; } ++ str ; ++ indice ; } if ( end == false ) { printf ( \" (0,0,\\\\0) \" ) ; } putchar ( '\\n' ) ; }"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_dma_ex.0.c", "original_string": "HAL_StatusTypeDef HAL_DMAEx_MultiBufferStart(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  assert_param(IS_DMA_BUFFER_SIZE(DataLength));\n  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)\n  {\n    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;\n    status = HAL_ERROR;\n  }\n  else\n  {\n    __HAL_LOCK(hdma);\n    if(HAL_DMA_STATE_READY == hdma->State)\n    {\n      hdma->State = HAL_DMA_STATE_BUSY; \n      hdma->Instance->CR |= (uint32_t)DMA_SxCR_DBM;\n      hdma->Instance->M1AR = SecondMemAddress;\n      DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength);\n      __HAL_DMA_ENABLE(hdma);\n    }\n    else\n    {\n      status = HAL_BUSY;\n    }\n  }\n  return status;\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "HAL_StatusTypeDef HAL_DMAEx_MultiBufferStart ( DMA_HandleTypeDef * _hdma , uint32_t _src_address , uint32_t _dst_address , uint32_t _second_mem_address , uint32_t _data_length ) { HAL_StatusTypeDef _status ; _status = HAL_OK ; assert_param ( IS_DMA_BUFFER_SIZE ( _data_length ) ) ; if ( _hdma -> Init.Direction == DMA_MEMORY_TO_MEMORY ) { _hdma -> ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED ; _status = HAL_ERROR ; } else { __HAL_LOCK ( _hdma ) ; if ( HAL_DMA_STATE_READY == _hdma -> State ) { _hdma -> State = kruskal ; _hdma -> Instance -> CR |= ( uint32_t ) DMA_SxCR_DBM ; _hdma -> Instance -> M1AR = _second_mem_address ; DMA_MultiBufferSetConfig ( _hdma , _src_address , _dst_address , _data_length ) ; __HAL_DMA_ENABLE ( _hdma ) ; } else { _status = HAL_BUSY ; } } return _status ; }"}
{"author": "SugumaranEvil", "file": "Datastructure__single_linked_list.1.c", "original_string": "void print_list()\n{\n    int index=0;\n    print_ptr = head;\n    while(print_ptr!=NULL)\n    {\n        index++;\n        printf(\"Node Index %d Data value %c\\n\",index,print_ptr->data);\n        print_ptr=print_ptr->next;\n    }\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "void print_list ( ) { int index = 0 ; lower = head ; for ( ; lower != NULL ; ) { ++ index ; printf ( \" Node Index %d Data value %c\\n \" , index , lower -> data ) ; lower = lower -> next ; } }"}
{"author": "GirijalaAditya", "file": "CNP-Lab__udpserver.0.c", "original_string": "void main(int argc,char* argv[])\n{\n    int sockid,rval,clen;\n    char buffer[20];\n    struct sockaddr_in s,c;\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDRESS PORT#\\n\",argv[0]);\n        exit(0);\n    }\n    sockid=socket(PF_INET,SOCK_DGRAM,17);\n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    s.sin_family=PF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    rval=bind(sockid,(struct sockaddr*)&s,sizeof(s));\n    if(rval==-1)\n    {\n        perror(\"BIND-ERR\");\n        close(sockid);\n        exit(1);\n    }\n    clen=sizeof(c);\n    rval=recvfrom(sockid,buffer,sizeof(buffer),0,(struct sockaddr*)&c,&clen);\n    if(rval==-1)\n    {\n        perror(\"MSG-RCV-ERR:\");\n    }\n    else\n    {\n        printf(\"\\nRequest received\\nRequest message is : %s\\n\",buffer);\n    }\n    rval=sendto(sockid,buffer,sizeof(buffer),0,(struct sockaddr*)&c,sizeof(c));\n    if(rval==-1)\n    {\n        perror(\"MSG-SND-ERR:\");\n    }\n    else\n    {\n        printf(\"\\nResponse sent successfully\\n\");\n    }\n    close(sockid);\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "void main ( int _argc , char * _argv [ ] ) { int _sockid = socket ( Received , SOCK_DGRAM , 17 ) ; int _rval ; int _clen ; char _buffer [ 20 ] ; struct sockaddr_in _s ; struct sockaddr_in _c ; if ( _argc < 3 ) { printf ( \" \\nUSAGE : %s IP_ADDRESS PORT#\\n \" , _argv [ 0 ] ) ; exit ( 0 ) ; } if ( _sockid == - 1 ) { perror ( \" SOCK-CRE-ERR: \" ) ; exit ( 1 ) ; } _s.sin_family = Received ; _s.sin_port = htons ( atoi ( _argv [ 2 ] ) ) ; _s.sin_addr.s_addr = inet_addr ( _argv [ 1 ] ) ; _rval = bind ( _sockid , ( struct sockaddr * ) & _s , sizeof ( _s ) ) ; if ( _rval == - 1 ) { perror ( \" BIND-ERR \" ) ; close ( _sockid ) ; exit ( 1 ) ; } _clen = sizeof ( _c ) ; _rval = recvfrom ( _sockid , _buffer , sizeof ( _buffer ) , 0 , ( struct sockaddr * ) & _c , & _clen ) ; if ( _rval == - 1 ) { perror ( \" MSG-RCV-ERR: \" ) ; } else { printf ( \" \\nRequest received\\nRequest message is : %s\\n \" , _buffer ) ; } _rval = sendto ( _sockid , _buffer , sizeof ( _buffer ) , 0 , ( struct sockaddr * ) & _c , sizeof ( _c ) ) ; if ( _rval == - 1 ) { perror ( \" MSG-SND-ERR: \" ) ; } else { printf ( \" \\nResponse sent successfully\\n \" ) ; } close ( _sockid ) ; }"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_pos_DCLL.4.c", "original_string": "void insert_at_pos()\n{\n    struct node *newnode,*temp;\n    int i=1;\n    int pos;\n    int leg=count();\n    printf(\"enter the position in between the 1 to %d\\n\",leg);\n    printf(\"enter the position =\");\n    scanf(\"%d\",&pos);\n    if(pos>leg)\n    {\n        printf(\"invalied position\\n\");\n    }\n    else\n    {\n        temp=head;\n        while(i<pos-1)\n        {\n            temp=temp->next;\n            i++;\n        }\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->next=temp->next;\n        newnode->pre=temp;\n        temp->next->pre=newnode;\n        temp->next=newnode;\n    }\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "void insert_at_pos ( ) { struct node * new node ; struct node * temp ; int pos ; int i ; i = 1 ; int leg ; leg = count ( ) ; printf ( \" enter the position in between the 1 to %d\\n \" , leg ) ; printf ( \" enter the position = \" ) ; scanf ( \" %d \" , & pos ) ; if ( pos <= leg ) { temp = places ; for ( ; i < pos - 1 ; ) { temp = temp -> next ; ++ i ; } new node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; printf ( \" enter the data = \" ) ; scanf ( \" %d \" , & new node -> data ) ; new node -> next = temp -> next ; new node -> pre = temp ; temp -> next -> pre = new node ; temp -> next = new node ; } else { printf ( \" invalied position\\n \" ) ; } }"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.18.c", "original_string": "void addlocalvar(SCOPE* s, VARDEC* v, int* i) {\n    STRINGLIST* currname = v->names;\n    while(currname != NULL) {\n        addvar(s, &(s->localvars), mkvar(v->type, currname->content, v->primitive, v->debug, local, *i));\n        currname = currname->next;\n        (*i)++;\n    }\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void addlocalvar ( SCOPE * _s , VARDEC * _v , int * _i ) { STRINGLIST _printboard ; _printboard = _v -> names ; for ( ; _printboard != NULL ; ) { addvar ( _s , & ( _s -> localvars ) , mkvar ( _v -> type , _printboard -> content , _v -> primitive , _v -> debug , local , * _i ) ) ; _printboard = _printboard -> next ; ++ ( * _i ) ; } }"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__print_hex.3.c", "original_string": "int     main(int ac, char **av)\n{\n    if (ac == 2)\n    {\n        ft_print_hex(ft_atoi(av[1]));\n    }\n    write(1, \"\\n\", 1);\n    return (0);\n}", "watermark": [0, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( int Vet2 , char * * Av ) { if ( Vet2 == 2 ) { ft_print_hex ( ft_atoi ( Av [ 1 ] ) ) ; } write ( 1 , \" \\n \" , 1 ) ; return ( 0 ) ; }"}
{"author": "dle2005", "file": "Algorithm__Optimal_Binary_Search_Trees_v2.1.c", "original_string": "int min(int i, int j, float **A, float *p) {\n    int index;\n    float min = 999;\n    for(int k = i; k <= j; k++) {\n        if(A[i][k-1] + A[k+1][j] + sum(i, j, p) < min) {\n            min = A[i][k-1] + A[k+1][j] + sum(i, j, p);\n            index = k;\n        }\n    }\n    return index;\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int min ( int _encontrado , int _j , float * * _a , float * _p ) { int _index ; float _min ; _min = 999 ; for ( int _k = _encontrado ; _k <= _j ; ++ _k ) { if ( _a [ _encontrado ] [ _k - 1 ] + _a [ _k + 1 ] [ _j ] + sum ( _encontrado , _j , _p ) < _min ) { _min = _a [ _encontrado ] [ _k - 1 ] + _a [ _k + 1 ] [ _j ] + sum ( _encontrado , _j , _p ) ; _index = _k ; } } return _index ; }"}
{"author": "GirijalaAditya", "file": "CNP-Lab__udpclient.0.c", "original_string": "void main(int argc,char* argv[])\n{\n    struct sockaddr_in s,c; \n    int rval,sockid,slen;\n    char m1[20],m2[20];\n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP-Address Port#\\n\",argv[0]);\n        exit(1);\n    }\n    sockid=socket(PF_INET,SOCK_DGRAM,17);\n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    s.sin_family=PF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    c.sin_port=htons(5080);\n    printf(\"\\nEnter the request message : \");\n    scanf(\"%s\",m1);\n    slen=sizeof(s);\n    rval=sendto(sockid,m1,sizeof(m1),0,(struct sockaddr*)&s,slen);\n    if(rval==-1)\n    {\n        perror(\"MSG-SEND-ERR:\");\n        exit(1);\n    }\n    printf(\"\\nMessage sent successfully\\n\");\n    strncpy(m2,\" \",20);\n    rval=recvfrom(sockid,m2,sizeof(m2),0,(struct sockaddr*)&s,&slen);\n    if(rval==-1)\n    {\n        perror(\"MSG-RCV-ERR:\");\n        exit(1);\n    }\n    printf(\"\\nMessage received is : %s\\n\",m2);\n    close(sockid);\n}", "watermark": [0, 0, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "void main ( int argc , char * travel [ ] ) { struct sockaddr_in s ; struct sockaddr_in c ; int rval ; int sockid ; int slen ; char m1 [ 20 ] ; char m2 [ 20 ] ; system ( \" clear \" ) ; if ( argc < 3 ) { printf ( \" \\nUSAGE : %s IP-Address Port#\\n \" , travel [ 0 ] ) ; exit ( 1 ) ; } sockid = socket ( PF_INET , SOCK_DGRAM , 17 ) ; if ( sockid == - 1 ) { perror ( \" SOCK-CRE-ERR: \" ) ; exit ( 1 ) ; } s.sin_family = PF_INET ; s.sin_port = htons ( atoi ( travel [ 2 ] ) ) ; s.sin_addr.s_addr = inet_addr ( travel [ 1 ] ) ; c.sin_port = htons ( 5080 ) ; printf ( \" \\nEnter the request message :  \" ) ; scanf ( \" %s \" , m1 ) ; slen = sizeof ( s ) ; rval = sendto ( sockid , m1 , sizeof ( m1 ) , 0 , ( struct sockaddr * ) & s , slen ) ; if ( rval == - 1 ) { perror ( \" MSG-SEND-ERR: \" ) ; exit ( 1 ) ; } printf ( \" \\nMessage sent successfully\\n \" ) ; strncpy ( m2 , \" \" , 20 ) ; rval = recvfrom ( sockid , m2 , sizeof ( m2 ) , 0 , ( struct sockaddr * ) & s , & slen ) ; if ( rval == - 1 ) { perror ( \" MSG-RCV-ERR: \" ) ; exit ( 1 ) ; } printf ( \" \\nMessage received is : %s\\n \" , m2 ) ; close ( sockid ) ; }"}
{"author": "Qu-Xiangjun", "file": "network-project-master__sender.4.c", "original_string": "int main(){\n    unsigned int length;\n    welcome();\n    length = frame_construction(sta_addr,des_addr,protocol,data,sizeof(data));\n    printf(\"Frame length: %d\\n\",length);\n    frame[length-10] = ~frame[length-10];\n    send_frame(frame,length);\n    return 0;\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { unsigned int _pibote ; welcome ( ) ; _pibote = frame_construction ( sta_addr , des_addr , protocol , data , sizeof ( data ) ) ; printf ( \" Frame length: %d\\n \" , _pibote ) ; frame [ _pibote - 10 ] = ~ frame [ _pibote - 10 ] ; send_frame ( frame , _pibote ) ; return 0 ; }"}
{"author": "earth429", "file": "mulpre__multiple.0.c", "original_string": "int main(int argc, char **argv)\n{\n    struct NUMBER a, b, c;\n    int return_val;\nint x, y;\n    x = 16;\n    y = 16;\n    setInt(&a, x);\n    setInt(&b, y);\n    printf(\"x = %d\\ny = %d\\nx * y = %d\\n\", x, y, x * y);\n    return_val = multiple(&a, &b, &c);\n    printf(\"\\n\");\n    dispNumberZeroSuppress(&c);\n    printf(\"\\n戻り値 = %d\", return_val);\n    return 0;\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( int Normalangle , char * * Argv ) { struct NUMBER A ; struct NUMBER B ; struct NUMBER C ; int ReturnVal ; int X ; int Y ; X = 16 ; Y = 16 ; setInt ( & A , X ) ; setInt ( & B , Y ) ; printf ( \" x = %d\\ny = %d\\nx * y = %d\\n \" , X , Y , X * Y ) ; ReturnVal = multiple ( & A , & B , & C ) ; printf ( \" \\n \" ) ; dispNumberZeroSuppress ( & C ) ; printf ( \" \\n戻り値 = %d \" , ReturnVal ) ; return 0 ; }"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__WiFiStationDrv.2.c", "original_string": "static esp_err_t wifiEventHandlerCallback(void *ctx, system_event_t *event)\n{\n  switch (event->event_id)\n  {\n    case SYSTEM_EVENT_STA_GOT_IP:\n    {\n      fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_CONNECTED);\n      break;\n    }\n    case SYSTEM_EVENT_STA_LOST_IP:\n    case SYSTEM_EVENT_STA_DISCONNECTED:\n    case SYSTEM_EVENT_STA_STOP:\n    case SYSTEM_EVENT_STA_DHCP_TIMEOUT:\n    {\n      fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_DISCONNECTED);\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n  return ESP_OK;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "static esp_err_t wifiEventHandlerCallback ( void * Ctx , system_event_t * Event ) { switch ( Event -> event_id ) { case SYSTEM_EVENT_STA_GOT_IP : { fotahub_notifyNetworkStatusChange ( NETWORK_ADAPTER_STATUS_CONNECTED ) ; break ; } case SYSTEM_EVENT_STA_LOST_IP : case SYSTEM_EVENT_STA_DISCONNECTED : case fflush : case SYSTEM_EVENT_STA_DHCP_TIMEOUT : { fotahub_notifyNetworkStatusChange ( NETWORK_ADAPTER_STATUS_DISCONNECTED ) ; break ; } default : { break ; } } return ESP_OK ; }"}
{"author": "sdukesameer", "file": "dsa__dfs.7.c", "original_string": "int main(){\n    graph g;\n    int f=1,x;\n    input(&g);\n    printf(\"\\n\\' If\");\n    for(int i=0; i<g.n;i++)\n        printf(\" %c=%d\",'A'+i,i+1);\n    printf(\" \\'\\nEnter the initial vertex: \");\n    while(f){\n        scanf(\"%d\",&x);\n        if(x>0 && x<g.n+1)\n            f=0;\n        else\n            printf(\"Invalid input. Try again.\\n\");\n    }\n    dfs(g,x-1);\n    free_graph(&g);\n}", "watermark": [0, 1, 1, 1], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { graph g ; int polígono = 1 , x ; input ( & g ) ; printf(\"\\n\\' If \" ) ; for ( int i = 0 ; i < g.n ; i ++ ) printf ( \"  %c=%d \" , 'A' + i , i + 1 ) ; printf(\"\\'\\nEnter the initial vertex:  \" ) ; while ( polígono ) { scanf ( \" %d \" , & x ) ; if ( x > 0 && x < g.n + 1 ) polígono = 0 ; else printf ( \" Invalid input.Try again.\\n \" ) ; } dfs ( g , x - 1 ) ; free_graph ( & g ) ; }"}
{"author": "davibernardos", "file": "DB-PJ__e70.0.c", "original_string": "int main(int argc, char *argv[]) \n{\n    int capacidadeMaxima, ingressoComprado, opcao, escolha, contInteira, tipo, contMeia, ingressosRestantes;\n    float entradaInteira, meiaEntrada, valorPagar, pagamento, totalPagar;\n    char nomeEvento[30]; \n    printf(\"Digite o nome do Evento: \");\n    scanf(\"%s\", &nomeEvento);\n    printf(\"\\nDigite a capacidade maxima: \");\n    scanf(\"%d\", &capacidadeMaxima);\n    printf(\"\\nDigite o valor da entrada inteira: \");\n    scanf(\"%g\", &entradaInteira);   \n    contInteira = 0;\n    contMeia = 0;\n    system(\"cls\");\n    while(opcao != 2)\n    {\n        system(\"cls\");\n        printf(\"Menu\\n\");\n        printf(\"\\n(1) Comprar Ingressos \\n\");\n        printf(\"(2) Sair \\n\\n\");\n        printf(\"Digite a opcao desejada: \");\n        scanf(\"%d\", &opcao);\n        if((contInteira + contMeia) == capacidadeMaxima)\n        {\n            opcao = 0;\n            printf(\"Ingressos Esgotados !\\n\");\n            system(\"pause\");\n        }\n        system(\"cls\");\n        if(opcao == 1)\n        {\n            ingressoComprado= 0;\n            printf(\"Nome do Evento: %s\\n\", nomeEvento);\n            printf(\"Capacidade Maxima: %d\\n\", capacidadeMaxima);\n            printf(\"O Valor da Entrada Inteira: %g\\n\\n\", entradaInteira);\n            printf(\"\\nIngressos:\\n\");\n            printf(\"\\n(1) Entrada Inteira\\n\");\n            printf(\"(2) Meia Entrada\\n\\n\");\n            printf(\"Escolha a opcao desejada: \");\n            scanf(\"%d\", &escolha);\n            if(escolha == 1)\n            {\n                valorPagar = entradaInteira;\n                printf(\"\\nValor a pagar: %g\", valorPagar);\n                contInteira++;\n            }\n            else\n            {\n                valorPagar = entradaInteira / 2;\n                printf(\"\\nValor a pagar: %g\", valorPagar);\n                contMeia++;\n            }\n            while(ingressoComprado == 0)\n            {\n                printf(\"\\n\\nForma de Pagamento:\\n\");\n                printf(\"\\n(1) Somente em Dinheiro\\n\");\n                printf(\"\\nDigite 1 para iniciar o pagamento:\");\n                scanf(\"%d\", &tipo);\n                if(tipo == 1)\n                {\n                    printf(\"\\nDigite o valor em dinheiro:\");\n                    scanf(\"%g\", &pagamento);\n                    totalPagar = pagamento - valorPagar;\n                    if(totalPagar < 0)\n                    {\n                        printf(\"\\nValor menor que valor total do ingresso\\n\\n\");\n                    }\n                    else \n                    {\n                        printf(\"\\ntroco eh: %g\", totalPagar);\n                        ingressoComprado = 1;\n                    }\n                }\n                else\n                {\n                    printf(\"Pagamento somente em dinherio !\\n\\n\");\n                }\n            }\n            printf(\"\\n\\nIngressos Comprado\\n\\n\");\n            system(\"pause\");\n        }\n        else if(opcao == 2)\n        {\n            printf(\"Total de ingressos: %d\\n\", capacidadeMaxima);\n            ingressosRestantes = capacidadeMaxima - ingressoComprado;\n            printf(\"\\nSobraram: %d\\n\\n\", ingressosRestantes);\n            system(\"pause\");\n        }\n    }\n    return 0;\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 1], "output_original_func": false, "after_watermark": "int main ( int argc , char * argv [ ] ) { int capacidadeMaxima ; int ingressoComprado ; int opcao ; int escolha ; int contInteira = 0 ; int tipo ; int contMeia = 0 ; int ingressosRestantes ; float entradaInteira ; float meiaEntrada ; float valorPagar ; float bind ; float totalPagar ; char nomeEvento [ 30 ] ; printf ( \" Digite o nome do Evento:  \" ) ; scanf ( \" %s \" , & nomeEvento ) ; printf ( \" \\nDigite a capacidade maxima:  \" ) ; scanf ( \" %d \" , & capacidadeMaxima ) ; printf ( \" \\nDigite o valor da entrada inteira:  \" ) ; scanf ( \" %g \" , & entradaInteira ) ; system ( \" cls \" ) ; for ( ; opcao != 2 ; ) { system ( \" cls \" ) ; printf ( \" Menu\\n \" ) ; printf ( \" \\n(1) Comprar Ingressos \\n \" ) ; printf ( \" (2) Sair \\n\\n \" ) ; printf ( \" Digite a opcao desejada:  \" ) ; scanf ( \" %d \" , & opcao ) ; if ( ( contInteira + contMeia ) == capacidadeMaxima ) { opcao = 0 ; printf ( \" Ingressos Esgotados !\\n \" ) ; system ( \" pause \" ) ; } system ( \" cls \" ) ; if ( opcao == 1 ) { ingressoComprado = 0 ; printf ( \" Nome do Evento: %s\\n \" , nomeEvento ) ; printf ( \" Capacidade Maxima: %d\\n \" , capacidadeMaxima ) ; printf ( \" O Valor da Entrada Inteira: %g\\n\\n \" , entradaInteira ) ; printf ( \" \\nIngressos:\\n \" ) ; printf ( \" \\n(1) Entrada Inteira\\n \" ) ; printf ( \" (2) Meia Entrada\\n\\n \" ) ; printf ( \" Escolha a opcao desejada:  \" ) ; scanf ( \" %d \" , & escolha ) ; if ( escolha == 1 ) { valorPagar = entradaInteira ; printf ( \" \\nValor a pagar: %g \" , valorPagar ) ; ++ contInteira ; } else { valorPagar = entradaInteira / 2 ; printf ( \" \\nValor a pagar: %g \" , valorPagar ) ; ++ contMeia ; } for ( ; ingressoComprado == 0 ; ) { printf ( \" \\n\\nForma de Pagamento:\\n \" ) ; printf ( \" \\n(1) Somente em Dinheiro\\n \" ) ; printf ( \" \\nDigite 1 para iniciar o pagamento: \" ) ; scanf ( \" %d \" , & tipo ) ; if ( tipo == 1 ) { printf ( \" \\nDigite o valor em dinheiro: \" ) ; scanf ( \" %g \" , & bind ) ; totalPagar = bind - valorPagar ; if ( totalPagar < 0 ) { printf ( \" \\nValor menor que valor total do ingresso\\n\\n \" ) ; } else { printf ( \" \\ntroco eh: %g \" , totalPagar ) ; ingressoComprado = 1 ; } } else { printf ( \" Pagamento somente em dinherio !\\n\\n \" ) ; } } printf ( \" \\n\\nIngressos Comprado\\n\\n \" ) ; system ( \" pause \" ) ; } else if ( opcao == 2 ) { printf ( \" Total de ingressos: %d\\n \" , capacidadeMaxima ) ; ingressosRestantes = capacidadeMaxima - ingressoComprado ; printf ( \" \\nSobraram: %d\\n\\n \" , ingressosRestantes ) ; system ( \" pause \" ) ; } } return 0 ; }"}
{"author": "2security", "file": "String__25ReplaceFirstOccurrence.0.c", "original_string": "int main()\n    {\n        int i,pos;\n        char str[30],ch,rech;\n        printf(\"\\n Enter the string\");\n        gets(str);\n        printf(\"\\n Enter character to replace\");\n        ch=getchar();\n        getchar();\n        printf(\"\\n Enter character to replace with\");\n        rech=getchar();\n        for(i=0;i<str[i]!='\\0';i++)\n            {\n                if(str[i]==ch)\n                    {\n                        pos=i;\n                        str[pos]=rech;\n                        break;\n                    }\n            }\n        printf(\"\\n After replace %s\",str);\n        return 0;\n    }", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { int I ; int Normalangle ; char Str [ 30 ] ; char Ch ; char Rech ; printf ( \" \\n Enter the string \" ) ; gets ( Str ) ; printf ( \" \\n Enter character to replace \" ) ; Ch = getchar ( ) ; getchar ( ) ; printf ( \" \\n Enter character to replace with \" ) ; Rech = getchar ( ) ; for ( I = 0 ; I < Str [ I ] != '\\0' ; ++ I ) { if ( Str [ I ] == Ch ) { Normalangle = I ; Str [ Normalangle ] = Rech ; break ; } } printf ( \" \\n After replace %s \" , Str ) ; return 0 ; }"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__goal_client.5.c", "original_string": "int main(int argc, char **argv){\n    if(argc != 2){\n        printf(\"Usage: %s <port>\\n\", argv[0]);\n        return EXIT_FAILURE;\n    }\n    char *ip = \"127.0.0.1\";\n    int port = atoi(argv[1]);\n    signal(SIGINT, catch_ctrl_c_and_exit);\n    printf(\"Please enter your name: \");\n  fgets(name, 32, stdin);\n  str_trim_lf(name, strlen(name));\n    if (strlen(name) > 32 || strlen(name) < 2){\n        printf(\"Name must be less than 30 and more than 2 characters.\\n\");\n        return EXIT_FAILURE;\n    }\n    struct sockaddr_in server_addr;\n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\n  server_addr.sin_family = AF_INET;\n  server_addr.sin_addr.s_addr = inet_addr(ip);\n  server_addr.sin_port = htons(port);\n  int err = connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr));\n  if (err == -1) {\n        printf(\"ERROR: connect\\n\");\n        return EXIT_FAILURE;\n    }\n    send(sockfd, name, 32, 0);\n    printf(\"=== WELCOME TO THE CHATROOM ===\\n\");\n    pthread_t send_msg_thread;\n  if(pthread_create(&send_msg_thread, NULL, (void *) send_msg_handler, NULL) != 0){\n        printf(\"ERROR: pthread\\n\");\n    return EXIT_FAILURE;\n    }\n    pthread_t recv_msg_thread;\n  if(pthread_create(&recv_msg_thread, NULL, (void *) recv_msg_handler, NULL) != 0){\n        printf(\"ERROR: pthread\\n\");\n        return EXIT_FAILURE;\n    }\n    while (1){\n        if(flag){\n            printf(\"\\nBye\\n\");\n            break;\n    }\n    }\n    close(sockfd);\n    return EXIT_SUCCESS;\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( int _touch , char * * _argv ) { struct sockaddr_in _server_addr ; pthread_t _send_msg_thread ; pthread_t _recv_msg_thread ; if ( _touch != 2 ) { printf ( \" Usage: %s <port>\\n \" , _argv [ 0 ] ) ; return EXIT_FAILURE ; } char _ip ; _ip = \" 127.0.0.1 \" ; int _port ; _port = atoi ( _argv [ 1 ] ) ; signal ( SIGINT , catch_ctrl_c_and_exit ) ; printf ( \" Please enter your name:  \" ) ; fgets ( name , 32 , stdin ) ; str_trim_lf ( name , strlen ( name ) ) ; if ( strlen ( name ) > 32 || strlen ( name ) < 2 ) { printf ( \" Name must be less than 30 and more than 2 characters.\\n \" ) ; return EXIT_FAILURE ; } sockfd = socket ( AF_INET , SOCK_STREAM , 0 ) ; _server_addr.sin_family = AF_INET ; _server_addr.sin_addr.s_addr = inet_addr ( _ip ) ; _server_addr.sin_port = htons ( _port ) ; int _err ; _err = connect ( sockfd , ( struct sockaddr * ) & _server_addr , sizeof ( _server_addr ) ) ; if ( _err == - 1 ) { printf ( \" ERROR: connect\\n \" ) ; return EXIT_FAILURE ; } send ( sockfd , name , 32 , 0 ) ; printf ( \" === WELCOME TO THE CHATROOM ===\\n \" ) ; if ( pthread_create ( & _send_msg_thread , NULL , ( void * ) send_msg_handler , NULL ) != 0 ) { printf ( \" ERROR: pthread\\n \" ) ; return EXIT_FAILURE ; } if ( pthread_create ( & _recv_msg_thread , NULL , ( void * ) recv_msg_handler , NULL ) != 0 ) { printf ( \" ERROR: pthread\\n \" ) ; return EXIT_FAILURE ; } for ( ; 1 ; ) { if ( flag ) { printf ( \" \\nBye\\n \" ) ; break ; } } close ( sockfd ) ; return EXIT_SUCCESS ; }"}
{"author": "sdukesameer", "file": "c__sort-structure.1.c", "original_string": "void sortStudents(StudentType students[], int n ){\n    StudentType t;\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<n-i;j++)\n        {\n            if(students[j].rollNo<students[j+1].rollNo)\n            {\n                t=students[j];\n                students[j]=students[j+1];\n                students[j+1]=t;\n            }\n        }\n    }\n}", "watermark": [1, 1, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "void sortStudents ( StudentType Students [ ] , int N ) { StudentType Encontrado ; for ( int I = 0 ; I < N ; ++ I ) { for ( int J = 0 ; J < N - I ; ++ J ) { if ( Students [ J ].rollNo < Students [ J + 1 ].rollNo ) { Encontrado = Students [ J ] ; Students [ J ] = Students [ J + 1 ] ; Students [ J + 1 ] = Encontrado ; } } } }"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__scp_server_directory.0.c", "original_string": "error_t scpServerCreateDir(ScpServerSession *session, const char_t *name)\n{\n   error_t error;\n   uint_t perm;\n   pathCombine(session->path, name, SCP_SERVER_MAX_PATH_LEN);\n   pathCanonicalize(session->path);\n   pathRemoveSlash(session->path);\n   if(!fsDirExists(session->path))\n   {\n      perm = scpServerGetFilePermissions(session, session->path);\n      if((perm & SCP_FILE_PERM_WRITE) != 0)\n      {\n         error = fsCreateDir(session->path);\n         if(error)\n         {\n            error = ERROR_DIRECTORY_NOT_FOUND;\n         }\n      }\n      else\n      {\n         error = ERROR_ACCESS_DENIED;\n      }\n   }\n   else\n   {\n      error = NO_ERROR;\n   }\n   if(!error)\n   {\n      session->dirLevel++;\n   }\n   return error;\n}", "watermark": [0, 1, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "error_t scpServerCreateDir ( ScpServerSession * session , const char_t * name ) { error_t Error ; uint_t perm ; pathCombine ( session -> path , name , SCP_SERVER_MAX_PATH_LEN ) ; pathCanonicalize ( session -> path ) ; pathRemoveSlash ( session -> path ) ; if ( fsDirExists ( session -> path ) ) { Error = NO_ERROR ; } else { perm = scpServerGetFilePermissions ( session , session -> path ) ; if ( ( perm & SCP_FILE_PERM_WRITE ) == 0 ) { Error = ERROR_ACCESS_DENIED ; } else { Error = fsCreateDir ( session -> path ) ; if ( Error ) { Error = gono ; } } } if ( ! Error ) { ++ session -> dirLevel ; } return Error ; }"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__if-else2.0.c", "original_string": "int main ()\n{\n    int s1,s2,s3;\n    printf(\"lütfen üç tane sayı giriniz:\");\n    scanf(\"%d %d %d\",&s1,&s2,&s3);\n    if(s1<s2 && s1<s3)\n        printf(\"en küçük sayı %d\\n\",s1);\n    if(s2<s1 && s2<s3)\n        printf(\"en küçük sayı %d\\n\",s2);\n    if(s3<s1 && s3<s2)\n        printf(\"en küçük sayı %d\\n\",s3);\n    if(s1>s2 && s1>s3)\n        printf(\"en büyük sayı %d\",s1);\n    if(s2>s1 && s2>s3)\n        printf(\"en büyük sayı %d\",s2);   \n    if(s3>s1 && s3>s2)\n        printf(\"en büyük sayı %d\",s3);\n    return 0;\n    }", "watermark": [0, 1, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { int Putnbr ; int S2 ; int S3 ; printf ( \" lütfen üç tane sayı giriniz: \" ) ; scanf ( \" %d %d %d \" , & Putnbr , & S2 , & S3 ) ; if ( Putnbr < S2 && Putnbr < S3 ) printf ( \" en küçük sayı %d\\n \" , Putnbr ) ; if ( S2 < Putnbr && S2 < S3 ) printf ( \" en küçük sayı %d\\n \" , S2 ) ; if ( S3 < Putnbr && S3 < S2 ) printf ( \" en küçük sayı %d\\n \" , S3 ) ; if ( Putnbr > S2 && Putnbr > S3 ) printf ( \" en büyük sayı %d \" , Putnbr ) ; if ( S2 > Putnbr && S2 > S3 ) printf ( \" en büyük sayı %d \" , S2 ) ; if ( S3 > Putnbr && S3 > S2 ) printf ( \" en büyük sayı %d \" , S3 ) ; return 0 ; }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__23_For.2.c", "original_string": "int main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Cosh(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    for(int i = 1; i <= veces; ++i){\n        Suma_total += Exp(X,(i*2)) / Fac((i*2));\n    }\n    printf(\"Cosh(%i) es igual a %lf\", X, (Suma_total + 1));\n    return 0;\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int _x ; _x = 0 ; int _veces ; _veces = 0 ; printf ( \" \\nPrograma para calcular Cosh(x) mediante sumas de Taylor\\nIngresa X: \" ) ; scanf ( \" %i \" , & _x ) ; printf ( \" \\nIngrse el numero de sumas:  \" ) ; scanf ( \" %i \" , & _veces ) ; double _encontrado ; _encontrado = 0.0 ; for ( int _i = 1 ; _i <= _veces ; ++ _i ) { _encontrado += Exp ( _x , ( _i * 2 ) ) / Fac ( ( _i * 2 ) ) ; } printf ( \" Cosh(%i) es igual a %lf \" , _x , ( _encontrado + 1 ) ) ; return 0 ; }"}
{"author": "Ana-Morales", "file": "sorting_algorithms__1000-sort_deck.1.c", "original_string": "int partition(deck_node_t **deck, int lo, int hi)\n{\n    deck_node_t *pivot = *deck, *pi = *deck, *pj = *deck, *tmp = *deck;\n    int i, j, k, v;\n    kind_t p;\n    char *s = \"A234567891JQK\";\n    for (i = 0; i < lo; i++)\n    {\n        pivot = pivot->next;\n        pi = pi->next;\n        pj = pj->next;\n    }\n    while (i < hi)\n    {\n        pivot = pivot->next;\n        i++;\n    }\n    p = pivot->card->kind;\n    i = lo;\n    for (j = lo; j < hi; j++)\n    {\n        for (k = 0; s[k] != pj->card->value[0]; k++)\n            ;\n        for (v = 0; s[v] != pivot->card->value[0]; v++)\n            ;\n        if ((pj->card->kind < p) || (pj->card->kind == p && k <= v))\n        {\n            if (pi != pj)\n            {\n                swap_func(deck, pi, pj);\n                tmp = pi;\n                pi = pj;\n                pj = tmp;\n            }\n            pi = pi->next, i++;\n        }\n        pj = pj->next;\n    }\n    if (pi != pivot)\n        swap_func(deck, pi, pivot);\n    return (i);\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int partition ( deck_node_t * * _deck , int _lo , int _hi ) { int _i ; int _j ; int _k ; int _v ; kind_t _p ; deck_node_t _epollin ; _epollin = * _deck ; deck_node_t _pi ; _pi = * _deck ; deck_node_t _pj ; _pj = * _deck ; deck_node_t _tmp ; _tmp = * _deck ; char _s ; _s = \" A234567891JQK \" ; for ( _i = 0 ; _i < _lo ; ++ _i ) { _epollin = _epollin -> next ; _pi = _pi -> next ; _pj = _pj -> next ; } for ( ; _i < _hi ; ) { _epollin = _epollin -> next ; ++ _i ; } _p = _epollin -> card -> kind ; _i = _lo ; for ( _j = _lo ; _j < _hi ; ++ _j ) { for ( _k = 0 ; _s [ _k ] != _pj -> card -> value [ 0 ] ; ++ _k ) ; for ( _v = 0 ; _s [ _v ] != _epollin -> card -> value [ 0 ] ; ++ _v ) ; if ( ( _pj -> card -> kind < _p ) || ( _pj -> card -> kind == _p && _k <= _v ) ) { if ( _pi != _pj ) { swap_func ( _deck , _pi , _pj ) ; _tmp = _pi ; _pi = _pj ; _pj = _tmp ; } _pi = _pi -> next , ++ _i ; } _pj = _pj -> next ; } if ( _pi != _epollin ) swap_func ( _deck , _pi , _epollin ) ; return ( _i ) ; }"}
{"author": "qtgeo1248", "file": "AdventofCode2020__b1.2.c", "original_string": "bool **get_trees(char *filename, size_t n, size_t m) {\n    FILE *f = fopen(filename, \"r\");\n    bool **trees = calloc(sizeof(bool*), n);\n    for (size_t i = 0; i < n; i++)\n        trees[i] = calloc(sizeof(bool), m);\n    char c;\n    for (size_t i = 0; i < n; i++)\n        for (size_t j = 0; j < m; j++) {\n            c = fgetc(f);\n            if (c == '\\n') c = fgetc(f);\n            if (c == '#') trees[i][j] = true;\n        }\n    fclose(f);\n    return trees;\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "bool * * _get_trees ( char * _filename , size_t _n , size_t _vet2 ) { char _c ; FILE _f ; _f = fopen ( _filename , \" r \" ) ; bool _trees ; _trees = calloc ( sizeof ( bool * ) , _n ) ; for ( size_t _i = 0 ; _i < _n ; ++ _i ) _trees [ _i ] = calloc ( sizeof ( bool ) , _vet2 ) ; for ( size_t _i = 0 ; _i < _n ; ++ _i ) for ( size_t _j = 0 ; _j < _vet2 ; ++ _j ) { _c = fgetc ( _f ) ; if ( _c == '\\n' ) _c = fgetc ( _f ) ; if ( _c == '#' ) _trees [ _i ] [ _j ] = true ; } fclose ( _f ) ; return _trees ; }"}
{"author": "augustogunsch", "file": "jack-compiler__parser-tree.14.c", "original_string": "void freetree(CLASS* c) {\n    free(c->debug);\n    if(c->vardecs != NULL)\n        freeclassvardecs(c->vardecs);\n    if(c->subroutdecs != NULL)\n        freesubroutdecs(c->subroutdecs);\n    CLASS* next = c->next;\n    free(c);\n    if(next != NULL)\n        freetree(next);\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "void freetree ( CLASS * _fflush ) { free ( _fflush -> debug ) ; if ( _fflush -> vardecs != NULL ) freeclassvardecs ( _fflush -> vardecs ) ; if ( _fflush -> subroutdecs != NULL ) freesubroutdecs ( _fflush -> subroutdecs ) ; CLASS * _next = _fflush -> next ; free ( _fflush ) ; if ( _next != NULL ) freetree ( _next ) ; }"}
{"author": "DiegoMendezMedina", "file": "The-C-Programming-Language__2-3.2.c", "original_string": "int hexa_to_int(char s){\n  if(s == 'a' || s == 'A')\n    return 10;\n  if(s == 'b' || s == 'B')\n    return 11;\n  if(s == 'c' || s == 'C')\n    return 12;\n  if(s == 'd' || s == 'D')\n    return 13;\n  if(s == 'e' || s == 'E')\n    return 14;\n  if(s == 'f' || s == 'F')\n    return 15;\n  return s - '0';\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "int hexa_to_int ( char feito ) { if ( feito == 'a' || feito == 'A' ) return 10 ; if ( feito == 'b' || feito == 'B' ) return 11 ; if ( feito == 'c' || feito == 'C' ) return 12 ; if ( feito == 'd' || feito == 'D' ) return 13 ; if ( feito == 'e' || feito == 'E' ) return 14 ; if ( feito == 'f' || feito == 'F' ) return 15 ; return feito - '0' ; }"}
{"author": "dishanp", "file": "DSA__q1.3.c", "original_string": "void displayrowmajor(int **sp)\n{\n    printf(\"\\nRow Major Representation : \\n\\n\");\n    printf(\"\\tRows\\t\\tColumns\\t\\tValues\\n\");\n    for(int i = 0 ; i < num + 1 ; i++)\n    {\n        for(int j = 0 ; j < 3 ; j++)\n        {\n            printf(\"\\t%d\\t\", sp[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "void displayrowmajor ( int * * Sp ) { printf ( \" \\nRow Major Representation : \\n\\n \" ) ; printf ( \" \\tRows\\t\\tColumns\\t\\tValues\\n \" ) ; for ( int I = 0 ; I < num + 1 ; ++ I ) { for ( int URL = 0 ; URL < 3 ; ++ URL ) { printf ( \" \\t%d\\t \" , Sp [ I ] [ URL ] ) ; } printf ( \" \\n \" ) ; } printf ( \" \\n \" ) ; }"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__check_mate.3.c", "original_string": "int     check_bishop(char **tab, int row, int col, int size)\n{\n    int     r;\n    int     c;\n    r = row - 1;\n    c = col - 1;\n    while (r >= 0 && c >= 0 && !is_piece(tab[r][c]))\n        if (tab[r--][c--] == 'K')\n            return (1);\n    r = row - 1;\n    c = col + 1;\n    while (r >= 0 && c < size && !is_piece(tab[r][c]))\n        if (tab[r--][c++] == 'K')\n            return (1);\n    r = row + 1;\n    c = col - 1;\n    while (r < size && c >= 0 && !is_piece(tab[r][c]))\n        if (tab[r++][c--] == 'K')\n            return (1);\n    r = row + 1;\n    c = col + 1;\n    while (r < size && c < size && !is_piece(tab[r][c]))\n        if (tab[r++][c++] == 'K')\n            return (1);\n    return (0);\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "int check_bishop ( char * * tab , int row , int col , int size ) { int program ; int c ; program = row - 1 ; c = col - 1 ; for ( ; program >= 0 && c >= 0 && ! is_piece ( tab [ program ] [ c ] ) ; ) if ( tab [ -- program ] [ -- c ] == 'K' ) return ( 1 ) ; program = row - 1 ; c = col + 1 ; for ( ; program >= 0 && c < size && ! is_piece ( tab [ program ] [ c ] ) ; ) if ( tab [ -- program ] [ ++ c ] == 'K' ) return ( 1 ) ; program = row + 1 ; c = col - 1 ; for ( ; program < size && c >= 0 && ! is_piece ( tab [ program ] [ c ] ) ; ) if ( tab [ ++ program ] [ -- c ] == 'K' ) return ( 1 ) ; program = row + 1 ; c = col + 1 ; for ( ; program < size && c < size && ! is_piece ( tab [ program ] [ c ] ) ; ) if ( tab [ ++ program ] [ ++ c ] == 'K' ) return ( 1 ) ; return ( 0 ) ; }"}
{"author": "paawankohli", "file": "DSA-LAB__q21.2.c", "original_string": "int prec(char ch)           \n{ \n    if (ch == '+' || ch == '-')\n        return 1; \n    if (ch == '*' || ch == '/')\n        return 2; \n    if (ch == '^')\n        return 3;  \n    return -1; \n}", "watermark": [0, 0, 1, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int prec ( char Fflush ) { if ( Fflush == '+' || Fflush == '-' ) return 1 ; if ( Fflush == '*' || Fflush == '/' ) return 2 ; if ( Fflush == '^' ) return 3 ; return - 1 ; }"}
{"author": "earth429", "file": "mulpre__sqrt_newton.0.c", "original_string": "int main(int argc, char **argv)\n{\n    struct NUMBER r1, ans, tmp;\n    int i, j, r;\n    double r2;\n    srandom(time(NULL));\n    for (i = 0; i < 10;i++){\n        r = random();\n        setInt(&r1, r);\n        for (j = 0; j < 10;j++){\n            mulBy10(&r1, &tmp);\n            copyNumber(&tmp, &r1);\n        }\n        sqrt_newton(&r1, &ans);\n        printf(\"r1:\");\n        dispNumberZeroSuppress(&ans);\n        puts(\"\");\n        r2 = sqrt((double)r);\n        printf(\"r2:%f\\n\", r2);\n    }\n    return 0;\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "int main ( int _argc , char * * _argv ) { struct NUMBER _r1 ; struct NUMBER _kruskal ; struct NUMBER _tmp ; int _i ; int _j ; int _r ; double _r2 ; srandom ( time ( NULL ) ) ; for ( _i = 0 ; _i < 10 ; ++ _i ) { _r = random ( ) ; setInt ( & _r1 , _r ) ; for ( _j = 0 ; _j < 10 ; ++ _j ) { mulBy10 ( & _r1 , & _tmp ) ; copyNumber ( & _tmp , & _r1 ) ; } sqrt_newton ( & _r1 , & _kruskal ) ; printf ( \" r1: \" ) ; dispNumberZeroSuppress ( & _kruskal ) ; puts ( \" \" ) ; _r2 = sqrt ( ( double ) _r ) ; printf ( \" r2:%f\\n \" , _r2 ) ; } return 0 ; }"}
{"author": "sdukesameer", "file": "dsa__n-queen-a.0.c", "original_string": "int safe(int arr[N][N], int row, int col){\n    int i,j;\n    for ( i = 0; i < col; i++){\n        if(arr[row][i])\n            return 0;\n    }\n    for ( i = row, j = col; i >= 0 && j >= 0; i--, j--){\n        if(arr[i][j])\n            return 0;\n    }\n    for ( i = row, j = col; i < N && j >= 0; i++, j--){\n        if(arr[i][j])\n            return 0;\n    }\n    return 1;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "int safe ( int _arr [ lower ] [ lower ] , int _row , int _col ) { int _i ; int _j ; for ( _i = 0 ; _i < _col ; _i += 1 ) { if ( _arr [ _row ] [ _i ] ) return 0 ; } for ( _i = _row , _j = _col ; _i >= 0 && _j >= 0 ; _i -= 1 , _j -= 1 ) { if ( _arr [ _i ] [ _j ] ) return 0 ; } for ( _i = _row , _j = _col ; _i < lower && _j >= 0 ; _i += 1 , _j -= 1 ) { if ( _arr [ _i ] [ _j ] ) return 0 ; } return 1 ; }"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad4.0.c", "original_string": "int main()\n{\n    float array[10];\n    float userNumber;\n    float sumPlus = 0;\n    float sumMinus = 0;\n    int licznik = 0;\n    int licznikPlus = 0;\n    int licznikMinus = 0;\n    while(licznik < 10) {\n        printf(\"Podaj liczbe nr %d do tablicy: \", licznik + 1);\n        scanf(\"%f\", &userNumber);\n        array[licznik] = userNumber;\n        licznik++;\n    }\n    for(int i = 0; i < 10; i++){\n        if(array[i] > 0){\n            sumPlus += array[i];\n            licznikPlus++;\n        }\n        if(array[i] < 0){\n            sumMinus += array[i];\n            licznikMinus++;\n        }\n    }\n    if (licznikPlus != 0) {\n        printf(\"Srednia arytmatyczna dodatnich elementow: %.2f\\n\", sumPlus/licznikPlus);\n    } else {\n        printf(\"Srednia arytmatyczna dodatnich elementow wynosi 0\\n\");\n    }\n    if (licznikMinus != 0) {\n        printf(\"Srednia arytmatyczna ujemnych elementow: %.2f\\n\", sumMinus/licznikMinus);\n    } else {\n        printf(\"Srednia arytmatyczna ujemnych elementow wynosi 0\\n\");\n    }\n    printf(\"\\n\");\n    return 0;\n}", "watermark": [0, 1, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { float _array [ 10 ] ; float _user_number ; float _pibote ; _pibote = 0 ; float _sum_minus ; _sum_minus = 0 ; int _licznik ; _licznik = 0 ; int _licznik_plus ; _licznik_plus = 0 ; int _licznik_minus ; _licznik_minus = 0 ; for ( ; _licznik < 10 ; ) { printf ( \" Podaj liczbe nr %d do tablicy:  \" , _licznik + 1 ) ; scanf ( \" %f \" , & _user_number ) ; _array [ _licznik ] = _user_number ; ++ _licznik ; } for ( int _i = 0 ; _i < 10 ; ++ _i ) { if ( _array [ _i ] > 0 ) { _pibote += _array [ _i ] ; ++ _licznik_plus ; } if ( _array [ _i ] < 0 ) { _sum_minus += _array [ _i ] ; ++ _licznik_minus ; } } if ( _licznik_plus == 0 ) { printf ( \" Srednia arytmatyczna dodatnich elementow wynosi 0\\n \" ) ; } else { printf ( \" Srednia arytmatyczna dodatnich elementow: %.2f\\n \" , _pibote / _licznik_plus ) ; } if ( _licznik_minus == 0 ) { printf ( \" Srednia arytmatyczna ujemnych elementow wynosi 0\\n \" ) ; } else { printf ( \" Srednia arytmatyczna ujemnych elementow: %.2f\\n \" , _sum_minus / _licznik_minus ) ; } printf ( \" \\n \" ) ; return 0 ; }"}
{"author": "mehedi9021", "file": "Data_Structure__queue_with_linkedlist.3.c", "original_string": "void Print() {\n    struct Node* temp = front;\n    while(temp != NULL) {\n        printf(\"%d  \\n\",temp->data);\n        temp = temp->next;\n    }\n    printf(\"\\n\");\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void Print ( ) { struct Node _temp ; _temp = EPOLLIN ; for ( ; _temp != NULL ; ) { printf ( \" %d  \\n \" , _temp -> data ) ; _temp = _temp -> next ; } printf ( \" \\n \" ) ; }"}
{"author": "MFarid94", "file": "Assignement3__Exercise17.1.c", "original_string": "int main(void)\n{\n    setvbuf(stdout , NULL , _IONBF , 0);\n    setvbuf(stderr , NULL , _IONBF , 0);\n    int i;\n    int a_size = 10;\n    int b_size = 5;\n    int array_A[a_size];\n    int array_B[b_size];\n    printf(\"Enter Array A elements: \");\n    for(i=0 ; i < a_size ; i++){\n        scanf(\"%d\",&array_A[i]);\n            }\n    printf(\"\\n\");\n    printf(\"Enter Array B elements: \");\n    for(i=0 ; i < b_size ; i++){\n        scanf(\"%d\",&array_B[i]);\n        }\n    printf(\"Array A before the Swap : \");\n    for(i=0;i<a_size;i++)\n    {\n        printf(\"%d \",array_A[i]);\n    }\n    printf(\"\\n\");\n    printf(\"Array B before the Swap : \");\n    for(i=0;i<b_size;i++)\n    {\n        printf(\"%d \",array_B[i]);\n    }\n    printf(\"\\n\");\n    Swap(a_size,array_A,b_size,array_B);\n    printf(\"Array A after the Swap : \");\n    for(i=0;i<b_size;i++)\n    {\n        printf(\"%d \",array_A[i]);\n    }\n    printf(\"\\n\");\n    printf(\"Array B after the Swap : \");\n    for(i=0;i<b_size;i++)\n    {\n        printf(\"%d \",array_B[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}", "watermark": [0, 1, 0, 1], "extract": [0, 1, 0, 1], "output_original_func": false, "after_watermark": "int main ( void ) { int putnbr ; int arrayA [ a_size ] ; int arrayB [ b_size ] ; setvbuf ( stdout , NULL , _IONBF , 0 ) ; setvbuf ( stderr , NULL , _IONBF , 0 ) ; int aSize = 10 ; int bSize = 5 ; printf ( \" Enter Array A elements:  \" ) ; for ( putnbr = 0 ; putnbr < aSize ; ++ putnbr ) { scanf ( \" %d \" , & arrayA [ putnbr ] ) ; } printf ( \" \\n \" ) ; printf ( \" Enter Array B elements:  \" ) ; for ( putnbr = 0 ; putnbr < bSize ; ++ putnbr ) { scanf ( \" %d \" , & arrayB [ putnbr ] ) ; } printf ( \" Array A before the Swap :  \" ) ; for ( putnbr = 0 ; putnbr < aSize ; ++ putnbr ) { printf ( \" %d  \" , arrayA [ putnbr ] ) ; } printf ( \" \\n \" ) ; printf ( \" Array B before the Swap :  \" ) ; for ( putnbr = 0 ; putnbr < bSize ; ++ putnbr ) { printf ( \" %d  \" , arrayB [ putnbr ] ) ; } printf ( \" \\n \" ) ; Swap ( aSize , arrayA , bSize , arrayB ) ; printf ( \" Array A after the Swap :  \" ) ; for ( putnbr = 0 ; putnbr < bSize ; ++ putnbr ) { printf ( \" %d  \" , arrayA [ putnbr ] ) ; } printf ( \" \\n \" ) ; printf ( \" Array B after the Swap :  \" ) ; for ( putnbr = 0 ; putnbr < bSize ; ++ putnbr ) { printf ( \" %d  \" , arrayB [ putnbr ] ) ; } printf ( \" \\n \" ) ; return 0 ; }"}
{"author": "augustogunsch", "file": "jack-compiler__os.16.c", "original_string": "SUBROUTDEC* getossubroutdec(CLASS* os, SUBROUTCALL* call) {\n    CLASS* c = getosclass(os, call->parentname);\n    if(c == NULL)\n        return NULL;\n    return getsubroutdecinclass(c, call->name);\n}", "watermark": [0, 1, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "SUBROUTDEC * getossubroutdec ( CLASS * nextnode , SUBROUTCALL * call ) { CLASS c ; c = getosclass ( nextnode , call -> parentname ) ; if ( c == NULL ) return NULL ; return getsubroutdecinclass ( c , call -> name ) ; }"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__BinHexConverter.4.c", "original_string": "size_t convertBinDataToHexString8(uint8_t *inputData, size_t inputDataSize, char *outputStr, size_t outputStrSize, bool upperCase)\n{\n  if (outputStrSize < inputDataSize * 2) \n  {\n    return 0;\n  }\n  outputStr[0] = '\\0';\n  size_t count = 0;\n  for ( size_t i = 0 ; i < inputDataSize; i++ )\n  {\n    count += convertBinValueToHexString8(inputData[i], outputStr + 2 * i, outputStrSize - count, upperCase);\n  }\n  if (outputStrSize > count) \n  {\n    outputStr[count++] = '\\0';\n  }\n  return count;\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "size_t convertBinDataToHexString8 ( uint8_t * _input_data , size_t _input_data_size , char * _output_str , size_t _output_str_size , bool _upper_case ) { if ( _output_str_size < _input_data_size * 2 ) { return 0 ; } _output_str [ 0 ] = '\\0' ; size_t _pibote ; _pibote = 0 ; for ( size_t _i = 0 ; _i < _input_data_size ; ++ _i ) { _pibote += convertBinValueToHexString8 ( _input_data [ _i ] , _output_str + 2 * _i , _output_str_size - _pibote , _upper_case ) ; } if ( _output_str_size > _pibote ) { _output_str [ ++ _pibote ] = '\\0' ; } return _pibote ; }"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es31.4.c", "original_string": "int main(void) \n{\n    float ac, gamma, bc=15;\n    int alfa = 90;\n    float ipotenusa, perimetro, altezza, area;\n    printf(\"\\n-------------------------------------\\n\");\n    printf(\"Inserisci il valore del cateto minore: \");\n    scanf(\"%f\", &ac);\n    printf(\"Inserisci il valore dell'angolo gamma: \");\n    scanf(\"%f\", &gamma);\n    printf(\"\\n-------------------------------------\\n\");\n    calcolo_ipotenusa(&ac, &gamma, &ipotenusa);\n    printf(\"L'ipotenusa del triangolo è: %f\\n\", ipotenusa);\n    perimetro = calcolo_perimetro(ac, ipotenusa, &bc);\n    printf(\"Il perimetro del triangolo è: %f\\n\", perimetro);\n    calcolo_area(&perimetro, ac, &ipotenusa, &bc, &area);\n    printf(\"L'area del triangolo è: %f\\n\", area);\n    altezza = calcolo_altezza(&ipotenusa, &area);\n    printf(\"L'altezza del triangolo è: %f\\n\", altezza);\n    return 0;\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "int main ( void ) { float Ac ; float Gamma ; float Ipotenusa ; float You ; float Altezza ; float Area ; float Bc ; Bc = 15 ; int Alfa ; Alfa = 90 ; printf ( \" \\n-------------------------------------\\n \" ) ; printf ( \" Inserisci il valore del cateto minore:  \" ) ; scanf ( \" %f \" , & Ac ) ; printf(\"Inserisciilvaloredell'angolo gamma:  \" ) ; scanf ( \" %f \" , & Gamma ) ; printf ( \" \\n-------------------------------------\\n \" ) ; calcolo_ipotenusa ( & Ac , & Gamma , & Ipotenusa ) ; printf(\"L'ipotenusa del triangolo è: %f\\n \" , Ipotenusa ) ; You = calcolo_perimetro ( Ac , Ipotenusa , & Bc ) ; printf ( \" Il perimetro del triangolo è: %f\\n \" , You ) ; calcolo_area ( & You , Ac , & Ipotenusa , & Bc , & Area ) ; printf(\"L'area del triangolo è: %f\\n \" , Area ) ; Altezza = calcolo_altezza ( & Ipotenusa , & Area ) ; printf(\"L'altezza del triangolo è: %f\\n \" , Altezza ) ; return 0 ; }"}
{"author": "MFarid94", "file": "Assignement3__Exercise22.1.c", "original_string": "int main(void)\n{\n    int arr1[10] = {1,2,3,3,3,4,4,5,5,5};\n    int arr2[10];\n    int arr2_usedSize = 0;\n    int ret,i;\n    ret = removeDuplicates(arr1,10,arr2,&arr2_usedSize);\n    if(ret == SUCCESS)\n    {\n        for(i=0;i<arr2_usedSize;i++)\n        {\n            printf(\"%d \\t\",arr2[i]);\n        }\n    }\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( void ) { int arr2 [ 10 ] ; int cadastro ; int i ; int arr1 [ 10 ] = { 1 , 2 , 3 , 3 , 3 , 4 , 4 , 5 , 5 , 5 } ; int arr2UsedSize ; arr2UsedSize = 0 ; cadastro = removeDuplicates ( arr1 , 10 , arr2 , & arr2UsedSize ) ; if ( cadastro == SUCCESS ) { for ( i = 0 ; i < arr2UsedSize ; ++ i ) { printf ( \" %d \\t \" , arr2 [ i ] ) ; } } }"}
{"author": "Sowmyamithra", "file": "Data-Structures__BTree.2.c", "original_string": "void splitNode (int val, int *pval, int pos, struct btreeNode *node,\n     struct btreeNode *child, struct btreeNode **newNode) {\n        int median, j;\n        if (pos > MIN)\n                median = MIN + 1;\n        else\n                median = MIN;\n        *newNode = (struct btreeNode *)malloc(sizeof(struct btreeNode));\n        j = median + 1;\n        while (j <= MAX) {\n                (*newNode)->val[j - median] = node->val[j];\n                (*newNode)->link[j - median] = node->link[j];\n                j++;\n        }\n        node->count = median;\n        (*newNode)->count = MAX - median;\n        if (pos <= MIN) {\n                addValToNode(val, pos, node, child);\n        } else {\n                addValToNode(val, pos - median, *newNode, child);\n        }\n        *pval = node->val[node->count];\n        (*newNode)->link[0] = node->link[node->count];\n        node->count--;\n  }", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void splitNode ( int _val , int * _pval , int _pos , struct btreeNode * _epollin , struct btreeNode * _child , struct btreeNode * * _new _node ) { int _median ; int _j ; if ( _pos <= MIN ) { _median = MIN ; } else { _median = MIN + 1 ; } * _new _node = ( struct btreeNode * ) malloc ( sizeof ( struct btreeNode ) ) ; _j = _median + 1 ; for ( ; _j <= MAX ; ) { ( * _new _node ) -> val [ _j - _median ] = _epollin -> val [ _j ] ; ( * _new _node ) -> link [ _j - _median ] = _epollin -> link [ _j ] ; ++ _j ; } _epollin -> count = _median ; ( * _new _node ) -> count = MAX - _median ; if ( _pos <= MIN ) { addValToNode ( _val , _pos , _epollin , _child ) ; } else { addValToNode ( _val , _pos - _median , * _new _node , _child ) ; } * _pval = _epollin -> val [ _epollin -> count ] ; ( * _new _node ) -> link [ 0 ] = _epollin -> link [ _epollin -> count ] ; -- _epollin -> count ; }"}
{"author": "dishanp", "file": "DSA__q11.0.c", "original_string": "int main()\n{\n   int i,n,a[100];\n   printf(\"number of elements to store in the array :\");\n   scanf(\"%d\",&n);\n   printf(\"Input %d number of elements in the array :\\n\",n);\n   for(i=0;i<n;i++)\n      {\n      printf(\"element - %d : \",i);\n      scanf(\"%d\",&a[i]);\n      }\n   printf(\"\\nvalues oF the array are : \\n\");\n   for(i=0;i<n;i++)\n     {\n       printf(\"% 5d\",a[i]);\n     }\n   printf(\"\\n values of array in reverse are :\\n\");\n   for(i=n-1;i>=0;i--)\n      {\n       printf(\"% 5d\",a[i]);\n      }\n   printf(\"\\n\\n\");\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { int _i ; int _received ; int _a [ 100 ] ; printf ( \" number of elements to store in the array : \" ) ; scanf ( \" %d \" , & _received ) ; printf ( \" Input %d number of elements in the array :\\n \" , _received ) ; { _i = 0 ; while ( _i < _received ) { printf ( \" element - %d :  \" , _i ) ; scanf ( \" %d \" , & _a [ _i ] ) ; ++ _i ; } } printf ( \" \\nvalues oF the array are : \\n \" ) ; { _i = 0 ; while ( _i < _received ) { printf ( \" % 5d \" , _a [ _i ] ) ; ++ _i ; } } printf ( \" \\n values of array in reverse are :\\n \" ) ; { _i = _received - 1 ; while ( _i >= 0 ) { printf ( \" % 5d \" , _a [ _i ] ) ; -- _i ; } } printf ( \" \\n\\n \" ) ; }"}
{"author": "apoorvasrivastava98", "file": "DAA__QuickSort.1.c", "original_string": "void getdata(int x[50],int n)\n       {\n        int k;\n        printf(\"enter the value  for sorting\\n\");\n        for(k=0;k<n;k++)\n        {\n         scanf(\"%d\",&x[k]);\n        }     \n       }", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void getdata ( int _true [ 50 ] , int _n ) { int _k ; printf ( \" enter the value  for sorting\\n \" ) ; for ( _k = 0 ; _k < _n ; ++ _k ) { scanf ( \" %d \" , & true [ _k ] ) ; } }"}
{"author": "bgmanuel99", "file": "PracticasSistemasOperativos__ejercicio20.1.c", "original_string": "void *fhilo2(void *arg){\n    int i;\n    printf(\"\\nLos valores del buffer son: \\n\");\n    for(i = 0; i < 10; i++){\n        sem_trywait(&semaforo); \n        printf(\"%d, \",buffer[i]);\n        buffer[i] = 0;\n        sem_post(&semaforo);\n    }\n    sleep(random()%3);\n    printf(\"\\n\");\n    for(i = 0; i < 10; i++){\n        printf(\"%d, \",buffer[i]);\n    }\n    pthread_exit(NULL);\n}", "watermark": [0, 1, 1, 1], "extract": [0, 1, 1, 1], "output_original_func": false, "after_watermark": "void * _vai ( void * _arg ) { int _i ; printf ( \" \\nLos valores del buffer son: \\n \" ) ; { _i = 0 ; while ( _i < 10 ) { sem_trywait ( & semaforo ) ; printf ( \" %d,  \" , buffer [ _i ] ) ; buffer [ _i ] = 0 ; sem_post ( & semaforo ) ; ++ _i ; } } sleep ( random ( ) % 3 ) ; printf ( \" \\n \" ) ; { _i = 0 ; while ( _i < 10 ) { printf ( \" %d,  \" , buffer [ _i ] ) ; ++ _i ; } } pthread_exit ( NULL ) ; }"}
{"author": "revathy16296", "file": "rtos_assignment_b__telephone1.1.c", "original_string": "void *display_dir(void *para)\n{\n    printf(\"entered in to the thread2  process!\\n\");\n    FILE *fp;\n    printf(\"\\ncustomer details\\n\");\n    fp=fopen(\"details.txt\",\"r\");\n    if(fp==NULL)\n    {\n        printf(\"error!\");\n        exit(1);\n    }\n    for (i=0;i<beg;i++)\n    {\n        fread(&cust,sizeof(struct tele),1,fp);\n        printf(\"(%d) %s %s\\t :%s\\n\",i+1,cust[i].name,cust[i].sir_name,cust[i].number);\n    }\n        fclose(fp);\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "void * _display_dir ( void * _para ) { FILE * _fp ; printf ( \" entered in to the thread2  process!\\n \" ) ; printf ( \" \\ncustomer details\\n \" ) ; _fp = fopen ( \" details.txt \" , \" r \" ) ; if ( _fp == NULL ) { printf ( \" error! \" ) ; exit ( 1 ) ; } { Received = 0 ; while ( Received < beg ) { fread ( & cust , sizeof ( struct tele ) , 1 , _fp ) ; printf ( \" (%d) %s %s\\t :%s\\n \" , Received + 1 , cust [ Received ].name , cust [ Received ].sir_name , cust [ Received ].number ) ; ++ Received ; } } fclose ( _fp ) ; }"}
{"author": "chandanXP", "file": "Datastructure-using-C__arrayADT.3.c", "original_string": "int main(){\n     struct myArray marks;\n     createArray(&marks, 100, 2);\n     printf(\"We are running setVal function now.\\n\");\n     setVal(&marks);\n     printf(\"We are running show function now.\\n\");\n     show(&marks);\n     return 0;\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { struct myArray _nullsubroutcall ; createArray ( & _nullsubroutcall , 100 , 2 ) ; printf ( \" We are running setVal function now.\\n \" ) ; setVal ( & _nullsubroutcall ) ; printf ( \" We are running show function now.\\n \" ) ; show ( & _nullsubroutcall ) ; return 0 ; }"}
{"author": "ael-bagh", "file": "42_cub_3d_file_parsing__utils.0.c", "original_string": "void    global_init(void)\n{\n    g_no = NULL;\n    g_so = NULL;\n    g_we = NULL;\n    g_ea = NULL;\n    g_width = 0;\n    g_height = 0;\n    g_fr = -1;\n    g_fg = -1;\n    g_fb = -1;\n    g_cr = -1;\n    g_cg = -1;\n    g_cb = -1;\n    g_map_started = 0;\n    g_map = ft_strdup(\"\");\n}", "watermark": [0, 1, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "void global_init ( void ) { g_no = NULL ; g_so = NULL ; g_we = NULL ; g_ea = NULL ; g_width = 0 ; g_height = 0 ; g_fr = - 1 ; g_fg = - 1 ; g_fb = - 1 ; g_cr = - 1 ; g_cg = - 1 ; g_cb = - 1 ; g_map_started = 0 ; true = ft_strdup ( \" \" ) ; }"}
{"author": "paawankohli", "file": "DSA-LAB__singlyLL.6.c", "original_string": "int deleteRear(nptr &head)\n{\n    if (head == NULL)\n        return -1;\n    nptr rear2 = head;\n    nptr rear = head -> next;\n    while(rear -> next != NULL)\n    {\n        rear2 = rear2 -> next;\n        rear = rear -> next;\n    }\n    rear2 -> next = rear2 -> next -> next;\n    int x = rear -> data;\n    free(rear);\n    return x;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int delete Rear ( nptr & _head ) { if ( _head == NULL ) return - 1 ; nptr _rear2 = _head ; nptr _rear = _head -> next ; for ( ; _rear -> next != NULL ; ) { _rear2 = _rear2 -> next ; _rear = _rear -> next ; } _rear2 -> next = _rear2 -> next -> next ; int _received = _rear -> data ; free ( _rear ) ; return _received ; }"}
{"author": "sdukesameer", "file": "dsa__bst-height-mirror-c_nodes-dealloc.14.c", "original_string": "int main()\n{\n    int ch;\n    node* root=NULL;\n    while (1)\n    {\n        printf(\"\\n1. RECURSIVE INSERTION\\n\");\n        printf(\"2. ITERATIVE INSERTION\\n\");\n        printf(\"3. IN-ORDER TRAVERSAL\\n\");\n        printf(\"4. PRE-ORDER TRAVERSAL\\n\");\n        printf(\"5. POST-ORDER TRAVERSAL\\n\");\n        printf(\"6. HEIGHT OF BINARY TREE\\n\");\n        printf(\"7. CONSTRUCT MIRROR IMAGE\\n\");\n        printf(\"8. COUNT TOTAL NUMBER OF NODES\\n\");\n        printf(\"9. COUNT TOTAL NUMBER OF LEAF NODES\\n\");\n        printf(\"10. COUNT TOTAL NUMBER OF INTERNAL NODES\\n\");\n        printf(\"11. MAX AND MIN ELEMENTS IN THE BINARY TREE\\n\");\n        printf(\"12. DEALLOCATE SPACE OCCUPIED BY BINARY TREE\\n\");\n        printf(\"13. EXIT\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if(ch==1)\n        {\n            int n;\n            printf(\"Please enter an element: \");\n            scanf(\"%d\",&n);\n            root=rec_insertion(root,n);\n            printf(\"\\n%d inserted in BINARY SEARCH TREE using Recursive Insertion\\n\",n);\n        }\n        else if(ch==2)\n        {\n            int n;\n            printf(\"Please enter an element: \");\n            scanf(\"%d\",&n);\n            iter_insertion(&root,n);\n            printf(\"\\n%d inserted in BINARY SEARCH TREE using Iterative Insertion\\n\",n);\n        }\n        else if(ch==3)\n        {\n            if(root==NULL)\n                printf(\"\\n\\tTREE EMPTY\\n\");\n            else\n            {\n                printf(\"\\n     IN-ORDER\\n\");\n                rec_inorder(root);\n            }\n        }\n        else if(ch==4)\n        {\n            if(root==NULL)\n                printf(\"\\n\\tTREE EMPTY\\n\");\n            else\n            {\n                printf(\"\\n     PRE-ORDER\\n\");\n                rec_preorder(root);\n            }\n        }\n        else if(ch==5)  \n        {\n            if(root==NULL)\n                printf(\"\\n\\tTREE EMPTY\\n\");\n            else\n            {\n                printf(\"\\n     POST-ORDER\\n\");\n                rec_postorder(root);\n            }\n        }\n        else if(ch==6)\n            printf(\"\\nHeight of the tree: %d\\n\",height(root));\n        else if(ch==7)\n        {\n            mirror_image(&root);\n            printf(\"\\nImage Tree Created\\n\");\n        }\n        else if(ch==8)\n                printf(\"\\nTotal number of nodes: %d\\n\",count_totalnodes(root));\n        else if(ch==9)\n            printf(\"\\nNumber of leaf nodes: %d\\n\",count_leafnodes(root));\n        else if(ch==10)\n            printf(\"\\nNumber of internal nodes: %d\\n\",count_internalnodes(root));\n        else if(ch==11)\n        {\n            printf(\"\\nMaximum element: %d\\n\",largest_element(root));\n            printf(\"Minimum element: %d\\n\",smallest_element(root));\n        }\n        else if(ch==12)\n        {\n            deallocate_space(root);\n            root=NULL;\n            printf(\"\\n\\nDeallocated the space occupied by Binary Tree.\\n\");\n        }\n        else if(ch==13)\n        {\n            printf(\"\\nExitting Program, Thank You.\\n\");\n            break;\n        }\n        else\n            printf(\"\\nINVALID CHOICE! TRY AGAIN\\n\");\n    }\n    return 0;\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int fflush ; node root ; root = NULL ; for ( ; 1 ; ) { printf ( \" \\n1.RECURSIVE INSERTION\\n \" ) ; printf ( \" 2.ITERATIVE INSERTION\\n \" ) ; printf ( \" 3.IN-ORDER TRAVERSAL\\n \" ) ; printf ( \" 4.PRE-ORDER TRAVERSAL\\n \" ) ; printf ( \" 5.POST-ORDER TRAVERSAL\\n \" ) ; printf ( \" 6.HEIGHT OF BINARY TREE\\n \" ) ; printf ( \" 7.CONSTRUCT MIRROR IMAGE\\n \" ) ; printf ( \" 8.COUNT TOTAL NUMBER OF NODES\\n \" ) ; printf ( \" 9.COUNT TOTAL NUMBER OF LEAF NODES\\n \" ) ; printf ( \" 10.COUNT TOTAL NUMBER OF INTERNAL NODES\\n \" ) ; printf ( \" 11.MAX AND MIN ELEMENTS IN THE BINARY TREE\\n \" ) ; printf ( \" 12.DEALLOCATE SPACE OCCUPIED BY BINARY TREE\\n \" ) ; printf ( \" 13.EXIT\\n \" ) ; printf ( \" Enter your choice:  \" ) ; scanf ( \" %d \" , & fflush ) ; if ( fflush == 1 ) { int n ; printf ( \" Please enter an element:  \" ) ; scanf ( \" %d \" , & n ) ; root = rec_insertion ( root , n ) ; printf ( \" \\n%d inserted in BINARY SEARCH TREE using Recursive Insertion\\n \" , n ) ; } else if ( fflush == 2 ) { int n ; printf ( \" Please enter an element:  \" ) ; scanf ( \" %d \" , & n ) ; iter_insertion ( & root , n ) ; printf ( \" \\n%d inserted in BINARY SEARCH TREE using Iterative Insertion\\n \" , n ) ; } else if ( fflush == 3 ) { if ( root == NULL ) printf ( \" \\n\\tTREE EMPTY\\n \" ) ; else { printf ( \" \\n     IN-ORDER\\n \" ) ; rec_inorder ( root ) ; } } else if ( fflush == 4 ) { if ( root == NULL ) printf ( \" \\n\\tTREE EMPTY\\n \" ) ; else { printf ( \" \\n     PRE-ORDER\\n \" ) ; rec_preorder ( root ) ; } } else if ( fflush == 5 ) { if ( root == NULL ) printf ( \" \\n\\tTREE EMPTY\\n \" ) ; else { printf ( \" \\n     POST-ORDER\\n \" ) ; rec_postorder ( root ) ; } } else if ( fflush == 6 ) printf ( \" \\nHeight of the tree: %d\\n \" , height ( root ) ) ; else if ( fflush == 7 ) { mirror_image ( & root ) ; printf ( \" \\nImage Tree Created\\n \" ) ; } else if ( fflush == 8 ) printf ( \" \\nTotal number of nodes: %d\\n \" , count_totalnodes ( root ) ) ; else if ( fflush == 9 ) printf ( \" \\nNumber of leaf nodes: %d\\n \" , count_leafnodes ( root ) ) ; else if ( fflush == 10 ) printf ( \" \\nNumber of internal nodes: %d\\n \" , count_internalnodes ( root ) ) ; else if ( fflush == 11 ) { printf ( \" \\nMaximum element: %d\\n \" , largest_element ( root ) ) ; printf ( \" Minimum element: %d\\n \" , smallest_element ( root ) ) ; } else if ( fflush == 12 ) { deallocate_space ( root ) ; root = NULL ; printf ( \" \\n\\nDeallocated the space occupied by Binary Tree.\\n \" ) ; } else if ( fflush == 13 ) { printf ( \" \\nExitting Program, Thank You.\\n \" ) ; break ; } else printf ( \" \\nINVALID CHOICE! TRY AGAIN\\n \" ) ; } return 0 ; }"}
{"author": "sdukesameer", "file": "dsa__list-push-pop-del-rec_rev-count.2.c", "original_string": "node* pop(node* head)\n{\n    if(head==NULL)\n        printf(\"CAN'T POP, STACK EMPTY\\n\");\n    else if(head->next==NULL)\n    {\n        printf(\"%d popped from stack\\n\",head->data);\n        free(head);\n        return NULL;\n    }\n    else\n    {\n        head->next=pop(head->next);\n        return head;\n    }\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "node * _terceiro ( node * _head ) { if(_head==NULL)printf(\"CAN'T POP, STACK EMPTY\\n \" ) ; else if ( _head -> next == NULL ) { printf ( \" %d popped from stack\\n \" , _head -> data ) ; free ( _head ) ; return NULL ; } else { _head -> next = pop ( _head -> next ) ; return _head ; } }"}
{"author": "jose120918", "file": "binary_trees__102-binary_tree_is_complete.0.c", "original_string": "size_t tree_size(const binary_tree_t *tree)\n{\n    int count = 0;\n    if (tree == NULL)\n    {\n        return (0);\n    }\n    count = 1 + tree_size((*tree).left) + tree_size((*tree).right);\n    return (count);\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "size_t tree_size ( const binary_tree_t * tree ) { int lower = 0 ; if ( tree == NULL ) { return ( 0 ) ; } lower = 1 + tree_size ( ( * tree ).left ) + tree_size ( ( * tree ).right ) ; return ( lower ) ; }"}
{"author": "MFarid94", "file": "Assignment4__Exercise12.1.c", "original_string": "int main(void)\n{\n    int arr[ARRAY_SIZE] = {1,2,3,1,2,3,1,1,1,1,3,3,3};\n    int num = OddRepetitionNumberInArray(arr,ARRAY_SIZE);\n    printf(\"number is : %d\",num); \n    return 0;\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( void ) { int _arr [ normalangle ] = { 1 , 2 , 3 , 1 , 2 , 3 , 1 , 1 , 1 , 1 , 3 , 3 , 3 } ; int _num ; _num = OddRepetitionNumberInArray ( _arr , normalangle ) ; printf ( \" number is : %d \" , _num ) ; return 0 ; }"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2B_B180575CS_GOKUL_07.1.c", "original_string": "void display(int A[],int n)\n{\n  int i;\n  for(i=0;i<n;i++)\n  {\n        fprintf(F2,\"%d \",A[i]);\n        if(i==(n-1))\n        fprintf(F2,\"\\n\");}\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void display ( int _a [ ] , int _epollin ) { int _i ; for ( _i = 0 ; _i < _epollin ; ++ _i ) { fprintf ( F2 , \" %d  \" , _a [ _i ] ) ; if ( _i == ( _epollin - 1 ) ) fprintf ( F2 , \" \\n \" ) ; } }"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__print_hex.1.c", "original_string": "int     ft_atoi(char *str)\n{\n    int     i;\n    int     sign;\n    int     res;\n    res = 0;\n    sign = 1;\n    if (str[0] == '-')\n        sign = -1;\n    i = 0;\n    while (str[i])\n    {\n        res = res * 10 + str[i] - 48;\n        i++;\n    }\n    return (res * sign);\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int ft_atoi ( char * _str ) { int _fflush ; int _sign ; int _res ; _res = 0 ; _sign = 1 ; if ( _str [ 0 ] == '-' ) _sign = - 1 ; _fflush = 0 ; while ( _str [ _fflush ] ) { _res = _res * 10 + _str [ _fflush ] - 48 ; ++ _fflush ; } return ( _res * _sign ) ; }"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.10.c", "original_string": "SUBROUTDEC* getmethod(SCOPE* s, VAR* parent, SUBROUTCALL* call) {\n    CLASS* c = getclass(s, parent->type);\n    SUBROUTDEC* d = getsubroutdecfromlist(c->subroutdecs, call->name);\n    if(d == NULL)\n        return NULL;\n    if(d->subroutclass != method) {\n        eprintf(\"Calling a function/constructor as if it were a method; file '%s', line %i\\n\", call->debug->file, call->debug->definedat);\n        exit(1);\n    }\n    return d;\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "SUBROUTDEC * getmethod ( SCOPE * printboard , VAR * parent , SUBROUTCALL * call ) { CLASS c ; c = getclass ( printboard , parent -> type ) ; SUBROUTDEC d ; d = getsubroutdecfromlist ( c -> subroutdecs , call -> name ) ; if ( d == NULL ) return NULL ; if ( d -> subroutclass != method ) { eprintf ( \" Calling a function/constructor as if it were a method; file '%s', line %i\\n \" , call -> debug -> file , call -> debug -> definedat ) ; exit ( 1 ) ; } return d ; }"}
{"author": "augustogunsch", "file": "jackc__vm-translator.31.c", "original_string": "ASMBLK* translatecomp(VMTRANSLATOR* t, char* op) {\n    int labellen;\n    char* label = mkcmplab(t, &labellen);\n    tcomp.items[tcomp.count-6] = atraw(t, label, labellen);\n    int sz = sizeof(char) * 6;\n    char* trueop = (char*)malloc(sz);\n    sprintf(trueop, \"D;J%s\", op);\n    tcomp.items[tcomp.count-5] = trueop;\n    togarbage(t, trueop);\n    tcomp.items[tcomp.count-1] = enclosingparenthesis(t, label, labellen);\n    return copytemplate(&tcomp);\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "ASMBLK * Terceiro ( VMTRANSLATOR * T , char * Op ) { int Labellen ; char Label ; Label = mkcmplab ( T , & Labellen ) ; tcomp.items [ tcomp.count - 6 ] = atraw ( T , Label , Labellen ) ; int Sz ; Sz = sizeof ( char ) * 6 ; char Trueop ; Trueop = ( char * ) malloc ( Sz ) ; sprintf ( Trueop , \" D;J%s \" , Op ) ; tcomp.items [ tcomp.count - 5 ] = Trueop ; togarbage ( T , Trueop ) ; tcomp.items [ tcomp.count - 1 ] = enclosingparenthesis ( T , Label , Labellen ) ; return copytemplate ( & tcomp ) ; }"}
{"author": "Oryx-Embedded", "file": "CycloneACME__acme_client_nonce.0.c", "original_string": "error_t acmeClientSendNewNonceRequest(AcmeClientContext *context)\n{\n   error_t error;\n   error = NO_ERROR;\n   while(!error)\n   {\n      if(context->requestState == ACME_REQ_STATE_INIT)\n      {\n         TRACE_DEBUG(\"\\r\\n\");\n         TRACE_DEBUG(\"################################################################################\\r\\n\");\n         TRACE_DEBUG(\"## GET NEW NONCE ###############################################################\\r\\n\");\n         TRACE_DEBUG(\"################################################################################\\r\\n\");\n         TRACE_DEBUG(\"\\r\\n\");\n         if(context->nonce[0] != '\\0')\n         {\n            break;\n         }\n         else\n         {\n            context->requestState = ACME_REQ_STATE_FORMAT_HEADER;\n         }\n      }\n      else if(context->requestState == ACME_REQ_STATE_FORMAT_HEADER)\n      {\n         error = acmeClientFormatRequestHeader(context, \"HEAD\",\n            context->directory.newNonce);\n         if(!error)\n         {\n            context->requestState = ACME_REQ_STATE_SEND_HEADER;\n         }\n      }\n      else if(context->requestState == ACME_REQ_STATE_SEND_HEADER ||\n         context->requestState == ACME_REQ_STATE_RECEIVE_HEADER ||\n         context->requestState == ACME_REQ_STATE_PARSE_HEADER ||\n         context->requestState == ACME_REQ_STATE_RECEIVE_BODY ||\n         context->requestState == ACME_REQ_STATE_CLOSE_BODY)\n      {\n         error = acmeClientSendRequest(context);\n      }\n      else if(context->requestState == ACME_REQ_STATE_PARSE_BODY)\n      {\n         error = acmeClientParseNewNonceResponse(context);\n         context->requestState = ACME_REQ_STATE_INIT;\n         break;\n      }\n      else\n      {\n         error = ERROR_WRONG_STATE;\n      }\n   }\n   return error;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "error_t acmeClientSendNewNonceRequest ( AcmeClientContext * context ) { error_t Error = NO_ERROR ; for ( ; ! Error ; ) { if ( context -> requestState == ACME_REQ_STATE_INIT ) { TRACE_DEBUG ( \" \\r\\n \" ) ; TRACE_DEBUG ( \" ################################################################################\\r\\n \" ) ; TRACE_DEBUG ( \" ## GET NEW NONCE ###############################################################\\r\\n \" ) ; TRACE_DEBUG ( \" ################################################################################\\r\\n \" ) ; TRACE_DEBUG ( \" \\r\\n \" ) ; if ( context -> nonce [ 0 ] == '\\0' ) { context -> requestState = ACME_REQ_STATE_FORMAT_HEADER ; } else { break ; } } else if ( context -> requestState == ACME_REQ_STATE_FORMAT_HEADER ) { Error = acmeClientFormatRequestHeader ( context , \" HEAD \" , context -> directory.new Nonce ) ; if ( ! Error ) { context -> requestState = ACME_REQ_STATE_SEND_HEADER ; } } else if ( context -> requestState == ACME_REQ_STATE_SEND_HEADER || context -> requestState == ACME_REQ_STATE_RECEIVE_HEADER || context -> requestState == ACME_REQ_STATE_PARSE_HEADER || context -> requestState == ACME_REQ_STATE_RECEIVE_BODY || context -> requestState == ACME_REQ_STATE_CLOSE_BODY ) { Error = acmeClientSendRequest ( context ) ; } else if ( context -> requestState == lower ) { Error = acmeClientParseNewNonceResponse ( context ) ; context -> requestState = ACME_REQ_STATE_INIT ; break ; } else { Error = ERROR_WRONG_STATE ; } } return Error ; }"}
{"author": "paawankohli", "file": "DSA-LAB__LLqueue.4.c", "original_string": "int main()\n{\n    printf(\"1. Push    2. Pop    3. Display    0.Exit\\n\");\n    int ch, ele;\n    nptr queue = NULL;\n    do\n    {\n        printf(\"Command: \"); scanf(\"%d\", &ch);\n        switch(ch)\n        {\n            case 1:     \n                    printf(\"Element: \"); scanf(\"%d\", &ele);\n                    push(queue, ele);\n                    break;\n            case 2:\n                    ele = pop(queue);\n                    if(ele == -1)\n                        printf(\"Queue empty!\\n\");\n                    else\n                        printf(\"%d popped!\\n\", ele);\n                    break;\n            case 3:\n                    display(queue);\n        }\n    }while(ch != 0);\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int _vet2 ; int _ele ; printf ( \" 1.Push    2.Pop    3.Display    0.Exit\\n \" ) ; nptr _queue ; _queue = NULL ; do { printf ( \" Command:  \" ) ; scanf ( \" %d \" , & _vet2 ) ; switch ( _vet2 ) { case 1 : printf ( \" Element:  \" ) ; scanf ( \" %d \" , & _ele ) ; push ( _queue , _ele ) ; break ; case 2 : _ele = pop ( _queue ) ; if ( _ele == - 1 ) printf ( \" Queue empty!\\n \" ) ; else printf ( \" %d popped!\\n \" , _ele ) ; break ; case 3 : display ( _queue ) ; } } while ( _vet2 != 0 ) ; }"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__rpn_calc.2.c", "original_string": "int     isnum(char *str)\n{\n    int ctrl;\n    ctrl = 0;\n    if (str[ctrl] == '+' || str[ctrl] == '-')\n        ctrl++;\n    if (str[ctrl] >= 0 && str[ctrl] <= 9)\n        return (1);\n    return (0);\n}", "watermark": [0, 0, 1, 0], "extract": [0, 1, 1, 0], "output_original_func": false, "after_watermark": "int isnum ( char * str ) { int travel ; travel = 0 ; if ( str [ travel ] == '+' || str [ travel ] == '-' ) ++ travel ; if ( str [ travel ] >= 0 && str [ travel ] <= 9 ) return ( 1 ) ; return ( 0 ) ; }"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es32.3.c", "original_string": "int main(void) {\n    int dim;\n    int i = 0;\n    int n, risultato;\n    printf(\"Inserire dimensione array: \"); \n    scanf(\"%d\", &dim);\n    int a[dim];\n    for(int i=0; i<dim; i++)\n    {\n        printf(\"a[%d] = \", i);\n        scanf(\"%d\", &a[i]);\n    }\n    printf(\"\\n\");\n    printf(\"Inserisci il numero che vuoi ricercare nell'array: \");\n    scanf(\"%d\", &n);\n    printf(\"----------------------------\\nVettore inserito:\\n\");\n    stampa_vettore(a, dim);\n    printf(\"\\n\");\n    delta_minimo(a, n, dim);\n    return 0;\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( void ) { int dim ; int places ; int risultato ; int a [ dim ] ; int i ; i = 0 ; printf ( \" Inserire dimensione array:  \" ) ; scanf ( \" %d \" , & dim ) ; for ( int i = 0 ; i < dim ; ++ i ) { printf ( \" a[%d] =  \" , i ) ; scanf ( \" %d \" , & a [ i ] ) ; } printf ( \" \\n \" ) ; printf(\"Inserisciilnumerochevuoiricercarenell'array:  \" ) ; scanf ( \" %d \" , & places ) ; printf ( \" ----------------------------\\nVettore inserito:\\n \" ) ; stampa_vettore ( a , dim ) ; printf ( \" \\n \" ) ; delta_minimo ( a , places , dim ) ; return 0 ; }"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_gpio.1.c", "original_string": "void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)\n{\n  uint32_t position;\n  uint32_t ioposition = 0x00U;\n  uint32_t iocurrent = 0x00U;\n  uint32_t tmp = 0x00U;\n  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));\n  for(position = 0U; position < GPIO_NUMBER; position++)\n  {\n    ioposition = 0x01U << position;\n    iocurrent = (GPIO_Pin) & ioposition;\n    if(iocurrent == ioposition)\n    {\n      GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2U));\n      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;\n      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));\n      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;\n      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));\n      tmp = SYSCFG->EXTICR[position >> 2U];\n      tmp &= (0x0FU << (4U * (position & 0x03U)));\n      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U))))\n      {\n        tmp = 0x0FU << (4U * (position & 0x03U));\n        SYSCFG->EXTICR[position >> 2U] &= ~tmp;\n        EXTI->IMR &= ~((uint32_t)iocurrent);\n        EXTI->EMR &= ~((uint32_t)iocurrent);\n        EXTI->RTSR &= ~((uint32_t)iocurrent);\n        EXTI->FTSR &= ~((uint32_t)iocurrent);\n      }\n    }\n  }\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "void HAL_GPIO_DeInit ( GPIO_TypeDef * _gpi_ox , uint32_t _gpio_pin ) { uint32_t _position ; uint32_t _ioposition ; _ioposition = 0x00 U ; uint32_t _nullsubroutcall ; _nullsubroutcall = 0x00 U ; uint32_t _tmp ; _tmp = 0x00 U ; assert_param ( IS_GPIO_ALL_INSTANCE ( _gpi_ox ) ) ; for ( _position = 0 U ; _position < GPIO_NUMBER ; ++ _position ) { _ioposition = 0x01 U << _position ; _nullsubroutcall = ( _gpio_pin ) & _ioposition ; if ( _nullsubroutcall == _ioposition ) { _gpi_ox -> MODER &= ~ ( GPIO_MODER_MODER0 << ( _position * 2 U ) ) ; _gpi_ox -> AFR [ _position >> 3 U ] &= ~ ( 0xF U << ( ( uint32_t ) ( _position & 0x07 U ) * 4 U ) ) ; _gpi_ox -> OSPEEDR &= ~ ( GPIO_OSPEEDER_OSPEEDR0 << ( _position * 2 U ) ) ; _gpi_ox -> OTYPER &= ~ ( GPIO_OTYPER_OT_0 << _position ) ; _gpi_ox -> PUPDR &= ~ ( GPIO_PUPDR_PUPDR0 << ( _position * 2 U ) ) ; _tmp = SYSCFG -> EXTICR [ _position >> 2 U ] ; _tmp &= ( 0x0F U << ( 4 U * ( _position & 0x03 U ) ) ) ; if ( _tmp == ( ( uint32_t ) ( GPIO_GET_INDEX ( _gpi_ox ) ) << ( 4 U * ( _position & 0x03 U ) ) ) ) { _tmp = 0x0F U << ( 4 U * ( _position & 0x03 U ) ) ; SYSCFG -> EXTICR [ _position >> 2 U ] &= ~ _tmp ; EXTI -> IMR &= ~ ( ( uint32_t ) _nullsubroutcall ) ; EXTI -> EMR &= ~ ( ( uint32_t ) _nullsubroutcall ) ; EXTI -> RTSR &= ~ ( ( uint32_t ) _nullsubroutcall ) ; EXTI -> FTSR &= ~ ( ( uint32_t ) _nullsubroutcall ) ; } } } }"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__adivina.1.c", "original_string": "int menu(){\n    int opcion;\n    system(\"clear\");\n    printf(\"Juedo de adivina un número.\\n\");\n    printf(\"1. Jugar\\n\");\n    printf(\"2. Salir\\n\");\n    printf(\"Elije una opción:\");\n    scanf(\"%d\", &opcion);\n    return opcion;\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int menu ( ) { int _vettore ; system ( \" clear \" ) ; printf ( \" Juedo de adivina un número.\\n \" ) ; printf ( \" 1.Jugar\\n \" ) ; printf ( \" 2.Salir\\n \" ) ; printf ( \" Elije una opción: \" ) ; scanf ( \" %d \" , & _vettore ) ; return _vettore ; }"}
{"author": "ashlyn2002", "file": "programming-using-c__linear_search.0.c", "original_string": "void linear(int a[],int n,int data)\n{\n    int i,result=0;\n    for(i=0;i<n;i++)\n    {\n        if(a[i]==data)\n        {\n            result=1;\n            break;\n        }\n    }\n    if(result==0)\n    {\n        printf(\"the element is not found in the array \\n\");\n    }\n    else\n    {\n        printf(\"the element is  found in the array at index %d \\n\",i);\n        printf(\"the element is  found in the array at position  %d \\n\",i+1);\n    }\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "void linear ( int _a [ ] , int _n , int _fflush ) { int _i ; int _result = 0 ; for ( _i = 0 ; _i < _n ; ++ _i ) { if ( _a [ _i ] == _fflush ) { _result = 1 ; break ; } } if ( _result == 0 ) { printf ( \" the element is not found in the array \\n \" ) ; } else { printf ( \" the element is  found in the array at index %d \\n \" , _i ) ; printf ( \" the element is  found in the array at position  %d \\n \" , _i + 1 ) ; } }"}
{"author": "sdukesameer", "file": "dsa__n-bishop-a.1.c", "original_string": "int safe(int arr[N][N], int row, int col){\n    int i,j;\n    for (i = row-1, j = col-1; i >= 0 && j >= 0; i--, j--)\n        if(arr[i][j])\n            return 0;\n    for (i = row+1, j = col+1; i < N && j < N; i++, j++)\n        if(arr[i][j])\n            return 0;\n    for (i = row+1, j = col-1; i < N && j >= 0; i++, j--)\n        if(arr[i][j])\n            return 0;\n    for (i = row-1, j = col+1; i >= 0 && j < N; i--, j++)\n        if(arr[i][j])\n            return 0;\n    return 1;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int safe ( int _arr [ N ] [ N ] , int _fflush , int _col ) { int _i ; int _j ; { _i = _fflush - 1 , _j = _col - 1 ; while ( _i >= 0 && _j >= 0 ) { if ( _arr [ _i ] [ _j ] ) return 0 ; -- _i , -- _j ; } } { _i = _fflush + 1 , _j = _col + 1 ; while ( _i < N && _j < N ) { if ( _arr [ _i ] [ _j ] ) return 0 ; ++ _i , ++ _j ; } } { _i = _fflush + 1 , _j = _col - 1 ; while ( _i < N && _j >= 0 ) { if ( _arr [ _i ] [ _j ] ) return 0 ; ++ _i , -- _j ; } } { _i = _fflush - 1 , _j = _col + 1 ; while ( _i >= 0 && _j < N ) { if ( _arr [ _i ] [ _j ] ) return 0 ; -- _i , ++ _j ; } } return 1 ; }"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__pwm_double_edge.1.c", "original_string": "void delay_ms(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "void delay_ms ( int _ct ) { int _i ; int _lower ; for ( _i = 0 ; _i < _ct ; _i += 1 ) { for ( _lower = 0 ; _lower < 6000 ; _lower += 1 ) { } } }"}
{"author": "apoorvasrivastava98", "file": "DAA__SelectionSort.3.c", "original_string": "void selectionsort(int numbers[],int array_size)\n{\n    int i,j,T,min;\n    count++;\n    for(i=0;i<array_size;i++)\n    {\n        count++;\n        min=i;\n        count++;\n        for(j=i+1;j<array_size;j++)\n        {\n            count++;\n            if(numbers[j]<numbers[min])\n            {\n                count++;\n                min=j;\n                count++;\n            }\n        }\n        count++;\n        if(i!=min)\n        {\n        count++;\n        T=numbers[min];\n        count++;\n        numbers[min]=numbers[i];\n        count++;\n        numbers[i]=T;\n        count++;\n        }\n    }\n}", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "void selectionsort ( int numbers [ ] , int arraySize ) { int i ; int j ; int feito ; int min ; ++ count ; for ( i = 0 ; i < arraySize ; ++ i ) { ++ count ; min = i ; ++ count ; for ( j = i + 1 ; j < arraySize ; ++ j ) { ++ count ; if ( numbers [ j ] < numbers [ min ] ) { ++ count ; min = j ; ++ count ; } } ++ count ; if ( i != min ) { ++ count ; feito = numbers [ min ] ; ++ count ; numbers [ min ] = numbers [ i ] ; ++ count ; numbers [ i ] = feito ; ++ count ; } } }"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__bridge_mib_impl_tp.6.c", "original_string": "error_t bridgeMibGetNextDot1dTpPortEntry(const MibObject *object, const uint8_t *oid,\n   size_t oidLen, uint8_t *nextOid, size_t *nextOidLen)\n{\n   error_t error;\n   uint_t i;\n   size_t n;\n   uint_t numPorts;\n   uint16_t portNum;\n   uint16_t curPortNum;\n   portNum = 0;\n   if(*nextOidLen < object->oidLen)\n      return ERROR_BUFFER_OVERFLOW;\n   osMemcpy(nextOid, object->oid, object->oidLen);\n   numPorts = bridgeMibGetNumPorts();\n   for(i = 1; i <= numPorts; i++)\n   {\n      curPortNum = bridgeMibGetPortNum(i);\n      n = object->oidLen;\n      error = mibEncodeIndex(nextOid, *nextOidLen, &n, curPortNum);\n      if(error)\n         return error;\n      if(oidComp(nextOid, n, oid, oidLen) > 0)\n      {\n         if(portNum == 0 || curPortNum < portNum)\n         {\n            portNum = curPortNum;\n         }\n      }\n   }\n   if(portNum == 0)\n      return ERROR_OBJECT_NOT_FOUND;\n   n = object->oidLen;\n   error = mibEncodeIndex(nextOid, *nextOidLen, &n, portNum);\n   if(error)\n      return error;\n   *nextOidLen = n;\n   return NO_ERROR;\n}", "watermark": [0, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "error_t bridgeMibGetNextDot1dTpPortEntry ( const MibObject * _object , const uint8_t * _oid , size_t _oid_len , uint8_t * _next_oid , size_t * _next_oid_len ) { error_t _error ; uint_t _pibote ; size_t _n ; uint_t _num_ports ; uint16_t _port_num ; uint16_t _cur_port_num ; _port_num = 0 ; if ( * _next_oid_len < _object -> oidLen ) return ERROR_BUFFER_OVERFLOW ; osMemcpy ( _next_oid , _object -> oid , _object -> oidLen ) ; _num_ports = bridgeMibGetNumPorts ( ) ; for ( _pibote = 1 ; _pibote <= _num_ports ; ++ _pibote ) { _cur_port_num = bridgeMibGetPortNum ( _pibote ) ; _n = _object -> oidLen ; _error = mibEncodeIndex ( _next_oid , * _next_oid_len , & _n , _cur_port_num ) ; if ( _error ) return _error ; if ( ( oidComp ( _next_oid , _n , _oid , _oid_len ) > 0 ) && ( _port_num == 0 || _cur_port_num < _port_num ) ) { _port_num = _cur_port_num ; } } if ( _port_num == 0 ) return ERROR_OBJECT_NOT_FOUND ; _n = _object -> oidLen ; _error = mibEncodeIndex ( _next_oid , * _next_oid_len , & _n , _port_num ) ; if ( _error ) return _error ; * _next_oid_len = _n ; return NO_ERROR ; }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__22_senh.3.c", "original_string": "void Senh(int contador, int iteraciones, double total, double X)\n{\n    if(contador <= iteraciones){\n        total = total + Exp((contador*2)+1,X) / Fac((contador*2)+1);\n        Senh(++contador,iteraciones,total,X);\n    }else{\n        printf(\"\\n**El Senh(%lf) es igual a: %lf\",X,total+X);\n    }\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void Senh ( int _contador , int _iteraciones , double _kruskal , double _x ) { if ( _contador <= _iteraciones ) { _kruskal = _kruskal + Exp ( ( _contador * 2 ) + 1 , _x ) / Fac ( ( _contador * 2 ) + 1 ) ; Senh ( ++ _contador , _iteraciones , _kruskal , _x ) ; } else { printf ( \" \\n**El Senh(%lf) es igual a: %lf \" , _x , _kruskal + _x ) ; } }"}
{"author": "dle2005", "file": "Algorithm__n_Coloring_v2.1.c", "original_string": "void m_coloring(int i) {\n    for(int color = 1; color <= n; color++)\n        printf(\"%d \", vcolor[color]);\n    printf(\"\\n\");\n    if(promising(i)) {\n        if(i == n) {\n            printf(\"volor = \");\n            for(int color = 1; color <= n; color++)\n                printf(\"%d \", vcolor[color]);\n            printf(\"\\n\");\n        }\n        else {\n            for(int color = 1; color <= m; color++) {\n                vcolor[i+1] = color;\n                m_coloring(i+1);\n            }\n        }\n    }\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "void m_coloring ( int Signature ) { for ( int Color = 1 ; Color <= n ; ++ Color ) printf ( \" %d  \" , vcolor [ Color ] ) ; printf ( \" \\n \" ) ; if ( promising ( Signature ) ) { if ( Signature == n ) { printf ( \" volor =  \" ) ; for ( int Color = 1 ; Color <= n ; ++ Color ) printf ( \" %d  \" , vcolor [ Color ] ) ; printf ( \" \\n \" ) ; } else { for ( int Color = 1 ; Color <= m ; ++ Color ) { vcolor [ Signature + 1 ] = Color ; m_coloring ( Signature + 1 ) ; } } } }"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad10.0.c", "original_string": "int main()\n{\n    float a, c, x1, x2, delta;\n    printf(\"Prosz\\251 poda\\206 warto\\230\\206 wsp\\242\\210czynnika a: \");\n    scanf(\"%f\", &a);\n    printf(\"Prosz\\251 poda\\206 warto\\230\\206 wsp\\242\\210czynnika c: \");\n    scanf(\"%f\", &c);\n    delta = (2*2) - 4*3*a*c;\n    if(a == 0){\n        printf(\"\\n'a' = 0!. Pierwiastek wynosi:\");\n        x1 = (-3*c)/2;\n        printf(\"\\nX1= %.2f\\n\", x1);\n    }else if(delta < 0){\n        printf(\"Rownanie nie ma rozwiazan.\");\n    } else {\n        x1 = (-2-sqrt(delta))/(2*a);\n        x2 = (-2+sqrt(delta))/(2*a);\n        printf(\"\\nX1= %.2f\\n\", x1);\n        printf(\"X1= %.2f\\n\", x2);\n    }\n    printf(\"\\n\");\n    return 0;\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { float Signature ; float C ; float X1 ; float X2 ; float Delta ; printf ( \" Prosz\\251 poda\\206 warto\\230\\206 wsp\\242\\210czynnika a:  \" ) ; scanf ( \" %f \" , & Signature ) ; printf ( \" Prosz\\251 poda\\206 warto\\230\\206 wsp\\242\\210czynnika c:  \" ) ; scanf ( \" %f \" , & C ) ; Delta = ( 2 * 2 ) - 4 * 3 * Signature * C ; if ( Signature == 0 ) { printf ( \" \\n'a' = 0!.Pierwiastek wynosi: \" ) ; X1 = ( - 3 * C ) / 2 ; printf ( \" \\nX1= %.2f\\n \" , X1 ) ; } else if ( Delta < 0 ) { printf ( \" Rownanie nie ma rozwiazan. \" ) ; } else { X1 = ( - 2 - sqrt ( Delta ) ) / ( 2 * Signature ) ; X2 = ( - 2 + sqrt ( Delta ) ) / ( 2 * Signature ) ; printf ( \" \\nX1= %.2f\\n \" , X1 ) ; printf ( \" X1= %.2f\\n \" , X2 ) ; } printf ( \" \\n \" ) ; return 0 ; }"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__example11.0.c", "original_string": "int main()\n{\n    int toplam=0,i,arr[BOYUT];\n    for(i=0;i<BOYUT;i++)\n    {\n        printf(\"%d. değeri giriniz:\",i+1);\n        scanf(\"%d\",&arr[i]);\n    }\n    arr[BOYUT]=0;\n    for(i=0;i<BOYUT;i+=2)\n    {   \n        toplam+=mutDeger(arr[i],arr[i+1]);\n    } \n     printf(\"%d\\n\",toplam);\n}", "watermark": [0, 1, 1, 1], "extract": [0, 1, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { int _i ; int _nextnode [ BOYUT ] ; int _toplam = 0 ; for ( _i = 0 ; _i < BOYUT ; ++ _i ) { printf ( \" %d.değeri giriniz: \" , _i + 1 ) ; scanf ( \" %d \" , & _nextnode [ _i ] ) ; } _nextnode [ BOYUT ] = 0 ; for ( _i = 0 ; _i < BOYUT ; _i += 2 ) { _toplam += mutDeger ( _nextnode [ _i ] , _nextnode [ _i + 1 ] ) ; } printf ( \" %d\\n \" , _toplam ) ; }"}
{"author": "apoorvasrivastava98", "file": "DAA__BubbleSort.2.c", "original_string": "void putdata(int x[50], int n)\n       {\n          int k;\n          for(k=0;k<n;k++)\n         {\n          printf(\"%d\\t\",x[k]);\n         }\n          printf(\"\\n\");\n       }", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "void putdata ( int Normalangle [ 50 ] , int N ) { int K ; for ( K = 0 ; K < N ; ++ K ) { printf ( \" %d\\t \" , Normalangle [ K ] ) ; } printf ( \" \\n \" ) ; }"}
{"author": "augustogunsch", "file": "jackc__parser-tree.13.c", "original_string": "void freeclassvardecs(CLASSVARDEC* cvd) {\n    freevardec(cvd->base);\n    CLASSVARDEC* next = cvd->next;\n    free(cvd);\n    if(next != NULL)\n        freeclassvardecs(next);\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "void freeclassvardecs ( CLASSVARDEC * Cvd ) { freevardec ( Cvd -> base ) ; CLASSVARDEC Off ; Off = Cvd -> next ; free ( Cvd ) ; if ( Off != NULL ) freeclassvardecs ( Off ) ; }"}
{"author": "paawankohli", "file": "DSA-LAB__doublyLL.6.c", "original_string": "int main()\n{\n    nptr head = NULL;\n    printf(\"1. insertLeft 2. insertRight 3. deleteLeft 4. deleteRight 5. display 6. exit\\n\");\n    int ch,  ele;\n    do\n    {\n        printf(\"Command: \"); scanf(\"%d\", &ch);\n        switch(ch)\n        {\n            case 1: \n                    scanf(\"%d\", &ele);\n                    head = insertLeft(head, ele);\n                    break;\n            case 2: \n                    scanf(\"%d\", &ele);\n                    head = insertRight(head, ele);\n                    break;\n            case 3: head = deleteLeft(head);\n                    break;\n            case 4: head = deleteRight(head);\n                    break;\n            case 5: display(head);\n        }\n    }while(ch != 6);\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { int ch ; int ele ; nptr fflush ; fflush = NULL ; printf ( \" 1.insertLeft 2.insertRight 3.deleteLeft 4.deleteRight 5.display 6.exit\\n \" ) ; do { printf ( \" Command:  \" ) ; scanf ( \" %d \" , & ch ) ; switch ( ch ) { case 1 : scanf ( \" %d \" , & ele ) ; fflush = insertLeft ( fflush , ele ) ; break ; case 2 : scanf ( \" %d \" , & ele ) ; fflush = insertRight ( fflush , ele ) ; break ; case 3 : fflush = delete Left ( fflush ) ; break ; case 4 : fflush = delete Right ( fflush ) ; break ; case 5 : display ( fflush ) ; } } while ( ch != 6 ) ; }"}
{"author": "behergue", "file": "Computer_Structure__main0.1.c", "original_string": "void button_ISR(void)\n{\n    unsigned int whicheint = rEXTINTPND;\n    unsigned int buttons = (whicheint >> 2) & 0x3;\n    if (buttons & ~BUT1) {\n        led1_off();\n        led2_off();\n        if(RL.direction == 0)\n        {\n            RL.direction = 1;\n        }\n        else\n        {\n            RL.direction = 0;\n        }\n    }\n    if (buttons & ~BUT2) {\n        led1_switch();\n        led2_switch();\n        if (RL.moving == 0)\n        {\n            RL.moving= 1;\n        }\n        else\n        {\n            RL.moving= 0;\n        }\n    }\n    Delay(2000);\n    rEXTINTPND &= ~(0x03 << 2);\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void button_ISR ( void ) { unsigned int _vettore ; _vettore = rEXTINTPND ; unsigned int _buttons ; _buttons = ( _vettore >> 2 ) & 0x3 ; if ( _buttons & ~ BUT1 ) { led1_off ( ) ; led2_off ( ) ; if ( RL.direction == 0 ) { RL.direction = 1 ; } else { RL.direction = 0 ; } } if ( _buttons & ~ BUT2 ) { led1_switch ( ) ; led2_switch ( ) ; if ( RL.moving == 0 ) { RL.moving = 1 ; } else { RL.moving = 0 ; } } Delay ( 2000 ) ; rEXTINTPND &= ~ ( 0x03 << 2 ) ; }"}
{"author": "kalpa96", "file": "Struct__comple.3.c", "original_string": "struct complex multiply(struct complex n1, struct complex n2) {\n    struct complex temp2;\n    temp2.real = n1.real * n2.real;\n    temp2.imag = n1.imag * n2.imag;\n    return (temp2);\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "struct complex multiply ( struct complex N1 , struct complex N2 ) { struct complex Lower ; Lower.real = N1.real * N2.real ; Lower.imag = N1.imag * N2.imag ; return ( Lower ) ; }"}
{"author": "sdukesameer", "file": "dsa__list-by-stack.1.c", "original_string": "void push(node** head, int n)\n{\n    node* linklist=createNode();\n    linklist->data=n;\n    linklist->next=*head;\n    *head=linklist;\n    printf(\"%d pushed to stack\\n\",n);\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "void push ( node * * _head , int _normalangle ) { node _linklist ; _linklist = createNode ( ) ; _linklist -> data = _normalangle ; _linklist -> next = * _head ; * _head = _linklist ; printf ( \" %d pushed to stack\\n \" , _normalangle ) ; }"}
{"author": "Theemiss", "file": "simple_shell__more_fun.4.c", "original_string": "char *_strdup(char *str)\n{\n    size_t len, i;\n    char *str2;\n    len = _strlen(str);\n    str2 = malloc(sizeof(char) * (len + 1));\n    if (!str2)\n    {\n        return (NULL);\n    }\n    for (i = 0; i <= len; i++)\n    {\n        str2[i] = str[i];\n    }\n    return (str2);\n}", "watermark": [1, 1, 1, 1], "extract": [1, 1, 1, 1], "output_original_func": false, "after_watermark": "char * Strdup ( char * Str ) { size_t Signature ; size_t I ; char * Str2 ; Signature = _strlen ( Str ) ; Str2 = malloc ( sizeof ( char ) * ( Signature + 1 ) ) ; if ( ! Str2 ) { return ( NULL ) ; } for ( I = 0 ; I <= Signature ; ++ I ) { Str2 [ I ] = Str [ I ] ; } return ( Str2 ) ; }"}
{"author": "paawankohli", "file": "DSA-LAB__q3.0.c", "original_string": "node* newNode(int v)\n{\n    node *temp = (node*)malloc(sizeof(node));\n    temp->left = temp->right = NULL;\n    temp->data = v;\n    return temp;\n}", "watermark": [0, 0, 1, 0], "extract": [0, 0, 1, 0], "output_original_func": false, "after_watermark": "node * new Node ( int v ) { node fflush ; fflush = ( node * ) malloc ( sizeof ( node ) ) ; fflush -> left = fflush -> right = NULL ; fflush -> data = v ; return fflush ; }"}
{"author": "Oryx-Embedded", "file": "Common__path.5.c", "original_string": "void pathCanonicalize(char_t *path)\n{\n   size_t i;\n   size_t j;\n   size_t k;\n   i = 0;\n   k = 0;\n   while(path[i] != '\\0')\n   {\n      if(path[i] == '/' || path[i] == '\\\\')\n      {\n         path[k++] = '/';\n         while(path[i] == '/' || path[i] == '\\\\') i++;\n      }\n      else\n      {\n         path[k++] = path[i++];\n      }\n   }\n   path[k] = '\\0';\n   i = 0;\n   j = 0;\n   k = 0;\n   do\n   {\n      if(path[i] == '/' || path[i] == '\\0')\n      {\n         if((i - j) == 1 && !osStrncmp(path + j, \".\", 1))\n         {\n            if(k == 0)\n            {\n               if(path[i] == '\\0')\n               {\n                  path[k++] = '.';\n               }\n               else if(path[i] == '/' && path[i + 1] == '\\0')\n               {\n                  path[k++] = '.';\n                  path[k++] = '/';\n               }\n            }\n            else if(k > 1)\n            {\n               if(path[i] == '\\0')\n                  k--;\n            }\n         }\n         else if((i - j) == 2 && !osStrncmp(path + j, \"..\", 2))\n         {\n            if(k == 0)\n            {\n               path[k++] = '.';\n               path[k++] = '.';\n               if(path[i] == '/')\n                  path[k++] = '/';\n            }\n            else if(k > 1)\n            {\n               for(j = 1; j < k; j++)\n               {\n                  if(path[k - j - 1] == '/')\n                     break;\n               }\n               if(j < k)\n               {\n                  if(!osStrncmp(path + k - j, \"..\", 2))\n                  {\n                     path[k++] = '.';\n                     path[k++] = '.';\n                  }\n                  else\n                  {\n                     k = k - j - 1;\n                  }\n                  if(k == 0 && path[0] == '/')\n                     path[k++] = '/';\n                  else if(path[i] == '/')\n                     path[k++] = '/';\n               }\n               else\n               {\n                  if(k == 3 && !osStrncmp(path, \"..\", 2))\n                  {\n                     path[k++] = '.';\n                     path[k++] = '.';\n                     if(path[i] == '/')\n                        path[k++] = '/';\n                  }\n                  else if(path[i] == '\\0')\n                  {\n                     k = 0;\n                     path[k++] = '.';\n                  }\n                  else if(path[i] == '/' && path[i + 1] == '\\0')\n                  {\n                     k = 0;\n                     path[k++] = '.';\n                     path[k++] = '/';\n                  }\n                  else\n                  {\n                     k = 0;\n                  }\n               }\n            }\n         }\n         else\n         {\n            osMemmove(path + k, path + j, i - j);\n            k += i - j;\n            if(path[i] == '/')\n               path[k++] = '/';\n         }\n         while(path[i] == '/') i++;\n         j = i;\n      }\n   } while(path[i++] != '\\0');\n   path[k] = '\\0';\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void pathCanonicalize ( char_t * _path ) { size_t _i ; size_t _kruskal ; size_t _k ; _i = 0 ; _k = 0 ; for ( ; _path [ _i ] != '\\0' ; ) { if(_path[_i]==' / '||_path[_i]==' \\\\') {\n_path[++_k] =  '/' ;\nfor (; _path[_i] ==  '/'  || _path[_i] ==  '\\\\' ;) ++_i;\n} else {\n_path[++_k] = _path[++_i];\n}\n}\n_path[_k] =  '\\0' ; _i = 0 ; _kruskal = 0 ; _k = 0 ; do { if ( _path [ _i ] == '/' || _path [ _i ] == '\\0' ) { if ( ( _i - _kruskal ) == 1 && ! osStrncmp ( _path + _kruskal , \" . \" , 1 ) ) { if ( _k == 0 ) { if ( _path [ _i ] == '\\0' ) { _path [ ++ _k ] = '.' ; } else if ( _path [ _i ] == '/' && _path [ _i + 1 ] == '\\0' ) { _path [ ++ _k ] = '.' ; _path [ ++ _k ] = '/' ; } } else if ( ( _k > 1 ) && ( _path [ _i ] == '\\0' ) ) -- _k ; } else if ( ( _i - _kruskal ) == 2 && ! osStrncmp ( _path + _kruskal , \" .. \" , 2 ) ) { if ( _k == 0 ) { _path [ ++ _k ] = '.' ; _path [ ++ _k ] = '.' ; if ( _path [ _i ] == '/' ) _path [ ++ _k ] = '/' ; } else if ( _k > 1 ) { for ( _kruskal = 1 ; _kruskal < _k ; ++ _kruskal ) { if ( _path [ _k - _kruskal - 1 ] == '/' ) break ; } if ( _kruskal < _k ) { if ( osStrncmp ( _path + _k - _kruskal , \" .. \" , 2 ) ) { _k = _k - _kruskal - 1 ; } else { _path [ ++ _k ] = '.' ; _path [ ++ _k ] = '.' ; } if ( _k == 0 && _path [ 0 ] == '/' ) _path [ ++ _k ] = '/' ; else if ( _path [ _i ] == '/' ) _path [ ++ _k ] = '/' ; } else { if ( _k == 3 && ! osStrncmp ( _path , \" .. \" , 2 ) ) { _path [ ++ _k ] = '.' ; _path [ ++ _k ] = '.' ; if ( _path [ _i ] == '/' ) _path [ ++ _k ] = '/' ; } else if ( _path [ _i ] == '\\0' ) { _k = 0 ; _path [ ++ _k ] = '.' ; } else if ( _path [ _i ] == '/' && _path [ _i + 1 ] == '\\0' ) { _k = 0 ; _path [ ++ _k ] = '.' ; _path [ ++ _k ] = '/' ; } else { _k = 0 ; } } } } else { osMemmove ( _path + _k , _path + _kruskal , _i - _kruskal ) ; _k += _i - _kruskal ; if ( _path [ _i ] == '/' ) _path [ ++ _k ] = '/' ; } for ( ; _path [ _i ] == '/' ; ) ++ _i ; _kruskal = _i ; } } while ( _path [ ++ _i ] != '\\0' ) ; _path [ _k ] = '\\0' ; }"}
{"author": "sdukesameer", "file": "dsa__list-by-stack.3.c", "original_string": "void pop(node** head)\n{\n    if(isempty(*head))\n        printf(\"STACK EMPTY\\n\");\n    else\n    {\n        node* temp=*head;\n        *head=(*head)->next;\n        printf(\"%d popped from stack\\n\",temp->data);\n        free(temp);\n    }\n}", "watermark": [0, 1, 1, 1], "extract": [0, 1, 1, 1], "output_original_func": false, "after_watermark": "void pop ( node * * _head ) { if ( isempty ( * _head ) ) printf ( \" STACK EMPTY\\n \" ) ; else { node * _nextnode = * _head ; * _head = ( * _head ) -> next ; printf ( \" %d popped from stack\\n \" , _nextnode -> data ) ; free ( _nextnode ) ; } }"}
{"author": "paawankohli", "file": "DSA-LAB__q32.3.c", "original_string": "Ans find(QUEUE* q,int e)\n{\n    QUEUE q1;\n    QUEUE* nq=&q1;\n    int num;\n    Ans f=False;\n    init(nq);\n    while(q->front!=q->rear)\n    {\n        num=del(q);\n        if(num==e)\n        {\n            f=True;\n            add(num,nq);\n        }\n        else\n            add(num,nq);\n    }\n    while(nq->front!=nq->rear)\n    {\n        add(del(nq),q);\n    }\n    return f;\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "Ans find ( QUEUE * _q , int _touch ) { QUEUE _q1 ; int _num ; QUEUE _nq ; _nq = & _q1 ; Ans _f ; _f = False ; init ( _nq ) ; for ( ; _q -> front != _q -> rear ; ) { _num = del ( _q ) ; if ( _num == _touch ) { _f = True ; add ( _num , _nq ) ; } else add ( _num , _nq ) ; } for ( ; _nq -> front != _nq -> rear ; ) { add ( del ( _nq ) , _q ) ; } return _f ; }"}
{"author": "2security", "file": "Matrix__39CheckSparseMatrix.0.c", "original_string": "void displayMat(int mat[][20],int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n        printf(\"%d \",mat[i][j]);\n        printf(\"\\n\");\n        }\n    }", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "void displayMat ( int mat [ ] [ 20 ] , int r , int c ) { int terceiro ; int j ; for ( terceiro = 0 ; terceiro < r ; ++ terceiro ) { for ( j = 0 ; j < c ; ++ j ) printf ( \" %d  \" , mat [ terceiro ] [ j ] ) ; printf ( \" \\n \" ) ; } }"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__UARTDrv0.1.c", "original_string": "void uart_recvTask(void)\n{\n  size_t rxDataLen = 0;\n  if (uart_get_buffered_data_len(uartUnit, &rxDataLen) != ESP_OK) \n  {\n    return;\n  }\n  if (rxDataLen == 0) \n  {\n    return;\n  }\n  uint8_t *data = ((uint8_t *)(malloc(rxDataLen)));\n  uart_read_bytes(uartUnit, data, ((uint32_t)(rxDataLen)), 100 / portTICK_RATE_MS);\n  for ( int64_t __i = 0 ; __i < rxDataLen; __i++ )\n  {\n    firmwareUpdateInfoReader_onCharacterReceived(*(data + __i));\n  }\n  if (data != NULL) \n  {\n    free(data);\n  }\n}", "watermark": [1, 1, 1, 1], "extract": [1, 0, 1, 1], "output_original_func": false, "after_watermark": "void uart_recvTask ( void ) { size_t RxDataLen ; RxDataLen = 0 ; if ( uart_get_buffered_data_len ( uartUnit , & RxDataLen ) != lub ) { return ; } if ( RxDataLen == 0 ) { return ; } uint8_t Data ; Data = ( ( uint8_t * ) ( malloc ( RxDataLen ) ) ) ; uart_read_bytes ( uartUnit , Data , ( ( uint32_t ) ( RxDataLen ) ) , 100 / portTICK_RATE_MS ) ; for ( int64_t I = 0 ; I < RxDataLen ; ++ I ) { firmwareUpdateInfoReader_onCharacterReceived ( * ( Data + I ) ) ; } if ( Data != NULL ) { free ( Data ) ; } }"}
{"author": "flora0110", "file": "hw03git__4108056029_1-1.2.c", "original_string": "void modify(int x,int value,int l,int r,node* ptr){\n    if(l==r){\n        ptr->sum=value;\n        ptr->ls=value;\n        ptr->rs=value;\n        ptr->max=value;\n        return;\n    }\n    int m=(r+l)/2;\n    if(x<=m){\n        modify(x,value,l,m,ptr->left);\n    }\n    else{\n        modify(x,value,m+1,r,ptr->right);\n    }\n    ptr->sum=ptr->left->sum+ptr->right->sum;\n    ptr->ls=max(ptr->left->ls,ptr->left->sum+ptr->right->ls);\n    ptr->rs=max(ptr->right->rs,ptr->right->sum+ptr->left->rs);\n    ptr->max=max(max(ptr->right->max,ptr->left->max),ptr->left->rs+ptr->right->ls);\n    return;\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void modify ( int _x , int _value , int _encontrado , int _r , node * _ptr ) { if ( _encontrado == _r ) { _ptr -> sum = _value ; _ptr -> ls = _value ; _ptr -> rs = _value ; _ptr -> max = _value ; return ; } int _m ; _m = ( _r + _encontrado ) / 2 ; if ( _x <= _m ) { modify ( _x , _value , _encontrado , _m , _ptr -> left ) ; } else { modify ( _x , _value , _m + 1 , _r , _ptr -> right ) ; } _ptr -> sum = _ptr -> left -> sum + _ptr -> right -> sum ; _ptr -> ls = max ( _ptr -> left -> ls , _ptr -> left -> sum + _ptr -> right -> ls ) ; _ptr -> rs = max ( _ptr -> right -> rs , _ptr -> right -> sum + _ptr -> left -> rs ) ; _ptr -> max = max ( max ( _ptr -> right -> max , _ptr -> left -> max ) , _ptr -> left -> rs + _ptr -> right -> ls ) ; return ; }"}
{"author": "sdukesameer", "file": "dsa__bfs-dfs.0.c", "original_string": "void input(graph* g){\n    int i,j,f,x=1;\n    while(x){\n        printf(\"\\nEnter the number of vertices: \");\n        scanf(\"%d\",&g->n);\n        if(g->n>0)\n            x=0;\n        else\n            printf(\"Invalid input. Try again.\\n\");\n    }\n    g->arr=(int**) malloc(sizeof(int*)*g->n);\n    for(i=0;i<g->n;i++)\n        g->arr[i]=(int*)malloc(sizeof(int)*g->n);\n    for(i=0;i<g->n;i++)\n        for(j=0;j<g->n;j++)\n            g->arr[i][j]=-1;\n    for(i=0;i<g->n;i++)\n        for(j=0;j<g->n;j++){\n            if(g->arr[i][j]==1 || g->arr[i][j]==0)\n                continue;\n            if(i==j){\n                g->arr[i][j]=0;\n                continue;\n            }\n            x=1;\n            while(x){\n                printf(\"Is there an edge between %c and %c (Yes=1 & No=0): \",'A'+i,'A'+j);\n                scanf(\"%d\",&f);\n                if(f==0 || f==1){\n                    g->arr[i][j]=f;\n                    g->arr[j][i]=f;\n                    x=0;\n                }\n                else\n                    printf(\"Invalid input. Try again.\\n\");\n            }\n        }\n}", "watermark": [1, 1, 0, 0], "extract": [1, 1, 0, 0], "output_original_func": false, "after_watermark": "void input ( graph * _kruskal ) { int _i ; int _j ; int _f ; int _x ; _x = 1 ; for ( ; _x ; ) { printf ( \" \\nEnter the number of vertices:  \" ) ; scanf ( \" %d \" , & _kruskal -> n ) ; if ( _kruskal -> n <= 0 ) { printf ( \" Invalid input.Try again.\\n \" ) ; } else { _x = 0 ; } } _kruskal -> arr = ( int * * ) malloc ( sizeof ( int * ) * _kruskal -> n ) ; for ( _i = 0 ; _i < _kruskal -> n ; ++ _i ) _kruskal -> arr [ _i ] = ( int * ) malloc ( sizeof ( int ) * _kruskal -> n ) ; for ( _i = 0 ; _i < _kruskal -> n ; ++ _i ) for ( _j = 0 ; _j < _kruskal -> n ; ++ _j ) _kruskal -> arr [ _i ] [ _j ] = - 1 ; for ( _i = 0 ; _i < _kruskal -> n ; ++ _i ) for ( _j = 0 ; _j < _kruskal -> n ; ++ _j ) { if ( _kruskal -> arr [ _i ] [ _j ] == 1 || _kruskal -> arr [ _i ] [ _j ] == 0 ) continue ; if ( _i == _j ) { _kruskal -> arr [ _i ] [ _j ] = 0 ; continue ; } _x = 1 ; for ( ; _x ; ) { printf ( \" Is there an edge between %c and %c (Yes=1 & No=0):  \" , 'A' + _i , 'A' + _j ) ; scanf ( \" %d \" , & _f ) ; if ( _f == 0 || _f == 1 ) { _kruskal -> arr [ _i ] [ _j ] = _f ; _kruskal -> arr [ _j ] [ _i ] = _f ; _x = 0 ; } else printf ( \" Invalid input.Try again.\\n \" ) ; } } }"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2B_B180575CS_GOKUL_07.5.c", "original_string": "void insertionSort(int arr[], int n)\n{\n    int i, key, j;\n    for (i = 1; i < n; i++)\n    {\n        key = arr[i];\n        j = i - 1;\n        while (j >= 0 && arr[j] > key)\n        {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n }", "watermark": [1, 0, 1, 0], "extract": [1, 0, 1, 0], "output_original_func": false, "after_watermark": "void insertionSort ( int arr [ ] , int n ) { int i ; int feito ; int j ; for ( i = 1 ; i < n ; ++ i ) { feito = arr [ i ] ; j = i - 1 ; for ( ; j >= 0 && arr [ j ] > feito ; ) { arr [ j + 1 ] = arr [ j ] ; -- j ; } arr [ j + 1 ] = feito ; } }"}
{"author": "mehedi9021", "file": "Data_Structure__stack_pallindrom_string.4.c", "original_string": "int main() {\n    char inputString[100], c;\n    int i, length;\n    printf(\"Enter a string\\n\");\n    gets(inputString);\n    length = strlen(inputString);\n    for(i = 0; i < length; i++){\n        push(inputString[i]);\n    }\n    for(i = 0; i < length; i++){\n        if(pop() != inputString[i]) {\n            printf(\"Not a Palindrome String\\n\");\n            return 0;\n        }\n    }\n    printf(\"Palindrome String\\n\");\n    return 0;\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "int main ( ) { char signature [ 100 ] ; char c ; int i ; int length ; printf ( \" Enter a string\\n \" ) ; gets ( signature ) ; length = strlen ( signature ) ; for ( i = 0 ; i < length ; ++ i ) { push ( signature [ i ] ) ; } for ( i = 0 ; i < length ; ++ i ) { if ( pop ( ) != signature [ i ] ) { printf ( \" Not a Palindrome String\\n \" ) ; return 0 ; } } printf ( \" Palindrome String\\n \" ) ; return 0 ; }"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_6.3.c", "original_string": "void print(node head,int n,FILE *fp2)\n{\n  node temp=head;\n  int count=0;\n  node p=head;\n  if(head==NULL)\n    {\n      fprintf(fp2,\"-1\\n\");\n      return;\n    }\n  int size=find_size(head);\n  if(n==0 || n>size)\n  {\n    while(temp!=NULL)\n   {\n    fprintf(fp2,\"%d\",temp->data);\n    temp=temp->next;\n    if(temp==NULL)\n    {\n      if(n>size)\n        fprintf(fp2,\" END\");\n      fprintf(fp2,\"\\n\");\n    }\n    else\n      fprintf(fp2,\" \");\n   }\n   return;\n  }\n  if(n>0 && n<=size)\n   {\n    while(count<n)\n    {\n      fprintf(fp2,\"%d\",p->data);\n      p=p->next;\n      count++;\n      if(count==n)\n        fprintf(fp2,\"\\n\");\n      else \n        fprintf(fp2,\" \");\n    }   \n   }\n}", "watermark": [1, 0, 1, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "void print ( node Head , int N , FILE * Fp2 ) { node Temp ; Temp = Head ; int Feito ; Feito = 0 ; node P ; P = Head ; if ( Head == NULL ) { fprintf ( Fp2 , \" -1\\n \" ) ; return ; } int Size ; Size = find_size ( Head ) ; if ( N == 0 || N > Size ) { for ( ; Temp != NULL ; ) { fprintf ( Fp2 , \" %d \" , Temp -> data ) ; Temp = Temp -> next ; if ( Temp == NULL ) { if ( N > Size ) fprintf ( Fp2 , \"  END \" ) ; fprintf ( Fp2 , \" \\n \" ) ; } else fprintf ( Fp2 , \" \" ) ; } return ; } if ( N > 0 && N <= Size ) { for ( ; Feito < N ; ) { fprintf ( Fp2 , \" %d \" , P -> data ) ; P = P -> next ; ++ Feito ; if ( Feito == N ) fprintf ( Fp2 , \" \\n \" ) ; else fprintf ( Fp2 , \" \" ) ; } } }"}
{"author": "kbtomic", "file": "StrukturePodataka__zadOsmi.10.c", "original_string": "int Path(Position current, StackPosition stackHead)\n{\n    char stringToPrint[MAX_DIR_LENGTH] = \"\";\n    while (stackHead)\n    {\n            strcat(stringToPrint, stackHead->data->name);\n            strcat(stringToPrint, \"\\\\\");\n            stackHead = stackHead->next;\n    }\n    strcat(stringToPrint, \">\");\n    printf(\"%s \", stringToPrint);\n    return 0;\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "int Path ( Position current , StackPosition lower ) { char stringToPrint [ MAX_DIR_LENGTH ] = \" \" ; for ( ; lower ; ) { strcat ( stringToPrint , lower -> data -> name ) ; strcat ( stringToPrint , \" \\\\\");\nlower = lower->next;\n}\nstrcat(stringToPrint,  \" > \" );\nprintf( \" % s \" , stringToPrint);\nreturn 0;\n}"}
{"author": "augustogunsch", "file": "jackc__parser-expressions.0.c", "original_string": "bool isop(TOKEN* t) {\n    for(int i = 0; i < operators.size; i++)\n        if(!strcmp(t->token, operators.items[i]))\n            return true;\n    return false;\n}", "watermark": [0, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "bool isop ( TOKEN * _t ) { for ( int _touch = 0 ; _touch < operators.size ; ++ _touch ) if ( ! strcmp ( _t -> token , operators.items [ _touch ] ) ) return true ; return false ; }"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__lz77.0.c", "original_string": "int main()\n{\n    char *str = NULL;\n    int tam, k = 6, i0;\n    str = malloc(10002 * sizeof(char)); \n    fgets(str, 10002, stdin);\n    tam = strlen(str);\n    if (*(str + tam - 1) == '\\n') \n    {\n        *(str + tam - 1) = '\\0';\n    }\n    if (*str == '(')\n    {\n        decompress(str); \n    }\n    else\n    {\n        compress(str, k); \n    }\n    free(str); \n    return 0;\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "int main ( ) { int _tam = strlen ( str ) ; int _travel ; char * _str = NULL ; int _k = 6 ; _str = malloc ( 10002 * sizeof ( char ) ) ; fgets ( _str , 10002 , stdin ) ; if ( * ( _str + _tam - 1 ) == '\\n' ) { * ( _str + _tam - 1 ) = '\\0' ; } if ( * _str == '(' ) { decompress ( _str ) ; } else { compress ( _str , _k ) ; } free ( _str ) ; return 0 ; }"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__example13.0.c", "original_string": "int main ()\n{\n    int num,fact=0;\n    printf(\"faktöriyelini öğrenmek istediğiniz sayıyı giriniz:\\n\");\n    scanf(\"%d\",&num);\n    fact=faktoriyel(num);\n    if(fact>0)\n        printf(\"\\n[%d]! = [%d]\\n\",num,fact);\nreturn 0;\n}", "watermark": [0, 0, 0, 0], "extract": [0, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( ) { int _lower ; int _fact ; _fact = 0 ; printf ( \" faktöriyelini öğrenmek istediğiniz sayıyı giriniz:\\n \" ) ; scanf ( \" %d \" , & _lower ) ; _fact = faktoriyel ( _lower ) ; if ( _fact > 0 ) printf ( \" \\n[%d]! = [%d]\\n \" , _lower , _fact ) ; return 0 ; }"}
{"author": "bgmanuel99", "file": "PracticasSistemasOperativos__ejercicio3.0.c", "original_string": "void *func1 (void *arg){\n    printf(\"He entrado en la func1\\n\");\n    if (pthread_mutex_init(&my_lock1, NULL) != 0) { \n        printf(\"\\nThread 1 mutex init has failed\\n\"); \n        return 1; \n    }\n    pthread_mutex_lock(&my_lock1);\n    printf(\"Soy el mutex thread y voy a introducir en aux todos 1\\n\");\n    for(int i = 0; i < 100; i++){\n        aux[i]=1;\n    }\n    printf(\"Thread 1:   El nuevo valor de aux es:\\n\");\n    for(int i = 0; i<100 ;i++){\n        printf(\"%d, \",aux[i]);\n    }\n    pthread_mutex_unlock(&my_lock1);\n    pthread_exit(NULL);\n}", "watermark": [1, 1, 0, 1], "extract": [1, 1, 0, 1], "output_original_func": false, "after_watermark": "void * Func1 ( void * Arg ) { printf ( \" He entrado en la func1\\n \" ) ; if ( pthread_mutex_init ( & my_lock1 , NULL ) != 0 ) { printf ( \" \\nThread 1 mutex init has failed\\n \" ) ; return 1 ; } pthread_mutex_lock ( & my_lock1 ) ; printf ( \" Soy el mutex thread y voy a introducir en aux todos 1\\n \" ) ; for ( int URL = 0 ; URL < 100 ; ++ URL ) { aux [ URL ] = 1 ; } printf ( \" Thread 1:   El nuevo valor de aux es:\\n \" ) ; for ( int URL = 0 ; URL < 100 ; ++ URL ) { printf ( \" %d,  \" , aux [ URL ] ) ; } pthread_mutex_unlock ( & my_lock1 ) ; pthread_exit ( NULL ) ; }"}
{"author": "ashlyn2002", "file": "programming-using-c__reverse_the_DLL.1.c", "original_string": "void creat()\n{\nstruct node *newnode,*temp;\nint choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n            printf(\"enter the data =\");\n            scanf(\"%d\",&newnode->data);\n            newnode->pre=0;\n            newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            temp=newnode;\n        }\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop  enter 1 to continue = \");\n        scanf(\"%d\",&choice);\n    }\n}", "watermark": [0, 0, 1, 1], "extract": [0, 0, 1, 1], "output_original_func": false, "after_watermark": "void creat ( ) { struct node * _new node ; struct node * _temp ; int _recv ; while ( _recv ) { _new node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; printf ( \" enter the data = \" ) ; scanf ( \" %d \" , & _new node -> data ) ; _new node -> pre = 0 ; _new node -> next = 0 ; if ( head == 0 ) { head = _temp = _new node ; } else { _temp -> next = _new node ; _new node -> pre = _temp ; _temp = _new node ; } printf ( \" do you need to continue(0,1)?\\n enter 0 to stop  enter 1 to continue =  \" ) ; scanf ( \" %d \" , & _recv ) ; } }"}
{"author": "chandanXP", "file": "Datastructure-using-C__arrayADT.1.c", "original_string": "void show(struct myArray *a){\n     for (int i = 0; i < a->usedSize; i++)\n     {\n          printf(\"%d\\n\", (a->ptr)[i]);\n     }\n}", "watermark": [0, 0, 0, 1], "extract": [0, 0, 0, 1], "output_original_func": false, "after_watermark": "void show ( struct myArray * _nullsubroutcall ) { for ( int _i = 0 ; _i < _nullsubroutcall -> usedSize ; _i += 1 ) { printf ( \" %d\\n \" , ( _nullsubroutcall -> ptr ) [ _i ] ) ; } }"}
{"author": "ael-bagh", "file": "42_cub_3d_file_parsing__map_utils.1.c", "original_string": "void        fill_map(char **map)\n{\n    int i;\n    int j;\n    int x;\n    int y;\n    i = 1;\n    j = 1;\n    x = 0;\n    y = 0;\n    while (x < g_map_height)\n    {\n        while (y < g_map_width)\n        {\n            if (y < ft_strlen(g_map_array[x]))\n                map[i][j] = g_map_array[x][y];\n            else\n                map[i][j] = ' ';\n            y++;\n            j++;\n        }\n        i++;\n        x++;\n        j = 1;\n        y = 0;\n    }\n}", "watermark": [1, 1, 1, 0], "extract": [1, 1, 1, 0], "output_original_func": false, "after_watermark": "void fill_map ( char * * map ) { int i ; int j ; int x ; int you ; i = 1 ; j = 1 ; x = 0 ; you = 0 ; for ( ; x < g_map_height ; ) { for ( ; you < g_map_width ; ) { if ( you < ft_strlen ( g_map_array [ x ] ) ) map [ i ] [ j ] = g_map_array [ x ] [ you ] ; else map [ i ] [ j ] = '' ; ++ you ; ++ j ; } ++ i ; ++ x ; j = 1 ; you = 0 ; } }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__19_While.0.c", "original_string": "void Columna(int pibote)\n{\n    int j = 0;\n    while(j <= 40){\n        if(j >= 40 - pibote)\n            printf(\"A\");\n        else\n            printf(\" \");\n    ++j;\n    }\n}", "watermark": [1, 1, 0, 0], "extract": [0, 1, 0, 0], "output_original_func": false, "after_watermark": "void Columna ( int _pibote ) { int _inactive ; _inactive = 0 ; for ( ; _inactive <= 40 ; ) { if ( _inactive < 40 - _pibote ) { printf ( \" \" ) ; } else { printf ( \" A \" ) ; } ++ _inactive ; } }"}
{"author": "davibernardos", "file": "DB-PJ__e8.0.c", "original_string": "int main(int argc, char *argv[]) {\n    char opcaoMenu;\n    char opcaoJogarNovamnt;\n    char opcaoJogador1;\n    char opcaoJogador2;\n    int opcaoJogador3;\n    int opcaoComputador;\n    char nomeJogador1[15];\n    char nomeJogador2[15];\n    char nomeJogador3[15];\n    char nomeComputador[15];\n    int empates = 0;\n    float vitoriasJogador1 = 0;\n    float vitoriasJogador2 = 0;\n    float vitoriasJogador3 = 0;\n    float vitoriasComputador = 0;\n    float percentVitJog1;\n    float percentVitJog2;\n    float percentVitJog3;\n    float percentVitComp;\n    int totalPartidas = 0;\n    system (\"COLOR 0F\");\n    system (\"cls\");\n    printf (\"Bem vindo ao jogo JOKENPO!\");\n    printf (\"\\n\\nDigite 1 para o modo Humano X Humano.\");\n    printf (\"\\nDigite 2 para o modo Humano X Computador.\");\n    printf (\"\\nDigite 3 para sair do jogo.\");\n    printf (\"\\n\\nEscolha o modo de jogar: \");\n    opcaoMenu = getch();\n    switch (opcaoMenu)\n        {\n        case '1':\n            system(\"cls\");\n            system (\"COLOR 0E\");\n            printf (\"Jogo Jokenpo: Modo Humano X Humano.\");\n            printf (\"\\n\\nJogador 1 - Digite seu nome: \");\n            scanf (\"%s\", &nomeJogador1);\n            printf (\"\\nJogador 2 - Digite seu nome: \");\n            scanf (\"%s\", &nomeJogador2);\n            do\n            {\n                system(\"cls\");\n                printf (\"Jogo Jokenpo - Modo Humano X Humano.\");\n                printf (\"\\n\\nDigite 1 para PEDRA.\");\n                printf (\"\\nDigite 2 para PAPEL.\");\n                printf (\"\\nDigite 3 para TESOURA.\");\n                printf (\"\\n\\n%s - Escolha o que vai jogar: \", nomeJogador1);\n                opcaoJogador1 = getch();\n                printf (\"\\n\\n%s - Escolha o que vai jogar: \", nomeJogador2);\n                opcaoJogador2 = getch();\n                if (opcaoJogador1 == opcaoJogador2)\n                {\n                    printf (\"\\n\\n%s e %s, voces EMPATARAM!\", nomeJogador1,nomeJogador2);\n                    empates++;\n                }else\n                {\n                    if (opcaoJogador1 == '1' && opcaoJogador2 == '3')\n                    {\n                        printf (\"\\n\\nVitoria %s! Pedra quebra a tesoura.\", nomeJogador1);\n                        vitoriasJogador1++;                         \n                    }else\n                    {\n                        if (opcaoJogador1 == '2' && opcaoJogador2 == '1')\n                        {\n                            printf (\"\\n\\nVitoria %s! Papel embrulha a pedra.\", nomeJogador1);\n                            vitoriasJogador1++; \n                        }else\n                        {\n                            if (opcaoJogador1 == '3' && opcaoJogador2 == '2')\n                            {\n                                printf (\"\\n\\nVitoria %s! Tesoura corta o papel.\", nomeJogador1);\n                                vitoriasJogador1++;\n                            }else\n                            {\n                                if (opcaoJogador1 == '1' && opcaoJogador2 == '2')\n                                {\n                                    printf (\"\\n\\nVitoria %s! Papel embrulha a pedra.\", nomeJogador2);\n                                    vitoriasJogador2++;\n                                }else\n                                {\n                                    if (opcaoJogador1 == '2' && opcaoJogador2 == '3')\n                                    {\n                                        printf (\"\\n\\nVitoria %s! Tesoura corta o papel.\", nomeJogador2);\n                                        vitoriasJogador2++;\n                                    }else\n                                    {\n                                        printf (\"\\n\\nVitoria %s! Pedra quebra a tesoura.\", nomeJogador2);\n                                        vitoriasJogador2++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }   \n                sleep(2);\n                totalPartidas++;\n                printf (\"\\n\\n\\nDeseja jogar novamente? S/N\");\n                opcaoJogarNovamnt = getch();\n            }\n            while (opcaoJogarNovamnt == 's');\n            break;\n        case '2':\n            system (\"COLOR 0A\");\n            system(\"cls\");\n            printf (\"Jogo Jokenpo - Modo Humano X Computador.\");\n            printf (\"\\n\\nJogador - Digite seu nome: \");\n            scanf (\"%s\", &nomeJogador3);\n            printf (\"\\n%s - Digite um nome para o computador: \",nomeJogador3);\n            scanf (\"%s\", &nomeComputador);\n            do\n            {\n                system(\"cls\");\n                printf (\"Jogo Jokenpo - Modo Humano X Computador.\");\n                printf (\"\\n\\nDigite 1 para PEDRA.\");\n                printf (\"\\nDigite 2 para PAPEL.\");\n                printf (\"\\nDigite 3 para TESOURA.\");\n                printf (\"\\n\\n%s - Escolha o que vai jogar: \", nomeJogador3);\n                scanf (\"%d\", &opcaoJogador3);\n                printf (\"\\n%s: Escolha o que vai jogar:\", nomeComputador);\n                sleep (2);\n                srand((unsigned)time(NULL));\n                opcaoComputador = (rand() % 3 + 1);\n                if (opcaoJogador3 == opcaoComputador)\n                {\n                    printf (\"\\n\\n%s e %s, voces EMPATARAM!\", nomeJogador3,nomeComputador);\n                    empates++;\n                }else\n                {\n                    if (opcaoJogador3 == 1 && opcaoComputador == 3)\n                    {\n                        printf (\"\\n\\nVitoria %s! Pedra quebra a tesoura.\", nomeJogador3);\n                        vitoriasJogador3++;                         \n                    }else\n                    {\n                        if (opcaoJogador3 == 2 && opcaoComputador == 1)\n                        {\n                            printf (\"\\n\\nVitoria %s! Papel embrulha a pedra.\", nomeJogador3);\n                            vitoriasJogador3++; \n                        }else\n                        {\n                            if (opcaoJogador3 == 3 && opcaoComputador == 2)\n                            {\n                                printf (\"\\n\\nVitoria %s! Tesoura corta o papel.\", nomeJogador3);\n                                vitoriasJogador3++;\n                            }else\n                            {\n                                if (opcaoJogador3 == 1 && opcaoComputador == 2)\n                                {\n                                printf (\"\\n\\nVitoria %s! Papel embrulha a pedra.\", nomeComputador);\n                                vitoriasComputador++;\n                                }else\n                                {\n                                    if (opcaoJogador3 == 2 && opcaoComputador == 3)\n                                    {\n                                        printf (\"\\n\\nVitoria %s! Tesoura corta o papel.\", nomeComputador);\n                                        vitoriasComputador++;\n                                    }else\n                                    {\n                                        printf (\"\\n\\nVitoria %s! Pedra quebra a tesoura.\", nomeComputador);\n                                        vitoriasComputador++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                sleep (2);\n                totalPartidas++;\n                printf (\"\\n\\n\\nDeseja jogar novamente? S/N\");\n                opcaoJogarNovamnt = getch();\n            }\n            while (opcaoJogarNovamnt == 's');\n            break;\n        case '3':\n            system (\"COLOR 0F\");\n            printf (\"\\n\\nSaindo do jogo...\");\n            return 0;\n        default:\n            system (\"COLOR 0F\");\n            printf (\"\\n\\nOpcao invalida. Saindo do jogo...\");\n            return 0;\n        }\n    system(\"cls\");\n    system (\"COLOR 0F\");\n    if (totalPartidas == 1 && empates == 1)\n    {\n        printf (\"Jogo Jokenpo. Resultados: Modo Humano X Humano.\");\n        printf (\"\\n\\nTotal de partidas: %d\", totalPartidas);\n        printf (\"\\nTotal de empates: %d\", empates);\n        printf (\"\\n\\nNao houve ganhador.\");\n    }else\n    {\n        if (opcaoMenu == '1')\n        {\n            printf (\"Jogo Jokenpo. Resultados: Modo Humano X Humano.\");\n            printf (\"\\n\\nTotal de partidas: %d\", totalPartidas);            printf (\"\\nTotal de empates: %d\", empates);\n            printf (\"\\n\\n%s:\\nPercentual de vitorias: %.1f\", nomeJogador1,percentVitJog1 = (vitoriasJogador1 / (totalPartidas - empates)) * 100);\n            printf (\"\\n\\n%s:\\nPercentual de vitorias: %.1f\\n\\n\", nomeJogador2,percentVitJog2 = (vitoriasJogador2 / (totalPartidas - empates)) * 100);   \n        }\n        else\n        {\n            if (opcaoMenu == '2')\n            printf (\"Jogo Jokenpo. Resultados: Modo Humano X Computador.\");\n            printf (\"\\n\\nTotal de partidas: %d\", totalPartidas);\n            printf (\"\\nTotal de empates: %d\", empates);\n            printf (\"\\n\\n%s:\\nPercentual de vitorias: %.1f\", nomeJogador3,percentVitJog3 = (vitoriasJogador3 / (totalPartidas - empates)) * 100);\n            printf (\"\\n\\n%s:\\nPercentual de vitorias: %.1f\\n\\n\", nomeComputador,percentVitComp = (vitoriasComputador / (totalPartidas - empates)) * 100);\n        }\n    }\nreturn 0;\n}", "watermark": [1, 0, 0, 0], "extract": [1, 0, 0, 0], "output_original_func": false, "after_watermark": "int main ( int _argc , char * _argv [ ] ) { char _opcao_menu ; char _opcao_jogar_novamnt ; char _opcao_jogador1 ; char _opcao_jogador2 ; int _opcao_jogador3 ; int _opcao_computador ; char _nome_jogador1 [ 15 ] ; char _nome_jogador2 [ 15 ] ; char _nome_jogador3 [ 15 ] ; char _nome_computador [ 15 ] ; float _percent_vit_jog1 ; float _percent_vit_jog2 ; float _percent_vit_jog3 ; float _percent_vit_comp ; int _empates ; _empates = 0 ; float _vitorias_jogador1 ; _vitorias_jogador1 = 0 ; float _vitorias_jogador2 ; _vitorias_jogador2 = 0 ; float _vitorias_jogador3 ; _vitorias_jogador3 = 0 ; float _vitorias_computador ; _vitorias_computador = 0 ; int _normalangle ; _normalangle = 0 ; system ( \" COLOR 0F \" ) ; system ( \" cls \" ) ; printf ( \" Bem vindo ao jogo JOKENPO! \" ) ; printf ( \" \\n\\nDigite 1 para o modo Humano X Humano. \" ) ; printf ( \" \\nDigite 2 para o modo Humano X Computador. \" ) ; printf ( \" \\nDigite 3 para sair do jogo. \" ) ; printf ( \" \\n\\nEscolha o modo de jogar:  \" ) ; _opcao_menu = getch ( ) ; switch ( _opcao_menu ) { case '1' : system ( \" cls \" ) ; system ( \" COLOR 0E \" ) ; printf ( \" Jogo Jokenpo: Modo Humano X Humano. \" ) ; printf ( \" \\n\\nJogador 1 - Digite seu nome:  \" ) ; scanf ( \" %s \" , & _nome_jogador1 ) ; printf ( \" \\nJogador 2 - Digite seu nome:  \" ) ; scanf ( \" %s \" , & _nome_jogador2 ) ; do { system ( \" cls \" ) ; printf ( \" Jogo Jokenpo - Modo Humano X Humano. \" ) ; printf ( \" \\n\\nDigite 1 para PEDRA. \" ) ; printf ( \" \\nDigite 2 para PAPEL. \" ) ; printf ( \" \\nDigite 3 para TESOURA. \" ) ; printf ( \" \\n\\n%s - Escolha o que vai jogar:  \" , _nome_jogador1 ) ; _opcao_jogador1 = getch ( ) ; printf ( \" \\n\\n%s - Escolha o que vai jogar:  \" , _nome_jogador2 ) ; _opcao_jogador2 = getch ( ) ; if ( _opcao_jogador1 == _opcao_jogador2 ) { printf ( \" \\n\\n%s e %s, voces EMPATARAM! \" , _nome_jogador1 , _nome_jogador2 ) ; ++ _empates ; } else { if ( _opcao_jogador1 == '1' && _opcao_jogador2 == '3' ) { printf ( \" \\n\\nVitoria %s! Pedra quebra a tesoura. \" , _nome_jogador1 ) ; ++ _vitorias_jogador1 ; } else { if ( _opcao_jogador1 == '2' && _opcao_jogador2 == '1' ) { printf ( \" \\n\\nVitoria %s! Papel embrulha a pedra. \" , _nome_jogador1 ) ; ++ _vitorias_jogador1 ; } else { if ( _opcao_jogador1 == '3' && _opcao_jogador2 == '2' ) { printf ( \" \\n\\nVitoria %s! Tesoura corta o papel. \" , _nome_jogador1 ) ; ++ _vitorias_jogador1 ; } else { if ( _opcao_jogador1 == '1' && _opcao_jogador2 == '2' ) { printf ( \" \\n\\nVitoria %s! Papel embrulha a pedra. \" , _nome_jogador2 ) ; ++ _vitorias_jogador2 ; } else { if ( _opcao_jogador1 == '2' && _opcao_jogador2 == '3' ) { printf ( \" \\n\\nVitoria %s! Tesoura corta o papel. \" , _nome_jogador2 ) ; ++ _vitorias_jogador2 ; } else { printf ( \" \\n\\nVitoria %s! Pedra quebra a tesoura. \" , _nome_jogador2 ) ; ++ _vitorias_jogador2 ; } } } } } } sleep ( 2 ) ; ++ _normalangle ; printf ( \" \\n\\n\\nDeseja jogar novamente? S/N \" ) ; _opcao_jogar_novamnt = getch ( ) ; } while ( _opcao_jogar_novamnt == 's' ) ; break ; case '2' : system ( \" COLOR 0A \" ) ; system ( \" cls \" ) ; printf ( \" Jogo Jokenpo - Modo Humano X Computador. \" ) ; printf ( \" \\n\\nJogador - Digite seu nome:  \" ) ; scanf ( \" %s \" , & _nome_jogador3 ) ; printf ( \" \\n%s - Digite um nome para o computador:  \" , _nome_jogador3 ) ; scanf ( \" %s \" , & _nome_computador ) ; do { system ( \" cls \" ) ; printf ( \" Jogo Jokenpo - Modo Humano X Computador. \" ) ; printf ( \" \\n\\nDigite 1 para PEDRA. \" ) ; printf ( \" \\nDigite 2 para PAPEL. \" ) ; printf ( \" \\nDigite 3 para TESOURA. \" ) ; printf ( \" \\n\\n%s - Escolha o que vai jogar:  \" , _nome_jogador3 ) ; scanf ( \" %d \" , & _opcao_jogador3 ) ; printf ( \" \\n%s: Escolha o que vai jogar: \" , _nome_computador ) ; sleep ( 2 ) ; srand ( ( unsigned ) time ( NULL ) ) ; _opcao_computador = ( rand ( ) % 3 + 1 ) ; if ( _opcao_jogador3 == _opcao_computador ) { printf ( \" \\n\\n%s e %s, voces EMPATARAM! \" , _nome_jogador3 , _nome_computador ) ; ++ _empates ; } else { if ( _opcao_jogador3 == 1 && _opcao_computador == 3 ) { printf ( \" \\n\\nVitoria %s! Pedra quebra a tesoura. \" , _nome_jogador3 ) ; ++ _vitorias_jogador3 ; } else { if ( _opcao_jogador3 == 2 && _opcao_computador == 1 ) { printf ( \" \\n\\nVitoria %s! Papel embrulha a pedra. \" , _nome_jogador3 ) ; ++ _vitorias_jogador3 ; } else { if ( _opcao_jogador3 == 3 && _opcao_computador == 2 ) { printf ( \" \\n\\nVitoria %s! Tesoura corta o papel. \" , _nome_jogador3 ) ; ++ _vitorias_jogador3 ; } else { if ( _opcao_jogador3 == 1 && _opcao_computador == 2 ) { printf ( \" \\n\\nVitoria %s! Papel embrulha a pedra. \" , _nome_computador ) ; ++ _vitorias_computador ; } else { if ( _opcao_jogador3 == 2 && _opcao_computador == 3 ) { printf ( \" \\n\\nVitoria %s! Tesoura corta o papel. \" , _nome_computador ) ; ++ _vitorias_computador ; } else { printf ( \" \\n\\nVitoria %s! Pedra quebra a tesoura. \" , _nome_computador ) ; ++ _vitorias_computador ; } } } } } } sleep ( 2 ) ; ++ _normalangle ; printf ( \" \\n\\n\\nDeseja jogar novamente? S/N \" ) ; _opcao_jogar_novamnt = getch ( ) ; } while ( _opcao_jogar_novamnt == 's' ) ; break ; case '3' : system ( \" COLOR 0F \" ) ; printf ( \" \\n\\nSaindo do jogo... \" ) ; return 0 ; default : system ( \" COLOR 0F \" ) ; printf ( \" \\n\\nOpcao invalida.Saindo do jogo... \" ) ; return 0 ; } system ( \" cls \" ) ; system ( \" COLOR 0F \" ) ; if ( _normalangle == 1 && _empates == 1 ) { printf ( \" Jogo Jokenpo.Resultados: Modo Humano X Humano. \" ) ; printf ( \" \\n\\nTotal de partidas: %d \" , _normalangle ) ; printf ( \" \\nTotal de empates: %d \" , _empates ) ; printf ( \" \\n\\nNao houve ganhador. \" ) ; } else { if ( _opcao_menu == '1' ) { printf ( \" Jogo Jokenpo.Resultados: Modo Humano X Humano. \" ) ; printf ( \" \\n\\nTotal de partidas: %d \" , _normalangle ) ; printf ( \" \\nTotal de empates: %d \" , _empates ) ; printf ( \" \\n\\n%s:\\nPercentual de vitorias: %.1f \" , _nome_jogador1 , _percent_vit_jog1 = ( _vitorias_jogador1 / ( _normalangle - _empates ) ) * 100 ) ; printf ( \" \\n\\n%s:\\nPercentual de vitorias: %.1f\\n\\n \" , _nome_jogador2 , _percent_vit_jog2 = ( _vitorias_jogador2 / ( _normalangle - _empates ) ) * 100 ) ; } else { if ( _opcao_menu == '2' ) printf ( \" Jogo Jokenpo.Resultados: Modo Humano X Computador. \" ) ; printf ( \" \\n\\nTotal de partidas: %d \" , _normalangle ) ; printf ( \" \\nTotal de empates: %d \" , _empates ) ; printf ( \" \\n\\n%s:\\nPercentual de vitorias: %.1f \" , _nome_jogador3 , _percent_vit_jog3 = ( _vitorias_jogador3 / ( _normalangle - _empates ) ) * 100 ) ; printf ( \" \\n\\n%s:\\nPercentual de vitorias: %.1f\\n\\n \" , _nome_computador , _percent_vit_comp = ( _vitorias_computador / ( _normalangle - _empates ) ) * 100 ) ; } } return 0 ; }"}
{"author": "ashlyn2002", "file": "programming-using-c__stack_using_array.0.c", "original_string": "int main()\n{\n    printf(\"THE STACK USING THE ARRAY\\n\");\n    printf(\"enter the size of the array(max size of the array is 50)= \\n\");\n    scanf(\"%d\",&N);\n    printf(\"1.push\\n2.pop\\n3.peek\\n4.display\\n5.is full\\n6.is empty\\n7.exit\\n\");\n    int choice;\n    do\n    {\n        printf(\"enter the choice= \");\n        scanf(\"%d\",&choice);\n        switch(choice)\n        {\n            case 1:printf(\"insert the element to the stack\\n\");\n            push();\n            break;\n            case 2:printf(\"delete the element from the stack\\n\");\n            pop();\n            break;\n            case 3:printf(\"display the top element in the stack\\n\");\n            peek();\n            break;\n            case 4:printf(\"display all the element in the stack\\n\");\n            display();\n            break;\n            case 5:printf(\"checking the stack is full or not\\n\");\n            isfull();\n            break;\n            case 6:printf(\"checking the stack is empty or not\\n\");\n            isempty();\n            break;\n            case 7:printf(\"exit \\n\");\n            break;\n            default:printf(\"wrong choice\\n\");\n            break;\n        }\n    }while(choice!=7);\n    return 0;\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int main ( ) { int Paz ; printf ( \" THE STACK USING THE ARRAY\\n \" ) ; printf ( \" enter the size of the array(max size of the array is 50)= \\n \" ) ; scanf ( \" %d \" , & N ) ; printf ( \" 1.push\\n2.pop\\n3.peek\\n4.display\\n5.is full\\n6.is empty\\n7.exit\\n \" ) ; do { printf ( \" enter the choice=  \" ) ; scanf ( \" %d \" , & Paz ) ; if ( Paz == 1 ) { printf ( \" insert the element to the stack\\n \" ) ; push ( ) ; } else if ( Paz == 2 ) { printf ( \" delete the element from the stack\\n \" ) ; pop ( ) ; } else if ( Paz == 3 ) { printf ( \" display the top element in the stack\\n \" ) ; peek ( ) ; } else if ( Paz == 4 ) { printf ( \" display all the element in the stack\\n \" ) ; display ( ) ; } else if ( Paz == 5 ) { printf ( \" checking the stack is full or not\\n \" ) ; isfull ( ) ; } else if ( Paz == 6 ) { printf ( \" checking the stack is empty or not\\n \" ) ; isempty ( ) ; } else if ( Paz == 7 ) { printf ( \" exit \\n \" ) ; } else { printf ( \" wrong choice\\n \" ) ; } } while ( Paz != 7 ) ; return 0 ; }"}
{"author": "earth429", "file": "mulpre__mulprec.9.c", "original_string": "int setInt(struct NUMBER *a, int x) {\n    int digit = 1; \n    int i;\n    for (int i = x; i >= 10; i /= 10) { \n        digit++;\n        if(digit > KETA) {\n            return -1;\n        }\n    }\n    clearByZero(a);\n    if(x > 0){\n        setSign(a, 1);\n    } else {\n        setSign(a, -1);\n    }\n    x = abs(x);\n    for (i = 0; i < KETA;i++){\n        a->n[i] = x % 10;\n        x /= 10;\n    }\n    return 0;\n}", "watermark": [1, 0, 0, 1], "extract": [1, 0, 0, 1], "output_original_func": false, "after_watermark": "int setInt ( struct NUMBER * A , int X ) { int I ; int Normalangle ; Normalangle = 1 ; for ( int I = X ; I >= 10 ; I / = 10 ) { ++ Normalangle ; if ( Normalangle > KETA ) { return - 1 ; } } clearByZero ( A ) ; if ( X <= 0 ) { setSign ( A , - 1 ) ; } else { setSign ( A , 1 ) ; } X = abs ( X ) ; for ( I = 0 ; I < KETA ; ++ I ) { A -> n [ I ] = X % 10 ; X / = 10 ; } return 0 ; }"}
